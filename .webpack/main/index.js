/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WriteStreamSync = exports.WriteStream = exports.ReadStreamSync = exports.ReadStream = void 0;\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst minipass_1 = __webpack_require__(/*! minipass */ \"./node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/commonjs/index.js\");\nconst writev = fs_1.default.writev;\nconst _autoClose = Symbol('_autoClose');\nconst _close = Symbol('_close');\nconst _ended = Symbol('_ended');\nconst _fd = Symbol('_fd');\nconst _finished = Symbol('_finished');\nconst _flags = Symbol('_flags');\nconst _flush = Symbol('_flush');\nconst _handleChunk = Symbol('_handleChunk');\nconst _makeBuf = Symbol('_makeBuf');\nconst _mode = Symbol('_mode');\nconst _needDrain = Symbol('_needDrain');\nconst _onerror = Symbol('_onerror');\nconst _onopen = Symbol('_onopen');\nconst _onread = Symbol('_onread');\nconst _onwrite = Symbol('_onwrite');\nconst _open = Symbol('_open');\nconst _path = Symbol('_path');\nconst _pos = Symbol('_pos');\nconst _queue = Symbol('_queue');\nconst _read = Symbol('_read');\nconst _readSize = Symbol('_readSize');\nconst _reading = Symbol('_reading');\nconst _remain = Symbol('_remain');\nconst _size = Symbol('_size');\nconst _write = Symbol('_write');\nconst _writing = Symbol('_writing');\nconst _defaultFlag = Symbol('_defaultFlag');\nconst _errored = Symbol('_errored');\nclass ReadStream extends minipass_1.Minipass {\n    [_errored] = false;\n    [_fd];\n    [_path];\n    [_readSize];\n    [_reading] = false;\n    [_size];\n    [_remain];\n    [_autoClose];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this.readable = true;\n        this.writable = false;\n        if (typeof path !== 'string') {\n            throw new TypeError('path must be a string');\n        }\n        this[_errored] = false;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_path] = path;\n        this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n        this[_reading] = false;\n        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n        this[_remain] = this[_size];\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        if (typeof this[_fd] === 'number') {\n            this[_read]();\n        }\n        else {\n            this[_open]();\n        }\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    //@ts-ignore\n    write() {\n        throw new TypeError('this is a readable stream');\n    }\n    //@ts-ignore\n    end() {\n        throw new TypeError('this is a readable stream');\n    }\n    [_open]() {\n        fs_1.default.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            this[_read]();\n        }\n    }\n    [_makeBuf]() {\n        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n    [_read]() {\n        if (!this[_reading]) {\n            this[_reading] = true;\n            const buf = this[_makeBuf]();\n            /* c8 ignore start */\n            if (buf.length === 0) {\n                return process.nextTick(() => this[_onread](null, 0, buf));\n            }\n            /* c8 ignore stop */\n            fs_1.default.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));\n        }\n    }\n    [_onread](er, br, buf) {\n        this[_reading] = false;\n        if (er) {\n            this[_onerror](er);\n        }\n        else if (this[_handleChunk](br, buf)) {\n            this[_read]();\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n    [_onerror](er) {\n        this[_reading] = true;\n        this[_close]();\n        this.emit('error', er);\n    }\n    [_handleChunk](br, buf) {\n        let ret = false;\n        // no effect if infinite\n        this[_remain] -= br;\n        if (br > 0) {\n            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);\n        }\n        if (br === 0 || this[_remain] <= 0) {\n            ret = false;\n            this[_close]();\n            super.end();\n        }\n        return ret;\n    }\n    emit(ev, ...args) {\n        switch (ev) {\n            case 'prefinish':\n            case 'finish':\n                return false;\n            case 'drain':\n                if (typeof this[_fd] === 'number') {\n                    this[_read]();\n                }\n                return false;\n            case 'error':\n                if (this[_errored]) {\n                    return false;\n                }\n                this[_errored] = true;\n                return super.emit(ev, ...args);\n            default:\n                return super.emit(ev, ...args);\n        }\n    }\n}\nexports.ReadStream = ReadStream;\nclass ReadStreamSync extends ReadStream {\n    [_open]() {\n        let threw = true;\n        try {\n            this[_onopen](null, fs_1.default.openSync(this[_path], 'r'));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_read]() {\n        let threw = true;\n        try {\n            if (!this[_reading]) {\n                this[_reading] = true;\n                do {\n                    const buf = this[_makeBuf]();\n                    /* c8 ignore start */\n                    const br = buf.length === 0\n                        ? 0\n                        : fs_1.default.readSync(this[_fd], buf, 0, buf.length, null);\n                    /* c8 ignore stop */\n                    if (!this[_handleChunk](br, buf)) {\n                        break;\n                    }\n                } while (true);\n                this[_reading] = false;\n            }\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.closeSync(fd);\n            this.emit('close');\n        }\n    }\n}\nexports.ReadStreamSync = ReadStreamSync;\nclass WriteStream extends events_1.default {\n    readable = false;\n    writable = true;\n    [_errored] = false;\n    [_writing] = false;\n    [_ended] = false;\n    [_queue] = [];\n    [_needDrain] = false;\n    [_path];\n    [_mode];\n    [_autoClose];\n    [_fd];\n    [_defaultFlag];\n    [_flags];\n    [_finished] = false;\n    [_pos];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this[_path] = path;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        // truncating makes no sense when writing into the middle\n        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';\n        this[_defaultFlag] = opt.flags === undefined;\n        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;\n        if (this[_fd] === undefined) {\n            this[_open]();\n        }\n    }\n    emit(ev, ...args) {\n        if (ev === 'error') {\n            if (this[_errored]) {\n                return false;\n            }\n            this[_errored] = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    [_onerror](er) {\n        this[_close]();\n        this[_writing] = true;\n        this.emit('error', er);\n    }\n    [_open]() {\n        fs_1.default.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (this[_defaultFlag] &&\n            this[_flags] === 'r+' &&\n            er &&\n            er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            this[_open]();\n        }\n        else if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            if (!this[_writing]) {\n                this[_flush]();\n            }\n        }\n    }\n    end(buf, enc) {\n        if (buf) {\n            //@ts-ignore\n            this.write(buf, enc);\n        }\n        this[_ended] = true;\n        // synthetic after-write logic, where drain/finish live\n        if (!this[_writing] &&\n            !this[_queue].length &&\n            typeof this[_fd] === 'number') {\n            this[_onwrite](null, 0);\n        }\n        return this;\n    }\n    write(buf, enc) {\n        if (typeof buf === 'string') {\n            buf = Buffer.from(buf, enc);\n        }\n        if (this[_ended]) {\n            this.emit('error', new Error('write() after end()'));\n            return false;\n        }\n        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {\n            this[_queue].push(buf);\n            this[_needDrain] = true;\n            return false;\n        }\n        this[_writing] = true;\n        this[_write](buf);\n        return true;\n    }\n    [_write](buf) {\n        fs_1.default.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n    [_onwrite](er, bw) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            if (this[_pos] !== undefined && typeof bw === 'number') {\n                this[_pos] += bw;\n            }\n            if (this[_queue].length) {\n                this[_flush]();\n            }\n            else {\n                this[_writing] = false;\n                if (this[_ended] && !this[_finished]) {\n                    this[_finished] = true;\n                    this[_close]();\n                    this.emit('finish');\n                }\n                else if (this[_needDrain]) {\n                    this[_needDrain] = false;\n                    this.emit('drain');\n                }\n            }\n        }\n    }\n    [_flush]() {\n        if (this[_queue].length === 0) {\n            if (this[_ended]) {\n                this[_onwrite](null, 0);\n            }\n        }\n        else if (this[_queue].length === 1) {\n            this[_write](this[_queue].pop());\n        }\n        else {\n            const iovec = this[_queue];\n            this[_queue] = [];\n            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n}\nexports.WriteStream = WriteStream;\nclass WriteStreamSync extends WriteStream {\n    [_open]() {\n        let fd;\n        // only wrap in a try{} block if we know we'll retry, to avoid\n        // the rethrow obscuring the error's source frame in most cases.\n        if (this[_defaultFlag] && this[_flags] === 'r+') {\n            try {\n                fd = fs_1.default.openSync(this[_path], this[_flags], this[_mode]);\n            }\n            catch (er) {\n                if (er?.code === 'ENOENT') {\n                    this[_flags] = 'w';\n                    return this[_open]();\n                }\n                else {\n                    throw er;\n                }\n            }\n        }\n        else {\n            fd = fs_1.default.openSync(this[_path], this[_flags], this[_mode]);\n        }\n        this[_onopen](null, fd);\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.closeSync(fd);\n            this.emit('close');\n        }\n    }\n    [_write](buf) {\n        // throw the original, but try to close if it fails\n        let threw = true;\n        try {\n            this[_onwrite](null, fs_1.default.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                try {\n                    this[_close]();\n                }\n                catch {\n                    // ok error\n                }\n            }\n        }\n    }\n}\nexports.WriteStreamSync = WriteStreamSync;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9mcy1taW5pcGFzcy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCO0FBQzNGLGlDQUFpQyxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsaUdBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9AaXNhYWNzL2ZzLW1pbmlwYXNzL2Rpc3QvY29tbW9uanMvaW5kZXguanM/ZGJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV3JpdGVTdHJlYW1TeW5jID0gZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IGV4cG9ydHMuUmVhZFN0cmVhbVN5bmMgPSBleHBvcnRzLlJlYWRTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXZlbnRzXCIpKTtcbmNvbnN0IGZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IG1pbmlwYXNzXzEgPSByZXF1aXJlKFwibWluaXBhc3NcIik7XG5jb25zdCB3cml0ZXYgPSBmc18xLmRlZmF1bHQud3JpdGV2O1xuY29uc3QgX2F1dG9DbG9zZSA9IFN5bWJvbCgnX2F1dG9DbG9zZScpO1xuY29uc3QgX2Nsb3NlID0gU3ltYm9sKCdfY2xvc2UnKTtcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnX2VuZGVkJyk7XG5jb25zdCBfZmQgPSBTeW1ib2woJ19mZCcpO1xuY29uc3QgX2ZpbmlzaGVkID0gU3ltYm9sKCdfZmluaXNoZWQnKTtcbmNvbnN0IF9mbGFncyA9IFN5bWJvbCgnX2ZsYWdzJyk7XG5jb25zdCBfZmx1c2ggPSBTeW1ib2woJ19mbHVzaCcpO1xuY29uc3QgX2hhbmRsZUNodW5rID0gU3ltYm9sKCdfaGFuZGxlQ2h1bmsnKTtcbmNvbnN0IF9tYWtlQnVmID0gU3ltYm9sKCdfbWFrZUJ1ZicpO1xuY29uc3QgX21vZGUgPSBTeW1ib2woJ19tb2RlJyk7XG5jb25zdCBfbmVlZERyYWluID0gU3ltYm9sKCdfbmVlZERyYWluJyk7XG5jb25zdCBfb25lcnJvciA9IFN5bWJvbCgnX29uZXJyb3InKTtcbmNvbnN0IF9vbm9wZW4gPSBTeW1ib2woJ19vbm9wZW4nKTtcbmNvbnN0IF9vbnJlYWQgPSBTeW1ib2woJ19vbnJlYWQnKTtcbmNvbnN0IF9vbndyaXRlID0gU3ltYm9sKCdfb253cml0ZScpO1xuY29uc3QgX29wZW4gPSBTeW1ib2woJ19vcGVuJyk7XG5jb25zdCBfcGF0aCA9IFN5bWJvbCgnX3BhdGgnKTtcbmNvbnN0IF9wb3MgPSBTeW1ib2woJ19wb3MnKTtcbmNvbnN0IF9xdWV1ZSA9IFN5bWJvbCgnX3F1ZXVlJyk7XG5jb25zdCBfcmVhZCA9IFN5bWJvbCgnX3JlYWQnKTtcbmNvbnN0IF9yZWFkU2l6ZSA9IFN5bWJvbCgnX3JlYWRTaXplJyk7XG5jb25zdCBfcmVhZGluZyA9IFN5bWJvbCgnX3JlYWRpbmcnKTtcbmNvbnN0IF9yZW1haW4gPSBTeW1ib2woJ19yZW1haW4nKTtcbmNvbnN0IF9zaXplID0gU3ltYm9sKCdfc2l6ZScpO1xuY29uc3QgX3dyaXRlID0gU3ltYm9sKCdfd3JpdGUnKTtcbmNvbnN0IF93cml0aW5nID0gU3ltYm9sKCdfd3JpdGluZycpO1xuY29uc3QgX2RlZmF1bHRGbGFnID0gU3ltYm9sKCdfZGVmYXVsdEZsYWcnKTtcbmNvbnN0IF9lcnJvcmVkID0gU3ltYm9sKCdfZXJyb3JlZCcpO1xuY2xhc3MgUmVhZFN0cmVhbSBleHRlbmRzIG1pbmlwYXNzXzEuTWluaXBhc3Mge1xuICAgIFtfZXJyb3JlZF0gPSBmYWxzZTtcbiAgICBbX2ZkXTtcbiAgICBbX3BhdGhdO1xuICAgIFtfcmVhZFNpemVdO1xuICAgIFtfcmVhZGluZ10gPSBmYWxzZTtcbiAgICBbX3NpemVdO1xuICAgIFtfcmVtYWluXTtcbiAgICBbX2F1dG9DbG9zZV07XG4gICAgY29uc3RydWN0b3IocGF0aCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tfZXJyb3JlZF0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tfZmRdID0gdHlwZW9mIG9wdC5mZCA9PT0gJ251bWJlcicgPyBvcHQuZmQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbX3BhdGhdID0gcGF0aDtcbiAgICAgICAgdGhpc1tfcmVhZFNpemVdID0gb3B0LnJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjQ7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbX3NpemVdID0gdHlwZW9mIG9wdC5zaXplID09PSAnbnVtYmVyJyA/IG9wdC5zaXplIDogSW5maW5pdHk7XG4gICAgICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXTtcbiAgICAgICAgdGhpc1tfYXV0b0Nsb3NlXSA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID8gb3B0LmF1dG9DbG9zZSA6IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpc1tfcmVhZF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbX29wZW5dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tfZmRdO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbX3BhdGhdO1xuICAgIH1cbiAgICAvL0B0cy1pZ25vcmVcbiAgICB3cml0ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgIH1cbiAgICAvL0B0cy1pZ25vcmVcbiAgICBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICB9XG4gICAgW19vcGVuXSgpIHtcbiAgICAgICAgZnNfMS5kZWZhdWx0Lm9wZW4odGhpc1tfcGF0aF0sICdyJywgKGVyLCBmZCkgPT4gdGhpc1tfb25vcGVuXShlciwgZmQpKTtcbiAgICB9XG4gICAgW19vbm9wZW5dKGVyLCBmZCkge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbX29uZXJyb3JdKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbX2ZkXSA9IGZkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgICAgICAgdGhpc1tfcmVhZF0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX21ha2VCdWZdKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWluKHRoaXNbX3JlYWRTaXplXSwgdGhpc1tfcmVtYWluXSkpO1xuICAgIH1cbiAgICBbX3JlYWRdKCkge1xuICAgICAgICBpZiAoIXRoaXNbX3JlYWRpbmddKSB7XG4gICAgICAgICAgICB0aGlzW19yZWFkaW5nXSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBidWYgPSB0aGlzW19tYWtlQnVmXSgpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHRoaXNbX29ucmVhZF0obnVsbCwgMCwgYnVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LnJlYWQodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIG51bGwsIChlciwgYnIsIGIpID0+IHRoaXNbX29ucmVhZF0oZXIsIGJyLCBiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW19vbnJlYWRdKGVyLCBiciwgYnVmKSB7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gZmFsc2U7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgdGhpc1tfb25lcnJvcl0oZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSkge1xuICAgICAgICAgICAgdGhpc1tfcmVhZF0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX2Nsb3NlXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdO1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtfb25lcnJvcl0oZXIpIHtcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlO1xuICAgICAgICB0aGlzW19jbG9zZV0oKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9XG4gICAgW19oYW5kbGVDaHVua10oYnIsIGJ1Zikge1xuICAgICAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgICAgIC8vIG5vIGVmZmVjdCBpZiBpbmZpbml0ZVxuICAgICAgICB0aGlzW19yZW1haW5dIC09IGJyO1xuICAgICAgICBpZiAoYnIgPiAwKSB7XG4gICAgICAgICAgICByZXQgPSBzdXBlci53cml0ZShiciA8IGJ1Zi5sZW5ndGggPyBidWYuc3ViYXJyYXkoMCwgYnIpIDogYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnIgPT09IDAgfHwgdGhpc1tfcmVtYWluXSA8PSAwKSB7XG4gICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbX2Nsb3NlXSgpO1xuICAgICAgICAgICAgc3VwZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICAgICAgICBjYXNlICdwcmVmaW5pc2gnOlxuICAgICAgICAgICAgY2FzZSAnZmluaXNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdkcmFpbic6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbX3JlYWRdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfZXJyb3JlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW19lcnJvcmVkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtO1xuY2xhc3MgUmVhZFN0cmVhbVN5bmMgZXh0ZW5kcyBSZWFkU3RyZWFtIHtcbiAgICBbX29wZW5dKCkge1xuICAgICAgICBsZXQgdGhyZXcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpc1tfb25vcGVuXShudWxsLCBmc18xLmRlZmF1bHQub3BlblN5bmModGhpc1tfcGF0aF0sICdyJykpO1xuICAgICAgICAgICAgdGhyZXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgICAgIHRoaXNbX2Nsb3NlXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFtfcmVhZF0oKSB7XG4gICAgICAgIGxldCB0aHJldyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbX3JlYWRpbmddKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKTtcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJyID0gYnVmLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZzXzEuZGVmYXVsdC5yZWFkU3luYyh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tfaGFuZGxlQ2h1bmtdKGJyLCBidWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbX3JlYWRpbmddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfY2xvc2VdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgW19jbG9zZV0oKSB7XG4gICAgICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBmZCA9IHRoaXNbX2ZkXTtcbiAgICAgICAgICAgIHRoaXNbX2ZkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmMoZmQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkU3RyZWFtU3luYyA9IFJlYWRTdHJlYW1TeW5jO1xuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBldmVudHNfMS5kZWZhdWx0IHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlID0gdHJ1ZTtcbiAgICBbX2Vycm9yZWRdID0gZmFsc2U7XG4gICAgW193cml0aW5nXSA9IGZhbHNlO1xuICAgIFtfZW5kZWRdID0gZmFsc2U7XG4gICAgW19xdWV1ZV0gPSBbXTtcbiAgICBbX25lZWREcmFpbl0gPSBmYWxzZTtcbiAgICBbX3BhdGhdO1xuICAgIFtfbW9kZV07XG4gICAgW19hdXRvQ2xvc2VdO1xuICAgIFtfZmRdO1xuICAgIFtfZGVmYXVsdEZsYWddO1xuICAgIFtfZmxhZ3NdO1xuICAgIFtfZmluaXNoZWRdID0gZmFsc2U7XG4gICAgW19wb3NdO1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIG9wdCkge1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXNbX3BhdGhdID0gcGF0aDtcbiAgICAgICAgdGhpc1tfZmRdID0gdHlwZW9mIG9wdC5mZCA9PT0gJ251bWJlcicgPyBvcHQuZmQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbX21vZGVdID0gb3B0Lm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0Lm1vZGU7XG4gICAgICAgIHRoaXNbX3Bvc10gPSB0eXBlb2Ygb3B0LnN0YXJ0ID09PSAnbnVtYmVyJyA/IG9wdC5zdGFydCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tfYXV0b0Nsb3NlXSA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID8gb3B0LmF1dG9DbG9zZSA6IHRydWU7XG4gICAgICAgIC8vIHRydW5jYXRpbmcgbWFrZXMgbm8gc2Vuc2Ugd2hlbiB3cml0aW5nIGludG8gdGhlIG1pZGRsZVxuICAgICAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IHVuZGVmaW5lZCA/ICdyKycgOiAndyc7XG4gICAgICAgIHRoaXNbX2RlZmF1bHRGbGFnXSA9IG9wdC5mbGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW19mbGFnc10gPSBvcHQuZmxhZ3MgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRGbGFnIDogb3B0LmZsYWdzO1xuICAgICAgICBpZiAodGhpc1tfZmRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXNbX29wZW5dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW19lcnJvcmVkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbX2Vycm9yZWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIGdldCBmZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbX2ZkXTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW19wYXRoXTtcbiAgICB9XG4gICAgW19vbmVycm9yXShlcikge1xuICAgICAgICB0aGlzW19jbG9zZV0oKTtcbiAgICAgICAgdGhpc1tfd3JpdGluZ10gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH1cbiAgICBbX29wZW5dKCkge1xuICAgICAgICBmc18xLmRlZmF1bHQub3Blbih0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSwgKGVyLCBmZCkgPT4gdGhpc1tfb25vcGVuXShlciwgZmQpKTtcbiAgICB9XG4gICAgW19vbm9wZW5dKGVyLCBmZCkge1xuICAgICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgICAgICB0aGlzW19mbGFnc10gPT09ICdyKycgJiZcbiAgICAgICAgICAgIGVyICYmXG4gICAgICAgICAgICBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnO1xuICAgICAgICAgICAgdGhpc1tfb3Blbl0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcikge1xuICAgICAgICAgICAgdGhpc1tfb25lcnJvcl0oZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gZmQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXNbX3dyaXRpbmddKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfZmx1c2hdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5kKGJ1ZiwgZW5jKSB7XG4gICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy53cml0ZShidWYsIGVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tfZW5kZWRdID0gdHJ1ZTtcbiAgICAgICAgLy8gc3ludGhldGljIGFmdGVyLXdyaXRlIGxvZ2ljLCB3aGVyZSBkcmFpbi9maW5pc2ggbGl2ZVxuICAgICAgICBpZiAoIXRoaXNbX3dyaXRpbmddICYmXG4gICAgICAgICAgICAhdGhpc1tfcXVldWVdLmxlbmd0aCAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3cml0ZShidWYsIGVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgZW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tfZW5kZWRdKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSgpIGFmdGVyIGVuZCgpJykpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW19mZF0gPT09IHVuZGVmaW5lZCB8fCB0aGlzW193cml0aW5nXSB8fCB0aGlzW19xdWV1ZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzW19xdWV1ZV0ucHVzaChidWYpO1xuICAgICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tfd3JpdGluZ10gPSB0cnVlO1xuICAgICAgICB0aGlzW193cml0ZV0oYnVmKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFtfd3JpdGVdKGJ1Zikge1xuICAgICAgICBmc18xLmRlZmF1bHQud3JpdGUodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10sIChlciwgYncpID0+IHRoaXNbX29ud3JpdGVdKGVyLCBidykpO1xuICAgIH1cbiAgICBbX29ud3JpdGVdKGVyLCBidykge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbX29uZXJyb3JdKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzW19wb3NdICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJ3ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXNbX3Bvc10gKz0gYnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX2ZsdXNoXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfZW5kZWRdICYmICF0aGlzW19maW5pc2hlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfZmluaXNoZWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfY2xvc2VdKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNbX25lZWREcmFpbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFtfZmx1c2hdKCkge1xuICAgICAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbX2VuZGVkXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbX3dyaXRlXSh0aGlzW19xdWV1ZV0ucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW92ZWMgPSB0aGlzW19xdWV1ZV07XG4gICAgICAgICAgICB0aGlzW19xdWV1ZV0gPSBbXTtcbiAgICAgICAgICAgIHdyaXRldih0aGlzW19mZF0sIGlvdmVjLCB0aGlzW19wb3NdLCAoZXIsIGJ3KSA9PiB0aGlzW19vbndyaXRlXShlciwgYncpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX2Nsb3NlXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdO1xuICAgICAgICAgICAgdGhpc1tfZmRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtO1xuY2xhc3MgV3JpdGVTdHJlYW1TeW5jIGV4dGVuZHMgV3JpdGVTdHJlYW0ge1xuICAgIFtfb3Blbl0oKSB7XG4gICAgICAgIGxldCBmZDtcbiAgICAgICAgLy8gb25seSB3cmFwIGluIGEgdHJ5e30gYmxvY2sgaWYgd2Uga25vdyB3ZSdsbCByZXRyeSwgdG8gYXZvaWRcbiAgICAgICAgLy8gdGhlIHJldGhyb3cgb2JzY3VyaW5nIHRoZSBlcnJvcidzIHNvdXJjZSBmcmFtZSBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmIHRoaXNbX2ZsYWdzXSA9PT0gJ3IrJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmZCA9IGZzXzEuZGVmYXVsdC5vcGVuU3luYyh0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXI/LmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbX2ZsYWdzXSA9ICd3JztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX29wZW5dKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmZCA9IGZzXzEuZGVmYXVsdC5vcGVuU3luYyh0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tfb25vcGVuXShudWxsLCBmZCk7XG4gICAgfVxuICAgIFtfY2xvc2VdKCkge1xuICAgICAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF07XG4gICAgICAgICAgICB0aGlzW19mZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbX3dyaXRlXShidWYpIHtcbiAgICAgICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsLCBidXQgdHJ5IHRvIGNsb3NlIGlmIGl0IGZhaWxzXG4gICAgICAgIGxldCB0aHJldyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzW19vbndyaXRlXShudWxsLCBmc18xLmRlZmF1bHQud3JpdGVTeW5jKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzW19wb3NdKSk7XG4gICAgICAgICAgICB0aHJldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tfY2xvc2VdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2sgZXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLldyaXRlU3RyZWFtU3luYyA9IFdyaXRlU3RyZWFtU3luYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/commonjs/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/commonjs/index.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGlzYWFjcy9mcy1taW5pcGFzcy9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxzQ0FBc0MsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUF5QztBQUNqRCxRQUFRLHNDQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw4QkFBOEI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL0Bpc2FhY3MvZnMtbWluaXBhc3Mvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2Rpc3QvY29tbW9uanMvaW5kZXguanM/NDFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWluaXBhc3MgPSBleHBvcnRzLmlzV3JpdGFibGUgPSBleHBvcnRzLmlzUmVhZGFibGUgPSBleHBvcnRzLmlzU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgcHJvYyA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG4gICAgPyBwcm9jZXNzXG4gICAgOiB7XG4gICAgICAgIHN0ZG91dDogbnVsbCxcbiAgICAgICAgc3RkZXJyOiBudWxsLFxuICAgIH07XG5jb25zdCBub2RlX2V2ZW50c18xID0gcmVxdWlyZShcIm5vZGU6ZXZlbnRzXCIpO1xuY29uc3Qgbm9kZV9zdHJlYW1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpzdHJlYW1cIikpO1xuY29uc3Qgbm9kZV9zdHJpbmdfZGVjb2Rlcl8xID0gcmVxdWlyZShcIm5vZGU6c3RyaW5nX2RlY29kZXJcIik7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIE1pbmlwYXNzIHN0cmVhbSwgTm9kZSBzdHJlYW0sIG9yIHNvbWV0aGluZ1xuICogZWxzZSB0aGF0IE1pbmlwYXNzIGNhbiBpbnRlcmFjdCB3aXRoLlxuICovXG5jb25zdCBpc1N0cmVhbSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICAocyBpbnN0YW5jZW9mIE1pbmlwYXNzIHx8XG4gICAgICAgIHMgaW5zdGFuY2VvZiBub2RlX3N0cmVhbV8xLmRlZmF1bHQgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNSZWFkYWJsZSkocykgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNXcml0YWJsZSkocykpO1xuZXhwb3J0cy5pc1N0cmVhbSA9IGlzU3RyZWFtO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCB7QGxpbmsgTWluaXBhc3MuUmVhZGFibGV9XG4gKi9cbmNvbnN0IGlzUmVhZGFibGUgPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgcyBpbnN0YW5jZW9mIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyICYmXG4gICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIC8vIG5vZGUgY29yZSBXcml0YWJsZSBzdHJlYW1zIGhhdmUgYSBwaXBlKCkgbWV0aG9kLCBidXQgaXQgdGhyb3dzXG4gICAgcy5waXBlICE9PSBub2RlX3N0cmVhbV8xLmRlZmF1bHQuV3JpdGFibGUucHJvdG90eXBlLnBpcGU7XG5leHBvcnRzLmlzUmVhZGFibGUgPSBpc1JlYWRhYmxlO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCB7QGxpbmsgTWluaXBhc3MuV3JpdGFibGV9XG4gKi9cbmNvbnN0IGlzV3JpdGFibGUgPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgcyBpbnN0YW5jZW9mIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyICYmXG4gICAgdHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygcy5lbmQgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLmlzV3JpdGFibGUgPSBpc1dyaXRhYmxlO1xuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKTtcbmNvbnN0IE1BWUJFX0VNSVRfRU5EID0gU3ltYm9sKCdtYXliZUVtaXRFbmQnKTtcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJyk7XG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJyk7XG5jb25zdCBFTUlUVEVEX0VSUk9SID0gU3ltYm9sKCdlbWl0dGVkRXJyb3InKTtcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJyk7XG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJyk7XG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKTtcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKTtcbmNvbnN0IEVOQ09ESU5HID0gU3ltYm9sKCdlbmNvZGluZycpO1xuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpO1xuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpO1xuY29uc3QgUEFVU0VEID0gU3ltYm9sKCdwYXVzZWQnKTtcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJyk7XG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgUElQRVMgPSBTeW1ib2woJ3BpcGVzJyk7XG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpO1xuY29uc3QgQlVGRkVSUFVTSCA9IFN5bWJvbCgnYnVmZmVyUHVzaCcpO1xuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0Jyk7XG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBpcyBkZXN0cm95ZWRcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBoYXMgYW4gZXJyb3JcbmNvbnN0IEVSUk9SID0gU3ltYm9sKCdlcnJvcicpO1xuY29uc3QgRU1JVERBVEEgPSBTeW1ib2woJ2VtaXREYXRhJyk7XG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJyk7XG5jb25zdCBFTUlURU5EMiA9IFN5bWJvbCgnZW1pdEVuZDInKTtcbmNvbnN0IEFTWU5DID0gU3ltYm9sKCdhc3luYycpO1xuY29uc3QgQUJPUlQgPSBTeW1ib2woJ2Fib3J0Jyk7XG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJyk7XG5jb25zdCBTSUdOQUwgPSBTeW1ib2woJ3NpZ25hbCcpO1xuY29uc3QgREFUQUxJU1RFTkVSUyA9IFN5bWJvbCgnZGF0YUxpc3RlbmVycycpO1xuY29uc3QgRElTQ0FSREVEID0gU3ltYm9sKCdkaXNjYXJkZWQnKTtcbmNvbnN0IGRlZmVyID0gKGZuKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbmNvbnN0IG5vZGVmZXIgPSAoZm4pID0+IGZuKCk7XG5jb25zdCBpc0VuZGlzaCA9IChldikgPT4gZXYgPT09ICdlbmQnIHx8IGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCc7XG5jb25zdCBpc0FycmF5QnVmZmVyTGlrZSA9IChiKSA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAoISFiICYmXG4gICAgICAgIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBiLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgICBiLmJ5dGVMZW5ndGggPj0gMCk7XG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IChiKSA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKTtcbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGlwZSB7XG4gICAgc3JjO1xuICAgIGRlc3Q7XG4gICAgb3B0cztcbiAgICBvbmRyYWluO1xuICAgIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5kZXN0ID0gZGVzdDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5vbmRyYWluID0gKCkgPT4gc3JjW1JFU1VNRV0oKTtcbiAgICAgICAgdGhpcy5kZXN0Lm9uKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIHVucGlwZSgpIHtcbiAgICAgICAgdGhpcy5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIC8vIG9ubHkgaGVyZSBmb3IgdGhlIHByb3RvdHlwZVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIHByb3h5RXJyb3JzKF9lcikgeyB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMudW5waXBlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgICAgICAgdGhpcy5kZXN0LmVuZCgpO1xuICAgIH1cbn1cbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbSB3aGVyZVxuICogZXJyb3JzIGFyZSBwcm94aWVkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQaXBlUHJveHlFcnJvcnMgZXh0ZW5kcyBQaXBlIHtcbiAgICB1bnBpcGUoKSB7XG4gICAgICAgIHRoaXMuc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpO1xuICAgICAgICBzdXBlci51bnBpcGUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHNyYywgZGVzdCwgb3B0cyk7XG4gICAgICAgIHRoaXMucHJveHlFcnJvcnMgPSBlciA9PiBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycyk7XG4gICAgfVxufVxuY29uc3QgaXNPYmplY3RNb2RlT3B0aW9ucyA9IChvKSA9PiAhIW8ub2JqZWN0TW9kZTtcbmNvbnN0IGlzRW5jb2RpbmdPcHRpb25zID0gKG8pID0+ICFvLm9iamVjdE1vZGUgJiYgISFvLmVuY29kaW5nICYmIG8uZW5jb2RpbmcgIT09ICdidWZmZXInO1xuLyoqXG4gKiBNYWluIGV4cG9ydCwgdGhlIE1pbmlwYXNzIGNsYXNzXG4gKlxuICogYFJUeXBlYCBpcyB0aGUgdHlwZSBvZiBkYXRhIGVtaXR0ZWQsIGRlZmF1bHRzIHRvIEJ1ZmZlclxuICpcbiAqIGBXVHlwZWAgaXMgdGhlIHR5cGUgb2YgZGF0YSB0byBiZSB3cml0dGVuLCBpZiBSVHlwZSBpcyBidWZmZXIgb3Igc3RyaW5nLFxuICogdGhlbiBhbnkge0BsaW5rIE1pbmlwYXNzLkNvbnRpZ3VvdXNEYXRhfSBpcyBhbGxvd2VkLlxuICpcbiAqIGBFdmVudHNgIGlzIHRoZSBzZXQgb2YgZXZlbnQgaGFuZGxlciBzaWduYXR1cmVzIHRoYXQgdGhpcyBvYmplY3RcbiAqIHdpbGwgZW1pdCwgc2VlIHtAbGluayBNaW5pcGFzcy5FdmVudHN9XG4gKi9cbmNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIFtGTE9XSU5HXSA9IGZhbHNlO1xuICAgIFtQQVVTRURdID0gZmFsc2U7XG4gICAgW1BJUEVTXSA9IFtdO1xuICAgIFtCVUZGRVJdID0gW107XG4gICAgW09CSkVDVE1PREVdO1xuICAgIFtFTkNPRElOR107XG4gICAgW0FTWU5DXTtcbiAgICBbREVDT0RFUl07XG4gICAgW0VPRl0gPSBmYWxzZTtcbiAgICBbRU1JVFRFRF9FTkRdID0gZmFsc2U7XG4gICAgW0VNSVRUSU5HX0VORF0gPSBmYWxzZTtcbiAgICBbQ0xPU0VEXSA9IGZhbHNlO1xuICAgIFtFTUlUVEVEX0VSUk9SXSA9IG51bGw7XG4gICAgW0JVRkZFUkxFTkdUSF0gPSAwO1xuICAgIFtERVNUUk9ZRURdID0gZmFsc2U7XG4gICAgW1NJR05BTF07XG4gICAgW0FCT1JURURdID0gZmFsc2U7XG4gICAgW0RBVEFMSVNURU5FUlNdID0gMDtcbiAgICBbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBjYW4gYmUgd3JpdHRlblxuICAgICAqL1xuICAgIHdyaXRhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gY2FuIGJlIHJlYWRcbiAgICAgKi9cbiAgICByZWFkYWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogSWYgYFJUeXBlYCBpcyBCdWZmZXIsIHRoZW4gb3B0aW9ucyBkbyBub3QgbmVlZCB0byBiZSBwcm92aWRlZC5cbiAgICAgKiBPdGhlcndpc2UsIGFuIG9wdGlvbnMgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQgdG8gc3BlY2lmeSBlaXRoZXJcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MuU2hhcmVkT3B0aW9ucy5vYmplY3RNb2RlfSBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcy5TaGFyZWRPcHRpb25zLmVuY29kaW5nfSwgYXMgYXBwcm9wcmlhdGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3NbMF0gfHxcbiAgICAgICAgICAgIHt9KTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSAmJiB0eXBlb2Ygb3B0aW9ucy5lbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kaW5nIGFuZCBvYmplY3RNb2RlIG1heSBub3QgYmUgdXNlZCB0b2dldGhlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdE1vZGVPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VuY29kaW5nT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zLmVuY29kaW5nO1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQVNZTkNdID0gISFvcHRpb25zLmFzeW5jO1xuICAgICAgICB0aGlzW0RFQ09ERVJdID0gdGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gbmV3IG5vZGVfc3RyaW5nX2RlY29kZXJfMS5TdHJpbmdEZWNvZGVyKHRoaXNbRU5DT0RJTkddKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAvL0B0cy1pZ25vcmUgLSBwcml2YXRlIG9wdGlvbiBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdFeHBvc2VCdWZmZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywgeyBnZXQ6ICgpID0+IHRoaXNbQlVGRkVSXSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL0B0cy1pZ25vcmUgLSBwcml2YXRlIG9wdGlvbiBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdFeHBvc2VQaXBlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwaXBlcycsIHsgZ2V0OiAoKSA9PiB0aGlzW1BJUEVTXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgdGhpc1tTSUdOQUxdID0gc2lnbmFsO1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tBQk9SVF0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXNbQUJPUlRdKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2YgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nIHRvIGJlIHJlYWQuXG4gICAgICpcbiAgICAgKiBGb3IgQnVmZmVyIHN0cmluZ3MsIHRoaXMgd2lsbCBiZSB0aGUgdG90YWwgYnl0ZSBsZW5ndGguXG4gICAgICogRm9yIHN0cmluZyBlbmNvZGluZyBzdHJlYW1zLCB0aGlzIHdpbGwgYmUgdGhlIHN0cmluZyBjaGFyYWN0ZXIgbGVuZ3RoLFxuICAgICAqIGFjY29yZGluZyB0byBKYXZhU2NyaXB0J3MgYHN0cmluZy5sZW5ndGhgIGxvZ2ljLlxuICAgICAqIEZvciBvYmplY3RNb2RlIHN0cmVhbXMsIHRoaXMgaXMgYSBjb3VudCBvZiB0aGUgaXRlbXMgd2FpdGluZyB0byBiZVxuICAgICAqIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZ2V0IGJ1ZmZlckxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBCdWZmZXJFbmNvZGluZ2AgY3VycmVudGx5IGluIHVzZSwgb3IgYG51bGxgXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tFTkNPRElOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVGhpcyBpcyBhIHJlYWQgb25seSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldCBlbmNvZGluZyhfZW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RpbmcgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gRW5jb2RpbmcgbWF5IG9ubHkgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZVxuICAgICAqL1xuICAgIHNldEVuY29kaW5nKF9lbmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGlzIGFuIG9iamVjdE1vZGUgc3RyZWFtXG4gICAgICovXG4gICAgZ2V0IG9iamVjdE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgaXMgYSByZWFkLW9ubHkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXQgb2JqZWN0TW9kZShfb20pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmplY3RNb2RlIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoaXMgaXMgYW4gYXN5bmMgc3RyZWFtXG4gICAgICovXG4gICAgZ2V0IFsnYXN5bmMnXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQVNZTkNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtYWtlIHRoaXMgc3RyZWFtIGFzeW5jLlxuICAgICAqXG4gICAgICogT25jZSBzZXQsIGl0IGNhbm5vdCBiZSB1bnNldCwgYXMgdGhpcyB3b3VsZCBwb3RlbnRpYWxseSBjYXVzZSBpbmNvcnJlY3RcbiAgICAgKiBiZWhhdmlvci4gIEllLCBhIHN5bmMgc3RyZWFtIGNhbiBiZSBtYWRlIGFzeW5jLCBidXQgYW4gYXN5bmMgc3RyZWFtXG4gICAgICogY2Fubm90IGJlIHNhZmVseSBtYWRlIHN5bmMuXG4gICAgICovXG4gICAgc2V0IFsnYXN5bmMnXShhKSB7XG4gICAgICAgIHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhO1xuICAgIH1cbiAgICAvLyBkcm9wIGV2ZXJ5dGhpbmcgYW5kIGdldCBvdXQgb2YgdGhlIGZsb3cgY29tcGxldGVseVxuICAgIFtBQk9SVF0oKSB7XG4gICAgICAgIHRoaXNbQUJPUlRFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2Fib3J0JywgdGhpc1tTSUdOQUxdPy5yZWFzb24pO1xuICAgICAgICB0aGlzLmRlc3Ryb3kodGhpc1tTSUdOQUxdPy5yZWFzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQUJPUlRFRF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vLW9wIHNldHRlci4gU3RyZWFtIGFib3J0ZWQgc3RhdHVzIGlzIHNldCB2aWEgdGhlIEFib3J0U2lnbmFsIHByb3ZpZGVkXG4gICAgICogaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0IGFib3J0ZWQoXykgeyB9XG4gICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodGhpc1tBQk9SVEVEXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignQ2Fubm90IGNhbGwgd3JpdGUgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcpLCB7IGNvZGU6ICdFUlJfU1RSRUFNX0RFU1RST1lFRCcgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW5jb2RpbmcpXG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogbm9kZWZlcjtcbiAgICAgICAgLy8gY29udmVydCBhcnJheSBidWZmZXJzIGFuZCB0eXBlZCBhcnJheSB2aWV3cyBpbnRvIGJ1ZmZlcnNcbiAgICAgICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgICAgIC8vIGxlYXZlIHN0cmluZ3MgYW5kIGJ1ZmZlcnMgYXMtaXNcbiAgICAgICAgLy8gYW55dGhpbmcgaXMgb25seSBhbGxvd2VkIGlmIGluIG9iamVjdCBtb2RlLCBzbyB0aHJvd1xuICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0gJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLmJ1ZmZlciwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyTGlrZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1jb250aWd1b3VzIGRhdGEgd3JpdHRlbiB0byBub24tb2JqZWN0TW9kZSBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgICAgICAvLyB0aGlzIHlpZWxkcyBiZXR0ZXIgcGVyZm9ybWFuY2UsIGZld2VyIGNoZWNrcyBsYXRlci5cbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIC8vIG1heWJlIGltcG9zc2libGU/XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzW0ZMVVNIXSh0cnVlKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuayk7XG4gICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgICAgIGlmIChjYilcbiAgICAgICAgICAgICAgICBmbihjYik7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBjaHVuayBpcyBhIGJ1ZmZlciBvciBzdHJpbmdcbiAgICAgICAgLy8gZG9uJ3QgYnVmZmVyIGl0IHVwIG9yIHNlbmQgaXQgdG8gdGhlIGRlY29kZXJcbiAgICAgICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhc3QtcGF0aCB3cml0aW5nIHN0cmluZ3Mgb2Ygc2FtZSBlbmNvZGluZyB0byBhIHN0cmVhbSB3aXRoXG4gICAgICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBzdHJpbmcgYWxyZWFkeSByZWFkeSBmb3IgdXMgdG8gdXNlXG4gICAgICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXT8ubGFzdE5lZWQpKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdlXG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdGhpc1tFTkNPRElOR10pIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgIGNodW5rID0gdGhpc1tERUNPREVSXS53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgdGhpc1tGTFVTSF0odHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIGV4cGxpY2l0IHJlYWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogSW4gb2JqZWN0TW9kZSwgdGhlIGFyZ3VtZW50IGlzIGlnbm9yZWQsIGFuZCBvbmUgaXRlbSBpcyByZXR1cm5lZCBpZlxuICAgICAqIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIGBuYCBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIChvciBpbiB0aGUgY2FzZSBvZiBlbmNvZGluZyBzdHJlYW1zLFxuICAgICAqIGNoYXJhY3RlcnMpIHRvIGNvbnN1bWUuIElmIGBuYCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGVudGlyZSBidWZmZXJcbiAgICAgKiBpcyByZXR1cm5lZCwgb3IgYG51bGxgIGlzIHJldHVybmVkIGlmIG5vIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogSWYgYG5gIGlzIGdyZWF0ZXIgdGhhdCB0aGUgYW1vdW50IG9mIGRhdGEgaW4gdGhlIGludGVybmFsIGJ1ZmZlcixcbiAgICAgKiB0aGVuIGBudWxsYCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICByZWFkKG4pIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fFxuICAgICAgICAgICAgbiA9PT0gMCB8fFxuICAgICAgICAgICAgKG4gJiYgbiA+IHRoaXNbQlVGRkVSTEVOR1RIXSkpIHtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIG4gPSBudWxsO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIC8vIG5vdCBvYmplY3QgbW9kZSwgc28gaWYgd2UgaGF2ZSBhbiBlbmNvZGluZywgdGhlbiBSVHlwZSBpcyBzdHJpbmdcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgbXVzdCBiZSBCdWZmZXJcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9IFtcbiAgICAgICAgICAgICAgICAodGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzW0JVRkZFUl0uam9pbignJylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXNbQlVGRkVSXSwgdGhpc1tCVUZGRVJMRU5HVEhdKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXNbUkVBRF0obiB8fCBudWxsLCB0aGlzW0JVRkZFUl1bMF0pO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbUkVBRF0obiwgY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUlNISUZUXSgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaHVuaztcbiAgICAgICAgICAgIGlmIChuID09PSBjLmxlbmd0aCB8fCBuID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl1bMF0gPSBjLnNsaWNlKG4pO1xuICAgICAgICAgICAgICAgIGNodW5rID0gYy5zbGljZSgwLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGMuc3ViYXJyYXkobik7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjLnN1YmFycmF5KDAsIG4pO1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgaWYgKCF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBjaHVuaztcbiAgICAgICAgICAgIGNodW5rID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYik7XG4gICAgICAgIHRoaXNbRU9GXSA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZW4ndCB3cml0dGVuIGFueXRoaW5nLCB0aGVuIGdvIGFoZWFkIGFuZCBlbWl0LFxuICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIG5vdCByZWFkaW5nLlxuICAgICAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAgICAgLy8gVGhpcyBtYWtlcyBNUCBtb3JlIHN1aXRhYmxlIHRvIHdyaXRlLW9ubHkgdXNlIGNhc2VzLlxuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGRvbid0IGxldCB0aGUgaW50ZXJuYWwgcmVzdW1lIGJlIG92ZXJ3cml0dGVuXG4gICAgW1JFU1VNRV0oKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpc1tEQVRBTElTVEVORVJTXSAmJiAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzW0ZMVVNIXSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgc3RyZWFtIGlmIGl0IGlzIGN1cnJlbnRseSBpbiBhIHBhdXNlZCBzdGF0ZVxuICAgICAqXG4gICAgICogSWYgY2FsbGVkIHdoZW4gdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zIG9yIGBkYXRhYCBldmVudCBsaXN0ZW5lcnMsXG4gICAgICogdGhpcyB3aWxsIHBsYWNlIHRoZSBzdHJlYW0gaW4gYSBcImRpc2NhcmRlZFwiIHN0YXRlLCB3aGVyZSBhbGwgZGF0YSB3aWxsXG4gICAgICogYmUgdGhyb3duIGF3YXkuIFRoZSBkaXNjYXJkZWQgc3RhdGUgaXMgcmVtb3ZlZCBpZiBhIHBpcGUgZGVzdGluYXRpb24gb3JcbiAgICAgKiBkYXRhIGhhbmRsZXIgaXMgYWRkZWQsIGlmIHBhdXNlKCkgaXMgY2FsbGVkLCBvciBpZiBhbnkgc3luY2hyb25vdXMgb3JcbiAgICAgKiBhc3luY2hyb25vdXMgaXRlcmF0aW9uIGlzIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tSRVNVTUVdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICB0aGlzW1BBVVNFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGZvcmNpYmx5IGRlc3Ryb3llZFxuICAgICAqL1xuICAgIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0RFU1RST1lFRF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgaW4gYSBmbG93aW5nIHN0YXRlLCBtZWFuaW5nIHRoYXRcbiAgICAgKiBhbnkgd3JpdGVzIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBnZXQgZmxvd2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgaW4gYSBwYXVzZWQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tQQVVTRURdO1xuICAgIH1cbiAgICBbQlVGRkVSUFVTSF0oY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpc1tCVUZGRVJdLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBbQlVGRkVSU0hJRlRdKCkge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gdGhpc1tCVUZGRVJdWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXNbQlVGRkVSXS5zaGlmdCgpO1xuICAgIH1cbiAgICBbRkxVU0hdKG5vRHJhaW4gPSBmYWxzZSkge1xuICAgICAgICBkbyB7IH0gd2hpbGUgKHRoaXNbRkxVU0hDSFVOS10odGhpc1tCVUZGRVJTSElGVF0oKSkgJiZcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGgpO1xuICAgICAgICBpZiAoIW5vRHJhaW4gJiYgIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gICAgW0ZMVVNIQ0hVTktdKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpcGUgYWxsIGRhdGEgZW1pdHRlZCBieSB0aGlzIHN0cmVhbSBpbnRvIHRoZSBkZXN0aW5hdGlvbiBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIHRoZSBmbG93IG9mIGRhdGEuXG4gICAgICovXG4gICAgcGlwZShkZXN0LCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVuZGVkID0gdGhpc1tFTUlUVEVEX0VORF07XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICAgICAgICBvcHRzLmVuZCA9IGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRzLmVuZCA9IG9wdHMuZW5kICE9PSBmYWxzZTtcbiAgICAgICAgb3B0cy5wcm94eUVycm9ycyA9ICEhb3B0cy5wcm94eUVycm9ycztcbiAgICAgICAgLy8gcGlwaW5nIGFuIGVuZGVkIHN0cmVhbSBlbmRzIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuZW5kKVxuICAgICAgICAgICAgICAgIGRlc3QuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBcImFzXCIgaGVyZSBqdXN0IGlnbm9yZXMgdGhlIFdUeXBlLCB3aGljaCBwaXBlcyBkb24ndCBjYXJlIGFib3V0LFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSdyZSBvbmx5IGNvbnN1bWluZyBmcm9tIHVzLCBhbmQgd3JpdGluZyB0byB0aGUgZGVzdFxuICAgICAgICAgICAgdGhpc1tQSVBFU10ucHVzaCghb3B0cy5wcm94eUVycm9yc1xuICAgICAgICAgICAgICAgID8gbmV3IFBpcGUodGhpcywgZGVzdCwgb3B0cylcbiAgICAgICAgICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpO1xuICAgICAgICAgICAgaWYgKHRoaXNbQVNZTkNdKVxuICAgICAgICAgICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW1JFU1VNRV0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVsbHkgdW5ob29rIGEgcGlwZWQgZGVzdGluYXRpb24gc3RyZWFtLlxuICAgICAqXG4gICAgICogSWYgdGhlIGRlc3RpbmF0aW9uIHN0cmVhbSB3YXMgdGhlIG9ubHkgY29uc3VtZXIgb2YgdGhpcyBzdHJlYW0gKGllLFxuICAgICAqIHRoZXJlIGFyZSBubyBvdGhlciBwaXBlZCBkZXN0aW5hdGlvbnMgb3IgYCdkYXRhJ2AgZXZlbnQgbGlzdGVuZXJzKVxuICAgICAqIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3AgdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqL1xuICAgIHVucGlwZShkZXN0KSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzW1BJUEVTXS5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmICh0aGlzW1BJUEVTXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0RBVEFMSVNURU5FUlNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1tQSVBFU10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW1BJUEVTXS5zcGxpY2UodGhpc1tQSVBFU10uaW5kZXhPZihwKSwgMSk7XG4gICAgICAgICAgICBwLnVucGlwZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgTWluaXBhc3Mjb259XG4gICAgICovXG4gICAgYWRkTGlzdGVuZXIoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXYsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIub25gLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBiZWhhdmlvciBkaWZmZXJlbmNlcyB0byBwcmV2ZW50IGRhdGEgbG9zcyBhbmQgdW5uZWNlc3NhcnkgaGFuZ3M6XG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhICdkYXRhJyBldmVudCBoYW5kbGVyIHdpbGwgdHJpZ2dlciB0aGUgZmxvdyBvZiBkYXRhXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhICdyZWFkYWJsZScgZXZlbnQgaGFuZGxlciB3aGVuIHRoZXJlIGlzIGRhdGEgd2FpdGluZyB0byBiZSByZWFkXG4gICAgICogICB3aWxsIGNhdXNlICdyZWFkYWJsZScgdG8gYmUgZW1pdHRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGFuICdlbmRpc2gnIGV2ZW50IGhhbmRsZXIgKCdlbmQnLCAnZmluaXNoJywgZXRjLikgd2hpY2ggaGFzXG4gICAgICogICBhbHJlYWR5IHBhc3NlZCB3aWxsIGNhdXNlIHRoZSBldmVudCB0byBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5IGFuZCBhbGxcbiAgICAgKiAgIGhhbmRsZXJzIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhbiAnZXJyb3InIGV2ZW50IGhhbmRsZXIgYWZ0ZXIgYW4gZXJyb3IgaGFzIGJlZW4gZW1pdHRlZCB3aWxsXG4gICAgICogICBjYXVzZSB0aGUgZXZlbnQgdG8gYmUgcmUtZW1pdHRlZCBpbW1lZGlhdGVseSB3aXRoIHRoZSBlcnJvciBwcmV2aW91c2x5XG4gICAgICogICByYWlzZWQuXG4gICAgICovXG4gICAgb24oZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIub24oZXYsIGhhbmRsZXIpO1xuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdKys7XG4gICAgICAgICAgICBpZiAoIXRoaXNbUElQRVNdLmxlbmd0aCAmJiAhdGhpc1tGTE9XSU5HXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbUkVTVU1FXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkge1xuICAgICAgICAgICAgc3VwZXIuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoZXYpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBoYW5kbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXNbQVNZTkNdKVxuICAgICAgICAgICAgICAgIGRlZmVyKCgpID0+IGguY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaC5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgTWluaXBhc3Mjb2ZmfVxuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5vZmZgXG4gICAgICpcbiAgICAgKiBJZiBhICdkYXRhJyBldmVudCBoYW5kbGVyIGlzIHJlbW92ZWQsIGFuZCBpdCB3YXMgdGhlIGxhc3QgY29uc3VtZXJcbiAgICAgKiAoaWUsIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyBvciBvdGhlciAnZGF0YScgZXZlbnQgbGlzdGVuZXJzKSxcbiAgICAgKiB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKi9cbiAgICBvZmYoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIub2ZmKGV2LCBoYW5kbGVyKTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgbGlzdGVuZXJzLCBhbmQgbm93IHdlIGRvbid0LCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgLy8gaGF2ZSBhbnkgcGlwZXMsIHRoZW4gc3RvcCB0aGUgZmxvdywgdW5sZXNzIGl0J3MgYmVlbiBleHBsaWNpdGx5XG4gICAgICAgIC8vIHB1dCBpbiBhIGRpc2NhcmRlZCBmbG93aW5nIHN0YXRlIHZpYSBzdHJlYW0ucmVzdW1lKCkuXG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdID0gdGhpcy5saXN0ZW5lcnMoJ2RhdGEnKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpc1tEQVRBTElTVEVORVJTXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICF0aGlzW0RJU0NBUkRFRF0gJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnNgXG4gICAgICpcbiAgICAgKiBJZiBhbGwgJ2RhdGEnIGV2ZW50IGhhbmRsZXJzIGFyZSByZW1vdmVkLCBhbmQgdGhleSB3ZXJlIHRoZSBsYXN0IGNvbnN1bWVyXG4gICAgICogKGllLCB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMpLCB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wXG4gICAgICogdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvciB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5XG4gICAgICogY2FsbGVkLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzW0RBVEFMSVNURU5FUlNdID0gMDtcbiAgICAgICAgICAgIGlmICghdGhpc1tESVNDQVJERURdICYmICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgJ2VuZCcgZXZlbnQgaGFzIGJlZW4gZW1pdHRlZFxuICAgICAqL1xuICAgIGdldCBlbWl0dGVkRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tFTUlUVEVEX0VORF07XG4gICAgfVxuICAgIFtNQVlCRV9FTUlUX0VORF0oKSB7XG4gICAgICAgIGlmICghdGhpc1tFTUlUVElOR19FTkRdICYmXG4gICAgICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0RFU1RST1lFRF0gJiZcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXNbRU9GXSkge1xuICAgICAgICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0NMT1NFRF0pXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLmVtaXRgLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBiZWhhdmlvciBkaWZmZXJlbmNlcyB0byBwcmV2ZW50IGRhdGEgbG9zcyBhbmQgdW5uZWNlc3NhcnkgaGFuZ3M6XG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGRlc3Ryb3llZCwgYW5kIHRoZSBldmVudCBpcyBzb21ldGhpbmcgb3RoZXJcbiAgICAgKiB0aGFuICdjbG9zZScgb3IgJ2Vycm9yJywgdGhlbiBgZmFsc2VgIGlzIHJldHVybmVkIGFuZCBubyBoYW5kbGVyc1xuICAgICAqIGFyZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2VuZCcsIGFuZCBoYXMgYWxyZWFkeSBiZWVuIGVtaXR0ZWQsIHRoZW4gdGhlIGV2ZW50XG4gICAgICogaXMgaWdub3JlZC4gSWYgdGhlIHN0cmVhbSBpcyBpbiBhIHBhdXNlZCBvciBub24tZmxvd2luZyBzdGF0ZSwgdGhlblxuICAgICAqIHRoZSBldmVudCB3aWxsIGJlIGRlZmVycmVkIHVudGlsIGRhdGEgZmxvdyByZXN1bWVzLiBJZiB0aGUgc3RyZWFtIGlzXG4gICAgICogYXN5bmMsIHRoZW4gaGFuZGxlcnMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIG5leHQgdGljayByYXRoZXIgdGhhblxuICAgICAqIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdjbG9zZScsIGFuZCAnZW5kJyBoYXMgbm90IHlldCBiZWVuIGVtaXR0ZWQsIHRoZW5cbiAgICAgKiB0aGUgZXZlbnQgd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCBhZnRlciAnZW5kJyBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdlcnJvcicsIGFuZCBhbiBBYm9ydFNpZ25hbCB3YXMgcHJvdmlkZWQgZm9yIHRoZSBzdHJlYW0sXG4gICAgICogYW5kIHRoZXJlIGFyZSBubyBsaXN0ZW5lcnMsIHRoZW4gdGhlIGV2ZW50IGlzIGlnbm9yZWQsIG1hdGNoaW5nIHRoZVxuICAgICAqIGJlaGF2aW9yIG9mIG5vZGUgY29yZSBzdHJlYW1zIGluIHRoZSBwcmVzZW5zZSBvZiBhbiBBYm9ydFNpZ25hbC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZmluaXNoJyBvciAncHJlZmluaXNoJywgdGhlbiBhbGwgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudCwgdG8gcHJldmVudCBkb3VibGUtZmlyaW5nLlxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFyZ3NbMF07XG4gICAgICAgIC8vIGVycm9yIGFuZCBjbG9zZSBhcmUgb25seSBldmVudHMgYWxsb3dlZCBhZnRlciBjYWxsaW5nIGRlc3Ryb3koKVxuICAgICAgICBpZiAoZXYgIT09ICdlcnJvcicgJiZcbiAgICAgICAgICAgIGV2ICE9PSAnY2xvc2UnICYmXG4gICAgICAgICAgICBldiAhPT0gREVTVFJPWUVEICYmXG4gICAgICAgICAgICB0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXNbT0JKRUNUTU9ERV0gJiYgIWRhdGFcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzW0FTWU5DXVxuICAgICAgICAgICAgICAgICAgICA/IChkZWZlcigoKSA9PiB0aGlzW0VNSVREQVRBXShkYXRhKSksIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpc1tFTUlUREFUQV0oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tFTUlURU5EXSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gZG9uJ3QgZW1pdCBjbG9zZSBiZWZvcmUgJ2VuZCcgYW5kICdmaW5pc2gnXG4gICAgICAgICAgICBpZiAoIXRoaXNbRU1JVFRFRF9FTkRdICYmICF0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IGRhdGE7XG4gICAgICAgICAgICBzdXBlci5lbWl0KEVSUk9SLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9ICF0aGlzW1NJR05BTF0gfHwgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAncmVzdW1lJykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgncmVzdW1lJyk7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbRU1JVERBVEFdKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICBpZiAocC5kZXN0LndyaXRlKGRhdGEpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tESVNDQVJERURdID8gZmFsc2UgOiBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlURU5EXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbRU1JVFRFRF9FTkRdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzW0VNSVRURURfRU5EXSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXNbQVNZTkNdXG4gICAgICAgICAgICA/IChkZWZlcigoKSA9PiB0aGlzW0VNSVRFTkQyXSgpKSwgdHJ1ZSlcbiAgICAgICAgICAgIDogdGhpc1tFTUlURU5EMl0oKTtcbiAgICB9XG4gICAgW0VNSVRFTkQyXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5kZXN0LndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbRElTQ0FSREVEXSlcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgcC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlbmQnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYWxsIGVtaXR0ZWQgZGF0YSBvbmNlXG4gICAgICogdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbGxlY3QoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IE9iamVjdC5hc3NpZ24oW10sIHtcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICBidWYuZGF0YUxlbmd0aCA9IDA7XG4gICAgICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAgICAgLy8gYnkgdHJpZ2dlcmluZyB0aGUgZmxvdyBoZXJlLlxuICAgICAgICBjb25zdCBwID0gdGhpcy5wcm9taXNlKCk7XG4gICAgICAgIHRoaXMub24oJ2RhdGEnLCBjID0+IHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgICAgIGJ1Zi5kYXRhTGVuZ3RoICs9IGMubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcDtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBlbWl0dGVkIGRhdGFcbiAgICAgKiBvbmNlIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKlxuICAgICAqIE5vdCBhbGxvd2VkIG9uIG9iamVjdE1vZGUgc3RyZWFtcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25jYXQoKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHRoaXMuY29sbGVjdCgpO1xuICAgICAgICByZXR1cm4gKHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICA/IGJ1Zi5qb2luKCcnKVxuICAgICAgICAgICAgOiBCdWZmZXIuY29uY2F0KGJ1ZiwgYnVmLmRhdGFMZW5ndGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdm9pZCBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2Vycm9yJywgZXIgPT4gcmVqZWN0KGVyKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzIGBmb3IgYXdhaXQgb2ZgIGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBjb250aW51ZSBlbWl0dGluZyBhbGwgY2h1bmtzIHVudGlsIHRoZSBzdHJlYW0gdGVybWluYXRlcy5cbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAvLyBzZXQgdGhpcyB1cCBmcm9udCwgaW4gY2FzZSB0aGUgY29uc3VtZXIgZG9lc24ndCBjYWxsIG5leHQoKVxuICAgICAgICAvLyByaWdodCBhd2F5LlxuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSk7XG4gICAgICAgICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgIGxldCByZWplY3Q7XG4gICAgICAgICAgICBjb25zdCBvbmVyciA9IChlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmRhdGEgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZGVzdHJveSA9ICgpID0+IG9uZXJyKG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIHRocm93OiBzdG9wLFxuICAgICAgICAgICAgcmV0dXJuOiBzdG9wLFxuICAgICAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIGBmb3Igb2ZgIGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRpb24gd2lsbCB0ZXJtaW5hdGUgd2hlbiB0aGUgaW50ZXJuYWwgYnVmZmVyIHJ1bnMgb3V0LCBldmVuXG4gICAgICogaWYgdGhlIHN0cmVhbSBoYXMgbm90IHlldCB0ZXJtaW5hdGVkLlxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAvLyBzZXQgdGhpcyB1cCBmcm9udCwgaW4gY2FzZSB0aGUgY29uc3VtZXIgZG9lc24ndCBjYWxsIG5leHQoKVxuICAgICAgICAvLyByaWdodCBhd2F5LlxuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKEVSUk9SLCBzdG9wKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgc3RvcCk7XG4gICAgICAgICAgICB0aGlzLm9mZignZW5kJywgc3RvcCk7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gc3RvcCgpIDogeyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBzdG9wKTtcbiAgICAgICAgdGhpcy5vbmNlKEVSUk9SLCBzdG9wKTtcbiAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgc3RvcCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICAgICAgICByZXR1cm46IHN0b3AsXG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYSBzdHJlYW0sIHByZXZlbnRpbmcgaXQgZnJvbSBiZWluZyB1c2VkIGZvciBhbnkgZnVydGhlciBwdXJwb3NlLlxuICAgICAqXG4gICAgICogSWYgdGhlIHN0cmVhbSBoYXMgYSBgY2xvc2UoKWAgbWV0aG9kLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIG9uXG4gICAgICogZGVzdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBBZnRlciBkZXN0cnVjdGlvbiwgYW55IGF0dGVtcHQgdG8gd3JpdGUgZGF0YSwgcmVhZCBkYXRhLCBvciBlbWl0IG1vc3RcbiAgICAgKiBldmVudHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogSWYgYW4gZXJyb3IgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBlbWl0dGVkIGluIGFuXG4gICAgICogJ2Vycm9yJyBldmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KGVyKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gdHJ1ZTtcbiAgICAgICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwO1xuICAgICAgICBjb25zdCB3YyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2MuY2xvc2UgPT09ICdmdW5jdGlvbicgJiYgIXRoaXNbQ0xPU0VEXSlcbiAgICAgICAgICAgIHdjLmNsb3NlKCk7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIC8vIGlmIG5vIGVycm9yIHRvIGVtaXQsIHN0aWxsIHJlamVjdCBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBpc1N0cmVhbX1cbiAgICAgKlxuICAgICAqIEZvcm1lciBleHBvcnQgbG9jYXRpb24sIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGlzU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5pc1N0cmVhbTtcbiAgICB9XG59XG5leHBvcnRzLk1pbmlwYXNzID0gTWluaXBhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@isaacs/fs-minipass/node_modules/minipass/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/adm-zip.js":
/*!*****************************************!*\
  !*** ./node_modules/adm-zip/adm-zip.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const Utils = __webpack_require__(/*! ./util */ \"./node_modules/adm-zip/util/index.js\");\nconst pth = __webpack_require__(/*! path */ \"path\");\nconst ZipEntry = __webpack_require__(/*! ./zipEntry */ \"./node_modules/adm-zip/zipEntry.js\");\nconst ZipFile = __webpack_require__(/*! ./zipFile */ \"./node_modules/adm-zip/zipFile.js\");\n\nconst get_Bool = (...val) => Utils.findLast(val, (c) => typeof c === \"boolean\");\nconst get_Str = (...val) => Utils.findLast(val, (c) => typeof c === \"string\");\nconst get_Fun = (...val) => Utils.findLast(val, (c) => typeof c === \"function\");\n\nconst defaultOptions = {\n    // option \"noSort\" : if true it disables files sorting\n    noSort: false,\n    // read entries during load (initial loading may be slower)\n    readEntries: false,\n    // default method is none\n    method: Utils.Constants.NONE,\n    // file system\n    fs: null\n};\n\nmodule.exports = function (/**String*/ input, /** object */ options) {\n    let inBuffer = null;\n\n    // create object based default options, allowing them to be overwritten\n    const opts = Object.assign(Object.create(null), defaultOptions);\n\n    // test input variable\n    if (input && \"object\" === typeof input) {\n        // if value is not buffer we accept it to be object with options\n        if (!(input instanceof Uint8Array)) {\n            Object.assign(opts, input);\n            input = opts.input ? opts.input : undefined;\n            if (opts.input) delete opts.input;\n        }\n\n        // if input is buffer\n        if (Buffer.isBuffer(input)) {\n            inBuffer = input;\n            opts.method = Utils.Constants.BUFFER;\n            input = undefined;\n        }\n    }\n\n    // assign options\n    Object.assign(opts, options);\n\n    // instanciate utils filesystem\n    const filetools = new Utils(opts);\n\n    if (typeof opts.decoder !== \"object\" || typeof opts.decoder.encode !== \"function\" || typeof opts.decoder.decode !== \"function\") {\n        opts.decoder = Utils.decoder;\n    }\n\n    // if input is file name we retrieve its content\n    if (input && \"string\" === typeof input) {\n        // load zip file\n        if (filetools.fs.existsSync(input)) {\n            opts.method = Utils.Constants.FILE;\n            opts.filename = input;\n            inBuffer = filetools.fs.readFileSync(input);\n        } else {\n            throw Utils.Errors.INVALID_FILENAME();\n        }\n    }\n\n    // create variable\n    const _zip = new ZipFile(inBuffer, opts);\n\n    const { canonical, sanitize, zipnamefix } = Utils;\n\n    function getEntry(/**Object*/ entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\") item = _zip.getEntry(pth.posix.normalize(entry));\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    function fixPath(zipPath) {\n        const { join, normalize, sep } = pth.posix;\n        // convert windows file separators and normalize\n        return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n    }\n\n    function filenameFilter(filterfn) {\n        if (filterfn instanceof RegExp) {\n            // if filter is RegExp wrap it\n            return (function (rx) {\n                return function (filename) {\n                    return rx.test(filename);\n                };\n            })(filterfn);\n        } else if (\"function\" !== typeof filterfn) {\n            // if filter is not function we will replace it\n            return () => true;\n        }\n        return filterfn;\n    }\n\n    // keep last character on folders\n    const relativePath = (local, entry) => {\n        let lastChar = entry.slice(-1);\n        lastChar = lastChar === filetools.sep ? filetools.sep : \"\";\n        return pth.relative(local, entry) + lastChar;\n    };\n\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {Buffer|string} [pass] - password\n         * @return Buffer or Null in case of error\n         */\n        readFile: function (entry, pass) {\n            var item = getEntry(entry);\n            return (item && item.getData(pass)) || null;\n        },\n\n        /**\n         * Returns how many child elements has on entry (directories) on files it is always 0\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @returns {integer}\n         */\n        childCount: function (entry) {\n            const item = getEntry(entry);\n            if (item) {\n                return _zip.getChildCount(item);\n            }\n        },\n\n        /**\n         * Asynchronous readFile\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {callback} callback\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFileAsync: function (entry, callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null, \"getEntry failed for:\" + entry);\n            }\n        },\n\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param {ZipEntry|string} entry - ZipEntry object or String with the full path of the entry\n         * @param {string} encoding - Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsText: function (entry, encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n\n        /**\n         * Asynchronous readAsText\n         * @param {ZipEntry|string} entry ZipEntry object or String with the full path of the entry\n         * @param {callback} callback\n         * @param {string} [encoding] - Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsTextAsync: function (entry, callback, encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function (data, err) {\n                    if (err) {\n                        callback(data, err);\n                        return;\n                    }\n\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                });\n            } else {\n                callback(\"\");\n            }\n        },\n\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param {ZipEntry|string} entry\n         * @returns {void}\n         */\n        deleteFile: function (entry, withsubfolders = true) {\n            // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteFile(item.entryName, withsubfolders);\n            }\n        },\n\n        /**\n         * Remove the entry from the file or directory without affecting any nested entries\n         *\n         * @param {ZipEntry|string} entry\n         * @returns {void}\n         */\n        deleteEntry: function (entry) {\n            // @TODO: test deleteEntry\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param {string} comment\n         */\n        addZipComment: function (comment) {\n            // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */\n        getZipComment: function () {\n            return _zip.comment || \"\";\n        },\n\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param {ZipEntry} entry\n         * @param {string} comment\n         */\n        addZipEntryComment: function (entry, comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param {ZipEntry} entry\n         * @return String\n         */\n        getZipEntryComment: function (entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || \"\";\n            }\n            return \"\";\n        },\n\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param {ZipEntry} entry\n         * @param {Buffer} content\n         */\n        updateFile: function (entry, content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param {string} localPath File to add to zip\n         * @param {string} [zipPath] Optional path inside the zip\n         * @param {string} [zipName] Optional name for the file\n         * @param {string} [comment] Optional file comment\n         */\n        addLocalFile: function (localPath, zipPath, zipName, comment) {\n            if (filetools.fs.existsSync(localPath)) {\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n                // p - local file name\n                const p = pth.win32.basename(pth.win32.normalize(localPath));\n\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n\n                // read file attributes\n                const _attr = filetools.fs.statSync(localPath);\n\n                // get file content\n                const data = _attr.isFile() ? filetools.fs.readFileSync(localPath) : Buffer.alloc(0);\n\n                // if folder\n                if (_attr.isDirectory()) zipPath += filetools.sep;\n\n                // add file into zip file\n                this.addFile(zipPath, data, comment, _attr);\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n            }\n        },\n\n        /**\n         * Callback for showing if everything was done.\n         *\n         * @callback doneCallback\n         * @param {Error} err - Error object\n         * @param {boolean} done - was request fully completed\n         */\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param {(object|string)} options - options object, if it is string it us used as localPath.\n         * @param {string} options.localPath - Local path to the file.\n         * @param {string} [options.comment] - Optional file comment.\n         * @param {string} [options.zipPath] - Optional path inside the zip\n         * @param {string} [options.zipName] - Optional name for the file\n         * @param {doneCallback} callback - The callback that handles the response.\n         */\n        addLocalFileAsync: function (options, callback) {\n            options = typeof options === \"object\" ? options : { localPath: options };\n            const localPath = pth.resolve(options.localPath);\n            const { comment } = options;\n            let { zipPath, zipName } = options;\n            const self = this;\n\n            filetools.fs.stat(localPath, function (err, stats) {\n                if (err) return callback(err, false);\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n                // p - local file name\n                const p = pth.win32.basename(pth.win32.normalize(localPath));\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n\n                if (stats.isFile()) {\n                    filetools.fs.readFile(localPath, function (err, data) {\n                        if (err) return callback(err, false);\n                        self.addFile(zipPath, data, comment, stats);\n                        return setImmediate(callback, undefined, true);\n                    });\n                } else if (stats.isDirectory()) {\n                    zipPath += filetools.sep;\n                    self.addFile(zipPath, Buffer.alloc(0), comment, stats);\n                    return setImmediate(callback, undefined, true);\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {string} localPath - local path to the folder\n         * @param {string} [zipPath] - optional path inside zip\n         * @param {(RegExp|function)} [filter] - optional RegExp or Function if files match will be included.\n         */\n        addLocalFolder: function (localPath, zipPath, filter) {\n            // Prepare filter\n            filter = filenameFilter(filter);\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            if (filetools.fs.existsSync(localPath)) {\n                const items = filetools.findFiles(localPath);\n                const self = this;\n\n                if (items.length) {\n                    for (const filepath of items) {\n                        const p = pth.join(zipPath, relativePath(localPath, filepath));\n                        if (filter(p)) {\n                            self.addLocalFile(filepath, pth.dirname(p));\n                        }\n                    }\n                }\n            } else {\n                throw Utils.Errors.FILE_NOT_FOUND(localPath);\n            }\n        },\n\n        /**\n         * Asynchronous addLocalFolder\n         * @param {string} localPath\n         * @param {callback} callback\n         * @param {string} [zipPath] optional path inside zip\n         * @param {RegExp|function} [filter] optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolderAsync: function (localPath, callback, zipPath, filter) {\n            // Prepare filter\n            filter = filenameFilter(filter);\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            var self = this;\n            filetools.fs.open(localPath, \"r\", function (err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    var items = filetools.findFiles(localPath);\n                    var i = -1;\n\n                    var next = function () {\n                        i += 1;\n                        if (i < items.length) {\n                            var filepath = items[i];\n                            var p = relativePath(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                            p = p\n                                .normalize(\"NFD\")\n                                .replace(/[\\u0300-\\u036f]/g, \"\")\n                                .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n                            if (filter(p)) {\n                                filetools.fs.stat(filepath, function (er0, stats) {\n                                    if (er0) callback(undefined, er0);\n                                    if (stats.isFile()) {\n                                        filetools.fs.readFile(filepath, function (er1, data) {\n                                            if (er1) {\n                                                callback(undefined, er1);\n                                            } else {\n                                                self.addFile(zipPath + p, data, \"\", stats);\n                                                next();\n                                            }\n                                        });\n                                    } else {\n                                        self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                                        next();\n                                    }\n                                });\n                            } else {\n                                process.nextTick(() => {\n                                    next();\n                                });\n                            }\n                        } else {\n                            callback(true, undefined);\n                        }\n                    };\n\n                    next();\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {object | string} options - options object, if it is string it us used as localPath.\n         * @param {string} options.localPath - Local path to the folder.\n         * @param {string} [options.zipPath] - optional path inside zip.\n         * @param {RegExp|function} [options.filter] - optional RegExp or Function if files match will be included.\n         * @param {function|string} [options.namefix] - optional function to help fix filename\n         * @param {doneCallback} callback - The callback that handles the response.\n         *\n         */\n        addLocalFolderAsync2: function (options, callback) {\n            const self = this;\n            options = typeof options === \"object\" ? options : { localPath: options };\n            localPath = pth.resolve(fixPath(options.localPath));\n            let { zipPath, filter, namefix } = options;\n\n            if (filter instanceof RegExp) {\n                filter = (function (rx) {\n                    return function (filename) {\n                        return rx.test(filename);\n                    };\n                })(filter);\n            } else if (\"function\" !== typeof filter) {\n                filter = function () {\n                    return true;\n                };\n            }\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // Check Namefix function\n            if (namefix == \"latin1\") {\n                namefix = (str) =>\n                    str\n                        .normalize(\"NFD\")\n                        .replace(/[\\u0300-\\u036f]/g, \"\")\n                        .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix (latin1 characers only)\n            }\n\n            if (typeof namefix !== \"function\") namefix = (str) => str;\n\n            // internal, create relative path + fix the name\n            const relPathFix = (entry) => pth.join(zipPath, namefix(relativePath(localPath, entry)));\n            const fileNameFix = (entry) => pth.win32.basename(pth.win32.normalize(namefix(entry)));\n\n            filetools.fs.open(localPath, \"r\", function (err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND(localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    filetools.findFilesAsync(localPath, function (err, fileEntries) {\n                        if (err) return callback(err);\n                        fileEntries = fileEntries.filter((dir) => filter(relPathFix(dir)));\n                        if (!fileEntries.length) callback(undefined, false);\n\n                        setImmediate(\n                            fileEntries.reverse().reduce(function (next, entry) {\n                                return function (err, done) {\n                                    if (err || done === false) return setImmediate(next, err, false);\n\n                                    self.addLocalFileAsync(\n                                        {\n                                            localPath: entry,\n                                            zipPath: pth.dirname(relPathFix(entry)),\n                                            zipName: fileNameFix(entry)\n                                        },\n                                        next\n                                    );\n                                };\n                            }, callback)\n                        );\n                    });\n                }\n            });\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param {string} localPath - path where files will be extracted\n         * @param {object} props - optional properties\n         * @param {string} [props.zipPath] - optional path inside zip\n         * @param {RegExp|function} [props.filter] - optional RegExp or Function if files match will be included.\n         * @param {function|string} [props.namefix] - optional function to help fix filename\n         */\n        addLocalFolderPromise: function (localPath, props) {\n            return new Promise((resolve, reject) => {\n                this.addLocalFolderAsync2(Object.assign({ localPath }, props), (err, done) => {\n                    if (err) reject(err);\n                    if (done) resolve(this);\n                });\n            });\n        },\n\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param {string} entryName\n         * @param {Buffer | string} content - file content as buffer or utf8 coded string\n         * @param {string} [comment] - file comment\n         * @param {number | object} [attr] - number as unix file permissions, object as filesystem Stats object\n         */\n        addFile: function (entryName, content, comment, attr) {\n            entryName = zipnamefix(entryName);\n            let entry = getEntry(entryName);\n            const update = entry != null;\n\n            // prepare new entry\n            if (!update) {\n                entry = new ZipEntry(opts);\n                entry.entryName = entryName;\n            }\n            entry.comment = comment || \"\";\n\n            const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n\n            // last modification time from file stats\n            if (isStat) {\n                entry.header.time = attr.mtime;\n            }\n\n            // Set file attribute\n            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n\n            // extended attributes field for Unix\n            // set file type either S_IFDIR / S_IFREG\n            let unix = entry.isDirectory ? 0x4000 : 0x8000;\n\n            if (isStat) {\n                // File attributes from file stats\n                unix |= 0xfff & attr.mode;\n            } else if (\"number\" === typeof attr) {\n                // attr from given attr values\n                unix |= 0xfff & attr;\n            } else {\n                // Default values:\n                unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n            }\n\n            fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes\n\n            entry.attr = fileattr;\n\n            entry.setData(content);\n            if (!update) _zip.setEntry(entry);\n\n            return entry;\n        },\n\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @param {string} [password]\n         * @returns Array\n         */\n        getEntries: function (password) {\n            _zip.password = password;\n            return _zip ? _zip.entries : [];\n        },\n\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param {string} name\n         * @return ZipEntry\n         */\n        getEntry: function (/**String*/ name) {\n            return getEntry(name);\n        },\n\n        getEntryCount: function () {\n            return _zip.getEntryCount();\n        },\n\n        forEach: function (callback) {\n            return _zip.forEach(callback);\n        },\n\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param {string|ZipEntry} entry - ZipEntry object or String with the full path of the entry\n         * @param {string} targetPath - Target folder where to write the file\n         * @param {boolean} [maintainEntryPath=true] - If maintainEntryPath is true and the entry is inside a folder, the entry folder will be created in targetPath as well. Default is TRUE\n         * @param {boolean} [overwrite=false] - If the file already exists at the target path, the file will be overwriten if this is true.\n         * @param {boolean} [keepOriginalPermission=false] - The file will be set as the permission from the entry if this is true.\n         * @param {string} [outFileName] - String If set will override the filename of the extracted file (Only works if the entry is a file)\n         *\n         * @return Boolean\n         */\n        extractEntryTo: function (entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {\n            overwrite = get_Bool(false, overwrite);\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            maintainEntryPath = get_Bool(true, maintainEntryPath);\n            outFileName = get_Str(keepOriginalPermission, outFileName);\n\n            var item = getEntry(entry);\n            if (!item) {\n                throw Utils.Errors.NO_ENTRY();\n            }\n\n            var entryName = canonical(item.entryName);\n\n            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n\n            if (item.isDirectory) {\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function (child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw Utils.Errors.CANT_EXTRACT_FILE();\n                    }\n                    var name = canonical(child.entryName);\n                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n                    // The reverse operation for attr depend on method addFile()\n                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n                    filetools.writeFileTo(childName, content, overwrite, fileAttr);\n                });\n                return true;\n            }\n\n            var content = item.getData(_zip.password);\n            if (!content) throw Utils.Errors.CANT_EXTRACT_FILE();\n\n            if (filetools.fs.existsSync(target) && !overwrite) {\n                throw Utils.Errors.CANT_OVERRIDE();\n            }\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileTo(target, content, overwrite, fileAttr);\n\n            return true;\n        },\n\n        /**\n         * Test the archive\n         * @param {string} [pass]\n         */\n        test: function (pass) {\n            if (!_zip) {\n                return false;\n            }\n\n            for (var entry in _zip.entries) {\n                try {\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData(pass);\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param {string} targetPath Target location\n         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param {string|Buffer} [pass] password\n         */\n        extractAllTo: function (targetPath, overwrite, keepOriginalPermission, pass) {\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            pass = get_Str(keepOriginalPermission, pass);\n            overwrite = get_Bool(false, overwrite);\n            if (!_zip) throw Utils.Errors.NO_ZIP();\n\n            _zip.entries.forEach(function (entry) {\n                var entryName = sanitize(targetPath, canonical(entry.entryName));\n                if (entry.isDirectory) {\n                    filetools.makeDir(entryName);\n                    return;\n                }\n                var content = entry.getData(pass);\n                if (!content) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE();\n                }\n                // The reverse operation for attr depend on method addFile()\n                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n                try {\n                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n                } catch (err) {\n                    throw Utils.Errors.CANT_EXTRACT_FILE();\n                }\n            });\n        },\n\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param {string} targetPath Target location\n         * @param {boolean} [overwrite=false] If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param {boolean} [keepOriginalPermission=false] The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param {function} callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n         */\n        extractAllToAsync: function (targetPath, overwrite, keepOriginalPermission, callback) {\n            callback = get_Fun(overwrite, keepOriginalPermission, callback);\n            keepOriginalPermission = get_Bool(false, keepOriginalPermission);\n            overwrite = get_Bool(false, overwrite);\n            if (!callback) {\n                return new Promise((resolve, reject) => {\n                    this.extractAllToAsync(targetPath, overwrite, keepOriginalPermission, function (err) {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(this);\n                        }\n                    });\n                });\n            }\n            if (!_zip) {\n                callback(Utils.Errors.NO_ZIP());\n                return;\n            }\n\n            targetPath = pth.resolve(targetPath);\n            // convert entryName to\n            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName)));\n            const getError = (msg, file) => new Error(msg + ': \"' + file + '\"');\n\n            // separate directories from files\n            const dirEntries = [];\n            const fileEntries = [];\n            _zip.entries.forEach((e) => {\n                if (e.isDirectory) {\n                    dirEntries.push(e);\n                } else {\n                    fileEntries.push(e);\n                }\n            });\n\n            // Create directory entries first synchronously\n            // this prevents race condition and assures folders are there before writing files\n            for (const entry of dirEntries) {\n                const dirPath = getPath(entry);\n                // The reverse operation for attr depend on method addFile()\n                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                try {\n                    filetools.makeDir(dirPath);\n                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n                    // in unix timestamp will change if files are later added to folder, but still\n                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n                } catch (er) {\n                    callback(getError(\"Unable to create folder\", dirPath));\n                }\n            }\n\n            fileEntries.reverse().reduce(function (next, entry) {\n                return function (err) {\n                    if (err) {\n                        next(err);\n                    } else {\n                        const entryName = pth.normalize(canonical(entry.entryName));\n                        const filePath = sanitize(targetPath, entryName);\n                        entry.getDataAsync(function (content, err_1) {\n                            if (err_1) {\n                                next(err_1);\n                            } else if (!content) {\n                                next(Utils.Errors.CANT_EXTRACT_FILE());\n                            } else {\n                                // The reverse operation for attr depend on method addFile()\n                                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                                filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n                                    if (!succ) {\n                                        next(getError(\"Unable to write file\", filePath));\n                                    }\n                                    filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n                                        if (err_2) {\n                                            next(getError(\"Unable to set times\", filePath));\n                                        } else {\n                                            next();\n                                        }\n                                    });\n                                });\n                            }\n                        });\n                    }\n                };\n            }, callback)();\n        },\n\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param {string} targetFileName\n         * @param {function} callback\n         */\n        writeZip: function (targetFileName, callback) {\n            if (arguments.length === 1) {\n                if (typeof targetFileName === \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n\n            if (!targetFileName && opts.filename) {\n                targetFileName = opts.filename;\n            }\n            if (!targetFileName) return;\n\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = filetools.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n            }\n        },\n\n        /**\n         *\n         * @param {string} targetFileName\n         * @param {object} [props]\n         * @param {boolean} [props.overwrite=true] If the file already exists at the target path, the file will be overwriten if this is true.\n         * @param {boolean} [props.perm] The file will be set as the permission from the entry if this is true.\n\n         * @returns {Promise<void>}\n         */\n        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {\n            const { overwrite, perm } = Object.assign({ overwrite: true }, props);\n\n            return new Promise((resolve, reject) => {\n                // find file name\n                if (!targetFileName && opts.filename) targetFileName = opts.filename;\n                if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n\n                this.toBufferPromise().then((zipData) => {\n                    const ret = (done) => (done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\"));\n                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n                }, reject);\n            });\n        },\n\n        /**\n         * @returns {Promise<Buffer>} A promise to the Buffer.\n         */\n        toBufferPromise: function () {\n            return new Promise((resolve, reject) => {\n                _zip.toAsyncBuffer(resolve, reject);\n            });\n        },\n\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @prop {function} [onSuccess]\n         * @prop {function} [onFail]\n         * @prop {function} [onItemStart]\n         * @prop {function} [onItemEnd]\n         * @returns {Buffer}\n         */\n        toBuffer: function (onSuccess, onFail, onItemStart, onItemEnd) {\n            if (typeof onSuccess === \"function\") {\n                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer();\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9hZG0temlwLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyxvREFBUTtBQUM5QixZQUFZLG1CQUFPLENBQUMsa0JBQU07QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsc0RBQVk7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQVc7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksa0NBQWtDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQyxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFp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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9hZG0temlwLmpzP2IzOTQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgcHRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBaaXBFbnRyeSA9IHJlcXVpcmUoXCIuL3ppcEVudHJ5XCIpO1xuY29uc3QgWmlwRmlsZSA9IHJlcXVpcmUoXCIuL3ppcEZpbGVcIik7XG5cbmNvbnN0IGdldF9Cb29sID0gKC4uLnZhbCkgPT4gVXRpbHMuZmluZExhc3QodmFsLCAoYykgPT4gdHlwZW9mIGMgPT09IFwiYm9vbGVhblwiKTtcbmNvbnN0IGdldF9TdHIgPSAoLi4udmFsKSA9PiBVdGlscy5maW5kTGFzdCh2YWwsIChjKSA9PiB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIik7XG5jb25zdCBnZXRfRnVuID0gKC4uLnZhbCkgPT4gVXRpbHMuZmluZExhc3QodmFsLCAoYykgPT4gdHlwZW9mIGMgPT09IFwiZnVuY3Rpb25cIik7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIG9wdGlvbiBcIm5vU29ydFwiIDogaWYgdHJ1ZSBpdCBkaXNhYmxlcyBmaWxlcyBzb3J0aW5nXG4gICAgbm9Tb3J0OiBmYWxzZSxcbiAgICAvLyByZWFkIGVudHJpZXMgZHVyaW5nIGxvYWQgKGluaXRpYWwgbG9hZGluZyBtYXkgYmUgc2xvd2VyKVxuICAgIHJlYWRFbnRyaWVzOiBmYWxzZSxcbiAgICAvLyBkZWZhdWx0IG1ldGhvZCBpcyBub25lXG4gICAgbWV0aG9kOiBVdGlscy5Db25zdGFudHMuTk9ORSxcbiAgICAvLyBmaWxlIHN5c3RlbVxuICAgIGZzOiBudWxsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKipTdHJpbmcqLyBpbnB1dCwgLyoqIG9iamVjdCAqLyBvcHRpb25zKSB7XG4gICAgbGV0IGluQnVmZmVyID0gbnVsbDtcblxuICAgIC8vIGNyZWF0ZSBvYmplY3QgYmFzZWQgZGVmYXVsdCBvcHRpb25zLCBhbGxvd2luZyB0aGVtIHRvIGJlIG92ZXJ3cml0dGVuXG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgZGVmYXVsdE9wdGlvbnMpO1xuXG4gICAgLy8gdGVzdCBpbnB1dCB2YXJpYWJsZVxuICAgIGlmIChpbnB1dCAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgaW5wdXQpIHtcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGJ1ZmZlciB3ZSBhY2NlcHQgaXQgdG8gYmUgb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGlucHV0KTtcbiAgICAgICAgICAgIGlucHV0ID0gb3B0cy5pbnB1dCA/IG9wdHMuaW5wdXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAob3B0cy5pbnB1dCkgZGVsZXRlIG9wdHMuaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpbnB1dCBpcyBidWZmZXJcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGluQnVmZmVyID0gaW5wdXQ7XG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9IFV0aWxzLkNvbnN0YW50cy5CVUZGRVI7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiBvcHRpb25zXG4gICAgT2JqZWN0LmFzc2lnbihvcHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluc3RhbmNpYXRlIHV0aWxzIGZpbGVzeXN0ZW1cbiAgICBjb25zdCBmaWxldG9vbHMgPSBuZXcgVXRpbHMob3B0cyk7XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb3B0cy5kZWNvZGVyLmVuY29kZSAhPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvcHRzLmRlY29kZXIuZGVjb2RlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0cy5kZWNvZGVyID0gVXRpbHMuZGVjb2RlcjtcbiAgICB9XG5cbiAgICAvLyBpZiBpbnB1dCBpcyBmaWxlIG5hbWUgd2UgcmV0cmlldmUgaXRzIGNvbnRlbnRcbiAgICBpZiAoaW5wdXQgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgICAgIC8vIGxvYWQgemlwIGZpbGVcbiAgICAgICAgaWYgKGZpbGV0b29scy5mcy5leGlzdHNTeW5jKGlucHV0KSkge1xuICAgICAgICAgICAgb3B0cy5tZXRob2QgPSBVdGlscy5Db25zdGFudHMuRklMRTtcbiAgICAgICAgICAgIG9wdHMuZmlsZW5hbWUgPSBpbnB1dDtcbiAgICAgICAgICAgIGluQnVmZmVyID0gZmlsZXRvb2xzLmZzLnJlYWRGaWxlU3luYyhpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9GSUxFTkFNRSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHZhcmlhYmxlXG4gICAgY29uc3QgX3ppcCA9IG5ldyBaaXBGaWxlKGluQnVmZmVyLCBvcHRzKTtcblxuICAgIGNvbnN0IHsgY2Fub25pY2FsLCBzYW5pdGl6ZSwgemlwbmFtZWZpeCB9ID0gVXRpbHM7XG5cbiAgICBmdW5jdGlvbiBnZXRFbnRyeSgvKipPYmplY3QqLyBlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkgJiYgX3ppcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgICAgICAvLyBJZiBlbnRyeSB3YXMgZ2l2ZW4gYXMgYSBmaWxlIG5hbWVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIpIGl0ZW0gPSBfemlwLmdldEVudHJ5KHB0aC5wb3NpeC5ub3JtYWxpemUoZW50cnkpKTtcbiAgICAgICAgICAgIC8vIGlmIGVudHJ5IHdhcyBnaXZlbiBhcyBhIFppcEVudHJ5IG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkuZW50cnlOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBlbnRyeS5oZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIGl0ZW0gPSBfemlwLmdldEVudHJ5KGVudHJ5LmVudHJ5TmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4UGF0aCh6aXBQYXRoKSB7XG4gICAgICAgIGNvbnN0IHsgam9pbiwgbm9ybWFsaXplLCBzZXAgfSA9IHB0aC5wb3NpeDtcbiAgICAgICAgLy8gY29udmVydCB3aW5kb3dzIGZpbGUgc2VwYXJhdG9ycyBhbmQgbm9ybWFsaXplXG4gICAgICAgIHJldHVybiBqb2luKFwiLlwiLCBub3JtYWxpemUoc2VwICsgemlwUGF0aC5zcGxpdChcIlxcXFxcIikuam9pbihzZXApICsgc2VwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsZW5hbWVGaWx0ZXIoZmlsdGVyZm4pIHtcbiAgICAgICAgaWYgKGZpbHRlcmZuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAvLyBpZiBmaWx0ZXIgaXMgUmVnRXhwIHdyYXAgaXRcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHJ4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcngudGVzdChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKGZpbHRlcmZuKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBmaWx0ZXJmbikge1xuICAgICAgICAgICAgLy8gaWYgZmlsdGVyIGlzIG5vdCBmdW5jdGlvbiB3ZSB3aWxsIHJlcGxhY2UgaXRcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJmbjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGxhc3QgY2hhcmFjdGVyIG9uIGZvbGRlcnNcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSAobG9jYWwsIGVudHJ5KSA9PiB7XG4gICAgICAgIGxldCBsYXN0Q2hhciA9IGVudHJ5LnNsaWNlKC0xKTtcbiAgICAgICAgbGFzdENoYXIgPSBsYXN0Q2hhciA9PT0gZmlsZXRvb2xzLnNlcCA/IGZpbGV0b29scy5zZXAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gcHRoLnJlbGF0aXZlKGxvY2FsLCBlbnRyeSkgKyBsYXN0Q2hhcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dHJhY3RzIHRoZSBnaXZlbiBlbnRyeSBmcm9tIHRoZSBhcmNoaXZlIGFuZCByZXR1cm5zIHRoZSBjb250ZW50IGFzIGEgQnVmZmVyIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gW3Bhc3NdIC0gcGFzc3dvcmRcbiAgICAgICAgICogQHJldHVybiBCdWZmZXIgb3IgTnVsbCBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRmlsZTogZnVuY3Rpb24gKGVudHJ5LCBwYXNzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiAoaXRlbSAmJiBpdGVtLmdldERhdGEocGFzcykpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaG93IG1hbnkgY2hpbGQgZWxlbWVudHMgaGFzIG9uIGVudHJ5IChkaXJlY3Rvcmllcykgb24gZmlsZXMgaXQgaXMgYWx3YXlzIDBcbiAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeXxzdHJpbmd9IGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQ291bnQ6IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF96aXAuZ2V0Q2hpbGRDb3VudChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmNocm9ub3VzIHJlYWRGaWxlXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcbiAgICAgICAgICogQHBhcmFtIHtjYWxsYmFja30gY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBCdWZmZXIgb3IgTnVsbCBpbiBjYXNlIG9mIGVycm9yXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRmlsZUFzeW5jOiBmdW5jdGlvbiAoZW50cnksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5nZXREYXRhQXN5bmMoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBcImdldEVudHJ5IGZhaWxlZCBmb3I6XCIgKyBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dHJhY3RzIHRoZSBnaXZlbiBlbnRyeSBmcm9tIHRoZSBhcmNoaXZlIGFuZCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHBsYWluIHRleHQgaW4gdGhlIGdpdmVuIGVuY29kaW5nXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeSAtIFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSBPcHRpb25hbC4gSWYgbm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHV0ZjggaXMgdXNlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEFzVGV4dDogZnVuY3Rpb24gKGVudHJ5LCBlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gaXRlbS5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3luY2hyb25vdXMgcmVhZEFzVGV4dFxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fHN0cmluZ30gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RpbmddIC0gT3B0aW9uYWwuIElmIG5vIGVuY29kaW5nIGlzIHNwZWNpZmllZCB1dGY4IGlzIHVzZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRBc1RleHRBc3luYzogZnVuY3Rpb24gKGVudHJ5LCBjYWxsYmFjaywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmdldERhdGFBc3luYyhmdW5jdGlvbiAoZGF0YSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YS50b1N0cmluZyhlbmNvZGluZyB8fCBcInV0ZjhcIikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgZmlsZSBvciB0aGUgZW50cnkgYW5kIGFsbCBpdCdzIG5lc3RlZCBkaXJlY3RvcmllcyBhbmQgZmlsZXMgaWYgdGhlIGdpdmVuIGVudHJ5IGlzIGEgZGlyZWN0b3J5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUZpbGU6IGZ1bmN0aW9uIChlbnRyeSwgd2l0aHN1YmZvbGRlcnMgPSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGVzdCBkZWxldGVGaWxlXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgX3ppcC5kZWxldGVGaWxlKGl0ZW0uZW50cnlOYW1lLCB3aXRoc3ViZm9sZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZW50cnkgZnJvbSB0aGUgZmlsZSBvciBkaXJlY3Rvcnkgd2l0aG91dCBhZmZlY3RpbmcgYW55IG5lc3RlZCBlbnRyaWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl8c3RyaW5nfSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUVudHJ5OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0ZXN0IGRlbGV0ZUVudHJ5XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgX3ppcC5kZWxldGVFbnRyeShpdGVtLmVudHJ5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb21tZW50IHRvIHRoZSB6aXAuIFRoZSB6aXAgbXVzdCBiZSByZXdyaXR0ZW4gYWZ0ZXIgYWRkaW5nIHRoZSBjb21tZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkWmlwQ29tbWVudDogZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0ZXN0IGFkZFppcENvbW1lbnRcbiAgICAgICAgICAgIF96aXAuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHppcCBjb21tZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBnZXRaaXBDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb21tZW50IHRvIGEgc3BlY2lmaWVkIHppcEVudHJ5LiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIGFkZGluZyB0aGUgY29tbWVudFxuICAgICAgICAgKiBUaGUgY29tbWVudCBjYW5ub3QgZXhjZWVkIDY1NTM1IGNoYXJhY3RlcnMgaW4gbGVuZ3RoXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl9IGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50XG4gICAgICAgICAqL1xuICAgICAgICBhZGRaaXBFbnRyeUNvbW1lbnQ6IGZ1bmN0aW9uIChlbnRyeSwgY29tbWVudCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbW1lbnQgb2YgdGhlIHNwZWNpZmllZCBlbnRyeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1ppcEVudHJ5fSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WmlwRW50cnlDb21tZW50OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY29udGVudCBvZiBhbiBleGlzdGluZyBlbnRyeSBpbnNpZGUgdGhlIGFyY2hpdmUuIFRoZSB6aXAgbXVzdCBiZSByZXdyaXR0ZW4gYWZ0ZXIgdXBkYXRpbmcgdGhlIGNvbnRlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtaaXBFbnRyeX0gZW50cnlcbiAgICAgICAgICogQHBhcmFtIHtCdWZmZXJ9IGNvbnRlbnRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUZpbGU6IGZ1bmN0aW9uIChlbnRyeSwgY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0RGF0YShjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGZpbGUgZnJvbSB0aGUgZGlzayB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIEZpbGUgdG8gYWRkIHRvIHppcFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ppcFBhdGhdIE9wdGlvbmFsIHBhdGggaW5zaWRlIHRoZSB6aXBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBOYW1lXSBPcHRpb25hbCBuYW1lIGZvciB0aGUgZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIE9wdGlvbmFsIGZpbGUgY29tbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGaWxlOiBmdW5jdGlvbiAobG9jYWxQYXRoLCB6aXBQYXRoLCB6aXBOYW1lLCBjb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoZmlsZXRvb2xzLmZzLmV4aXN0c1N5bmMobG9jYWxQYXRoKSkge1xuICAgICAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG4gICAgICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIHAgLSBsb2NhbCBmaWxlIG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcHRoLndpbjMyLmJhc2VuYW1lKHB0aC53aW4zMi5ub3JtYWxpemUobG9jYWxQYXRoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgZmlsZSBuYW1lIGludG8gemlwcGF0aFxuICAgICAgICAgICAgICAgIHppcFBhdGggKz0gemlwTmFtZSA/IHppcE5hbWUgOiBwO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBfYXR0ciA9IGZpbGV0b29scy5mcy5zdGF0U3luYyhsb2NhbFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGZpbGUgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBfYXR0ci5pc0ZpbGUoKSA/IGZpbGV0b29scy5mcy5yZWFkRmlsZVN5bmMobG9jYWxQYXRoKSA6IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGZvbGRlclxuICAgICAgICAgICAgICAgIGlmIChfYXR0ci5pc0RpcmVjdG9yeSgpKSB6aXBQYXRoICs9IGZpbGV0b29scy5zZXA7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgZmlsZSBpbnRvIHppcCBmaWxlXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKHppcFBhdGgsIGRhdGEsIGNvbW1lbnQsIF9hdHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkZJTEVfTk9UX0ZPVU5EKGxvY2FsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZvciBzaG93aW5nIGlmIGV2ZXJ5dGhpbmcgd2FzIGRvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjYWxsYmFjayBkb25lQ2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9uZSAtIHdhcyByZXF1ZXN0IGZ1bGx5IGNvbXBsZXRlZFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGZpbGUgZnJvbSB0aGUgZGlzayB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyhvYmplY3R8c3RyaW5nKX0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0LCBpZiBpdCBpcyBzdHJpbmcgaXQgdXMgdXNlZCBhcyBsb2NhbFBhdGguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxvY2FsUGF0aCAtIExvY2FsIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb21tZW50XSAtIE9wdGlvbmFsIGZpbGUgY29tbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnppcFBhdGhdIC0gT3B0aW9uYWwgcGF0aCBpbnNpZGUgdGhlIHppcFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuemlwTmFtZV0gLSBPcHRpb25hbCBuYW1lIGZvciB0aGUgZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge2RvbmVDYWxsYmFja30gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIHRoZSByZXNwb25zZS5cbiAgICAgICAgICovXG4gICAgICAgIGFkZExvY2FsRmlsZUFzeW5jOiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMgOiB7IGxvY2FsUGF0aDogb3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxQYXRoID0gcHRoLnJlc29sdmUob3B0aW9ucy5sb2NhbFBhdGgpO1xuICAgICAgICAgICAgY29uc3QgeyBjb21tZW50IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHsgemlwUGF0aCwgemlwTmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBmaWxldG9vbHMuZnMuc3RhdChsb2NhbFBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVyciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG4gICAgICAgICAgICAgICAgemlwUGF0aCA9IHppcFBhdGggPyBmaXhQYXRoKHppcFBhdGgpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAvLyBwIC0gbG9jYWwgZmlsZSBuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHB0aC53aW4zMi5iYXNlbmFtZShwdGgud2luMzIubm9ybWFsaXplKGxvY2FsUGF0aCkpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBmaWxlIG5hbWUgaW50byB6aXBwYXRoXG4gICAgICAgICAgICAgICAgemlwUGF0aCArPSB6aXBOYW1lID8gemlwTmFtZSA6IHA7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnJlYWRGaWxlKGxvY2FsUGF0aCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVyciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGgsIGRhdGEsIGNvbW1lbnQsIHN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICB6aXBQYXRoICs9IGZpbGV0b29scy5zZXA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkRmlsZSh6aXBQYXRoLCBCdWZmZXIuYWxsb2MoMCksIGNvbW1lbnQsIHN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjaywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGxvY2FsIGRpcmVjdG9yeSBhbmQgYWxsIGl0cyBuZXN0ZWQgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIHRvIHRoZSBhcmNoaXZlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbFBhdGggLSBsb2NhbCBwYXRoIHRvIHRoZSBmb2xkZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt6aXBQYXRoXSAtIG9wdGlvbmFsIHBhdGggaW5zaWRlIHppcFxuICAgICAgICAgKiBAcGFyYW0geyhSZWdFeHB8ZnVuY3Rpb24pfSBbZmlsdGVyXSAtIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGb2xkZXI6IGZ1bmN0aW9uIChsb2NhbFBhdGgsIHppcFBhdGgsIGZpbHRlcikge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBmaWx0ZXJcbiAgICAgICAgICAgIGZpbHRlciA9IGZpbGVuYW1lRmlsdGVyKGZpbHRlcik7XG5cbiAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG4gICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHBhdGggZmlyc3RcbiAgICAgICAgICAgIGxvY2FsUGF0aCA9IHB0aC5ub3JtYWxpemUobG9jYWxQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGZpbGV0b29scy5mcy5leGlzdHNTeW5jKGxvY2FsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGZpbGV0b29scy5maW5kRmlsZXMobG9jYWxQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHB0aC5qb2luKHppcFBhdGgsIHJlbGF0aXZlUGF0aChsb2NhbFBhdGgsIGZpbGVwYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRMb2NhbEZpbGUoZmlsZXBhdGgsIHB0aC5kaXJuYW1lKHApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkZJTEVfTk9UX0ZPVU5EKGxvY2FsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzeW5jaHJvbm91cyBhZGRMb2NhbEZvbGRlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoXG4gICAgICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbemlwUGF0aF0gb3B0aW9uYWwgcGF0aCBpbnNpZGUgemlwXG4gICAgICAgICAqIEBwYXJhbSB7UmVnRXhwfGZ1bmN0aW9ufSBbZmlsdGVyXSBvcHRpb25hbCBSZWdFeHAgb3IgRnVuY3Rpb24gaWYgZmlsZXMgbWF0Y2ggd2lsbFxuICAgICAgICAgKiAgICAgICAgICAgICAgIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGb2xkZXJBc3luYzogZnVuY3Rpb24gKGxvY2FsUGF0aCwgY2FsbGJhY2ssIHppcFBhdGgsIGZpbHRlcikge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBmaWx0ZXJcbiAgICAgICAgICAgIGZpbHRlciA9IGZpbGVuYW1lRmlsdGVyKGZpbHRlcik7XG5cbiAgICAgICAgICAgIC8vIGZpeCBaaXBQYXRoXG4gICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHBhdGggZmlyc3RcbiAgICAgICAgICAgIGxvY2FsUGF0aCA9IHB0aC5ub3JtYWxpemUobG9jYWxQYXRoKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZmlsZXRvb2xzLmZzLm9wZW4obG9jYWxQYXRoLCBcInJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBVdGlscy5FcnJvcnMuRklMRV9OT1RfRk9VTkQobG9jYWxQYXRoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGZpbGV0b29scy5maW5kRmlsZXMobG9jYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSByZWxhdGl2ZVBhdGgobG9jYWxQYXRoLCBmaWxlcGF0aCkuc3BsaXQoXCJcXFxcXCIpLmpvaW4oXCIvXCIpOyAvL3dpbmRvd3MgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vcm1hbGl6ZShcIk5GRFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teXFx4MjAtXFx4N0VdL2csIFwiXCIpOyAvLyBhY2NlbnQgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMuc3RhdChmaWxlcGF0aCwgZnVuY3Rpb24gKGVyMCwgc3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcjApIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXIwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy5yZWFkRmlsZShmaWxlcGF0aCwgZnVuY3Rpb24gKGVyMSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIGVyMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCArIHAsIGRhdGEsIFwiXCIsIHN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCArIHAgKyBcIi9cIiwgQnVmZmVyLmFsbG9jKDApLCBcIlwiLCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGxvY2FsIGRpcmVjdG9yeSBhbmQgYWxsIGl0cyBuZXN0ZWQgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIHRvIHRoZSBhcmNoaXZlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nfSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QsIGlmIGl0IGlzIHN0cmluZyBpdCB1cyB1c2VkIGFzIGxvY2FsUGF0aC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxQYXRoIC0gTG9jYWwgcGF0aCB0byB0aGUgZm9sZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuemlwUGF0aF0gLSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXAuXG4gICAgICAgICAqIEBwYXJhbSB7UmVnRXhwfGZ1bmN0aW9ufSBbb3B0aW9ucy5maWx0ZXJdIC0gb3B0aW9uYWwgUmVnRXhwIG9yIEZ1bmN0aW9uIGlmIGZpbGVzIG1hdGNoIHdpbGwgYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258c3RyaW5nfSBbb3B0aW9ucy5uYW1lZml4XSAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGhlbHAgZml4IGZpbGVuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZG9uZUNhbGxiYWNrfSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGb2xkZXJBc3luYzI6IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zIDogeyBsb2NhbFBhdGg6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgIGxvY2FsUGF0aCA9IHB0aC5yZXNvbHZlKGZpeFBhdGgob3B0aW9ucy5sb2NhbFBhdGgpKTtcbiAgICAgICAgICAgIGxldCB7IHppcFBhdGgsIGZpbHRlciwgbmFtZWZpeCB9ID0gb3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IChmdW5jdGlvbiAocngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKGZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IFppcFBhdGhcbiAgICAgICAgICAgIHppcFBhdGggPSB6aXBQYXRoID8gZml4UGF0aCh6aXBQYXRoKSA6IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIE5hbWVmaXggZnVuY3Rpb25cbiAgICAgICAgICAgIGlmIChuYW1lZml4ID09IFwibGF0aW4xXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lZml4ID0gKHN0cikgPT5cbiAgICAgICAgICAgICAgICAgICAgc3RyXG4gICAgICAgICAgICAgICAgICAgICAgICAubm9ybWFsaXplKFwiTkZEXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxceDIwLVxceDdFXS9nLCBcIlwiKTsgLy8gYWNjZW50IGZpeCAobGF0aW4xIGNoYXJhY2VycyBvbmx5KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVmaXggIT09IFwiZnVuY3Rpb25cIikgbmFtZWZpeCA9IChzdHIpID0+IHN0cjtcblxuICAgICAgICAgICAgLy8gaW50ZXJuYWwsIGNyZWF0ZSByZWxhdGl2ZSBwYXRoICsgZml4IHRoZSBuYW1lXG4gICAgICAgICAgICBjb25zdCByZWxQYXRoRml4ID0gKGVudHJ5KSA9PiBwdGguam9pbih6aXBQYXRoLCBuYW1lZml4KHJlbGF0aXZlUGF0aChsb2NhbFBhdGgsIGVudHJ5KSkpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWVGaXggPSAoZW50cnkpID0+IHB0aC53aW4zMi5iYXNlbmFtZShwdGgud2luMzIubm9ybWFsaXplKG5hbWVmaXgoZW50cnkpKSk7XG5cbiAgICAgICAgICAgIGZpbGV0b29scy5mcy5vcGVuKGxvY2FsUGF0aCwgXCJyXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgVXRpbHMuRXJyb3JzLkZJTEVfTk9UX0ZPVU5EKGxvY2FsUGF0aCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZmluZEZpbGVzQXN5bmMobG9jYWxQYXRoLCBmdW5jdGlvbiAoZXJyLCBmaWxlRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlRW50cmllcyA9IGZpbGVFbnRyaWVzLmZpbHRlcigoZGlyKSA9PiBmaWx0ZXIocmVsUGF0aEZpeChkaXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVFbnRyaWVzLmxlbmd0aCkgY2FsbGJhY2sodW5kZWZpbmVkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlRW50cmllcy5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uIChuZXh0LCBlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCBkb25lID09PSBmYWxzZSkgcmV0dXJuIHNldEltbWVkaWF0ZShuZXh0LCBlcnIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRMb2NhbEZpbGVBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUGF0aDogZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHppcFBhdGg6IHB0aC5kaXJuYW1lKHJlbFBhdGhGaXgoZW50cnkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemlwTmFtZTogZmlsZU5hbWVGaXgoZW50cnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBsb2NhbCBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gcGF0aCB3aGVyZSBmaWxlcyB3aWxsIGJlIGV4dHJhY3RlZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBvcHRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMuemlwUGF0aF0gLSBvcHRpb25hbCBwYXRoIGluc2lkZSB6aXBcbiAgICAgICAgICogQHBhcmFtIHtSZWdFeHB8ZnVuY3Rpb259IFtwcm9wcy5maWx0ZXJdIC0gb3B0aW9uYWwgUmVnRXhwIG9yIEZ1bmN0aW9uIGlmIGZpbGVzIG1hdGNoIHdpbGwgYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258c3RyaW5nfSBbcHJvcHMubmFtZWZpeF0gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBoZWxwIGZpeCBmaWxlbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGb2xkZXJQcm9taXNlOiBmdW5jdGlvbiAobG9jYWxQYXRoLCBwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExvY2FsRm9sZGVyQXN5bmMyKE9iamVjdC5hc3NpZ24oeyBsb2NhbFBhdGggfSwgcHJvcHMpLCAoZXJyLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGVudHJ5IChmaWxlIG9yIGRpcmVjdG9yeSkgaW4gdGhlIHppcCBmaWxlLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdGhlIGVudHJ5TmFtZSBtdXN0IGVuZCBpbiAvIGFuZCBhIG51bGwgYnVmZmVyIHNob3VsZCBiZSBwcm92aWRlZC5cbiAgICAgICAgICogQ29tbWVudCBhbmQgYXR0cmlidXRlcyBhcmUgb3B0aW9uYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IHN0cmluZ30gY29udGVudCAtIGZpbGUgY29udGVudCBhcyBidWZmZXIgb3IgdXRmOCBjb2RlZCBzdHJpbmdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSAtIGZpbGUgY29tbWVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlciB8IG9iamVjdH0gW2F0dHJdIC0gbnVtYmVyIGFzIHVuaXggZmlsZSBwZXJtaXNzaW9ucywgb2JqZWN0IGFzIGZpbGVzeXN0ZW0gU3RhdHMgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRGaWxlOiBmdW5jdGlvbiAoZW50cnlOYW1lLCBjb250ZW50LCBjb21tZW50LCBhdHRyKSB7XG4gICAgICAgICAgICBlbnRyeU5hbWUgPSB6aXBuYW1lZml4KGVudHJ5TmFtZSk7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBnZXRFbnRyeShlbnRyeU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gZW50cnkgIT0gbnVsbDtcblxuICAgICAgICAgICAgLy8gcHJlcGFyZSBuZXcgZW50cnlcbiAgICAgICAgICAgIGlmICghdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgWmlwRW50cnkob3B0cyk7XG4gICAgICAgICAgICAgICAgZW50cnkuZW50cnlOYW1lID0gZW50cnlOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkuY29tbWVudCA9IGNvbW1lbnQgfHwgXCJcIjtcblxuICAgICAgICAgICAgY29uc3QgaXNTdGF0ID0gXCJvYmplY3RcIiA9PT0gdHlwZW9mIGF0dHIgJiYgYXR0ciBpbnN0YW5jZW9mIGZpbGV0b29scy5mcy5TdGF0cztcblxuICAgICAgICAgICAgLy8gbGFzdCBtb2RpZmljYXRpb24gdGltZSBmcm9tIGZpbGUgc3RhdHNcbiAgICAgICAgICAgIGlmIChpc1N0YXQpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5oZWFkZXIudGltZSA9IGF0dHIubXRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCBmaWxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgdmFyIGZpbGVhdHRyID0gZW50cnkuaXNEaXJlY3RvcnkgPyAweDEwIDogMDsgLy8gKE1TLURPUyBkaXJlY3RvcnkgZmxhZylcblxuICAgICAgICAgICAgLy8gZXh0ZW5kZWQgYXR0cmlidXRlcyBmaWVsZCBmb3IgVW5peFxuICAgICAgICAgICAgLy8gc2V0IGZpbGUgdHlwZSBlaXRoZXIgU19JRkRJUiAvIFNfSUZSRUdcbiAgICAgICAgICAgIGxldCB1bml4ID0gZW50cnkuaXNEaXJlY3RvcnkgPyAweDQwMDAgOiAweDgwMDA7XG5cbiAgICAgICAgICAgIGlmIChpc1N0YXQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxlIGF0dHJpYnV0ZXMgZnJvbSBmaWxlIHN0YXRzXG4gICAgICAgICAgICAgICAgdW5peCB8PSAweGZmZiAmIGF0dHIubW9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRyIGZyb20gZ2l2ZW4gYXR0ciB2YWx1ZXNcbiAgICAgICAgICAgICAgICB1bml4IHw9IDB4ZmZmICYgYXR0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXM6XG4gICAgICAgICAgICAgICAgdW5peCB8PSBlbnRyeS5pc0RpcmVjdG9yeSA/IDBvNzU1IDogMG82NDQ7IC8vIHBlcm1pc3Npb25zIChkcnd4ci14ci14KSBvciAoLXItd3ItLXItLSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZWF0dHIgPSAoZmlsZWF0dHIgfCAodW5peCA8PCAxNikpID4+PiAwOyAvLyBhZGQgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICBlbnRyeS5hdHRyID0gZmlsZWF0dHI7XG5cbiAgICAgICAgICAgIGVudHJ5LnNldERhdGEoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZSkgX3ppcC5zZXRFbnRyeShlbnRyeSk7XG5cbiAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBaaXBFbnRyeSBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgZmlsZXMgYW5kIGZvbGRlcnMgaW5zaWRlIHRoZSBhcmNoaXZlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFzc3dvcmRdXG4gICAgICAgICAqIEByZXR1cm5zIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgICAgICAgICAgIF96aXAucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgICAgIHJldHVybiBfemlwID8gX3ppcC5lbnRyaWVzIDogW107XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBaaXBFbnRyeSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmaWxlIG9yIGZvbGRlciBzcGVjaWZpZWQgYnkgYGBuYW1lYGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gWmlwRW50cnlcbiAgICAgICAgICovXG4gICAgICAgIGdldEVudHJ5OiBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVudHJ5KG5hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVudHJ5Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfemlwLmdldEVudHJ5Q291bnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfemlwLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgdG8gdGhlIGdpdmVuIHRhcmdldFBhdGhcbiAgICAgICAgICogSWYgdGhlIGVudHJ5IGlzIGEgZGlyZWN0b3J5IGluc2lkZSB0aGUgYXJjaGl2ZSwgdGhlIGVudGlyZSBkaXJlY3RvcnkgYW5kIGl0J3Mgc3ViZGlyZWN0b3JpZXMgd2lsbCBiZSBleHRyYWN0ZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8WmlwRW50cnl9IGVudHJ5IC0gWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRQYXRoIC0gVGFyZ2V0IGZvbGRlciB3aGVyZSB0byB3cml0ZSB0aGUgZmlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYWludGFpbkVudHJ5UGF0aD10cnVlXSAtIElmIG1haW50YWluRW50cnlQYXRoIGlzIHRydWUgYW5kIHRoZSBlbnRyeSBpcyBpbnNpZGUgYSBmb2xkZXIsIHRoZSBlbnRyeSBmb2xkZXIgd2lsbCBiZSBjcmVhdGVkIGluIHRhcmdldFBhdGggYXMgd2VsbC4gRGVmYXVsdCBpcyBUUlVFXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV0gLSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBPcmlnaW5hbFBlcm1pc3Npb249ZmFsc2VdIC0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW291dEZpbGVOYW1lXSAtIFN0cmluZyBJZiBzZXQgd2lsbCBvdmVycmlkZSB0aGUgZmlsZW5hbWUgb2YgdGhlIGV4dHJhY3RlZCBmaWxlIChPbmx5IHdvcmtzIGlmIHRoZSBlbnRyeSBpcyBhIGZpbGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGZ1bmN0aW9uIChlbnRyeSwgdGFyZ2V0UGF0aCwgbWFpbnRhaW5FbnRyeVBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgb3V0RmlsZU5hbWUpIHtcbiAgICAgICAgICAgIG92ZXJ3cml0ZSA9IGdldF9Cb29sKGZhbHNlLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA9IGdldF9Cb29sKGZhbHNlLCBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIG1haW50YWluRW50cnlQYXRoID0gZ2V0X0Jvb2wodHJ1ZSwgbWFpbnRhaW5FbnRyeVBhdGgpO1xuICAgICAgICAgICAgb3V0RmlsZU5hbWUgPSBnZXRfU3RyKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIG91dEZpbGVOYW1lKTtcblxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuTk9fRU5UUlkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVudHJ5TmFtZSA9IGNhbm9uaWNhbChpdGVtLmVudHJ5TmFtZSk7XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzYW5pdGl6ZSh0YXJnZXRQYXRoLCBvdXRGaWxlTmFtZSAmJiAhaXRlbS5pc0RpcmVjdG9yeSA/IG91dEZpbGVOYW1lIDogbWFpbnRhaW5FbnRyeVBhdGggPyBlbnRyeU5hbWUgOiBwdGguYmFzZW5hbWUoZW50cnlOYW1lKSk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3ppcC5nZXRFbnRyeUNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc0RpcmVjdG9yeSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGNoaWxkLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNhbm9uaWNhbChjaGlsZC5lbnRyeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gc2FuaXRpemUodGFyZ2V0UGF0aCwgbWFpbnRhaW5FbnRyeVBhdGggPyBuYW1lIDogcHRoLmJhc2VuYW1lKG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGNoaWxkLmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvKGNoaWxkTmFtZSwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0cik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gaXRlbS5nZXREYXRhKF96aXAucGFzc3dvcmQpO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KSB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKTtcblxuICAgICAgICAgICAgaWYgKGZpbGV0b29scy5mcy5leGlzdHNTeW5jKHRhcmdldCkgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5DQU5UX09WRVJSSURFKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgIGNvbnN0IGZpbGVBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUbyh0YXJnZXQsIGNvbnRlbnQsIG92ZXJ3cml0ZSwgZmlsZUF0dHIpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB0aGUgYXJjaGl2ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3Bhc3NdXG4gICAgICAgICAqL1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAocGFzcykge1xuICAgICAgICAgICAgaWYgKCFfemlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBlbnRyeSBpbiBfemlwLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gX3ppcC5lbnRyaWVzW2VudHJ5XS5nZXREYXRhKHBhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dHJhY3RzIHRoZSBlbnRpcmUgYXJjaGl2ZSB0byB0aGUgZ2l2ZW4gbG9jYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhdGggVGFyZ2V0IGxvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV0gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBba2VlcE9yaWdpbmFsUGVybWlzc2lvbj1mYWxzZV0gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBbcGFzc10gcGFzc3dvcmRcbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhY3RBbGxUbzogZnVuY3Rpb24gKHRhcmdldFBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgcGFzcykge1xuICAgICAgICAgICAga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA9IGdldF9Cb29sKGZhbHNlLCBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIHBhc3MgPSBnZXRfU3RyKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIHBhc3MpO1xuICAgICAgICAgICAgb3ZlcndyaXRlID0gZ2V0X0Jvb2woZmFsc2UsIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICBpZiAoIV96aXApIHRocm93IFV0aWxzLkVycm9ycy5OT19aSVAoKTtcblxuICAgICAgICAgICAgX3ppcC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5TmFtZSA9IHNhbml0aXplKHRhcmdldFBhdGgsIGNhbm9uaWNhbChlbnRyeS5lbnRyeU5hbWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLm1ha2VEaXIoZW50cnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGVudHJ5LmdldERhdGEocGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvKGVudHJ5TmFtZSwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0cik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnV0aW1lc1N5bmMoZW50cnlOYW1lLCBlbnRyeS5oZWFkZXIudGltZSwgZW50cnkuaGVhZGVyLnRpbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmNocm9ub3VzIGV4dHJhY3RBbGxUb1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0UGF0aCBUYXJnZXQgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwT3JpZ2luYWxQZXJtaXNzaW9uPWZhbHNlXSBUaGUgZmlsZSB3aWxsIGJlIHNldCBhcyB0aGUgcGVybWlzc2lvbiBmcm9tIHRoZSBlbnRyeSBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFsbCBlbnRyaWVzIGFyZSBleHRyYWN0ZWQgc3VjY2Vzc2Z1bGx5IG9yIGFueSBlcnJvciBpcyB0aHJvd24uXG4gICAgICAgICAqL1xuICAgICAgICBleHRyYWN0QWxsVG9Bc3luYzogZnVuY3Rpb24gKHRhcmdldFBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZ2V0X0Z1bihvdmVyd3JpdGUsIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChmYWxzZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbik7XG4gICAgICAgICAgICBvdmVyd3JpdGUgPSBnZXRfQm9vbChmYWxzZSwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhY3RBbGxUb0FzeW5jKHRhcmdldFBhdGgsIG92ZXJ3cml0ZSwga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3ppcCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFV0aWxzLkVycm9ycy5OT19aSVAoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRQYXRoID0gcHRoLnJlc29sdmUodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGVudHJ5TmFtZSB0b1xuICAgICAgICAgICAgY29uc3QgZ2V0UGF0aCA9IChlbnRyeSkgPT4gc2FuaXRpemUodGFyZ2V0UGF0aCwgcHRoLm5vcm1hbGl6ZShjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lKSkpO1xuICAgICAgICAgICAgY29uc3QgZ2V0RXJyb3IgPSAobXNnLCBmaWxlKSA9PiBuZXcgRXJyb3IobXNnICsgJzogXCInICsgZmlsZSArICdcIicpO1xuXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBkaXJlY3RvcmllcyBmcm9tIGZpbGVzXG4gICAgICAgICAgICBjb25zdCBkaXJFbnRyaWVzID0gW107XG4gICAgICAgICAgICBjb25zdCBmaWxlRW50cmllcyA9IFtdO1xuICAgICAgICAgICAgX3ppcC5lbnRyaWVzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJFbnRyaWVzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJpZXMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBlbnRyaWVzIGZpcnN0IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgcmFjZSBjb25kaXRpb24gYW5kIGFzc3VyZXMgZm9sZGVycyBhcmUgdGhlcmUgYmVmb3JlIHdyaXRpbmcgZmlsZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGlyRW50cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBnZXRQYXRoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMubWFrZURpcihkaXJQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpckF0dHIpIGZpbGV0b29scy5mcy5jaG1vZFN5bmMoZGlyUGF0aCwgZGlyQXR0cik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHVuaXggdGltZXN0YW1wIHdpbGwgY2hhbmdlIGlmIGZpbGVzIGFyZSBsYXRlciBhZGRlZCB0byBmb2xkZXIsIGJ1dCBzdGlsbFxuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMudXRpbWVzU3luYyhkaXJQYXRoLCBlbnRyeS5oZWFkZXIudGltZSwgZW50cnkuaGVhZGVyLnRpbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGdldEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBmb2xkZXJcIiwgZGlyUGF0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAobmV4dCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeU5hbWUgPSBwdGgubm9ybWFsaXplKGNhbm9uaWNhbChlbnRyeS5lbnRyeU5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gc2FuaXRpemUodGFyZ2V0UGF0aCwgZW50cnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmdldERhdGFBc3luYyhmdW5jdGlvbiAoY29udGVudCwgZXJyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChlcnJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUF0dHIgPSBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID8gZW50cnkuaGVhZGVyLmZpbGVBdHRyIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG9Bc3luYyhmaWxlUGF0aCwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0ciwgZnVuY3Rpb24gKHN1Y2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoZ2V0RXJyb3IoXCJVbmFibGUgdG8gd3JpdGUgZmlsZVwiLCBmaWxlUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnV0aW1lcyhmaWxlUGF0aCwgZW50cnkuaGVhZGVyLnRpbWUsIGVudHJ5LmhlYWRlci50aW1lLCBmdW5jdGlvbiAoZXJyXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyXzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dChnZXRFcnJvcihcIlVuYWJsZSB0byBzZXQgdGltZXNcIiwgZmlsZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgdGhlIG5ld2x5IGNyZWF0ZWQgemlwIGZpbGUgdG8gZGlzayBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIG9yIGlmIGEgemlwIHdhcyBvcGVuZWQgYW5kIG5vIGBgdGFyZ2V0RmlsZU5hbWVgYCBpcyBwcm92aWRlZCwgaXQgd2lsbCBvdmVyd3JpdGUgdGhlIG9wZW5lZCB6aXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldEZpbGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZVppcDogZnVuY3Rpb24gKHRhcmdldEZpbGVOYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldEZpbGVOYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXJnZXRGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RmlsZU5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSAmJiBvcHRzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RmlsZU5hbWUgPSBvcHRzLmZpbGVuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgemlwRGF0YSA9IF96aXAuY29tcHJlc3NUb0J1ZmZlcigpO1xuICAgICAgICAgICAgaWYgKHppcERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2sgPSBmaWxldG9vbHMud3JpdGVGaWxlVG8odGFyZ2V0RmlsZU5hbWUsIHppcERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2soIW9rID8gbmV3IEVycm9yKFwiZmFpbGVkXCIpIDogbnVsbCwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRGaWxlTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5vdmVyd3JpdGU9dHJ1ZV0gSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcm9wcy5wZXJtXSBUaGUgZmlsZSB3aWxsIGJlIHNldCBhcyB0aGUgcGVybWlzc2lvbiBmcm9tIHRoZSBlbnRyeSBpZiB0aGlzIGlzIHRydWUuXG5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZVppcFByb21pc2U6IGZ1bmN0aW9uICgvKipTdHJpbmcqLyB0YXJnZXRGaWxlTmFtZSwgLyogb2JqZWN0ICovIHByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG92ZXJ3cml0ZSwgcGVybSB9ID0gT2JqZWN0LmFzc2lnbih7IG92ZXJ3cml0ZTogdHJ1ZSB9LCBwcm9wcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaWxlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldEZpbGVOYW1lICYmIG9wdHMuZmlsZW5hbWUpIHRhcmdldEZpbGVOYW1lID0gb3B0cy5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldEZpbGVOYW1lKSByZWplY3QoXCJBRE0tWklQOiBaSVAgRmlsZSBOYW1lIE1pc3NpbmdcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRvQnVmZmVyUHJvbWlzZSgpLnRoZW4oKHppcERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gKGRvbmUpID0+IChkb25lID8gcmVzb2x2ZShkb25lKSA6IHJlamVjdChcIkFETS1aSVA6IFdhc24ndCBhYmxlIHRvIHdyaXRlIHppcCBmaWxlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvQXN5bmModGFyZ2V0RmlsZU5hbWUsIHppcERhdGEsIG92ZXJ3cml0ZSwgcGVybSwgcmV0KTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IEEgcHJvbWlzZSB0byB0aGUgQnVmZmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9CdWZmZXJQcm9taXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIF96aXAudG9Bc3luY0J1ZmZlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGVudGlyZSB6aXAgZmlsZSBhcyBhIEJ1ZmZlciBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3Age2Z1bmN0aW9ufSBbb25TdWNjZXNzXVxuICAgICAgICAgKiBAcHJvcCB7ZnVuY3Rpb259IFtvbkZhaWxdXG4gICAgICAgICAqIEBwcm9wIHtmdW5jdGlvbn0gW29uSXRlbVN0YXJ0XVxuICAgICAgICAgKiBAcHJvcCB7ZnVuY3Rpb259IFtvbkl0ZW1FbmRdXG4gICAgICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0b0J1ZmZlcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25GYWlsLCBvbkl0ZW1TdGFydCwgb25JdGVtRW5kKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgX3ppcC50b0FzeW5jQnVmZmVyKG9uU3VjY2Vzcywgb25GYWlsLCBvbkl0ZW1TdGFydCwgb25JdGVtRW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfemlwLmNvbXByZXNzVG9CdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/adm-zip.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/headers/entryHeader.js":
/*!*****************************************************!*\
  !*** ./node_modules/adm-zip/headers/entryHeader.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Utils = __webpack_require__(/*! ../util */ \"./node_modules/adm-zip/util/index.js\"),\n    Constants = Utils.Constants;\n\n/* The central directory file header */\nmodule.exports = function () {\n    var _verMade = 20, // v2.0\n        _version = 10, // v1.0\n        _flags = 0,\n        _method = 0,\n        _time = 0,\n        _crc = 0,\n        _compressedSize = 0,\n        _size = 0,\n        _fnameLen = 0,\n        _extraLen = 0,\n        _comLen = 0,\n        _diskStart = 0,\n        _inattr = 0,\n        _attr = 0,\n        _offset = 0;\n\n    _verMade |= Utils.isWin ? 0x0a00 : 0x0300;\n\n    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.\n    // Without it file names may be corrupted for other apps when file names use unicode chars\n    _flags |= Constants.FLG_EFS;\n\n    const _localHeader = {\n        extraLen: 0\n    };\n\n    // casting\n    const uint32 = (val) => Math.max(0, val) >>> 0;\n    const uint16 = (val) => Math.max(0, val) & 0xffff;\n    const uint8 = (val) => Math.max(0, val) & 0xff;\n\n    _time = Utils.fromDate2DOS(new Date());\n\n    return {\n        get made() {\n            return _verMade;\n        },\n        set made(val) {\n            _verMade = val;\n        },\n\n        get version() {\n            return _version;\n        },\n        set version(val) {\n            _version = val;\n        },\n\n        get flags() {\n            return _flags;\n        },\n        set flags(val) {\n            _flags = val;\n        },\n\n        get flags_efs() {\n            return (_flags & Constants.FLG_EFS) > 0;\n        },\n        set flags_efs(val) {\n            if (val) {\n                _flags |= Constants.FLG_EFS;\n            } else {\n                _flags &= ~Constants.FLG_EFS;\n            }\n        },\n\n        get flags_desc() {\n            return (_flags & Constants.FLG_DESC) > 0;\n        },\n        set flags_desc(val) {\n            if (val) {\n                _flags |= Constants.FLG_DESC;\n            } else {\n                _flags &= ~Constants.FLG_DESC;\n            }\n        },\n\n        get method() {\n            return _method;\n        },\n        set method(val) {\n            switch (val) {\n                case Constants.STORED:\n                    this.version = 10;\n                case Constants.DEFLATED:\n                default:\n                    this.version = 20;\n            }\n            _method = val;\n        },\n\n        get time() {\n            return Utils.fromDOS2Date(this.timeval);\n        },\n        set time(val) {\n            this.timeval = Utils.fromDate2DOS(val);\n        },\n\n        get timeval() {\n            return _time;\n        },\n        set timeval(val) {\n            _time = uint32(val);\n        },\n\n        get timeHighByte() {\n            return uint8(_time >>> 8);\n        },\n        get crc() {\n            return _crc;\n        },\n        set crc(val) {\n            _crc = uint32(val);\n        },\n\n        get compressedSize() {\n            return _compressedSize;\n        },\n        set compressedSize(val) {\n            _compressedSize = uint32(val);\n        },\n\n        get size() {\n            return _size;\n        },\n        set size(val) {\n            _size = uint32(val);\n        },\n\n        get fileNameLength() {\n            return _fnameLen;\n        },\n        set fileNameLength(val) {\n            _fnameLen = val;\n        },\n\n        get extraLength() {\n            return _extraLen;\n        },\n        set extraLength(val) {\n            _extraLen = val;\n        },\n\n        get extraLocalLength() {\n            return _localHeader.extraLen;\n        },\n        set extraLocalLength(val) {\n            _localHeader.extraLen = val;\n        },\n\n        get commentLength() {\n            return _comLen;\n        },\n        set commentLength(val) {\n            _comLen = val;\n        },\n\n        get diskNumStart() {\n            return _diskStart;\n        },\n        set diskNumStart(val) {\n            _diskStart = uint32(val);\n        },\n\n        get inAttr() {\n            return _inattr;\n        },\n        set inAttr(val) {\n            _inattr = uint32(val);\n        },\n\n        get attr() {\n            return _attr;\n        },\n        set attr(val) {\n            _attr = uint32(val);\n        },\n\n        // get Unix file permissions\n        get fileAttr() {\n            return (_attr || 0) >> 16 & 0xfff;\n        },\n\n        get offset() {\n            return _offset;\n        },\n        set offset(val) {\n            _offset = uint32(val);\n        },\n\n        get encrypted() {\n            return (_flags & Constants.FLG_ENC) === Constants.FLG_ENC;\n        },\n\n        get centralHeaderSize() {\n            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n        },\n\n        get realDataOffset() {\n            return _offset + Constants.LOCHDR + _localHeader.fnameLen + _localHeader.extraLen;\n        },\n\n        get localHeader() {\n            return _localHeader;\n        },\n\n        loadLocalHeaderFromBinary: function (/*Buffer*/ input) {\n            var data = input.slice(_offset, _offset + Constants.LOCHDR);\n            // 30 bytes and should start with \"PK\\003\\004\"\n            if (data.readUInt32LE(0) !== Constants.LOCSIG) {\n                throw Utils.Errors.INVALID_LOC();\n            }\n\n            // version needed to extract\n            _localHeader.version = data.readUInt16LE(Constants.LOCVER);\n            // general purpose bit flag\n            _localHeader.flags = data.readUInt16LE(Constants.LOCFLG);\n            // compression method\n            _localHeader.method = data.readUInt16LE(Constants.LOCHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            _localHeader.time = data.readUInt32LE(Constants.LOCTIM);\n            // uncompressed file crc-32 valu\n            _localHeader.crc = data.readUInt32LE(Constants.LOCCRC);\n            // compressed size\n            _localHeader.compressedSize = data.readUInt32LE(Constants.LOCSIZ);\n            // uncompressed size\n            _localHeader.size = data.readUInt32LE(Constants.LOCLEN);\n            // filename length\n            _localHeader.fnameLen = data.readUInt16LE(Constants.LOCNAM);\n            // extra field length\n            _localHeader.extraLen = data.readUInt16LE(Constants.LOCEXT);\n\n            // read extra data\n            const extraStart = _offset + Constants.LOCHDR + _localHeader.fnameLen;\n            const extraEnd = extraStart + _localHeader.extraLen;\n            return input.slice(extraStart, extraEnd);\n        },\n\n        loadFromBinary: function (/*Buffer*/ data) {\n            // data should be 46 bytes and start with \"PK 01 02\"\n            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\n                throw Utils.Errors.INVALID_CEN();\n            }\n            // version made by\n            _verMade = data.readUInt16LE(Constants.CENVEM);\n            // version needed to extract\n            _version = data.readUInt16LE(Constants.CENVER);\n            // encrypt, decrypt flags\n            _flags = data.readUInt16LE(Constants.CENFLG);\n            // compression method\n            _method = data.readUInt16LE(Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            _time = data.readUInt32LE(Constants.CENTIM);\n            // uncompressed file crc-32 value\n            _crc = data.readUInt32LE(Constants.CENCRC);\n            // compressed size\n            _compressedSize = data.readUInt32LE(Constants.CENSIZ);\n            // uncompressed size\n            _size = data.readUInt32LE(Constants.CENLEN);\n            // filename length\n            _fnameLen = data.readUInt16LE(Constants.CENNAM);\n            // extra field length\n            _extraLen = data.readUInt16LE(Constants.CENEXT);\n            // file comment length\n            _comLen = data.readUInt16LE(Constants.CENCOM);\n            // volume number start\n            _diskStart = data.readUInt16LE(Constants.CENDSK);\n            // internal file attributes\n            _inattr = data.readUInt16LE(Constants.CENATT);\n            // external file attributes\n            _attr = data.readUInt32LE(Constants.CENATX);\n            // LOC header offset\n            _offset = data.readUInt32LE(Constants.CENOFF);\n        },\n\n        localHeaderToBinary: function () {\n            // LOC header size (30 bytes)\n            var data = Buffer.alloc(Constants.LOCHDR);\n            // \"PK\\003\\004\"\n            data.writeUInt32LE(Constants.LOCSIG, 0);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.LOCVER);\n            // general purpose bit flag\n            data.writeUInt16LE(_flags, Constants.LOCFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.LOCHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.LOCTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.LOCCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.LOCLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\n            // extra field length\n            data.writeUInt16LE(_localHeader.extraLen, Constants.LOCEXT);\n            return data;\n        },\n\n        centralHeaderToBinary: function () {\n            // CEN header size (46 bytes)\n            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\n            // \"PK\\001\\002\"\n            data.writeUInt32LE(Constants.CENSIG, 0);\n            // version made by\n            data.writeUInt16LE(_verMade, Constants.CENVEM);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.CENVER);\n            // encrypt, decrypt flags\n            data.writeUInt16LE(_flags, Constants.CENFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.CENTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.CENCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.CENLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.CENNAM);\n            // extra field length\n            data.writeUInt16LE(_extraLen, Constants.CENEXT);\n            // file comment length\n            data.writeUInt16LE(_comLen, Constants.CENCOM);\n            // volume number start\n            data.writeUInt16LE(_diskStart, Constants.CENDSK);\n            // internal file attributes\n            data.writeUInt16LE(_inattr, Constants.CENATT);\n            // external file attributes\n            data.writeUInt32LE(_attr, Constants.CENATX);\n            // LOC header offset\n            data.writeUInt32LE(_offset, Constants.CENOFF);\n            return data;\n        },\n\n        toJSON: function () {\n            const bytes = function (nr) {\n                return nr + \" bytes\";\n            };\n\n            return {\n                made: _verMade,\n                version: _version,\n                flags: _flags,\n                method: Utils.methodToString(_method),\n                time: this.time,\n                crc: \"0x\" + _crc.toString(16).toUpperCase(),\n                compressedSize: bytes(_compressedSize),\n                size: bytes(_size),\n                fileNameLength: bytes(_fnameLen),\n                extraLength: bytes(_extraLen),\n                commentLength: bytes(_comLen),\n                diskNumStart: _diskStart,\n                inAttr: _inattr,\n                attr: _attr,\n                offset: _offset,\n                centralHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL2VudHJ5SGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxxREFBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvaGVhZGVycy9lbnRyeUhlYWRlci5qcz83Y2Y0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cztcblxuLyogVGhlIGNlbnRyYWwgZGlyZWN0b3J5IGZpbGUgaGVhZGVyICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Zlck1hZGUgPSAyMCwgLy8gdjIuMFxuICAgICAgICBfdmVyc2lvbiA9IDEwLCAvLyB2MS4wXG4gICAgICAgIF9mbGFncyA9IDAsXG4gICAgICAgIF9tZXRob2QgPSAwLFxuICAgICAgICBfdGltZSA9IDAsXG4gICAgICAgIF9jcmMgPSAwLFxuICAgICAgICBfY29tcHJlc3NlZFNpemUgPSAwLFxuICAgICAgICBfc2l6ZSA9IDAsXG4gICAgICAgIF9mbmFtZUxlbiA9IDAsXG4gICAgICAgIF9leHRyYUxlbiA9IDAsXG4gICAgICAgIF9jb21MZW4gPSAwLFxuICAgICAgICBfZGlza1N0YXJ0ID0gMCxcbiAgICAgICAgX2luYXR0ciA9IDAsXG4gICAgICAgIF9hdHRyID0gMCxcbiAgICAgICAgX29mZnNldCA9IDA7XG5cbiAgICBfdmVyTWFkZSB8PSBVdGlscy5pc1dpbiA/IDB4MGEwMCA6IDB4MDMwMDtcblxuICAgIC8vIFNldCBFRlMgZmxhZyBzaW5jZSBmaWxlbmFtZSBhbmQgY29tbWVudCBmaWVsZHMgYXJlIGFsbCBieSBkZWZhdWx0IGVuY29kZWQgdXNpbmcgVVRGLTguXG4gICAgLy8gV2l0aG91dCBpdCBmaWxlIG5hbWVzIG1heSBiZSBjb3JydXB0ZWQgZm9yIG90aGVyIGFwcHMgd2hlbiBmaWxlIG5hbWVzIHVzZSB1bmljb2RlIGNoYXJzXG4gICAgX2ZsYWdzIHw9IENvbnN0YW50cy5GTEdfRUZTO1xuXG4gICAgY29uc3QgX2xvY2FsSGVhZGVyID0ge1xuICAgICAgICBleHRyYUxlbjogMFxuICAgIH07XG5cbiAgICAvLyBjYXN0aW5nXG4gICAgY29uc3QgdWludDMyID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSA+Pj4gMDtcbiAgICBjb25zdCB1aW50MTYgPSAodmFsKSA9PiBNYXRoLm1heCgwLCB2YWwpICYgMHhmZmZmO1xuICAgIGNvbnN0IHVpbnQ4ID0gKHZhbCkgPT4gTWF0aC5tYXgoMCwgdmFsKSAmIDB4ZmY7XG5cbiAgICBfdGltZSA9IFV0aWxzLmZyb21EYXRlMkRPUyhuZXcgRGF0ZSgpKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBtYWRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92ZXJNYWRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgbWFkZSh2YWwpIHtcbiAgICAgICAgICAgIF92ZXJNYWRlID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgdmVyc2lvbih2YWwpIHtcbiAgICAgICAgICAgIF92ZXJzaW9uID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmbGFncyh2YWwpIHtcbiAgICAgICAgICAgIF9mbGFncyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZmxhZ3NfZWZzKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfZmxhZ3MgJiBDb25zdGFudHMuRkxHX0VGUykgPiAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZmxhZ3NfZWZzKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0VGUztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2ZsYWdzICY9IH5Db25zdGFudHMuRkxHX0VGUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZmxhZ3NfZGVzYygpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2ZsYWdzICYgQ29uc3RhbnRzLkZMR19ERVNDKSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmbGFnc19kZXNjKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0RFU0M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9mbGFncyAmPSB+Q29uc3RhbnRzLkZMR19ERVNDO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gX21ldGhvZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG1ldGhvZCh2YWwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5ERUZMQVRFRDpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tZXRob2QgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZnJvbURPUzJEYXRlKHRoaXMudGltZXZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aW1lKHZhbCkge1xuICAgICAgICAgICAgdGhpcy50aW1ldmFsID0gVXRpbHMuZnJvbURhdGUyRE9TKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHRpbWV2YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aW1ldmFsKHZhbCkge1xuICAgICAgICAgICAgX3RpbWUgPSB1aW50MzIodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdGltZUhpZ2hCeXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4KF90aW1lID4+PiA4KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNyYygpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JjO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY3JjKHZhbCkge1xuICAgICAgICAgICAgX2NyYyA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21wcmVzc2VkU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcHJlc3NlZFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21wcmVzc2VkU2l6ZSh2YWwpIHtcbiAgICAgICAgICAgIF9jb21wcmVzc2VkU2l6ZSA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgc2l6ZSh2YWwpIHtcbiAgICAgICAgICAgIF9zaXplID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGZpbGVOYW1lTGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9mbmFtZUxlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGZpbGVOYW1lTGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2ZuYW1lTGVuID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBleHRyYUxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0cmFMZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBleHRyYUxlbmd0aCh2YWwpIHtcbiAgICAgICAgICAgIF9leHRyYUxlbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZXh0cmFMb2NhbExlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbG9jYWxIZWFkZXIuZXh0cmFMZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBleHRyYUxvY2FsTGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmV4dHJhTGVuID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21tZW50TGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21MZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21tZW50TGVuZ3RoKHZhbCkge1xuICAgICAgICAgICAgX2NvbUxlbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZGlza051bVN0YXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9kaXNrU3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBkaXNrTnVtU3RhcnQodmFsKSB7XG4gICAgICAgICAgICBfZGlza1N0YXJ0ID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGluQXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfaW5hdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgaW5BdHRyKHZhbCkge1xuICAgICAgICAgICAgX2luYXR0ciA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBhdHRyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9hdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgYXR0cih2YWwpIHtcbiAgICAgICAgICAgIF9hdHRyID0gdWludDMyKHZhbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZ2V0IFVuaXggZmlsZSBwZXJtaXNzaW9uc1xuICAgICAgICBnZXQgZmlsZUF0dHIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hdHRyIHx8IDApID4+IDE2ICYgMHhmZmY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgb2Zmc2V0KHZhbCkge1xuICAgICAgICAgICAgX29mZnNldCA9IHVpbnQzMih2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBlbmNyeXB0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9mbGFncyAmIENvbnN0YW50cy5GTEdfRU5DKSA9PT0gQ29uc3RhbnRzLkZMR19FTkM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGNlbnRyYWxIZWFkZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50cy5DRU5IRFIgKyBfZm5hbWVMZW4gKyBfZXh0cmFMZW4gKyBfY29tTGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCByZWFsRGF0YU9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUiArIF9sb2NhbEhlYWRlci5mbmFtZUxlbiArIF9sb2NhbEhlYWRlci5leHRyYUxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgbG9jYWxIZWFkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xvY2FsSGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWRMb2NhbEhlYWRlckZyb21CaW5hcnk6IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGlucHV0LnNsaWNlKF9vZmZzZXQsIF9vZmZzZXQgKyBDb25zdGFudHMuTE9DSERSKTtcbiAgICAgICAgICAgIC8vIDMwIGJ5dGVzIGFuZCBzaG91bGQgc3RhcnQgd2l0aCBcIlBLXFwwMDNcXDAwNFwiXG4gICAgICAgICAgICBpZiAoZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5MT0NTSUcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9MT0MoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLnZlcnNpb24gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DVkVSKTtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmZsYWdzID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0ZMRyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICAgICAgICAgIF9sb2NhbEhlYWRlci5tZXRob2QgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DSE9XKTtcbiAgICAgICAgICAgIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICAgICAgICAgIF9sb2NhbEhlYWRlci50aW1lID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkxPQ1RJTSk7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdVxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmNyYyA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NDUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuTE9DU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NMRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBfbG9jYWxIZWFkZXIuZm5hbWVMZW4gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgX2xvY2FsSGVhZGVyLmV4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0VYVCk7XG5cbiAgICAgICAgICAgIC8vIHJlYWQgZXh0cmEgZGF0YVxuICAgICAgICAgICAgY29uc3QgZXh0cmFTdGFydCA9IF9vZmZzZXQgKyBDb25zdGFudHMuTE9DSERSICsgX2xvY2FsSGVhZGVyLmZuYW1lTGVuO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFFbmQgPSBleHRyYVN0YXJ0ICsgX2xvY2FsSGVhZGVyLmV4dHJhTGVuO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGV4dHJhU3RhcnQsIGV4dHJhRW5kKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkRnJvbUJpbmFyeTogZnVuY3Rpb24gKC8qQnVmZmVyKi8gZGF0YSkge1xuICAgICAgICAgICAgLy8gZGF0YSBzaG91bGQgYmUgNDYgYnl0ZXMgYW5kIHN0YXJ0IHdpdGggXCJQSyAwMSAwMlwiXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IENvbnN0YW50cy5DRU5IRFIgfHwgZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5DRU5TSUcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9DRU4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcnNpb24gbWFkZSBieVxuICAgICAgICAgICAgX3Zlck1hZGUgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOVkVNKTtcbiAgICAgICAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICAgICAgICAgIF92ZXJzaW9uID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTlZFUik7XG4gICAgICAgICAgICAvLyBlbmNyeXB0LCBkZWNyeXB0IGZsYWdzXG4gICAgICAgICAgICBfZmxhZ3MgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VORkxHKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgICAgICAgICAgX21ldGhvZCA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5IT1cpO1xuICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgICAgICAgICAgX3RpbWUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOVElNKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgICAgICAgICAgX2NyYyA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5DUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5MRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBfZm5hbWVMZW4gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgX2V4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkVYVCk7XG4gICAgICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICBfY29tTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkNPTSk7XG4gICAgICAgICAgICAvLyB2b2x1bWUgbnVtYmVyIHN0YXJ0XG4gICAgICAgICAgICBfZGlza1N0YXJ0ID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkRTSyk7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIF9pbmF0dHIgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOQVRUKTtcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgX2F0dHIgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOQVRYKTtcbiAgICAgICAgICAgIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG4gICAgICAgICAgICBfb2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTk9GRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9jYWxIZWFkZXJUb0JpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTE9DIGhlYWRlciBzaXplICgzMCBieXRlcylcbiAgICAgICAgICAgIHZhciBkYXRhID0gQnVmZmVyLmFsbG9jKENvbnN0YW50cy5MT0NIRFIpO1xuICAgICAgICAgICAgLy8gXCJQS1xcMDAzXFwwMDRcIlxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKENvbnN0YW50cy5MT0NTSUcsIDApO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuTE9DVkVSKTtcbiAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9mbGFncywgQ29uc3RhbnRzLkxPQ0ZMRyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfbWV0aG9kLCBDb25zdGFudHMuTE9DSE9XKTtcbiAgICAgICAgICAgIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfdGltZSwgQ29uc3RhbnRzLkxPQ1RJTSk7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfY3JjLCBDb25zdGFudHMuTE9DQ1JDKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9jb21wcmVzc2VkU2l6ZSwgQ29uc3RhbnRzLkxPQ1NJWik7XG4gICAgICAgICAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9zaXplLCBDb25zdGFudHMuTE9DTEVOKTtcbiAgICAgICAgICAgIC8vIGZpbGVuYW1lIGxlbmd0aFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9mbmFtZUxlbiwgQ29uc3RhbnRzLkxPQ05BTSk7XG4gICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfbG9jYWxIZWFkZXIuZXh0cmFMZW4sIENvbnN0YW50cy5MT0NFWFQpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2VudHJhbEhlYWRlclRvQmluYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDRU4gaGVhZGVyIHNpemUgKDQ2IGJ5dGVzKVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkNFTkhEUiArIF9mbmFtZUxlbiArIF9leHRyYUxlbiArIF9jb21MZW4pO1xuICAgICAgICAgICAgLy8gXCJQS1xcMDAxXFwwMDJcIlxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKENvbnN0YW50cy5DRU5TSUcsIDApO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX3Zlck1hZGUsIENvbnN0YW50cy5DRU5WRU0pO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuQ0VOVkVSKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHQsIGRlY3J5cHQgZmxhZ3NcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZmxhZ3MsIENvbnN0YW50cy5DRU5GTEcpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX21ldGhvZCwgQ29uc3RhbnRzLkNFTkhPVyk7XG4gICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX3RpbWUsIENvbnN0YW50cy5DRU5USU0pO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NyYywgQ29uc3RhbnRzLkNFTkNSQyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfY29tcHJlc3NlZFNpemUsIENvbnN0YW50cy5DRU5TSVopO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkNFTkxFTik7XG4gICAgICAgICAgICAvLyBmaWxlbmFtZSBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZm5hbWVMZW4sIENvbnN0YW50cy5DRU5OQU0pO1xuICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2V4dHJhTGVuLCBDb25zdGFudHMuQ0VORVhUKTtcbiAgICAgICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfY29tTGVuLCBDb25zdGFudHMuQ0VOQ09NKTtcbiAgICAgICAgICAgIC8vIHZvbHVtZSBudW1iZXIgc3RhcnRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZGlza1N0YXJ0LCBDb25zdGFudHMuQ0VORFNLKTtcbiAgICAgICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9pbmF0dHIsIENvbnN0YW50cy5DRU5BVFQpO1xuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2F0dHIsIENvbnN0YW50cy5DRU5BVFgpO1xuICAgICAgICAgICAgLy8gTE9DIGhlYWRlciBvZmZzZXRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfb2Zmc2V0LCBDb25zdGFudHMuQ0VOT0ZGKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBmdW5jdGlvbiAobnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnIgKyBcIiBieXRlc1wiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYWRlOiBfdmVyTWFkZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBfdmVyc2lvbixcbiAgICAgICAgICAgICAgICBmbGFnczogX2ZsYWdzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogVXRpbHMubWV0aG9kVG9TdHJpbmcoX21ldGhvZCksXG4gICAgICAgICAgICAgICAgdGltZTogdGhpcy50aW1lLFxuICAgICAgICAgICAgICAgIGNyYzogXCIweFwiICsgX2NyYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkU2l6ZTogYnl0ZXMoX2NvbXByZXNzZWRTaXplKSxcbiAgICAgICAgICAgICAgICBzaXplOiBieXRlcyhfc2l6ZSksXG4gICAgICAgICAgICAgICAgZmlsZU5hbWVMZW5ndGg6IGJ5dGVzKF9mbmFtZUxlbiksXG4gICAgICAgICAgICAgICAgZXh0cmFMZW5ndGg6IGJ5dGVzKF9leHRyYUxlbiksXG4gICAgICAgICAgICAgICAgY29tbWVudExlbmd0aDogYnl0ZXMoX2NvbUxlbiksXG4gICAgICAgICAgICAgICAgZGlza051bVN0YXJ0OiBfZGlza1N0YXJ0LFxuICAgICAgICAgICAgICAgIGluQXR0cjogX2luYXR0cixcbiAgICAgICAgICAgICAgICBhdHRyOiBfYXR0cixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICAgICAgY2VudHJhbEhlYWRlclNpemU6IGJ5dGVzKENvbnN0YW50cy5DRU5IRFIgKyBfZm5hbWVMZW4gKyBfZXh0cmFMZW4gKyBfY29tTGVuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIFwiXFx0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/headers/entryHeader.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/headers/index.js":
/*!***********************************************!*\
  !*** ./node_modules/adm-zip/headers/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{exports.EntryHeader = __webpack_require__(/*! ./entryHeader */ \"./node_modules/adm-zip/headers/entryHeader.js\");\nexports.MainHeader = __webpack_require__(/*! ./mainHeader */ \"./node_modules/adm-zip/headers/mainHeader.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLCtHQUE4QztBQUM5Qyw0R0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL2hlYWRlcnMvaW5kZXguanM/ZmZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLkVudHJ5SGVhZGVyID0gcmVxdWlyZShcIi4vZW50cnlIZWFkZXJcIik7XG5leHBvcnRzLk1haW5IZWFkZXIgPSByZXF1aXJlKFwiLi9tYWluSGVhZGVyXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/headers/index.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/headers/mainHeader.js":
/*!****************************************************!*\
  !*** ./node_modules/adm-zip/headers/mainHeader.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Utils = __webpack_require__(/*! ../util */ \"./node_modules/adm-zip/util/index.js\"),\n    Constants = Utils.Constants;\n\n/* The entries in the end of central directory */\nmodule.exports = function () {\n    var _volumeEntries = 0,\n        _totalEntries = 0,\n        _size = 0,\n        _offset = 0,\n        _commentLength = 0;\n\n    return {\n        get diskEntries() {\n            return _volumeEntries;\n        },\n        set diskEntries(/*Number*/ val) {\n            _volumeEntries = _totalEntries = val;\n        },\n\n        get totalEntries() {\n            return _totalEntries;\n        },\n        set totalEntries(/*Number*/ val) {\n            _totalEntries = _volumeEntries = val;\n        },\n\n        get size() {\n            return _size;\n        },\n        set size(/*Number*/ val) {\n            _size = val;\n        },\n\n        get offset() {\n            return _offset;\n        },\n        set offset(/*Number*/ val) {\n            _offset = val;\n        },\n\n        get commentLength() {\n            return _commentLength;\n        },\n        set commentLength(/*Number*/ val) {\n            _commentLength = val;\n        },\n\n        get mainHeaderSize() {\n            return Constants.ENDHDR + _commentLength;\n        },\n\n        loadFromBinary: function (/*Buffer*/ data) {\n            // data should be 22 bytes and start with \"PK 05 06\"\n            // or be 56+ bytes and start with \"PK 06 06\" for Zip64\n            if (\n                (data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&\n                (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)\n            ) {\n                throw Utils.Errors.INVALID_END();\n            }\n\n            if (data.readUInt32LE(0) === Constants.ENDSIG) {\n                // number of entries on this volume\n                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\n                // total number of entries\n                _totalEntries = data.readUInt16LE(Constants.ENDTOT);\n                // central directory size in bytes\n                _size = data.readUInt32LE(Constants.ENDSIZ);\n                // offset of first CEN header\n                _offset = data.readUInt32LE(Constants.ENDOFF);\n                // zip file comment length\n                _commentLength = data.readUInt16LE(Constants.ENDCOM);\n            } else {\n                // number of entries on this volume\n                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\n                // total number of entries\n                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\n                // central directory size in bytes\n                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);\n                // offset of first CEN header\n                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\n\n                _commentLength = 0;\n            }\n        },\n\n        toBinary: function () {\n            var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\n            // \"PK 05 06\" signature\n            b.writeUInt32LE(Constants.ENDSIG, 0);\n            b.writeUInt32LE(0, 4);\n            // number of entries on this volume\n            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\n            // total number of entries\n            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\n            // central directory size in bytes\n            b.writeUInt32LE(_size, Constants.ENDSIZ);\n            // offset of first CEN header\n            b.writeUInt32LE(_offset, Constants.ENDOFF);\n            // zip file comment length\n            b.writeUInt16LE(_commentLength, Constants.ENDCOM);\n            // fill comment memory with spaces so no garbage is left there\n            b.fill(\" \", Constants.ENDHDR);\n\n            return b;\n        },\n\n        toJSON: function () {\n            // creates 0x0000 style output\n            const offset = function (nr, len) {\n                let offs = nr.toString(16).toUpperCase();\n                while (offs.length < len) offs = \"0\" + offs;\n                return \"0x\" + offs;\n            };\n\n            return {\n                diskEntries: _volumeEntries,\n                totalEntries: _totalEntries,\n                size: _size + \" bytes\",\n                offset: offset(_offset, 4),\n                commentLength: _commentLength\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n// Misspelled\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL21haW5IZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLHFEQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvaGVhZGVycy9tYWluSGVhZGVyLmpzPzQwYjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgQ29uc3RhbnRzID0gVXRpbHMuQ29uc3RhbnRzO1xuXG4vKiBUaGUgZW50cmllcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3ZvbHVtZUVudHJpZXMgPSAwLFxuICAgICAgICBfdG90YWxFbnRyaWVzID0gMCxcbiAgICAgICAgX3NpemUgPSAwLFxuICAgICAgICBfb2Zmc2V0ID0gMCxcbiAgICAgICAgX2NvbW1lbnRMZW5ndGggPSAwO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGRpc2tFbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF92b2x1bWVFbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZGlza0VudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF92b2x1bWVFbnRyaWVzID0gX3RvdGFsRW50cmllcyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdG90YWxFbnRyaWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90b3RhbEVudHJpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0b3RhbEVudHJpZXMoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF90b3RhbEVudHJpZXMgPSBfdm9sdW1lRW50cmllcyA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHNpemUoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF9zaXplID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG9mZnNldCgvKk51bWJlciovIHZhbCkge1xuICAgICAgICAgICAgX29mZnNldCA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgY29tbWVudExlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tbWVudExlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnRMZW5ndGgoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF9jb21tZW50TGVuZ3RoID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtYWluSGVhZGVyU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdGFudHMuRU5ESERSICsgX2NvbW1lbnRMZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZEZyb21CaW5hcnk6IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGRhdGEgc2hvdWxkIGJlIDIyIGJ5dGVzIGFuZCBzdGFydCB3aXRoIFwiUEsgMDUgMDZcIlxuICAgICAgICAgICAgLy8gb3IgYmUgNTYrIGJ5dGVzIGFuZCBzdGFydCB3aXRoIFwiUEsgMDYgMDZcIiBmb3IgWmlwNjRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZGF0YS5sZW5ndGggIT09IENvbnN0YW50cy5FTkRIRFIgfHwgZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5FTkRTSUcpICYmXG4gICAgICAgICAgICAgICAgKGRhdGEubGVuZ3RoIDwgQ29uc3RhbnRzLlpJUDY0SERSIHx8IGRhdGEucmVhZFVJbnQzMkxFKDApICE9PSBDb25zdGFudHMuWklQNjRTSUcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9FTkQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEucmVhZFVJbnQzMkxFKDApID09PSBDb25zdGFudHMuRU5EU0lHKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcbiAgICAgICAgICAgICAgICBfdm9sdW1lRW50cmllcyA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5FTkRTVUIpO1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5FTkRUT1QpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FTkRTSVopO1xuICAgICAgICAgICAgICAgIC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG4gICAgICAgICAgICAgICAgX29mZnNldCA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FTkRPRkYpO1xuICAgICAgICAgICAgICAgIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICAgICAgX2NvbW1lbnRMZW5ndGggPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuRU5EQ09NKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyB2b2x1bWVcbiAgICAgICAgICAgICAgICBfdm9sdW1lRW50cmllcyA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRTVUIpO1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICAgICAgX3RvdGFsRW50cmllcyA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRUT1QpO1xuICAgICAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgICAgICBfc2l6ZSA9IFV0aWxzLnJlYWRCaWdVSW50NjRMRShkYXRhLCBDb25zdGFudHMuWklQNjRTSVpFKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0T0ZGKTtcblxuICAgICAgICAgICAgICAgIF9jb21tZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b0JpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkVOREhEUiArIF9jb21tZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFwiUEsgMDUgMDZcIiBzaWduYXR1cmVcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShDb25zdGFudHMuRU5EU0lHLCAwKTtcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRSgwLCA0KTtcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgdm9sdW1lXG4gICAgICAgICAgICBiLndyaXRlVUludDE2TEUoX3ZvbHVtZUVudHJpZXMsIENvbnN0YW50cy5FTkRTVUIpO1xuICAgICAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAgICAgIGIud3JpdGVVSW50MTZMRShfdG90YWxFbnRyaWVzLCBDb25zdGFudHMuRU5EVE9UKTtcbiAgICAgICAgICAgIC8vIGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkVORFNJWik7XG4gICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICAgICAgYi53cml0ZVVJbnQzMkxFKF9vZmZzZXQsIENvbnN0YW50cy5FTkRPRkYpO1xuICAgICAgICAgICAgLy8gemlwIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgIGIud3JpdGVVSW50MTZMRShfY29tbWVudExlbmd0aCwgQ29uc3RhbnRzLkVORENPTSk7XG4gICAgICAgICAgICAvLyBmaWxsIGNvbW1lbnQgbWVtb3J5IHdpdGggc3BhY2VzIHNvIG5vIGdhcmJhZ2UgaXMgbGVmdCB0aGVyZVxuICAgICAgICAgICAgYi5maWxsKFwiIFwiLCBDb25zdGFudHMuRU5ESERSKTtcblxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIDB4MDAwMCBzdHlsZSBvdXRwdXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZ1bmN0aW9uIChuciwgbGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnMgPSBuci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmcy5sZW5ndGggPCBsZW4pIG9mZnMgPSBcIjBcIiArIG9mZnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG9mZnM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc2tFbnRyaWVzOiBfdm9sdW1lRW50cmllcyxcbiAgICAgICAgICAgICAgICB0b3RhbEVudHJpZXM6IF90b3RhbEVudHJpZXMsXG4gICAgICAgICAgICAgICAgc2l6ZTogX3NpemUgKyBcIiBieXRlc1wiLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0KF9vZmZzZXQsIDQpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRMZW5ndGg6IF9jb21tZW50TGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIE1pc3NwZWxsZWRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/headers/mainHeader.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/methods/deflater.js":
/*!**************************************************!*\
  !*** ./node_modules/adm-zip/methods/deflater.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = function (/*Buffer*/ inbuf) {\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\n    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };\n\n    return {\n        deflate: function () {\n            return zlib.deflateRawSync(inbuf, opts);\n        },\n\n        deflateAsync: function (/*Function*/ callback) {\n            var tmp = zlib.createDeflateRaw(opts),\n                parts = [],\n                total = 0;\n            tmp.on(\"data\", function (data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function () {\n                var buf = Buffer.alloc(total),\n                    written = 0;\n                buf.fill(0);\n                for (var i = 0; i < parts.length; i++) {\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2RlZmxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtCQUFNOztBQUU3QixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL21ldGhvZHMvZGVmbGF0ZXIuanM/ODRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGluYnVmKSB7XG4gICAgdmFyIHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcblxuICAgIHZhciBvcHRzID0geyBjaHVua1NpemU6IChwYXJzZUludChpbmJ1Zi5sZW5ndGggLyAxMDI0KSArIDEpICogMTAyNCB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpsaWIuZGVmbGF0ZVJhd1N5bmMoaW5idWYsIG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmxhdGVBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyhvcHRzKSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcbiAgICAgICAgICAgIHRtcC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bXAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2ModG90YWwpLFxuICAgICAgICAgICAgICAgICAgICB3cml0dGVuID0gMDtcbiAgICAgICAgICAgICAgICBidWYuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuY29weShidWYsIHdyaXR0ZW4pO1xuICAgICAgICAgICAgICAgICAgICB3cml0dGVuICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0bXAuZW5kKGluYnVmKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/methods/deflater.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/methods/index.js":
/*!***********************************************!*\
  !*** ./node_modules/adm-zip/methods/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{exports.Deflater = __webpack_require__(/*! ./deflater */ \"./node_modules/adm-zip/methods/deflater.js\");\nexports.Inflater = __webpack_require__(/*! ./inflater */ \"./node_modules/adm-zip/methods/inflater.js\");\nexports.ZipCrypto = __webpack_require__(/*! ./zipcrypto */ \"./node_modules/adm-zip/methods/zipcrypto.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHNHQUF3QztBQUN4QyxzR0FBd0M7QUFDeEMseUdBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2luZGV4LmpzPzUyMTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5EZWZsYXRlciA9IHJlcXVpcmUoXCIuL2RlZmxhdGVyXCIpO1xuZXhwb3J0cy5JbmZsYXRlciA9IHJlcXVpcmUoXCIuL2luZmxhdGVyXCIpO1xuZXhwb3J0cy5aaXBDcnlwdG8gPSByZXF1aXJlKFwiLi96aXBjcnlwdG9cIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/methods/index.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/methods/inflater.js":
/*!**************************************************!*\
  !*** ./node_modules/adm-zip/methods/inflater.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const version = +(process.versions ? process.versions.node : \"\").split(\".\")[0] || 0;\n\nmodule.exports = function (/*Buffer*/ inbuf, /*number*/ expectedLength) {\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const option = version >= 15 && expectedLength > 0 ? { maxOutputLength: expectedLength } : {};\n\n    return {\n        inflate: function () {\n            return zlib.inflateRawSync(inbuf, option);\n        },\n\n        inflateAsync: function (/*Function*/ callback) {\n            var tmp = zlib.createInflateRaw(option),\n                parts = [],\n                total = 0;\n            tmp.on(\"data\", function (data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function () {\n                var buf = Buffer.alloc(total),\n                    written = 0;\n                buf.fill(0);\n                for (var i = 0; i < parts.length; i++) {\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2luZmxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLDJEQUEyRCxrQ0FBa0M7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL21ldGhvZHMvaW5mbGF0ZXIuanM/NTkwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB2ZXJzaW9uID0gKyhwcm9jZXNzLnZlcnNpb25zID8gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDogXCJcIikuc3BsaXQoXCIuXCIpWzBdIHx8IDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5idWYsIC8qbnVtYmVyKi8gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICB2YXIgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuICAgIGNvbnN0IG9wdGlvbiA9IHZlcnNpb24gPj0gMTUgJiYgZXhwZWN0ZWRMZW5ndGggPiAwID8geyBtYXhPdXRwdXRMZW5ndGg6IGV4cGVjdGVkTGVuZ3RoIH0gOiB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGluZmxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6bGliLmluZmxhdGVSYXdTeW5jKGluYnVmLCBvcHRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluZmxhdGVBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyhvcHRpb24pLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgICAgdG1wLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0b3RhbCksXG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5KGJ1Ziwgd3JpdHRlbik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1Zik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5lbmQoaW5idWYpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/methods/inflater.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/methods/zipcrypto.js":
/*!***************************************************!*\
  !*** ./node_modules/adm-zip/methods/zipcrypto.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n// node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst Errors = __webpack_require__(/*! ../util/errors */ \"./node_modules/adm-zip/util/errors.js\");\n\n// generate CRC32 lookup table\nconst crctable = new Uint32Array(256).map((t, crc) => {\n    for (let j = 0; j < 8; j++) {\n        if (0 !== (crc & 1)) {\n            crc = (crc >>> 1) ^ 0xedb88320;\n        } else {\n            crc >>>= 1;\n        }\n    }\n    return crc >>> 0;\n});\n\n// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\nconst uMul = (a, b) => Math.imul(a, b) >>> 0;\n\n// crc32 byte single update (actually same function is part of utils.crc32 function :) )\nconst crc32update = (pCrc32, bval) => {\n    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);\n};\n\n// function for generating salt for encrytion header\nconst genSalt = () => {\n    if (\"function\" === typeof randomFillSync) {\n        return randomFillSync(Buffer.alloc(12));\n    } else {\n        // fallback if function is not defined\n        return genSalt.node();\n    }\n};\n\n// salt generation with node random function (mainly as fallback)\ngenSalt.node = () => {\n    const salt = Buffer.alloc(12);\n    const len = salt.length;\n    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;\n    return salt;\n};\n\n// general config\nconst config = {\n    genSalt\n};\n\n// Class Initkeys handles same basic ops with keys\nfunction Initkeys(pw) {\n    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n    for (let i = 0; i < pass.length; i++) {\n        this.updateKeys(pass[i]);\n    }\n}\n\nInitkeys.prototype.updateKeys = function (byteValue) {\n    const keys = this.keys;\n    keys[0] = crc32update(keys[0], byteValue);\n    keys[1] += keys[0] & 0xff;\n    keys[1] = uMul(keys[1], 134775813) + 1;\n    keys[2] = crc32update(keys[2], keys[1] >>> 24);\n    return byteValue;\n};\n\nInitkeys.prototype.next = function () {\n    const k = (this.keys[2] | 2) >>> 0; // key\n    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode\n};\n\nfunction make_decrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return decrypter function\n    return function (/*Buffer*/ data) {\n        // result - we create new Buffer for results\n        const result = Buffer.alloc(data.length);\n        let pos = 0;\n        // process input data\n        for (let c of data) {\n            //c ^= keys.next();\n            //result[pos++] = c; // decode & Save Value\n            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction make_encrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return encrypting function, result and pos is here so we dont have to merge buffers later\n    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {\n        // result - we create new Buffer for results\n        if (!result) result = Buffer.alloc(data.length);\n        // process input data\n        for (let c of data) {\n            const k = keys.next(); // save key byte\n            result[pos++] = c ^ k; // save val\n            keys.updateKeys(c); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {\n    if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n        return Buffer.alloc(0);\n    }\n\n    // 1. We Initialize and generate decrypting function\n    const decrypter = make_decrypter(pwd);\n\n    // 2. decrypt salt what is always 12 bytes and is a part of file content\n    const salt = decrypter(data.slice(0, 12));\n\n    // if bit 3 (0x08) of the general-purpose flags field is set, check salt[11] with the high byte of the header time\n    // 2 byte data block (as per Info-Zip spec), otherwise check with the high byte of the header entry\n    const verifyByte = (header.flags & 0x8) === 0x8 ? header.timeHighByte : header.crc >>> 24;\n\n    //3. does password meet expectations\n    if (salt[11] !== verifyByte) {\n        throw Errors.WRONG_PASSWORD();\n    }\n\n    // 4. decode content\n    return decrypter(data.slice(12));\n}\n\n// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\nfunction _salter(data) {\n    if (Buffer.isBuffer(data) && data.length >= 12) {\n        // be aware - currently salting buffer data is modified\n        config.genSalt = function () {\n            return data.slice(0, 12);\n        };\n    } else if (data === \"node\") {\n        // test salt generation with node random function\n        config.genSalt = genSalt.node;\n    } else {\n        // if value is not acceptable config gets reset.\n        config.genSalt = genSalt;\n    }\n}\n\nfunction encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {\n    // 1. test data if data is not Buffer we make buffer from it\n    if (data == null) data = Buffer.alloc(0);\n    // if data is not buffer be make buffer from it\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n\n    // 2. We Initialize and generate encrypting function\n    const encrypter = make_encrypter(pwd);\n\n    // 3. generate salt (12-bytes of random data)\n    const salt = config.genSalt();\n    salt[11] = (header.crc >>> 24) & 0xff;\n\n    // old implementations (before PKZip 2.04g) used two byte check\n    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;\n\n    // 4. create output\n    const result = Buffer.alloc(data.length + 12);\n    encrypter(salt, result);\n\n    // finally encode content\n    return encrypter(data, result, 12);\n}\n\nmodule.exports = { decrypt, encrypt, _salter };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL3ppcGNyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw2REFBZ0I7O0FBRXZDO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL21ldGhvZHMvemlwY3J5cHRvLmpzPzY3NzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIG5vZGUgY3J5cHQsIHdlIHVzZSBpdCBmb3IgZ2VuZXJhdGUgc2FsdFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9yc1wiKTtcblxuLy8gZ2VuZXJhdGUgQ1JDMzIgbG9va3VwIHRhYmxlXG5jb25zdCBjcmN0YWJsZSA9IG5ldyBVaW50MzJBcnJheSgyNTYpLm1hcCgodCwgY3JjKSA9PiB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgaWYgKDAgIT09IChjcmMgJiAxKSkge1xuICAgICAgICAgICAgY3JjID0gKGNyYyA+Pj4gMSkgXiAweGVkYjg4MzIwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3JjID4+Pj0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JjID4+PiAwO1xufSk7XG5cbi8vIEMtc3R5bGUgdUludDMyIE11bHRpcGx5IChkaXNjYXJkcyBoaWdoZXIgYml0cywgd2hlbiBKUyBtdWx0aXBseSBkaXNjYXJkcyBsb3dlciBiaXRzKVxuY29uc3QgdU11bCA9IChhLCBiKSA9PiBNYXRoLmltdWwoYSwgYikgPj4+IDA7XG5cbi8vIGNyYzMyIGJ5dGUgc2luZ2xlIHVwZGF0ZSAoYWN0dWFsbHkgc2FtZSBmdW5jdGlvbiBpcyBwYXJ0IG9mIHV0aWxzLmNyYzMyIGZ1bmN0aW9uIDopIClcbmNvbnN0IGNyYzMydXBkYXRlID0gKHBDcmMzMiwgYnZhbCkgPT4ge1xuICAgIHJldHVybiBjcmN0YWJsZVsocENyYzMyIF4gYnZhbCkgJiAweGZmXSBeIChwQ3JjMzIgPj4+IDgpO1xufTtcblxuLy8gZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgc2FsdCBmb3IgZW5jcnl0aW9uIGhlYWRlclxuY29uc3QgZ2VuU2FsdCA9ICgpID0+IHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmFuZG9tRmlsbFN5bmMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbUZpbGxTeW5jKEJ1ZmZlci5hbGxvYygxMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgIHJldHVybiBnZW5TYWx0Lm5vZGUoKTtcbiAgICB9XG59O1xuXG4vLyBzYWx0IGdlbmVyYXRpb24gd2l0aCBub2RlIHJhbmRvbSBmdW5jdGlvbiAobWFpbmx5IGFzIGZhbGxiYWNrKVxuZ2VuU2FsdC5ub2RlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhbHQgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICAgIGNvbnN0IGxlbiA9IHNhbHQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHNhbHRbaV0gPSAoTWF0aC5yYW5kb20oKSAqIDI1NikgJiAweGZmO1xuICAgIHJldHVybiBzYWx0O1xufTtcblxuLy8gZ2VuZXJhbCBjb25maWdcbmNvbnN0IGNvbmZpZyA9IHtcbiAgICBnZW5TYWx0XG59O1xuXG4vLyBDbGFzcyBJbml0a2V5cyBoYW5kbGVzIHNhbWUgYmFzaWMgb3BzIHdpdGgga2V5c1xuZnVuY3Rpb24gSW5pdGtleXMocHcpIHtcbiAgICBjb25zdCBwYXNzID0gQnVmZmVyLmlzQnVmZmVyKHB3KSA/IHB3IDogQnVmZmVyLmZyb20ocHcpO1xuICAgIHRoaXMua2V5cyA9IG5ldyBVaW50MzJBcnJheShbMHgxMjM0NTY3OCwgMHgyMzQ1Njc4OSwgMHgzNDU2Nzg5MF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnVwZGF0ZUtleXMocGFzc1tpXSk7XG4gICAgfVxufVxuXG5Jbml0a2V5cy5wcm90b3R5cGUudXBkYXRlS2V5cyA9IGZ1bmN0aW9uIChieXRlVmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gdGhpcy5rZXlzO1xuICAgIGtleXNbMF0gPSBjcmMzMnVwZGF0ZShrZXlzWzBdLCBieXRlVmFsdWUpO1xuICAgIGtleXNbMV0gKz0ga2V5c1swXSAmIDB4ZmY7XG4gICAga2V5c1sxXSA9IHVNdWwoa2V5c1sxXSwgMTM0Nzc1ODEzKSArIDE7XG4gICAga2V5c1syXSA9IGNyYzMydXBkYXRlKGtleXNbMl0sIGtleXNbMV0gPj4+IDI0KTtcbiAgICByZXR1cm4gYnl0ZVZhbHVlO1xufTtcblxuSW5pdGtleXMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgayA9ICh0aGlzLmtleXNbMl0gfCAyKSA+Pj4gMDsgLy8ga2V5XG4gICAgcmV0dXJuICh1TXVsKGssIGsgXiAxKSA+PiA4KSAmIDB4ZmY7IC8vIGRlY29kZVxufTtcblxuZnVuY3Rpb24gbWFrZV9kZWNyeXB0ZXIoLypCdWZmZXIqLyBwd2QpIHtcbiAgICAvLyAxLiBTdGFnZSBpbml0aWFsaXplIGtleVxuICAgIGNvbnN0IGtleXMgPSBuZXcgSW5pdGtleXMocHdkKTtcblxuICAgIC8vIHJldHVybiBkZWNyeXB0ZXIgZnVuY3Rpb25cbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qQnVmZmVyKi8gZGF0YSkge1xuICAgICAgICAvLyByZXN1bHQgLSB3ZSBjcmVhdGUgbmV3IEJ1ZmZlciBmb3IgcmVzdWx0c1xuICAgICAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2MoZGF0YS5sZW5ndGgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgLy8gcHJvY2VzcyBpbnB1dCBkYXRhXG4gICAgICAgIGZvciAobGV0IGMgb2YgZGF0YSkge1xuICAgICAgICAgICAgLy9jIF49IGtleXMubmV4dCgpO1xuICAgICAgICAgICAgLy9yZXN1bHRbcG9zKytdID0gYzsgLy8gZGVjb2RlICYgU2F2ZSBWYWx1ZVxuICAgICAgICAgICAgcmVzdWx0W3BvcysrXSA9IGtleXMudXBkYXRlS2V5cyhjIF4ga2V5cy5uZXh0KCkpOyAvLyB1cGRhdGUga2V5cyB3aXRoIGRlY29kZWQgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV9lbmNyeXB0ZXIoLypCdWZmZXIqLyBwd2QpIHtcbiAgICAvLyAxLiBTdGFnZSBpbml0aWFsaXplIGtleVxuICAgIGNvbnN0IGtleXMgPSBuZXcgSW5pdGtleXMocHdkKTtcblxuICAgIC8vIHJldHVybiBlbmNyeXB0aW5nIGZ1bmN0aW9uLCByZXN1bHQgYW5kIHBvcyBpcyBoZXJlIHNvIHdlIGRvbnQgaGF2ZSB0byBtZXJnZSBidWZmZXJzIGxhdGVyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEsIC8qQnVmZmVyKi8gcmVzdWx0LCAvKiBOdW1iZXIgKi8gcG9zID0gMCkge1xuICAgICAgICAvLyByZXN1bHQgLSB3ZSBjcmVhdGUgbmV3IEJ1ZmZlciBmb3IgcmVzdWx0c1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgLy8gcHJvY2VzcyBpbnB1dCBkYXRhXG4gICAgICAgIGZvciAobGV0IGMgb2YgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgayA9IGtleXMubmV4dCgpOyAvLyBzYXZlIGtleSBieXRlXG4gICAgICAgICAgICByZXN1bHRbcG9zKytdID0gYyBeIGs7IC8vIHNhdmUgdmFsXG4gICAgICAgICAgICBrZXlzLnVwZGF0ZUtleXMoYyk7IC8vIHVwZGF0ZSBrZXlzIHdpdGggZGVjb2RlZCBieXRlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkZWNyeXB0KC8qQnVmZmVyKi8gZGF0YSwgLypPYmplY3QqLyBoZWFkZXIsIC8qU3RyaW5nLCBCdWZmZXIqLyBwd2QpIHtcbiAgICBpZiAoIWRhdGEgfHwgIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhLmxlbmd0aCA8IDEyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuXG4gICAgLy8gMS4gV2UgSW5pdGlhbGl6ZSBhbmQgZ2VuZXJhdGUgZGVjcnlwdGluZyBmdW5jdGlvblxuICAgIGNvbnN0IGRlY3J5cHRlciA9IG1ha2VfZGVjcnlwdGVyKHB3ZCk7XG5cbiAgICAvLyAyLiBkZWNyeXB0IHNhbHQgd2hhdCBpcyBhbHdheXMgMTIgYnl0ZXMgYW5kIGlzIGEgcGFydCBvZiBmaWxlIGNvbnRlbnRcbiAgICBjb25zdCBzYWx0ID0gZGVjcnlwdGVyKGRhdGEuc2xpY2UoMCwgMTIpKTtcblxuICAgIC8vIGlmIGJpdCAzICgweDA4KSBvZiB0aGUgZ2VuZXJhbC1wdXJwb3NlIGZsYWdzIGZpZWxkIGlzIHNldCwgY2hlY2sgc2FsdFsxMV0gd2l0aCB0aGUgaGlnaCBieXRlIG9mIHRoZSBoZWFkZXIgdGltZVxuICAgIC8vIDIgYnl0ZSBkYXRhIGJsb2NrIChhcyBwZXIgSW5mby1aaXAgc3BlYyksIG90aGVyd2lzZSBjaGVjayB3aXRoIHRoZSBoaWdoIGJ5dGUgb2YgdGhlIGhlYWRlciBlbnRyeVxuICAgIGNvbnN0IHZlcmlmeUJ5dGUgPSAoaGVhZGVyLmZsYWdzICYgMHg4KSA9PT0gMHg4ID8gaGVhZGVyLnRpbWVIaWdoQnl0ZSA6IGhlYWRlci5jcmMgPj4+IDI0O1xuXG4gICAgLy8zLiBkb2VzIHBhc3N3b3JkIG1lZXQgZXhwZWN0YXRpb25zXG4gICAgaWYgKHNhbHRbMTFdICE9PSB2ZXJpZnlCeXRlKSB7XG4gICAgICAgIHRocm93IEVycm9ycy5XUk9OR19QQVNTV09SRCgpO1xuICAgIH1cblxuICAgIC8vIDQuIGRlY29kZSBjb250ZW50XG4gICAgcmV0dXJuIGRlY3J5cHRlcihkYXRhLnNsaWNlKDEyKSk7XG59XG5cbi8vIGxldHMgYWRkIHdheSB0byBwb3B1bGF0ZSBzYWx0LCBOT1QgUkVDT01NRU5ERUQgZm9yIHByb2R1Y3Rpb24gYnV0IG1heWJlIHVzZWZ1bCBmb3IgdGVzdGluZyBnZW5lcmFsIGZ1bmN0aW9uYWxpdHlcbmZ1bmN0aW9uIF9zYWx0ZXIoZGF0YSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkgJiYgZGF0YS5sZW5ndGggPj0gMTIpIHtcbiAgICAgICAgLy8gYmUgYXdhcmUgLSBjdXJyZW50bHkgc2FsdGluZyBidWZmZXIgZGF0YSBpcyBtb2RpZmllZFxuICAgICAgICBjb25maWcuZ2VuU2FsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIDEyKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIC8vIHRlc3Qgc2FsdCBnZW5lcmF0aW9uIHdpdGggbm9kZSByYW5kb20gZnVuY3Rpb25cbiAgICAgICAgY29uZmlnLmdlblNhbHQgPSBnZW5TYWx0Lm5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGFjY2VwdGFibGUgY29uZmlnIGdldHMgcmVzZXQuXG4gICAgICAgIGNvbmZpZy5nZW5TYWx0ID0gZ2VuU2FsdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHQoLypCdWZmZXIqLyBkYXRhLCAvKk9iamVjdCovIGhlYWRlciwgLypTdHJpbmcsIEJ1ZmZlciovIHB3ZCwgLypCb29sZWFuKi8gb2xkbGlrZSA9IGZhbHNlKSB7XG4gICAgLy8gMS4gdGVzdCBkYXRhIGlmIGRhdGEgaXMgbm90IEJ1ZmZlciB3ZSBtYWtlIGJ1ZmZlciBmcm9tIGl0XG4gICAgaWYgKGRhdGEgPT0gbnVsbCkgZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAvLyBpZiBkYXRhIGlzIG5vdCBidWZmZXIgYmUgbWFrZSBidWZmZXIgZnJvbSBpdFxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YS50b1N0cmluZygpKTtcblxuICAgIC8vIDIuIFdlIEluaXRpYWxpemUgYW5kIGdlbmVyYXRlIGVuY3J5cHRpbmcgZnVuY3Rpb25cbiAgICBjb25zdCBlbmNyeXB0ZXIgPSBtYWtlX2VuY3J5cHRlcihwd2QpO1xuXG4gICAgLy8gMy4gZ2VuZXJhdGUgc2FsdCAoMTItYnl0ZXMgb2YgcmFuZG9tIGRhdGEpXG4gICAgY29uc3Qgc2FsdCA9IGNvbmZpZy5nZW5TYWx0KCk7XG4gICAgc2FsdFsxMV0gPSAoaGVhZGVyLmNyYyA+Pj4gMjQpICYgMHhmZjtcblxuICAgIC8vIG9sZCBpbXBsZW1lbnRhdGlvbnMgKGJlZm9yZSBQS1ppcCAyLjA0ZykgdXNlZCB0d28gYnl0ZSBjaGVja1xuICAgIGlmIChvbGRsaWtlKSBzYWx0WzEwXSA9IChoZWFkZXIuY3JjID4+PiAxNikgJiAweGZmO1xuXG4gICAgLy8gNC4gY3JlYXRlIG91dHB1dFxuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCArIDEyKTtcbiAgICBlbmNyeXB0ZXIoc2FsdCwgcmVzdWx0KTtcblxuICAgIC8vIGZpbmFsbHkgZW5jb2RlIGNvbnRlbnRcbiAgICByZXR1cm4gZW5jcnlwdGVyKGRhdGEsIHJlc3VsdCwgMTIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjcnlwdCwgZW5jcnlwdCwgX3NhbHRlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/methods/zipcrypto.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/constants.js":
/*!************************************************!*\
  !*** ./node_modules/adm-zip/util/constants.js ***!
  \************************************************/
/***/ ((module) => {

eval("{module.exports = {\n    /* The local file header */\n    LOCHDR           : 30, // LOC header size\n    LOCSIG           : 0x04034b50, // \"PK\\003\\004\"\n    LOCVER           : 4,\t// version needed to extract\n    LOCFLG           : 6, // general purpose bit flag\n    LOCHOW           : 8, // compression method\n    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC           : 14, // uncompressed file crc-32 value\n    LOCSIZ           : 18, // compressed size\n    LOCLEN           : 22, // uncompressed size\n    LOCNAM           : 26, // filename length\n    LOCEXT           : 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG           : 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR           : 16, // EXT header size\n    EXTCRC           : 4, // uncompressed file crc-32 value\n    EXTSIZ           : 8, // compressed size\n    EXTLEN           : 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR           : 46, // CEN header size\n    CENSIG           : 0x02014b50, // \"PK\\001\\002\"\n    CENVEM           : 4, // version made by\n    CENVER           : 6, // version needed to extract\n    CENFLG           : 8, // encrypt, decrypt flags\n    CENHOW           : 10, // compression method\n    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC           : 16, // uncompressed file crc-32 value\n    CENSIZ           : 20, // compressed size\n    CENLEN           : 24, // uncompressed size\n    CENNAM           : 28, // filename length\n    CENEXT           : 30, // extra field length\n    CENCOM           : 32, // file comment length\n    CENDSK           : 34, // volume number start\n    CENATT           : 36, // internal file attributes\n    CENATX           : 38, // external file attributes (host system dependent)\n    CENOFF           : 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR           : 22, // END header size\n    ENDSIG           : 0x06054b50, // \"PK\\005\\006\"\n    ENDSUB           : 8, // number of entries on this disk\n    ENDTOT           : 10, // total number of entries\n    ENDSIZ           : 12, // central directory size in bytes\n    ENDOFF           : 16, // offset of first CEN header\n    ENDCOM           : 20, // zip file comment length\n\n    END64HDR         : 20, // zip64 END header size\n    END64SIG         : 0x07064b50, // zip64 Locator signature, \"PK\\006\\007\"\n    END64START       : 4, // number of the disk with the start of the zip64\n    END64OFF         : 8, // relative offset of the zip64 end of central directory\n    END64NUMDISKS    : 16, // total number of disks\n\n    ZIP64SIG         : 0x06064b50, // zip64 signature, \"PK\\006\\006\"\n    ZIP64HDR         : 56, // zip64 record minimum size\n    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE\n    ZIP64SIZE        : 4, // zip64 size of the central directory record\n    ZIP64VEM         : 12, // zip64 version made by\n    ZIP64VER         : 14, // zip64 version needed to extract\n    ZIP64DSK         : 16, // zip64 number of this disk\n    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory\n    ZIP64SUB         : 24, // number of entries on this disk\n    ZIP64TOT         : 32, // total number of entries\n    ZIP64SIZB        : 40, // zip64 central directory size in bytes\n    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number\n    ZIP64EXTRA       : 56, // extensible data sector\n\n    /* Compression methods */\n    STORED           : 0, // no compression\n    SHRUNK           : 1, // shrunk\n    REDUCED1         : 2, // reduced with compression factor 1\n    REDUCED2         : 3, // reduced with compression factor 2\n    REDUCED3         : 4, // reduced with compression factor 3\n    REDUCED4         : 5, // reduced with compression factor 4\n    IMPLODED         : 6, // imploded\n    // 7 reserved for Tokenizing compression algorithm\n    DEFLATED         : 8, // deflated\n    ENHANCED_DEFLATED: 9, // enhanced deflated\n    PKWARE           : 10,// PKWare DCL imploded\n    // 11 reserved by PKWARE\n    BZIP2            : 12, //  compressed using BZIP2\n    // 13 reserved by PKWARE\n    LZMA             : 14, // LZMA\n    // 15-17 reserved by PKWARE\n    IBM_TERSE        : 18, // compressed using IBM TERSE\n    IBM_LZ77         : 19, // IBM LZ77 z\n    AES_ENCRYPT      : 99, // WinZIP AES encryption method\n\n    /* General purpose bit flag */\n    // values can obtained with expression 2**bitnr\n    FLG_ENC          : 1,    // Bit 0: encrypted file\n    FLG_COMP1        : 2,    // Bit 1, compression option\n    FLG_COMP2        : 4,    // Bit 2, compression option\n    FLG_DESC         : 8,    // Bit 3, data descriptor\n    FLG_ENH          : 16,   // Bit 4, enhanced deflating\n    FLG_PATCH        : 32,   // Bit 5, indicates that the file is compressed patched data.\n    FLG_STR          : 64,   // Bit 6, strong encryption (patented)\n                             // Bits 7-10: Currently unused.\n    FLG_EFS          : 2048, // Bit 11: Language encoding flag (EFS)\n                             // Bit 12: Reserved by PKWARE for enhanced compression.\n                             // Bit 13: encrypted the Central Directory (patented).\n                             // Bits 14-15: Reserved by PKWARE.\n    FLG_MSK          : 4096, // mask header values\n\n    /* Load type */\n    FILE             : 2,\n    BUFFER           : 1,\n    NONE             : 0,\n\n    /* 4.5 Extensible data fields */\n    EF_ID            : 0,\n    EF_SIZE          : 2,\n\n    /* Header IDs */\n    ID_ZIP64         : 0x0001,\n    ID_AVINFO        : 0x0007,\n    ID_PFS           : 0x0008,\n    ID_OS2           : 0x0009,\n    ID_NTFS          : 0x000a,\n    ID_OPENVMS       : 0x000c,\n    ID_UNIX          : 0x000d,\n    ID_FORK          : 0x000e,\n    ID_PATCH         : 0x000f,\n    ID_X509_PKCS7    : 0x0014,\n    ID_X509_CERTID_F : 0x0015,\n    ID_X509_CERTID_C : 0x0016,\n    ID_STRONGENC     : 0x0017,\n    ID_RECORD_MGT    : 0x0018,\n    ID_X509_PKCS7_RL : 0x0019,\n    ID_IBM1          : 0x0065,\n    ID_IBM2          : 0x0066,\n    ID_POSZIP        : 0x4690,\n\n    EF_ZIP64_OR_32   : 0xffffffff,\n    EF_ZIP64_OR_16   : 0xffff,\n    EF_ZIP64_SUNCOMP : 0,\n    EF_ZIP64_SCOMP   : 8,\n    EF_ZIP64_RHO     : 16,\n    EF_ZIP64_DSN     : 24\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL3V0aWwvY29uc3RhbnRzLmpzPzJiNzkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyogVGhlIGxvY2FsIGZpbGUgaGVhZGVyICovXG4gICAgTE9DSERSICAgICAgICAgICA6IDMwLCAvLyBMT0MgaGVhZGVyIHNpemVcbiAgICBMT0NTSUcgICAgICAgICAgIDogMHgwNDAzNGI1MCwgLy8gXCJQS1xcMDAzXFwwMDRcIlxuICAgIExPQ1ZFUiAgICAgICAgICAgOiA0LFx0Ly8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgIExPQ0ZMRyAgICAgICAgICAgOiA2LCAvLyBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICBMT0NIT1cgICAgICAgICAgIDogOCwgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgTE9DVElNICAgICAgICAgICA6IDEwLCAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG4gICAgTE9DQ1JDICAgICAgICAgICA6IDE0LCAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcbiAgICBMT0NTSVogICAgICAgICAgIDogMTgsIC8vIGNvbXByZXNzZWQgc2l6ZVxuICAgIExPQ0xFTiAgICAgICAgICAgOiAyMiwgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICBMT0NOQU0gICAgICAgICAgIDogMjYsIC8vIGZpbGVuYW1lIGxlbmd0aFxuICAgIExPQ0VYVCAgICAgICAgICAgOiAyOCwgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG5cbiAgICAvKiBUaGUgRGF0YSBkZXNjcmlwdG9yICovXG4gICAgRVhUU0lHICAgICAgICAgICA6IDB4MDgwNzRiNTAsIC8vIFwiUEtcXDAwN1xcMDA4XCJcbiAgICBFWFRIRFIgICAgICAgICAgIDogMTYsIC8vIEVYVCBoZWFkZXIgc2l6ZVxuICAgIEVYVENSQyAgICAgICAgICAgOiA0LCAvLyB1bmNvbXByZXNzZWQgZmlsZSBjcmMtMzIgdmFsdWVcbiAgICBFWFRTSVogICAgICAgICAgIDogOCwgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgRVhUTEVOICAgICAgICAgICA6IDEyLCAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuXG4gICAgLyogVGhlIGNlbnRyYWwgZGlyZWN0b3J5IGZpbGUgaGVhZGVyICovXG4gICAgQ0VOSERSICAgICAgICAgICA6IDQ2LCAvLyBDRU4gaGVhZGVyIHNpemVcbiAgICBDRU5TSUcgICAgICAgICAgIDogMHgwMjAxNGI1MCwgLy8gXCJQS1xcMDAxXFwwMDJcIlxuICAgIENFTlZFTSAgICAgICAgICAgOiA0LCAvLyB2ZXJzaW9uIG1hZGUgYnlcbiAgICBDRU5WRVIgICAgICAgICAgIDogNiwgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgIENFTkZMRyAgICAgICAgICAgOiA4LCAvLyBlbmNyeXB0LCBkZWNyeXB0IGZsYWdzXG4gICAgQ0VOSE9XICAgICAgICAgICA6IDEwLCAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBDRU5USU0gICAgICAgICAgIDogMTIsIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICBDRU5DUkMgICAgICAgICAgIDogMTYsIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgIENFTlNJWiAgICAgICAgICAgOiAyMCwgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgQ0VOTEVOICAgICAgICAgICA6IDI0LCAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIENFTk5BTSAgICAgICAgICAgOiAyOCwgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgQ0VORVhUICAgICAgICAgICA6IDMwLCAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBDRU5DT00gICAgICAgICAgIDogMzIsIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICBDRU5EU0sgICAgICAgICAgIDogMzQsIC8vIHZvbHVtZSBudW1iZXIgc3RhcnRcbiAgICBDRU5BVFQgICAgICAgICAgIDogMzYsIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgIENFTkFUWCAgICAgICAgICAgOiAzOCwgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIChob3N0IHN5c3RlbSBkZXBlbmRlbnQpXG4gICAgQ0VOT0ZGICAgICAgICAgICA6IDQyLCAvLyBMT0MgaGVhZGVyIG9mZnNldFxuXG4gICAgLyogVGhlIGVudHJpZXMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSAqL1xuICAgIEVOREhEUiAgICAgICAgICAgOiAyMiwgLy8gRU5EIGhlYWRlciBzaXplXG4gICAgRU5EU0lHICAgICAgICAgICA6IDB4MDYwNTRiNTAsIC8vIFwiUEtcXDAwNVxcMDA2XCJcbiAgICBFTkRTVUIgICAgICAgICAgIDogOCwgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyBkaXNrXG4gICAgRU5EVE9UICAgICAgICAgICA6IDEwLCAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuICAgIEVORFNJWiAgICAgICAgICAgOiAxMiwgLy8gY2VudHJhbCBkaXJlY3Rvcnkgc2l6ZSBpbiBieXRlc1xuICAgIEVORE9GRiAgICAgICAgICAgOiAxNiwgLy8gb2Zmc2V0IG9mIGZpcnN0IENFTiBoZWFkZXJcbiAgICBFTkRDT00gICAgICAgICAgIDogMjAsIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG5cbiAgICBFTkQ2NEhEUiAgICAgICAgIDogMjAsIC8vIHppcDY0IEVORCBoZWFkZXIgc2l6ZVxuICAgIEVORDY0U0lHICAgICAgICAgOiAweDA3MDY0YjUwLCAvLyB6aXA2NCBMb2NhdG9yIHNpZ25hdHVyZSwgXCJQS1xcMDA2XFwwMDdcIlxuICAgIEVORDY0U1RBUlQgICAgICAgOiA0LCAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIHppcDY0XG4gICAgRU5ENjRPRkYgICAgICAgICA6IDgsIC8vIHJlbGF0aXZlIG9mZnNldCBvZiB0aGUgemlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgRU5ENjROVU1ESVNLUyAgICA6IDE2LCAvLyB0b3RhbCBudW1iZXIgb2YgZGlza3NcblxuICAgIFpJUDY0U0lHICAgICAgICAgOiAweDA2MDY0YjUwLCAvLyB6aXA2NCBzaWduYXR1cmUsIFwiUEtcXDAwNlxcMDA2XCJcbiAgICBaSVA2NEhEUiAgICAgICAgIDogNTYsIC8vIHppcDY0IHJlY29yZCBtaW5pbXVtIHNpemVcbiAgICBaSVA2NExFQUQgICAgICAgIDogMTIsIC8vIGxlYWRpbmcgYnl0ZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZWNvcmQsIG5vdCBjb3VudGVkIGJ5IHRoZSB2YWx1ZSBzdG9yZWQgaW4gWklQNjRTSVpFXG4gICAgWklQNjRTSVpFICAgICAgICA6IDQsIC8vIHppcDY0IHNpemUgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZFxuICAgIFpJUDY0VkVNICAgICAgICAgOiAxMiwgLy8gemlwNjQgdmVyc2lvbiBtYWRlIGJ5XG4gICAgWklQNjRWRVIgICAgICAgICA6IDE0LCAvLyB6aXA2NCB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgWklQNjREU0sgICAgICAgICA6IDE2LCAvLyB6aXA2NCBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgWklQNjREU0tESVIgICAgICA6IDIwLCAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIHJlY29yZCBkaXJlY3RvcnlcbiAgICBaSVA2NFNVQiAgICAgICAgIDogMjQsIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgZGlza1xuICAgIFpJUDY0VE9UICAgICAgICAgOiAzMiwgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICBaSVA2NFNJWkIgICAgICAgIDogNDAsIC8vIHppcDY0IGNlbnRyYWwgZGlyZWN0b3J5IHNpemUgaW4gYnl0ZXNcbiAgICBaSVA2NE9GRiAgICAgICAgIDogNDgsIC8vIG9mZnNldCBvZiBzdGFydCBvZiBjZW50cmFsIGRpcmVjdG9yeSB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXJ0aW5nIGRpc2sgbnVtYmVyXG4gICAgWklQNjRFWFRSQSAgICAgICA6IDU2LCAvLyBleHRlbnNpYmxlIGRhdGEgc2VjdG9yXG5cbiAgICAvKiBDb21wcmVzc2lvbiBtZXRob2RzICovXG4gICAgU1RPUkVEICAgICAgICAgICA6IDAsIC8vIG5vIGNvbXByZXNzaW9uXG4gICAgU0hSVU5LICAgICAgICAgICA6IDEsIC8vIHNocnVua1xuICAgIFJFRFVDRUQxICAgICAgICAgOiAyLCAvLyByZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDFcbiAgICBSRURVQ0VEMiAgICAgICAgIDogMywgLy8gcmVkdWNlZCB3aXRoIGNvbXByZXNzaW9uIGZhY3RvciAyXG4gICAgUkVEVUNFRDMgICAgICAgICA6IDQsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgM1xuICAgIFJFRFVDRUQ0ICAgICAgICAgOiA1LCAvLyByZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDRcbiAgICBJTVBMT0RFRCAgICAgICAgIDogNiwgLy8gaW1wbG9kZWRcbiAgICAvLyA3IHJlc2VydmVkIGZvciBUb2tlbml6aW5nIGNvbXByZXNzaW9uIGFsZ29yaXRobVxuICAgIERFRkxBVEVEICAgICAgICAgOiA4LCAvLyBkZWZsYXRlZFxuICAgIEVOSEFOQ0VEX0RFRkxBVEVEOiA5LCAvLyBlbmhhbmNlZCBkZWZsYXRlZFxuICAgIFBLV0FSRSAgICAgICAgICAgOiAxMCwvLyBQS1dhcmUgRENMIGltcGxvZGVkXG4gICAgLy8gMTEgcmVzZXJ2ZWQgYnkgUEtXQVJFXG4gICAgQlpJUDIgICAgICAgICAgICA6IDEyLCAvLyAgY29tcHJlc3NlZCB1c2luZyBCWklQMlxuICAgIC8vIDEzIHJlc2VydmVkIGJ5IFBLV0FSRVxuICAgIExaTUEgICAgICAgICAgICAgOiAxNCwgLy8gTFpNQVxuICAgIC8vIDE1LTE3IHJlc2VydmVkIGJ5IFBLV0FSRVxuICAgIElCTV9URVJTRSAgICAgICAgOiAxOCwgLy8gY29tcHJlc3NlZCB1c2luZyBJQk0gVEVSU0VcbiAgICBJQk1fTFo3NyAgICAgICAgIDogMTksIC8vIElCTSBMWjc3IHpcbiAgICBBRVNfRU5DUllQVCAgICAgIDogOTksIC8vIFdpblpJUCBBRVMgZW5jcnlwdGlvbiBtZXRob2RcblxuICAgIC8qIEdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZyAqL1xuICAgIC8vIHZhbHVlcyBjYW4gb2J0YWluZWQgd2l0aCBleHByZXNzaW9uIDIqKmJpdG5yXG4gICAgRkxHX0VOQyAgICAgICAgICA6IDEsICAgIC8vIEJpdCAwOiBlbmNyeXB0ZWQgZmlsZVxuICAgIEZMR19DT01QMSAgICAgICAgOiAyLCAgICAvLyBCaXQgMSwgY29tcHJlc3Npb24gb3B0aW9uXG4gICAgRkxHX0NPTVAyICAgICAgICA6IDQsICAgIC8vIEJpdCAyLCBjb21wcmVzc2lvbiBvcHRpb25cbiAgICBGTEdfREVTQyAgICAgICAgIDogOCwgICAgLy8gQml0IDMsIGRhdGEgZGVzY3JpcHRvclxuICAgIEZMR19FTkggICAgICAgICAgOiAxNiwgICAvLyBCaXQgNCwgZW5oYW5jZWQgZGVmbGF0aW5nXG4gICAgRkxHX1BBVENIICAgICAgICA6IDMyLCAgIC8vIEJpdCA1LCBpbmRpY2F0ZXMgdGhhdCB0aGUgZmlsZSBpcyBjb21wcmVzc2VkIHBhdGNoZWQgZGF0YS5cbiAgICBGTEdfU1RSICAgICAgICAgIDogNjQsICAgLy8gQml0IDYsIHN0cm9uZyBlbmNyeXB0aW9uIChwYXRlbnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0cyA3LTEwOiBDdXJyZW50bHkgdW51c2VkLlxuICAgIEZMR19FRlMgICAgICAgICAgOiAyMDQ4LCAvLyBCaXQgMTE6IExhbmd1YWdlIGVuY29kaW5nIGZsYWcgKEVGUylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0IDEyOiBSZXNlcnZlZCBieSBQS1dBUkUgZm9yIGVuaGFuY2VkIGNvbXByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXQgMTM6IGVuY3J5cHRlZCB0aGUgQ2VudHJhbCBEaXJlY3RvcnkgKHBhdGVudGVkKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQml0cyAxNC0xNTogUmVzZXJ2ZWQgYnkgUEtXQVJFLlxuICAgIEZMR19NU0sgICAgICAgICAgOiA0MDk2LCAvLyBtYXNrIGhlYWRlciB2YWx1ZXNcblxuICAgIC8qIExvYWQgdHlwZSAqL1xuICAgIEZJTEUgICAgICAgICAgICAgOiAyLFxuICAgIEJVRkZFUiAgICAgICAgICAgOiAxLFxuICAgIE5PTkUgICAgICAgICAgICAgOiAwLFxuXG4gICAgLyogNC41IEV4dGVuc2libGUgZGF0YSBmaWVsZHMgKi9cbiAgICBFRl9JRCAgICAgICAgICAgIDogMCxcbiAgICBFRl9TSVpFICAgICAgICAgIDogMixcblxuICAgIC8qIEhlYWRlciBJRHMgKi9cbiAgICBJRF9aSVA2NCAgICAgICAgIDogMHgwMDAxLFxuICAgIElEX0FWSU5GTyAgICAgICAgOiAweDAwMDcsXG4gICAgSURfUEZTICAgICAgICAgICA6IDB4MDAwOCxcbiAgICBJRF9PUzIgICAgICAgICAgIDogMHgwMDA5LFxuICAgIElEX05URlMgICAgICAgICAgOiAweDAwMGEsXG4gICAgSURfT1BFTlZNUyAgICAgICA6IDB4MDAwYyxcbiAgICBJRF9VTklYICAgICAgICAgIDogMHgwMDBkLFxuICAgIElEX0ZPUksgICAgICAgICAgOiAweDAwMGUsXG4gICAgSURfUEFUQ0ggICAgICAgICA6IDB4MDAwZixcbiAgICBJRF9YNTA5X1BLQ1M3ICAgIDogMHgwMDE0LFxuICAgIElEX1g1MDlfQ0VSVElEX0YgOiAweDAwMTUsXG4gICAgSURfWDUwOV9DRVJUSURfQyA6IDB4MDAxNixcbiAgICBJRF9TVFJPTkdFTkMgICAgIDogMHgwMDE3LFxuICAgIElEX1JFQ09SRF9NR1QgICAgOiAweDAwMTgsXG4gICAgSURfWDUwOV9QS0NTN19STCA6IDB4MDAxOSxcbiAgICBJRF9JQk0xICAgICAgICAgIDogMHgwMDY1LFxuICAgIElEX0lCTTIgICAgICAgICAgOiAweDAwNjYsXG4gICAgSURfUE9TWklQICAgICAgICA6IDB4NDY5MCxcblxuICAgIEVGX1pJUDY0X09SXzMyICAgOiAweGZmZmZmZmZmLFxuICAgIEVGX1pJUDY0X09SXzE2ICAgOiAweGZmZmYsXG4gICAgRUZfWklQNjRfU1VOQ09NUCA6IDAsXG4gICAgRUZfWklQNjRfU0NPTVAgICA6IDgsXG4gICAgRUZfWklQNjRfUkhPICAgICA6IDE2LFxuICAgIEVGX1pJUDY0X0RTTiAgICAgOiAyNFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/decoder.js":
/*!**********************************************!*\
  !*** ./node_modules/adm-zip/util/decoder.js ***!
  \**********************************************/
/***/ ((module) => {

eval("{module.exports = {\n    efs: true,\n    encode: (data) => Buffer.from(data, \"utf8\"),\n    decode: (data) => data.toString(\"utf8\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9kZWNvZGVyLmpzP2I3N2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZWZzOiB0cnVlLFxuICAgIGVuY29kZTogKGRhdGEpID0+IEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKSxcbiAgICBkZWNvZGU6IChkYXRhKSA9PiBkYXRhLnRvU3RyaW5nKFwidXRmOFwiKVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/decoder.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/adm-zip/util/errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{const errors = {\n    /* Header error messages */\n    INVALID_LOC: \"Invalid LOC header (bad signature)\",\n    INVALID_CEN: \"Invalid CEN header (bad signature)\",\n    INVALID_END: \"Invalid END header (bad signature)\",\n\n    /* Descriptor */\n    DESCRIPTOR_NOT_EXIST: \"No descriptor present\",\n    DESCRIPTOR_UNKNOWN: \"Unknown descriptor format\",\n    DESCRIPTOR_FAULTY: \"Descriptor data is malformed\",\n\n    /* ZipEntry error messages*/\n    NO_DATA: \"Nothing to decompress\",\n    BAD_CRC: \"CRC32 checksum failed {0}\",\n    FILE_IN_THE_WAY: \"There is a file in the way: {0}\",\n    UNKNOWN_METHOD: \"Invalid/unsupported compression method\",\n\n    /* Inflater error messages */\n    AVAIL_DATA: \"inflate::Available inflate data did not terminate\",\n    INVALID_DISTANCE: \"inflate::Invalid literal/length or distance code in fixed or dynamic block\",\n    TO_MANY_CODES: \"inflate::Dynamic block code description: too many length or distance codes\",\n    INVALID_REPEAT_LEN: \"inflate::Dynamic block code description: repeat more than specified lengths\",\n    INVALID_REPEAT_FIRST: \"inflate::Dynamic block code description: repeat lengths with no first length\",\n    INCOMPLETE_CODES: \"inflate::Dynamic block code description: code lengths codes incomplete\",\n    INVALID_DYN_DISTANCE: \"inflate::Dynamic block code description: invalid distance code lengths\",\n    INVALID_CODES_LEN: \"inflate::Dynamic block code description: invalid literal/length code lengths\",\n    INVALID_STORE_BLOCK: \"inflate::Stored block length did not match one's complement\",\n    INVALID_BLOCK_TYPE: \"inflate::Invalid block type (type == 3)\",\n\n    /* ADM-ZIP error messages */\n    CANT_EXTRACT_FILE: \"Could not extract the file\",\n    CANT_OVERRIDE: \"Target file already exists\",\n    DISK_ENTRY_TOO_LARGE: \"Number of disk entries is too large\",\n    NO_ZIP: \"No zip file was loaded\",\n    NO_ENTRY: \"Entry doesn't exist\",\n    DIRECTORY_CONTENT_ERROR: \"A directory cannot have content\",\n    FILE_NOT_FOUND: 'File not found: \"{0}\"',\n    NOT_IMPLEMENTED: \"Not implemented\",\n    INVALID_FILENAME: \"Invalid filename\",\n    INVALID_FORMAT: \"Invalid or unsupported zip format. No END header found\",\n    INVALID_PASS_PARAM: \"Incompatible password parameter\",\n    WRONG_PASSWORD: \"Wrong Password\",\n\n    /* ADM-ZIP */\n    COMMENT_TOO_LONG: \"Comment is too long\", // Comment can be max 65535 bytes long (NOTE: some non-US characters may take more space)\n    EXTRA_FIELD_PARSE_ERROR: \"Extra field parsing error\"\n};\n\n// template\nfunction E(message) {\n    return function (...args) {\n        if (args.length) { // Allow {0} .. {9} arguments in error message, based on argument number\n            message = message.replace(/\\{(\\d)\\}/g, (_, n) => args[n] || '');\n        }\n\n        return new Error('ADM-ZIP: ' + message);\n    };\n}\n\n// Init errors with template\nfor (const msg of Object.keys(errors)) {\n    exports[msg] = E(errors[msg]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QyxtREFBbUQsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxHQUFHLElBQUksR0FBRztBQUMvQyx5Q0FBeUMsTUFBTTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL3V0aWwvZXJyb3JzLmpzPzUxOTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZXJyb3JzID0ge1xuICAgIC8qIEhlYWRlciBlcnJvciBtZXNzYWdlcyAqL1xuICAgIElOVkFMSURfTE9DOiBcIkludmFsaWQgTE9DIGhlYWRlciAoYmFkIHNpZ25hdHVyZSlcIixcbiAgICBJTlZBTElEX0NFTjogXCJJbnZhbGlkIENFTiBoZWFkZXIgKGJhZCBzaWduYXR1cmUpXCIsXG4gICAgSU5WQUxJRF9FTkQ6IFwiSW52YWxpZCBFTkQgaGVhZGVyIChiYWQgc2lnbmF0dXJlKVwiLFxuXG4gICAgLyogRGVzY3JpcHRvciAqL1xuICAgIERFU0NSSVBUT1JfTk9UX0VYSVNUOiBcIk5vIGRlc2NyaXB0b3IgcHJlc2VudFwiLFxuICAgIERFU0NSSVBUT1JfVU5LTk9XTjogXCJVbmtub3duIGRlc2NyaXB0b3IgZm9ybWF0XCIsXG4gICAgREVTQ1JJUFRPUl9GQVVMVFk6IFwiRGVzY3JpcHRvciBkYXRhIGlzIG1hbGZvcm1lZFwiLFxuXG4gICAgLyogWmlwRW50cnkgZXJyb3IgbWVzc2FnZXMqL1xuICAgIE5PX0RBVEE6IFwiTm90aGluZyB0byBkZWNvbXByZXNzXCIsXG4gICAgQkFEX0NSQzogXCJDUkMzMiBjaGVja3N1bSBmYWlsZWQgezB9XCIsXG4gICAgRklMRV9JTl9USEVfV0FZOiBcIlRoZXJlIGlzIGEgZmlsZSBpbiB0aGUgd2F5OiB7MH1cIixcbiAgICBVTktOT1dOX01FVEhPRDogXCJJbnZhbGlkL3Vuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZFwiLFxuXG4gICAgLyogSW5mbGF0ZXIgZXJyb3IgbWVzc2FnZXMgKi9cbiAgICBBVkFJTF9EQVRBOiBcImluZmxhdGU6OkF2YWlsYWJsZSBpbmZsYXRlIGRhdGEgZGlkIG5vdCB0ZXJtaW5hdGVcIixcbiAgICBJTlZBTElEX0RJU1RBTkNFOiBcImluZmxhdGU6OkludmFsaWQgbGl0ZXJhbC9sZW5ndGggb3IgZGlzdGFuY2UgY29kZSBpbiBmaXhlZCBvciBkeW5hbWljIGJsb2NrXCIsXG4gICAgVE9fTUFOWV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBjb2Rlc1wiLFxuICAgIElOVkFMSURfUkVQRUFUX0xFTjogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHJlcGVhdCBtb3JlIHRoYW4gc3BlY2lmaWVkIGxlbmd0aHNcIixcbiAgICBJTlZBTElEX1JFUEVBVF9GSVJTVDogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IHJlcGVhdCBsZW5ndGhzIHdpdGggbm8gZmlyc3QgbGVuZ3RoXCIsXG4gICAgSU5DT01QTEVURV9DT0RFUzogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IGNvZGUgbGVuZ3RocyBjb2RlcyBpbmNvbXBsZXRlXCIsXG4gICAgSU5WQUxJRF9EWU5fRElTVEFOQ0U6IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiBpbnZhbGlkIGRpc3RhbmNlIGNvZGUgbGVuZ3Roc1wiLFxuICAgIElOVkFMSURfQ09ERVNfTEVOOiBcImluZmxhdGU6OkR5bmFtaWMgYmxvY2sgY29kZSBkZXNjcmlwdGlvbjogaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIGxlbmd0aHNcIixcbiAgICBJTlZBTElEX1NUT1JFX0JMT0NLOiBcImluZmxhdGU6OlN0b3JlZCBibG9jayBsZW5ndGggZGlkIG5vdCBtYXRjaCBvbmUncyBjb21wbGVtZW50XCIsXG4gICAgSU5WQUxJRF9CTE9DS19UWVBFOiBcImluZmxhdGU6OkludmFsaWQgYmxvY2sgdHlwZSAodHlwZSA9PSAzKVwiLFxuXG4gICAgLyogQURNLVpJUCBlcnJvciBtZXNzYWdlcyAqL1xuICAgIENBTlRfRVhUUkFDVF9GSUxFOiBcIkNvdWxkIG5vdCBleHRyYWN0IHRoZSBmaWxlXCIsXG4gICAgQ0FOVF9PVkVSUklERTogXCJUYXJnZXQgZmlsZSBhbHJlYWR5IGV4aXN0c1wiLFxuICAgIERJU0tfRU5UUllfVE9PX0xBUkdFOiBcIk51bWJlciBvZiBkaXNrIGVudHJpZXMgaXMgdG9vIGxhcmdlXCIsXG4gICAgTk9fWklQOiBcIk5vIHppcCBmaWxlIHdhcyBsb2FkZWRcIixcbiAgICBOT19FTlRSWTogXCJFbnRyeSBkb2Vzbid0IGV4aXN0XCIsXG4gICAgRElSRUNUT1JZX0NPTlRFTlRfRVJST1I6IFwiQSBkaXJlY3RvcnkgY2Fubm90IGhhdmUgY29udGVudFwiLFxuICAgIEZJTEVfTk9UX0ZPVU5EOiAnRmlsZSBub3QgZm91bmQ6IFwiezB9XCInLFxuICAgIE5PVF9JTVBMRU1FTlRFRDogXCJOb3QgaW1wbGVtZW50ZWRcIixcbiAgICBJTlZBTElEX0ZJTEVOQU1FOiBcIkludmFsaWQgZmlsZW5hbWVcIixcbiAgICBJTlZBTElEX0ZPUk1BVDogXCJJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHppcCBmb3JtYXQuIE5vIEVORCBoZWFkZXIgZm91bmRcIixcbiAgICBJTlZBTElEX1BBU1NfUEFSQU06IFwiSW5jb21wYXRpYmxlIHBhc3N3b3JkIHBhcmFtZXRlclwiLFxuICAgIFdST05HX1BBU1NXT1JEOiBcIldyb25nIFBhc3N3b3JkXCIsXG5cbiAgICAvKiBBRE0tWklQICovXG4gICAgQ09NTUVOVF9UT09fTE9ORzogXCJDb21tZW50IGlzIHRvbyBsb25nXCIsIC8vIENvbW1lbnQgY2FuIGJlIG1heCA2NTUzNSBieXRlcyBsb25nIChOT1RFOiBzb21lIG5vbi1VUyBjaGFyYWN0ZXJzIG1heSB0YWtlIG1vcmUgc3BhY2UpXG4gICAgRVhUUkFfRklFTERfUEFSU0VfRVJST1I6IFwiRXh0cmEgZmllbGQgcGFyc2luZyBlcnJvclwiXG59O1xuXG4vLyB0ZW1wbGF0ZVxuZnVuY3Rpb24gRShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkgeyAvLyBBbGxvdyB7MH0gLi4gezl9IGFyZ3VtZW50cyBpbiBlcnJvciBtZXNzYWdlLCBiYXNlZCBvbiBhcmd1bWVudCBudW1iZXJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoL1xceyhcXGQpXFx9L2csIChfLCBuKSA9PiBhcmdzW25dIHx8ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FETS1aSVA6ICcgKyBtZXNzYWdlKTtcbiAgICB9O1xufVxuXG4vLyBJbml0IGVycm9ycyB3aXRoIHRlbXBsYXRlXG5mb3IgKGNvbnN0IG1zZyBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgZXhwb3J0c1ttc2ddID0gRShlcnJvcnNbbXNnXSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/errors.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/fattr.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/fattr.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const pth = __webpack_require__(/*! path */ \"path\");\n\nmodule.exports = function (/*String*/ path, /*Utils object*/ { fs }) {\n    var _path = path || \"\",\n        _obj = newAttr(),\n        _stat = null;\n\n    function newAttr() {\n        return {\n            directory: false,\n            readonly: false,\n            hidden: false,\n            executable: false,\n            mtime: 0,\n            atime: 0\n        };\n    }\n\n    if (_path && fs.existsSync(_path)) {\n        _stat = fs.statSync(_path);\n        _obj.directory = _stat.isDirectory();\n        _obj.mtime = _stat.mtime;\n        _obj.atime = _stat.atime;\n        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner\n        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right\n        _obj.hidden = pth.basename(_path)[0] === \".\";\n    } else {\n        console.warn(\"Invalid path: \" + _path);\n    }\n\n    return {\n        get directory() {\n            return _obj.directory;\n        },\n\n        get readOnly() {\n            return _obj.readonly;\n        },\n\n        get hidden() {\n            return _obj.hidden;\n        },\n\n        get mtime() {\n            return _obj.mtime;\n        },\n\n        get atime() {\n            return _obj.atime;\n        },\n\n        get executable() {\n            return _obj.executable;\n        },\n\n        decodeAttributes: function () {},\n\n        encodeAttributes: function () {},\n\n        toJSON: function () {\n            return {\n                path: _path,\n                isDirectory: _obj.directory,\n                isReadOnly: _obj.readonly,\n                isHidden: _obj.hidden,\n                isExecutable: _obj.executable,\n                mTime: _obj.mtime,\n                aTime: _obj.atime\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2ZhdHRyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyxrQkFBTTs7QUFFMUIsK0RBQStELElBQUk7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBQ3BEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVCx3Q0FBd0M7O0FBRXhDLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL3V0aWwvZmF0dHIuanM/ODBlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwdGggPSByZXF1aXJlKFwicGF0aFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBwYXRoLCAvKlV0aWxzIG9iamVjdCovIHsgZnMgfSkge1xuICAgIHZhciBfcGF0aCA9IHBhdGggfHwgXCJcIixcbiAgICAgICAgX29iaiA9IG5ld0F0dHIoKSxcbiAgICAgICAgX3N0YXQgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gbmV3QXR0cigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdG9yeTogZmFsc2UsXG4gICAgICAgICAgICByZWFkb25seTogZmFsc2UsXG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgZXhlY3V0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBtdGltZTogMCxcbiAgICAgICAgICAgIGF0aW1lOiAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKF9wYXRoICYmIGZzLmV4aXN0c1N5bmMoX3BhdGgpKSB7XG4gICAgICAgIF9zdGF0ID0gZnMuc3RhdFN5bmMoX3BhdGgpO1xuICAgICAgICBfb2JqLmRpcmVjdG9yeSA9IF9zdGF0LmlzRGlyZWN0b3J5KCk7XG4gICAgICAgIF9vYmoubXRpbWUgPSBfc3RhdC5tdGltZTtcbiAgICAgICAgX29iai5hdGltZSA9IF9zdGF0LmF0aW1lO1xuICAgICAgICBfb2JqLmV4ZWN1dGFibGUgPSAoMG8xMTEgJiBfc3RhdC5tb2RlKSAhPT0gMDsgLy8gZmlsZSBpcyBleGVjdXRhYmxlIHdobyBldmVyIGhhciByaWdodCBub3QganVzdCBvd25lclxuICAgICAgICBfb2JqLnJlYWRvbmx5ID0gKDBvMjAwICYgX3N0YXQubW9kZSkgPT09IDA7IC8vIHJlYWRvbmx5IGlmIG93bmVyIGhhcyBubyB3cml0ZSByaWdodFxuICAgICAgICBfb2JqLmhpZGRlbiA9IHB0aC5iYXNlbmFtZShfcGF0aClbMF0gPT09IFwiLlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcGF0aDogXCIgKyBfcGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGRpcmVjdG9yeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmRpcmVjdG9yeTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgcmVhZE9ubHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iai5yZWFkb25seTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmouaGlkZGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLm10aW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBhdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmF0aW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBleGVjdXRhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmouZXhlY3V0YWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWNvZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBlbmNvZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IF9vYmouZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IF9vYmoucmVhZG9ubHksXG4gICAgICAgICAgICAgICAgaXNIaWRkZW46IF9vYmouaGlkZGVuLFxuICAgICAgICAgICAgICAgIGlzRXhlY3V0YWJsZTogX29iai5leGVjdXRhYmxlLFxuICAgICAgICAgICAgICAgIG1UaW1lOiBfb2JqLm10aW1lLFxuICAgICAgICAgICAgICAgIGFUaW1lOiBfb2JqLmF0aW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/fattr.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/index.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = __webpack_require__(/*! ./utils */ \"./node_modules/adm-zip/util/utils.js\");\nmodule.exports.Constants = __webpack_require__(/*! ./constants */ \"./node_modules/adm-zip/util/constants.js\");\nmodule.exports.Errors = __webpack_require__(/*! ./errors */ \"./node_modules/adm-zip/util/errors.js\");\nmodule.exports.FileAttr = __webpack_require__(/*! ./fattr */ \"./node_modules/adm-zip/util/fattr.js\");\nmodule.exports.decoder = __webpack_require__(/*! ./decoder */ \"./node_modules/adm-zip/util/decoder.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDJGQUFtQztBQUNuQyw2R0FBaUQ7QUFDakQsb0dBQTJDO0FBQzNDLG9HQUE0QztBQUM1Qyx1R0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL3V0aWwvaW5kZXguanM/ZWVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xubW9kdWxlLmV4cG9ydHMuQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMuRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xubW9kdWxlLmV4cG9ydHMuRmlsZUF0dHIgPSByZXF1aXJlKFwiLi9mYXR0clwiKTtcbm1vZHVsZS5leHBvcnRzLmRlY29kZXIgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/index.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/util/utils.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/utils.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const fsystem = __webpack_require__(/*! fs */ \"fs\");\nconst pth = __webpack_require__(/*! path */ \"path\");\nconst Constants = __webpack_require__(/*! ./constants */ \"./node_modules/adm-zip/util/constants.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"./node_modules/adm-zip/util/errors.js\");\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\n\nconst is_Obj = (obj) => typeof obj === \"object\" && obj !== null;\n\n// generate CRC32 lookup table\nconst crcTable = new Uint32Array(256).map((t, c) => {\n    for (let k = 0; k < 8; k++) {\n        if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ (c >>> 1);\n        } else {\n            c >>>= 1;\n        }\n    }\n    return c >>> 0;\n});\n\n// UTILS functions\n\nfunction Utils(opts) {\n    this.sep = pth.sep;\n    this.fs = fsystem;\n\n    if (is_Obj(opts)) {\n        // custom filesystem\n        if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n            this.fs = opts.fs;\n        }\n    }\n}\n\nmodule.exports = Utils;\n\n// INSTANTIABLE functions\n\nUtils.prototype.makeDir = function (/*String*/ folder) {\n    const self = this;\n\n    // Sync - make directories tree\n    function mkdirSync(/*String*/ fpath) {\n        let resolvedPath = fpath.split(self.sep)[0];\n        fpath.split(self.sep).forEach(function (name) {\n            if (!name || name.substr(-1, 1) === \":\") return;\n            resolvedPath += self.sep + name;\n            var stat;\n            try {\n                stat = self.fs.statSync(resolvedPath);\n            } catch (e) {\n                self.fs.mkdirSync(resolvedPath);\n            }\n            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY(`\"${resolvedPath}\"`);\n        });\n    }\n\n    mkdirSync(folder);\n};\n\nUtils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {\n    const self = this;\n    if (self.fs.existsSync(path)) {\n        if (!overwrite) return false; // cannot overwrite\n\n        var stat = self.fs.statSync(path);\n        if (stat.isDirectory()) {\n            return false;\n        }\n    }\n    var folder = pth.dirname(path);\n    if (!self.fs.existsSync(folder)) {\n        self.makeDir(folder);\n    }\n\n    var fd;\n    try {\n        fd = self.fs.openSync(path, \"w\", 0o666); // 0666\n    } catch (e) {\n        self.fs.chmodSync(path, 0o666);\n        fd = self.fs.openSync(path, \"w\", 0o666);\n    }\n    if (fd) {\n        try {\n            self.fs.writeSync(fd, content, 0, content.length, 0);\n        } finally {\n            self.fs.closeSync(fd);\n        }\n    }\n    self.fs.chmodSync(path, attr || 0o666);\n    return true;\n};\n\nUtils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {\n    if (typeof attr === \"function\") {\n        callback = attr;\n        attr = undefined;\n    }\n\n    const self = this;\n\n    self.fs.exists(path, function (exist) {\n        if (exist && !overwrite) return callback(false);\n\n        self.fs.stat(path, function (err, stat) {\n            if (exist && stat.isDirectory()) {\n                return callback(false);\n            }\n\n            var folder = pth.dirname(path);\n            self.fs.exists(folder, function (exists) {\n                if (!exists) self.makeDir(folder);\n\n                self.fs.open(path, \"w\", 0o666, function (err, fd) {\n                    if (err) {\n                        self.fs.chmod(path, 0o666, function () {\n                            self.fs.open(path, \"w\", 0o666, function (err, fd) {\n                                self.fs.write(fd, content, 0, content.length, 0, function () {\n                                    self.fs.close(fd, function () {\n                                        self.fs.chmod(path, attr || 0o666, function () {\n                                            callback(true);\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                    } else if (fd) {\n                        self.fs.write(fd, content, 0, content.length, 0, function () {\n                            self.fs.close(fd, function () {\n                                self.fs.chmod(path, attr || 0o666, function () {\n                                    callback(true);\n                                });\n                            });\n                        });\n                    } else {\n                        self.fs.chmod(path, attr || 0o666, function () {\n                            callback(true);\n                        });\n                    }\n                });\n            });\n        });\n    });\n};\n\nUtils.prototype.findFiles = function (/*String*/ path) {\n    const self = this;\n\n    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {\n        if (typeof pattern === \"boolean\") {\n            recursive = pattern;\n            pattern = undefined;\n        }\n        let files = [];\n        self.fs.readdirSync(dir).forEach(function (file) {\n            const path = pth.join(dir, file);\n            const stat = self.fs.statSync(path);\n\n            if (!pattern || pattern.test(path)) {\n                files.push(pth.normalize(path) + (stat.isDirectory() ? self.sep : \"\"));\n            }\n\n            if (stat.isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n        });\n        return files;\n    }\n\n    return findSync(path, undefined, true);\n};\n\n/**\n * Callback for showing if everything was done.\n *\n * @callback filelistCallback\n * @param {Error} err - Error object\n * @param {string[]} list - was request fully completed\n */\n\n/**\n *\n * @param {string} dir\n * @param {filelistCallback} cb\n */\nUtils.prototype.findFilesAsync = function (dir, cb) {\n    const self = this;\n    let results = [];\n    self.fs.readdir(dir, function (err, list) {\n        if (err) return cb(err);\n        let list_length = list.length;\n        if (!list_length) return cb(null, results);\n        list.forEach(function (file) {\n            file = pth.join(dir, file);\n            self.fs.stat(file, function (err, stat) {\n                if (err) return cb(err);\n                if (stat) {\n                    results.push(pth.normalize(file) + (stat.isDirectory() ? self.sep : \"\"));\n                    if (stat.isDirectory()) {\n                        self.findFilesAsync(file, function (err, res) {\n                            if (err) return cb(err);\n                            results = results.concat(res);\n                            if (!--list_length) cb(null, results);\n                        });\n                    } else {\n                        if (!--list_length) cb(null, results);\n                    }\n                }\n            });\n        });\n    });\n};\n\nUtils.prototype.getAttributes = function () {};\n\nUtils.prototype.setAttributes = function () {};\n\n// STATIC functions\n\n// crc32 single update (it is part of crc32)\nUtils.crc32update = function (crc, byte) {\n    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n};\n\nUtils.crc32 = function (buf) {\n    if (typeof buf === \"string\") {\n        buf = Buffer.from(buf, \"utf8\");\n    }\n\n    let len = buf.length;\n    let crc = ~0;\n    for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);\n    // xor and cast as uint32 number\n    return ~crc >>> 0;\n};\n\nUtils.methodToString = function (/*Number*/ method) {\n    switch (method) {\n        case Constants.STORED:\n            return \"STORED (\" + method + \")\";\n        case Constants.DEFLATED:\n            return \"DEFLATED (\" + method + \")\";\n        default:\n            return \"UNSUPPORTED (\" + method + \")\";\n    }\n};\n\n/**\n * removes \"..\" style path elements\n * @param {string} path - fixable path\n * @returns string - fixed filepath\n */\nUtils.canonical = function (/*string*/ path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.join(\".\", safeSuffix);\n};\n\n/**\n * fix file names in achive\n * @param {string} path - fixable path\n * @returns string - fixed filepath\n */\n\nUtils.zipnamefix = function (path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    const safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.posix.join(\".\", safeSuffix);\n};\n\n/**\n *\n * @param {Array} arr\n * @param {function} callback\n * @returns\n */\nUtils.findLast = function (arr, callback) {\n    if (!Array.isArray(arr)) throw new TypeError(\"arr is not array\");\n\n    const len = arr.length >>> 0;\n    for (let i = len - 1; i >= 0; i--) {\n        if (callback(arr[i], i, arr)) {\n            return arr[i];\n        }\n    }\n    return void 0;\n};\n\n// make abolute paths taking prefix as root folder\nUtils.sanitize = function (/*string*/ prefix, /*string*/ name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split(\"/\");\n    for (var i = 0, l = parts.length; i < l; i++) {\n        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n        if (path.indexOf(prefix) === 0) {\n            return path;\n        }\n    }\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n};\n\n// converts buffer, Uint8Array, string types to buffer\nUtils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input, /* function */ encoder) {\n    if (Buffer.isBuffer(input)) {\n        return input;\n    } else if (input instanceof Uint8Array) {\n        return Buffer.from(input);\n    } else {\n        // expect string all other values are invalid and return empty buffer\n        return typeof input === \"string\" ? encoder(input) : Buffer.alloc(0);\n    }\n};\n\nUtils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {\n    var slice = Buffer.from(buffer.slice(index, index + 8));\n    slice.swap64();\n\n    return parseInt(`0x${slice.toString(\"hex\")}`);\n};\n\nUtils.fromDOS2Date = function (val) {\n    return new Date(((val >> 25) & 0x7f) + 1980, Math.max(((val >> 21) & 0x0f) - 1, 0), Math.max((val >> 16) & 0x1f, 1), (val >> 11) & 0x1f, (val >> 5) & 0x3f, (val & 0x1f) << 1);\n};\n\nUtils.fromDate2DOS = function (val) {\n    let date = 0;\n    let time = 0;\n    if (val.getFullYear() > 1979) {\n        date = (((val.getFullYear() - 1980) & 0x7f) << 9) | ((val.getMonth() + 1) << 5) | val.getDate();\n        time = (val.getHours() << 11) | (val.getMinutes() << 5) | (val.getSeconds() >> 1);\n    }\n    return (date << 16) | time;\n};\n\nUtils.isWin = isWin; // Do we have windows system\nUtils.crcTable = crcTable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLGNBQUk7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLGtCQUFNO0FBQzFCLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx1REFBVTtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRixTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsc0JBQXNCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL3V0aWxzLmpzPzhlZDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnN5c3RlbSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHB0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXNXaW4gPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBcIndpbjMyXCIgPT09IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IGlzX09iaiA9IChvYmopID0+IHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsO1xuXG4vLyBnZW5lcmF0ZSBDUkMzMiBsb29rdXAgdGFibGVcbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKCh0LCBjKSA9PiB7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgaWYgKChjICYgMSkgIT09IDApIHtcbiAgICAgICAgICAgIGMgPSAweGVkYjg4MzIwIF4gKGMgPj4+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyA+Pj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGMgPj4+IDA7XG59KTtcblxuLy8gVVRJTFMgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIFV0aWxzKG9wdHMpIHtcbiAgICB0aGlzLnNlcCA9IHB0aC5zZXA7XG4gICAgdGhpcy5mcyA9IGZzeXN0ZW07XG5cbiAgICBpZiAoaXNfT2JqKG9wdHMpKSB7XG4gICAgICAgIC8vIGN1c3RvbSBmaWxlc3lzdGVtXG4gICAgICAgIGlmIChpc19PYmoob3B0cy5mcykgJiYgdHlwZW9mIG9wdHMuZnMuc3RhdFN5bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5mcyA9IG9wdHMuZnM7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8vIElOU1RBTlRJQUJMRSBmdW5jdGlvbnNcblxuVXRpbHMucHJvdG90eXBlLm1ha2VEaXIgPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBmb2xkZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIFN5bmMgLSBtYWtlIGRpcmVjdG9yaWVzIHRyZWVcbiAgICBmdW5jdGlvbiBta2RpclN5bmMoLypTdHJpbmcqLyBmcGF0aCkge1xuICAgICAgICBsZXQgcmVzb2x2ZWRQYXRoID0gZnBhdGguc3BsaXQoc2VsZi5zZXApWzBdO1xuICAgICAgICBmcGF0aC5zcGxpdChzZWxmLnNlcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUuc3Vic3RyKC0xLCAxKSA9PT0gXCI6XCIpIHJldHVybjtcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCArPSBzZWxmLnNlcCArIG5hbWU7XG4gICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZzLm1rZGlyU3luYyhyZXNvbHZlZFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXQgJiYgc3RhdC5pc0ZpbGUoKSkgdGhyb3cgRXJyb3JzLkZJTEVfSU5fVEhFX1dBWShgXCIke3Jlc29sdmVkUGF0aH1cImApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBta2RpclN5bmMoZm9sZGVyKTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS53cml0ZUZpbGVUbyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgsIC8qQnVmZmVyKi8gY29udGVudCwgLypCb29sZWFuKi8gb3ZlcndyaXRlLCAvKk51bWJlciovIGF0dHIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAgIGlmICghb3ZlcndyaXRlKSByZXR1cm4gZmFsc2U7IC8vIGNhbm5vdCBvdmVyd3JpdGVcblxuICAgICAgICB2YXIgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocGF0aCk7XG4gICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9sZGVyID0gcHRoLmRpcm5hbWUocGF0aCk7XG4gICAgaWYgKCFzZWxmLmZzLmV4aXN0c1N5bmMoZm9sZGVyKSkge1xuICAgICAgICBzZWxmLm1ha2VEaXIoZm9sZGVyKTtcbiAgICB9XG5cbiAgICB2YXIgZmQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZmQgPSBzZWxmLmZzLm9wZW5TeW5jKHBhdGgsIFwid1wiLCAwbzY2Nik7IC8vIDA2NjZcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYuZnMuY2htb2RTeW5jKHBhdGgsIDBvNjY2KTtcbiAgICAgICAgZmQgPSBzZWxmLmZzLm9wZW5TeW5jKHBhdGgsIFwid1wiLCAwbzY2Nik7XG4gICAgfVxuICAgIGlmIChmZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsZi5mcy53cml0ZVN5bmMoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNlbGYuZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmZzLmNobW9kU3luYyhwYXRoLCBhdHRyIHx8IDBvNjY2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS53cml0ZUZpbGVUb0FzeW5jID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCwgLypCdWZmZXIqLyBjb250ZW50LCAvKkJvb2xlYW4qLyBvdmVyd3JpdGUsIC8qTnVtYmVyKi8gYXR0ciwgLypGdW5jdGlvbiovIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhdHRyO1xuICAgICAgICBhdHRyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgc2VsZi5mcy5leGlzdHMocGF0aCwgZnVuY3Rpb24gKGV4aXN0KSB7XG4gICAgICAgIGlmIChleGlzdCAmJiAhb3ZlcndyaXRlKSByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuXG4gICAgICAgIHNlbGYuZnMuc3RhdChwYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICBpZiAoZXhpc3QgJiYgc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZvbGRlciA9IHB0aC5kaXJuYW1lKHBhdGgpO1xuICAgICAgICAgICAgc2VsZi5mcy5leGlzdHMoZm9sZGVyLCBmdW5jdGlvbiAoZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHNlbGYubWFrZURpcihmb2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5mcy5vcGVuKHBhdGgsIFwid1wiLCAwbzY2NiwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCAwbzY2NiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMub3BlbihwYXRoLCBcIndcIiwgMG82NjYsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCBhdHRyIHx8IDBvNjY2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jbG9zZShmZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIGF0dHIgfHwgMG82NjYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCBhdHRyIHx8IDBvNjY2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuVXRpbHMucHJvdG90eXBlLmZpbmRGaWxlcyA9IGZ1bmN0aW9uICgvKlN0cmluZyovIHBhdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRTeW5jKC8qU3RyaW5nKi8gZGlyLCAvKlJlZ0V4cCovIHBhdHRlcm4sIC8qQm9vbGVhbiovIHJlY3Vyc2l2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZWN1cnNpdmUgPSBwYXR0ZXJuO1xuICAgICAgICAgICAgcGF0dGVybiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsZXMgPSBbXTtcbiAgICAgICAgc2VsZi5mcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghcGF0dGVybiB8fCBwYXR0ZXJuLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHB0aC5ub3JtYWxpemUocGF0aCkgKyAoc3RhdC5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkgJiYgcmVjdXJzaXZlKSBmaWxlcyA9IGZpbGVzLmNvbmNhdChmaW5kU3luYyhwYXRoLCBwYXR0ZXJuLCByZWN1cnNpdmUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFN5bmMocGF0aCwgdW5kZWZpbmVkLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHNob3dpbmcgaWYgZXZlcnl0aGluZyB3YXMgZG9uZS5cbiAqXG4gKiBAY2FsbGJhY2sgZmlsZWxpc3RDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBsaXN0IC0gd2FzIHJlcXVlc3QgZnVsbHkgY29tcGxldGVkXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRpclxuICogQHBhcmFtIHtmaWxlbGlzdENhbGxiYWNrfSBjYlxuICovXG5VdGlscy5wcm90b3R5cGUuZmluZEZpbGVzQXN5bmMgPSBmdW5jdGlvbiAoZGlyLCBjYikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgc2VsZi5mcy5yZWFkZGlyKGRpciwgZnVuY3Rpb24gKGVyciwgbGlzdCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgbGV0IGxpc3RfbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGlmICghbGlzdF9sZW5ndGgpIHJldHVybiBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICBmaWxlID0gcHRoLmpvaW4oZGlyLCBmaWxlKTtcbiAgICAgICAgICAgIHNlbGYuZnMuc3RhdChmaWxlLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHB0aC5ub3JtYWxpemUoZmlsZSkgKyAoc3RhdC5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmluZEZpbGVzQXN5bmMoZmlsZSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWxpc3RfbGVuZ3RoKSBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWxpc3RfbGVuZ3RoKSBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblV0aWxzLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge307XG5cblV0aWxzLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFNUQVRJQyBmdW5jdGlvbnNcblxuLy8gY3JjMzIgc2luZ2xlIHVwZGF0ZSAoaXQgaXMgcGFydCBvZiBjcmMzMilcblV0aWxzLmNyYzMydXBkYXRlID0gZnVuY3Rpb24gKGNyYywgYnl0ZSkge1xuICAgIHJldHVybiBjcmNUYWJsZVsoY3JjIF4gYnl0ZSkgJiAweGZmXSBeIChjcmMgPj4+IDgpO1xufTtcblxuVXRpbHMuY3JjMzIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgaWYgKHR5cGVvZiBidWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmLCBcInV0ZjhcIik7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGNyYyA9IH4wO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IG9mZiA8IGxlbjsgKSBjcmMgPSBVdGlscy5jcmMzMnVwZGF0ZShjcmMsIGJ1ZltvZmYrK10pO1xuICAgIC8vIHhvciBhbmQgY2FzdCBhcyB1aW50MzIgbnVtYmVyXG4gICAgcmV0dXJuIH5jcmMgPj4+IDA7XG59O1xuXG5VdGlscy5tZXRob2RUb1N0cmluZyA9IGZ1bmN0aW9uICgvKk51bWJlciovIG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgQ29uc3RhbnRzLlNUT1JFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlNUT1JFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgY2FzZSBDb25zdGFudHMuREVGTEFURUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJERUZMQVRFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOU1VQUE9SVEVEIChcIiArIG1ldGhvZCArIFwiKVwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogcmVtb3ZlcyBcIi4uXCIgc3R5bGUgcGF0aCBlbGVtZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBmaXhhYmxlIHBhdGhcbiAqIEByZXR1cm5zIHN0cmluZyAtIGZpeGVkIGZpbGVwYXRoXG4gKi9cblV0aWxzLmNhbm9uaWNhbCA9IGZ1bmN0aW9uICgvKnN0cmluZyovIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBcIlwiO1xuICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG4gICAgY29uc3Qgc2FmZVN1ZmZpeCA9IHB0aC5wb3NpeC5ub3JtYWxpemUoXCIvXCIgKyBwYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKSk7XG4gICAgcmV0dXJuIHB0aC5qb2luKFwiLlwiLCBzYWZlU3VmZml4KTtcbn07XG5cbi8qKlxuICogZml4IGZpbGUgbmFtZXMgaW4gYWNoaXZlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGZpeGFibGUgcGF0aFxuICogQHJldHVybnMgc3RyaW5nIC0gZml4ZWQgZmlsZXBhdGhcbiAqL1xuXG5VdGlscy56aXBuYW1lZml4ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBcIlwiO1xuICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG4gICAgY29uc3Qgc2FmZVN1ZmZpeCA9IHB0aC5wb3NpeC5ub3JtYWxpemUoXCIvXCIgKyBwYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKSk7XG4gICAgcmV0dXJuIHB0aC5wb3NpeC5qb2luKFwiLlwiLCBzYWZlU3VmZml4KTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zXG4gKi9cblV0aWxzLmZpbmRMYXN0ID0gZnVuY3Rpb24gKGFyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyciBpcyBub3QgYXJyYXlcIik7XG5cbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoID4+PiAwO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG59O1xuXG4vLyBtYWtlIGFib2x1dGUgcGF0aHMgdGFraW5nIHByZWZpeCBhcyByb290IGZvbGRlclxuVXRpbHMuc2FuaXRpemUgPSBmdW5jdGlvbiAoLypzdHJpbmcqLyBwcmVmaXgsIC8qc3RyaW5nKi8gbmFtZSkge1xuICAgIHByZWZpeCA9IHB0aC5yZXNvbHZlKHB0aC5ub3JtYWxpemUocHJlZml4KSk7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcGFydHMuc2xpY2UoaSwgbCkuam9pbihwdGguc2VwKSkpO1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcHRoLmJhc2VuYW1lKG5hbWUpKSk7XG59O1xuXG4vLyBjb252ZXJ0cyBidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyB0eXBlcyB0byBidWZmZXJcblV0aWxzLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoLypidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyovIGlucHV0LCAvKiBmdW5jdGlvbiAqLyBlbmNvZGVyKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhwZWN0IHN0cmluZyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBpbnZhbGlkIGFuZCByZXR1cm4gZW1wdHkgYnVmZmVyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBlbmNvZGVyKGlucHV0KSA6IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG59O1xuXG5VdGlscy5yZWFkQmlnVUludDY0TEUgPSBmdW5jdGlvbiAoLypCdWZmZXIqLyBidWZmZXIsIC8qaW50Ki8gaW5kZXgpIHtcbiAgICB2YXIgc2xpY2UgPSBCdWZmZXIuZnJvbShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgOCkpO1xuICAgIHNsaWNlLnN3YXA2NCgpO1xuXG4gICAgcmV0dXJuIHBhcnNlSW50KGAweCR7c2xpY2UudG9TdHJpbmcoXCJoZXhcIil9YCk7XG59O1xuXG5VdGlscy5mcm9tRE9TMkRhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCgodmFsID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgTWF0aC5tYXgoKCh2YWwgPj4gMjEpICYgMHgwZikgLSAxLCAwKSwgTWF0aC5tYXgoKHZhbCA+PiAxNikgJiAweDFmLCAxKSwgKHZhbCA+PiAxMSkgJiAweDFmLCAodmFsID4+IDUpICYgMHgzZiwgKHZhbCAmIDB4MWYpIDw8IDEpO1xufTtcblxuVXRpbHMuZnJvbURhdGUyRE9TID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGxldCBkYXRlID0gMDtcbiAgICBsZXQgdGltZSA9IDA7XG4gICAgaWYgKHZhbC5nZXRGdWxsWWVhcigpID4gMTk3OSkge1xuICAgICAgICBkYXRlID0gKCgodmFsLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSAmIDB4N2YpIDw8IDkpIHwgKCh2YWwuZ2V0TW9udGgoKSArIDEpIDw8IDUpIHwgdmFsLmdldERhdGUoKTtcbiAgICAgICAgdGltZSA9ICh2YWwuZ2V0SG91cnMoKSA8PCAxMSkgfCAodmFsLmdldE1pbnV0ZXMoKSA8PCA1KSB8ICh2YWwuZ2V0U2Vjb25kcygpID4+IDEpO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGUgPDwgMTYpIHwgdGltZTtcbn07XG5cblV0aWxzLmlzV2luID0gaXNXaW47IC8vIERvIHdlIGhhdmUgd2luZG93cyBzeXN0ZW1cblV0aWxzLmNyY1RhYmxlID0gY3JjVGFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/util/utils.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/zipEntry.js":
/*!******************************************!*\
  !*** ./node_modules/adm-zip/zipEntry.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Utils = __webpack_require__(/*! ./util */ \"./node_modules/adm-zip/util/index.js\"),\n    Headers = __webpack_require__(/*! ./headers */ \"./node_modules/adm-zip/headers/index.js\"),\n    Constants = Utils.Constants,\n    Methods = __webpack_require__(/*! ./methods */ \"./node_modules/adm-zip/methods/index.js\");\n\nmodule.exports = function (/** object */ options, /*Buffer*/ input) {\n    var _centralHeader = new Headers.EntryHeader(),\n        _entryName = Buffer.alloc(0),\n        _comment = Buffer.alloc(0),\n        _isDirectory = false,\n        uncompressedData = null,\n        _extra = Buffer.alloc(0),\n        _extralocal = Buffer.alloc(0),\n        _efs = true;\n\n    // assign options\n    const opts = options;\n\n    const decoder = typeof opts.decoder === \"object\" ? opts.decoder : Utils.decoder;\n    _efs = decoder.hasOwnProperty(\"efs\") ? decoder.efs : false;\n\n    function getCompressedDataFromZip() {\n        //if (!input || !Buffer.isBuffer(input)) {\n        if (!input || !(input instanceof Uint8Array)) {\n            return Buffer.alloc(0);\n        }\n        _extralocal = _centralHeader.loadLocalHeaderFromBinary(input);\n        return input.slice(_centralHeader.realDataOffset, _centralHeader.realDataOffset + _centralHeader.compressedSize);\n    }\n\n    function crc32OK(data) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the local header is written\n        if (!_centralHeader.flags_desc) {\n            if (Utils.crc32(data) !== _centralHeader.localHeader.crc) {\n                return false;\n            }\n        } else {\n            const descriptor = {};\n            const dataEndOffset = _centralHeader.realDataOffset + _centralHeader.compressedSize;\n            // no descriptor after compressed data, instead new local header\n            if (input.readUInt32LE(dataEndOffset) == Constants.LOCSIG || input.readUInt32LE(dataEndOffset) == Constants.CENSIG) {\n                throw Utils.Errors.DESCRIPTOR_NOT_EXIST();\n            }\n\n            // get decriptor data\n            if (input.readUInt32LE(dataEndOffset) == Constants.EXTSIG) {\n                // descriptor with signature\n                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC);\n                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ);\n                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN);\n            } else if (input.readUInt16LE(dataEndOffset + 12) === 0x4b50) {\n                // descriptor without signature (we check is new header starting where we expect)\n                descriptor.crc = input.readUInt32LE(dataEndOffset + Constants.EXTCRC - 4);\n                descriptor.compressedSize = input.readUInt32LE(dataEndOffset + Constants.EXTSIZ - 4);\n                descriptor.size = input.readUInt32LE(dataEndOffset + Constants.EXTLEN - 4);\n            } else {\n                throw Utils.Errors.DESCRIPTOR_UNKNOWN();\n            }\n\n            // check data integrity\n            if (descriptor.compressedSize !== _centralHeader.compressedSize || descriptor.size !== _centralHeader.size || descriptor.crc !== _centralHeader.crc) {\n                throw Utils.Errors.DESCRIPTOR_FAULTY();\n            }\n            if (Utils.crc32(data) !== descriptor.crc) {\n                return false;\n            }\n\n            // @TODO: zip64 bit descriptor fields\n            // if bit 3 is set and any value in local header \"zip64 Extended information\" extra field are set 0 (place holder)\n            // then 64-bit descriptor format is used instead of 32-bit\n            // central header - \"zip64 Extended information\" extra field should store real values and not place holders\n        }\n        return true;\n    }\n\n    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {\n        if (typeof callback === \"undefined\" && typeof async === \"string\") {\n            pass = async;\n            async = void 0;\n        }\n        if (_isDirectory) {\n            if (async && callback) {\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR()); //si added error.\n            }\n            return Buffer.alloc(0);\n        }\n\n        var compressedData = getCompressedDataFromZip();\n\n        if (compressedData.length === 0) {\n            // File is empty, nothing to decompress.\n            if (async && callback) callback(compressedData);\n            return compressedData;\n        }\n\n        if (_centralHeader.encrypted) {\n            if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n                throw Utils.Errors.INVALID_PASS_PARAM();\n            }\n            compressedData = Methods.ZipCrypto.decrypt(compressedData, _centralHeader, pass);\n        }\n\n        var data = Buffer.alloc(_centralHeader.size);\n\n        switch (_centralHeader.method) {\n            case Utils.Constants.STORED:\n                compressedData.copy(data);\n                if (!crc32OK(data)) {\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC()); //si added error\n                    throw Utils.Errors.BAD_CRC();\n                } else {\n                    //si added otherwise did not seem to return data.\n                    if (async && callback) callback(data);\n                    return data;\n                }\n            case Utils.Constants.DEFLATED:\n                var inflater = new Methods.Inflater(compressedData, _centralHeader.size);\n                if (!async) {\n                    const result = inflater.inflate(data);\n                    result.copy(data, 0);\n                    if (!crc32OK(data)) {\n                        throw Utils.Errors.BAD_CRC(`\"${decoder.decode(_entryName)}\"`);\n                    }\n                    return data;\n                } else {\n                    inflater.inflateAsync(function (result) {\n                        result.copy(result, 0);\n                        if (callback) {\n                            if (!crc32OK(result)) {\n                                callback(result, Utils.Errors.BAD_CRC()); //si added error\n                            } else {\n                                callback(result);\n                            }\n                        }\n                    });\n                }\n                break;\n            default:\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD());\n                throw Utils.Errors.UNKNOWN_METHOD();\n        }\n    }\n\n    function compress(/*Boolean*/ async, /*Function*/ callback) {\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n            // no data set or the data wasn't changed to require recompression\n            if (async && callback) callback(getCompressedDataFromZip());\n            return getCompressedDataFromZip();\n        }\n\n        if (uncompressedData.length && !_isDirectory) {\n            var compressedData;\n            // Local file header\n            switch (_centralHeader.method) {\n                case Utils.Constants.STORED:\n                    _centralHeader.compressedSize = _centralHeader.size;\n\n                    compressedData = Buffer.alloc(uncompressedData.length);\n                    uncompressedData.copy(compressedData);\n\n                    if (async && callback) callback(compressedData);\n                    return compressedData;\n                default:\n                case Utils.Constants.DEFLATED:\n                    var deflater = new Methods.Deflater(uncompressedData);\n                    if (!async) {\n                        var deflated = deflater.deflate();\n                        _centralHeader.compressedSize = deflated.length;\n                        return deflated;\n                    } else {\n                        deflater.deflateAsync(function (data) {\n                            compressedData = Buffer.alloc(data.length);\n                            _centralHeader.compressedSize = data.length;\n                            data.copy(compressedData);\n                            callback && callback(compressedData);\n                        });\n                    }\n                    deflater = null;\n                    break;\n            }\n        } else if (async && callback) {\n            callback(Buffer.alloc(0));\n        } else {\n            return Buffer.alloc(0);\n        }\n    }\n\n    function readUInt64LE(buffer, offset) {\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n    }\n\n    function parseExtra(data) {\n        try {\n            var offset = 0;\n            var signature, size, part;\n            while (offset + 4 < data.length) {\n                signature = data.readUInt16LE(offset);\n                offset += 2;\n                size = data.readUInt16LE(offset);\n                offset += 2;\n                part = data.slice(offset, offset + size);\n                offset += size;\n                if (Constants.ID_ZIP64 === signature) {\n                    parseZip64ExtendedInformation(part);\n                }\n            }\n        } catch (error) {\n            throw Utils.Errors.EXTRA_FIELD_PARSE_ERROR();\n        }\n    }\n\n    //Override header field values with values from the ZIP64 extra field\n    function parseZip64ExtendedInformation(data) {\n        var size, compressedSize, offset, diskNumStart;\n\n        if (data.length >= Constants.EF_ZIP64_SCOMP) {\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n            if (_centralHeader.size === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.size = size;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_RHO) {\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n            if (_centralHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.compressedSize = compressedSize;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN) {\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n            if (_centralHeader.offset === Constants.EF_ZIP64_OR_32) {\n                _centralHeader.offset = offset;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n            if (_centralHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n                _centralHeader.diskNumStart = diskNumStart;\n            }\n        }\n    }\n\n    return {\n        get entryName() {\n            return decoder.decode(_entryName);\n        },\n        get rawEntryName() {\n            return _entryName;\n        },\n        set entryName(val) {\n            _entryName = Utils.toBuffer(val, decoder.encode);\n            var lastChar = _entryName[_entryName.length - 1];\n            _isDirectory = lastChar === 47 || lastChar === 92;\n            _centralHeader.fileNameLength = _entryName.length;\n        },\n\n        get efs() {\n            if (typeof _efs === \"function\") {\n                return _efs(this.entryName);\n            } else {\n                return _efs;\n            }\n        },\n\n        get extra() {\n            return _extra;\n        },\n        set extra(val) {\n            _extra = val;\n            _centralHeader.extraLength = val.length;\n            parseExtra(val);\n        },\n\n        get comment() {\n            return decoder.decode(_comment);\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val, decoder.encode);\n            _centralHeader.commentLength = _comment.length;\n            if (_comment.length > 0xffff) throw Utils.Errors.COMMENT_TOO_LONG();\n        },\n\n        get name() {\n            var n = decoder.decode(_entryName);\n            return _isDirectory\n                ? n\n                      .substr(n.length - 1)\n                      .split(\"/\")\n                      .pop()\n                : n.split(\"/\").pop();\n        },\n        get isDirectory() {\n            return _isDirectory;\n        },\n\n        getCompressedData: function () {\n            return compress(false, null);\n        },\n\n        getCompressedDataAsync: function (/*Function*/ callback) {\n            compress(true, callback);\n        },\n\n        setData: function (value) {\n            uncompressedData = Utils.toBuffer(value, Utils.decoder.encode);\n            if (!_isDirectory && uncompressedData.length) {\n                _centralHeader.size = uncompressedData.length;\n                _centralHeader.method = Utils.Constants.DEFLATED;\n                _centralHeader.crc = Utils.crc32(value);\n                _centralHeader.changed = true;\n            } else {\n                // folders and blank files should be stored\n                _centralHeader.method = Utils.Constants.STORED;\n            }\n        },\n\n        getData: function (pass) {\n            if (_centralHeader.changed) {\n                return uncompressedData;\n            } else {\n                return decompress(false, null, pass);\n            }\n        },\n\n        getDataAsync: function (/*Function*/ callback, pass) {\n            if (_centralHeader.changed) {\n                callback(uncompressedData);\n            } else {\n                decompress(true, callback, pass);\n            }\n        },\n\n        set attr(attr) {\n            _centralHeader.attr = attr;\n        },\n        get attr() {\n            return _centralHeader.attr;\n        },\n\n        set header(/*Buffer*/ data) {\n            _centralHeader.loadFromBinary(data);\n        },\n\n        get header() {\n            return _centralHeader;\n        },\n\n        packCentralHeader: function () {\n            _centralHeader.flags_efs = this.efs;\n            _centralHeader.extraLength = _extra.length;\n            // 1. create header (buffer)\n            var header = _centralHeader.centralHeaderToBinary();\n            var addpos = Utils.Constants.CENHDR;\n            // 2. add file name\n            _entryName.copy(header, addpos);\n            addpos += _entryName.length;\n            // 3. add extra data\n            _extra.copy(header, addpos);\n            addpos += _centralHeader.extraLength;\n            // 4. add file comment\n            _comment.copy(header, addpos);\n            return header;\n        },\n\n        packLocalHeader: function () {\n            let addpos = 0;\n            _centralHeader.flags_efs = this.efs;\n            _centralHeader.extraLocalLength = _extralocal.length;\n            // 1. construct local header Buffer\n            const localHeaderBuf = _centralHeader.localHeaderToBinary();\n            // 2. localHeader - crate header buffer\n            const localHeader = Buffer.alloc(localHeaderBuf.length + _entryName.length + _centralHeader.extraLocalLength);\n            // 2.1 add localheader\n            localHeaderBuf.copy(localHeader, addpos);\n            addpos += localHeaderBuf.length;\n            // 2.2 add file name\n            _entryName.copy(localHeader, addpos);\n            addpos += _entryName.length;\n            // 2.3 add extra field\n            _extralocal.copy(localHeader, addpos);\n            addpos += _extralocal.length;\n\n            return localHeader;\n        },\n\n        toJSON: function () {\n            const bytes = function (nr) {\n                return \"<\" + ((nr && nr.length + \" bytes buffer\") || \"null\") + \">\";\n            };\n\n            return {\n                entryName: this.entryName,\n                name: this.name,\n                comment: this.comment,\n                isDirectory: this.isDirectory,\n                header: _centralHeader.toJSON(),\n                compressedData: bytes(input),\n                data: bytes(uncompressedData)\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC96aXBFbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsb0RBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLDBEQUFXO0FBQ2pDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDBEQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvemlwRW50cnkuanM/YzE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIEhlYWRlcnMgPSByZXF1aXJlKFwiLi9oZWFkZXJzXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cyxcbiAgICBNZXRob2RzID0gcmVxdWlyZShcIi4vbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyoqIG9iamVjdCAqLyBvcHRpb25zLCAvKkJ1ZmZlciovIGlucHV0KSB7XG4gICAgdmFyIF9jZW50cmFsSGVhZGVyID0gbmV3IEhlYWRlcnMuRW50cnlIZWFkZXIoKSxcbiAgICAgICAgX2VudHJ5TmFtZSA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgX2NvbW1lbnQgPSBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIF9pc0RpcmVjdG9yeSA9IGZhbHNlLFxuICAgICAgICB1bmNvbXByZXNzZWREYXRhID0gbnVsbCxcbiAgICAgICAgX2V4dHJhID0gQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBfZXh0cmFsb2NhbCA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgX2VmcyA9IHRydWU7XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgZGVjb2RlciA9IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09IFwib2JqZWN0XCIgPyBvcHRzLmRlY29kZXIgOiBVdGlscy5kZWNvZGVyO1xuICAgIF9lZnMgPSBkZWNvZGVyLmhhc093blByb3BlcnR5KFwiZWZzXCIpID8gZGVjb2Rlci5lZnMgOiBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGdldENvbXByZXNzZWREYXRhRnJvbVppcCgpIHtcbiAgICAgICAgLy9pZiAoIWlucHV0IHx8ICFCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIGlmICghaW5wdXQgfHwgIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgICAgIF9leHRyYWxvY2FsID0gX2NlbnRyYWxIZWFkZXIubG9hZExvY2FsSGVhZGVyRnJvbUJpbmFyeShpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dC5zbGljZShfY2VudHJhbEhlYWRlci5yZWFsRGF0YU9mZnNldCwgX2NlbnRyYWxIZWFkZXIucmVhbERhdGFPZmZzZXQgKyBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JjMzJPSyhkYXRhKSB7XG4gICAgICAgIC8vIGlmIGJpdCAzICgweDA4KSBvZiB0aGUgZ2VuZXJhbC1wdXJwb3NlIGZsYWdzIGZpZWxkIGlzIHNldCwgdGhlbiB0aGUgQ1JDLTMyIGFuZCBmaWxlIHNpemVzIGFyZSBub3Qga25vd24gd2hlbiB0aGUgbG9jYWwgaGVhZGVyIGlzIHdyaXR0ZW5cbiAgICAgICAgaWYgKCFfY2VudHJhbEhlYWRlci5mbGFnc19kZXNjKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuY3JjMzIoZGF0YSkgIT09IF9jZW50cmFsSGVhZGVyLmxvY2FsSGVhZGVyLmNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFFbmRPZmZzZXQgPSBfY2VudHJhbEhlYWRlci5yZWFsRGF0YU9mZnNldCArIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgLy8gbm8gZGVzY3JpcHRvciBhZnRlciBjb21wcmVzc2VkIGRhdGEsIGluc3RlYWQgbmV3IGxvY2FsIGhlYWRlclxuICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuTE9DU0lHIHx8IGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuQ0VOU0lHKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkRFU0NSSVBUT1JfTk9UX0VYSVNUKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGdldCBkZWNyaXB0b3IgZGF0YVxuICAgICAgICAgICAgaWYgKGlucHV0LnJlYWRVSW50MzJMRShkYXRhRW5kT2Zmc2V0KSA9PSBDb25zdGFudHMuRVhUU0lHKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciB3aXRoIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY3JjID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUQ1JDKTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUU0laKTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNpemUgPSBpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCArIENvbnN0YW50cy5FWFRMRU4pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5yZWFkVUludDE2TEUoZGF0YUVuZE9mZnNldCArIDEyKSA9PT0gMHg0YjUwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciB3aXRob3V0IHNpZ25hdHVyZSAod2UgY2hlY2sgaXMgbmV3IGhlYWRlciBzdGFydGluZyB3aGVyZSB3ZSBleHBlY3QpXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5jcmMgPSBpbnB1dC5yZWFkVUludDMyTEUoZGF0YUVuZE9mZnNldCArIENvbnN0YW50cy5FWFRDUkMgLSA0KTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUU0laIC0gNCk7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zaXplID0gaW5wdXQucmVhZFVJbnQzMkxFKGRhdGFFbmRPZmZzZXQgKyBDb25zdGFudHMuRVhUTEVOIC0gNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5ERVNDUklQVE9SX1VOS05PV04oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZGF0YSBpbnRlZ3JpdHlcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmNvbXByZXNzZWRTaXplICE9PSBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSB8fCBkZXNjcmlwdG9yLnNpemUgIT09IF9jZW50cmFsSGVhZGVyLnNpemUgfHwgZGVzY3JpcHRvci5jcmMgIT09IF9jZW50cmFsSGVhZGVyLmNyYykge1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5ERVNDUklQVE9SX0ZBVUxUWSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFV0aWxzLmNyYzMyKGRhdGEpICE9PSBkZXNjcmlwdG9yLmNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQFRPRE86IHppcDY0IGJpdCBkZXNjcmlwdG9yIGZpZWxkc1xuICAgICAgICAgICAgLy8gaWYgYml0IDMgaXMgc2V0IGFuZCBhbnkgdmFsdWUgaW4gbG9jYWwgaGVhZGVyIFwiemlwNjQgRXh0ZW5kZWQgaW5mb3JtYXRpb25cIiBleHRyYSBmaWVsZCBhcmUgc2V0IDAgKHBsYWNlIGhvbGRlcilcbiAgICAgICAgICAgIC8vIHRoZW4gNjQtYml0IGRlc2NyaXB0b3IgZm9ybWF0IGlzIHVzZWQgaW5zdGVhZCBvZiAzMi1iaXRcbiAgICAgICAgICAgIC8vIGNlbnRyYWwgaGVhZGVyIC0gXCJ6aXA2NCBFeHRlbmRlZCBpbmZvcm1hdGlvblwiIGV4dHJhIGZpZWxkIHNob3VsZCBzdG9yZSByZWFsIHZhbHVlcyBhbmQgbm90IHBsYWNlIGhvbGRlcnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvbXByZXNzKC8qQm9vbGVhbiovIGFzeW5jLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFzeW5jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXNzID0gYXN5bmM7XG4gICAgICAgICAgICBhc3luYyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhCdWZmZXIuYWxsb2MoMCksIFV0aWxzLkVycm9ycy5ESVJFQ1RPUllfQ09OVEVOVF9FUlJPUigpKTsgLy9zaSBhZGRlZCBlcnJvci5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcHJlc3NlZERhdGEgPSBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcblxuICAgICAgICBpZiAoY29tcHJlc3NlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGlzIGVtcHR5LCBub3RoaW5nIHRvIGRlY29tcHJlc3MuXG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcGFzcyAmJiAhQnVmZmVyLmlzQnVmZmVyKHBhc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLklOVkFMSURfUEFTU19QQVJBTSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBNZXRob2RzLlppcENyeXB0by5kZWNyeXB0KGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlciwgcGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5hbGxvYyhfY2VudHJhbEhlYWRlci5zaXplKTtcblxuICAgICAgICBzd2l0Y2ggKF9jZW50cmFsSGVhZGVyLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBVdGlscy5Db25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgIGNvbXByZXNzZWREYXRhLmNvcHkoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjcmMzMk9LKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soZGF0YSwgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKSk7IC8vc2kgYWRkZWQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3NpIGFkZGVkIG90aGVyd2lzZSBkaWQgbm90IHNlZW0gdG8gcmV0dXJuIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlciA9IG5ldyBNZXRob2RzLkluZmxhdGVyKGNvbXByZXNzZWREYXRhLCBfY2VudHJhbEhlYWRlci5zaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluZmxhdGVyLmluZmxhdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KGRhdGEsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNyYzMyT0soZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5CQURfQ1JDKGBcIiR7ZGVjb2Rlci5kZWNvZGUoX2VudHJ5TmFtZSl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmZsYXRlci5pbmZsYXRlQXN5bmMoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3JjMzJPSyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCwgVXRpbHMuRXJyb3JzLkJBRF9DUkMoKSk7IC8vc2kgYWRkZWQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKEJ1ZmZlci5hbGxvYygwKSwgVXRpbHMuRXJyb3JzLlVOS05PV05fTUVUSE9EKCkpO1xuICAgICAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5VTktOT1dOX01FVEhPRCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHJlc3MoLypCb29sZWFuKi8gYXN5bmMsIC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICBpZiAoKCF1bmNvbXByZXNzZWREYXRhIHx8ICF1bmNvbXByZXNzZWREYXRhLmxlbmd0aCkgJiYgQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSBzZXQgb3IgdGhlIGRhdGEgd2Fzbid0IGNoYW5nZWQgdG8gcmVxdWlyZSByZWNvbXByZXNzaW9uXG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGdldENvbXByZXNzZWREYXRhRnJvbVppcCgpKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAmJiAhX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZERhdGE7XG4gICAgICAgICAgICAvLyBMb2NhbCBmaWxlIGhlYWRlclxuICAgICAgICAgICAgc3dpdGNoIChfY2VudHJhbEhlYWRlci5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ6XG4gICAgICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID0gX2NlbnRyYWxIZWFkZXIuc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEuY29weShjb21wcmVzc2VkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZXIgPSBuZXcgTWV0aG9kcy5EZWZsYXRlcih1bmNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkID0gZGVmbGF0ZXIuZGVmbGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkZWZsYXRlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZsYXRlci5kZWZsYXRlQXN5bmMoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNvcHkoY29tcHJlc3NlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmxhdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEJ1ZmZlci5hbGxvYygwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAoYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KSA8PCA0KSArIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4dHJhKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSwgc2l6ZSwgcGFydDtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyA0IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBkYXRhLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIHNpemUgPSBkYXRhLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKENvbnN0YW50cy5JRF9aSVA2NCA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlWmlwNjRFeHRlbmRlZEluZm9ybWF0aW9uKHBhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IFV0aWxzLkVycm9ycy5FWFRSQV9GSUVMRF9QQVJTRV9FUlJPUigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9PdmVycmlkZSBoZWFkZXIgZmllbGQgdmFsdWVzIHdpdGggdmFsdWVzIGZyb20gdGhlIFpJUDY0IGV4dHJhIGZpZWxkXG4gICAgZnVuY3Rpb24gcGFyc2VaaXA2NEV4dGVuZGVkSW5mb3JtYXRpb24oZGF0YSkge1xuICAgICAgICB2YXIgc2l6ZSwgY29tcHJlc3NlZFNpemUsIG9mZnNldCwgZGlza051bVN0YXJ0O1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfU0NPTVApIHtcbiAgICAgICAgICAgIHNpemUgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1NVTkNPTVApO1xuICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLnNpemUgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8zMikge1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfUkhPKSB7XG4gICAgICAgICAgICBjb21wcmVzc2VkU2l6ZSA9IHJlYWRVSW50NjRMRShkYXRhLCBDb25zdGFudHMuRUZfWklQNjRfU0NPTVApO1xuICAgICAgICAgICAgaWYgKF9jZW50cmFsSGVhZGVyLmNvbXByZXNzZWRTaXplID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfRFNOKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1JITyk7XG4gICAgICAgICAgICBpZiAoX2NlbnRyYWxIZWFkZXIub2Zmc2V0ID09PSBDb25zdGFudHMuRUZfWklQNjRfT1JfMzIpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9EU04gKyA0KSB7XG4gICAgICAgICAgICBkaXNrTnVtU3RhcnQgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuRUZfWklQNjRfRFNOKTtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5kaXNrTnVtU3RhcnQgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8xNikge1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmRpc2tOdW1TdGFydCA9IGRpc2tOdW1TdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBlbnRyeU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoX2VudHJ5TmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByYXdFbnRyeU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VudHJ5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGVudHJ5TmFtZSh2YWwpIHtcbiAgICAgICAgICAgIF9lbnRyeU5hbWUgPSBVdGlscy50b0J1ZmZlcih2YWwsIGRlY29kZXIuZW5jb2RlKTtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hhciA9IF9lbnRyeU5hbWVbX2VudHJ5TmFtZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIF9pc0RpcmVjdG9yeSA9IGxhc3RDaGFyID09PSA0NyB8fCBsYXN0Q2hhciA9PT0gOTI7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5maWxlTmFtZUxlbmd0aCA9IF9lbnRyeU5hbWUubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBlZnMoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9lZnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZWZzKHRoaXMuZW50cnlOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGV4dHJhKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9leHRyYTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGV4dHJhKHZhbCkge1xuICAgICAgICAgICAgX2V4dHJhID0gdmFsO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGggPSB2YWwubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VFeHRyYSh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21tZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKF9jb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnQodmFsKSB7XG4gICAgICAgICAgICBfY29tbWVudCA9IFV0aWxzLnRvQnVmZmVyKHZhbCwgZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuY29tbWVudExlbmd0aCA9IF9jb21tZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChfY29tbWVudC5sZW5ndGggPiAweGZmZmYpIHRocm93IFV0aWxzLkVycm9ycy5DT01NRU5UX1RPT19MT05HKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGRlY29kZXIuZGVjb2RlKF9lbnRyeU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF9pc0RpcmVjdG9yeVxuICAgICAgICAgICAgICAgID8gblxuICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHIobi5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAucG9wKClcbiAgICAgICAgICAgICAgICA6IG4uc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2lzRGlyZWN0b3J5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbXByZXNzZWREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3MoZmFsc2UsIG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbXByZXNzZWREYXRhQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbXByZXNzKHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEgPSBVdGlscy50b0J1ZmZlcih2YWx1ZSwgVXRpbHMuZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgaWYgKCFfaXNEaXJlY3RvcnkgJiYgdW5jb21wcmVzc2VkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5zaXplID0gdW5jb21wcmVzc2VkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEO1xuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmNyYyA9IFV0aWxzLmNyYzMyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBfY2VudHJhbEhlYWRlci5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9sZGVycyBhbmQgYmxhbmsgZmlsZXMgc2hvdWxkIGJlIHN0b3JlZFxuICAgICAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLm1ldGhvZCA9IFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKHBhc3MpIHtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuY29tcHJlc3NlZERhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvbXByZXNzKGZhbHNlLCBudWxsLCBwYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXREYXRhQXN5bmM6IGZ1bmN0aW9uICgvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIHBhc3MpIHtcbiAgICAgICAgICAgIGlmIChfY2VudHJhbEhlYWRlci5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodW5jb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3ModHJ1ZSwgY2FsbGJhY2ssIHBhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldCBhdHRyKGF0dHIpIHtcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmF0dHIgPSBhdHRyO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfY2VudHJhbEhlYWRlci5hdHRyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCBoZWFkZXIoLypCdWZmZXIqLyBkYXRhKSB7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5sb2FkRnJvbUJpbmFyeShkYXRhKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jZW50cmFsSGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhY2tDZW50cmFsSGVhZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfY2VudHJhbEhlYWRlci5mbGFnc19lZnMgPSB0aGlzLmVmcztcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmV4dHJhTGVuZ3RoID0gX2V4dHJhLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDEuIGNyZWF0ZSBoZWFkZXIgKGJ1ZmZlcilcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfY2VudHJhbEhlYWRlci5jZW50cmFsSGVhZGVyVG9CaW5hcnkoKTtcbiAgICAgICAgICAgIHZhciBhZGRwb3MgPSBVdGlscy5Db25zdGFudHMuQ0VOSERSO1xuICAgICAgICAgICAgLy8gMi4gYWRkIGZpbGUgbmFtZVxuICAgICAgICAgICAgX2VudHJ5TmFtZS5jb3B5KGhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDMuIGFkZCBleHRyYSBkYXRhXG4gICAgICAgICAgICBfZXh0cmEuY29weShoZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gX2NlbnRyYWxIZWFkZXIuZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICAvLyA0LiBhZGQgZmlsZSBjb21tZW50XG4gICAgICAgICAgICBfY29tbWVudC5jb3B5KGhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFja0xvY2FsSGVhZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgYWRkcG9zID0gMDtcbiAgICAgICAgICAgIF9jZW50cmFsSGVhZGVyLmZsYWdzX2VmcyA9IHRoaXMuZWZzO1xuICAgICAgICAgICAgX2NlbnRyYWxIZWFkZXIuZXh0cmFMb2NhbExlbmd0aCA9IF9leHRyYWxvY2FsLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXIgQnVmZmVyXG4gICAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlckJ1ZiA9IF9jZW50cmFsSGVhZGVyLmxvY2FsSGVhZGVyVG9CaW5hcnkoKTtcbiAgICAgICAgICAgIC8vIDIuIGxvY2FsSGVhZGVyIC0gY3JhdGUgaGVhZGVyIGJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgbG9jYWxIZWFkZXIgPSBCdWZmZXIuYWxsb2MobG9jYWxIZWFkZXJCdWYubGVuZ3RoICsgX2VudHJ5TmFtZS5sZW5ndGggKyBfY2VudHJhbEhlYWRlci5leHRyYUxvY2FsTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIDIuMSBhZGQgbG9jYWxoZWFkZXJcbiAgICAgICAgICAgIGxvY2FsSGVhZGVyQnVmLmNvcHkobG9jYWxIZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gbG9jYWxIZWFkZXJCdWYubGVuZ3RoO1xuICAgICAgICAgICAgLy8gMi4yIGFkZCBmaWxlIG5hbWVcbiAgICAgICAgICAgIF9lbnRyeU5hbWUuY29weShsb2NhbEhlYWRlciwgYWRkcG9zKTtcbiAgICAgICAgICAgIGFkZHBvcyArPSBfZW50cnlOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIDIuMyBhZGQgZXh0cmEgZmllbGRcbiAgICAgICAgICAgIF9leHRyYWxvY2FsLmNvcHkobG9jYWxIZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICBhZGRwb3MgKz0gX2V4dHJhbG9jYWwubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxIZWFkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGZ1bmN0aW9uIChucikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxcIiArICgobnIgJiYgbnIubGVuZ3RoICsgXCIgYnl0ZXMgYnVmZmVyXCIpIHx8IFwibnVsbFwiKSArIFwiPlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbnRyeU5hbWU6IHRoaXMuZW50cnlOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb21tZW50OiB0aGlzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IHRoaXMuaXNEaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBfY2VudHJhbEhlYWRlci50b0pTT04oKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YTogYnl0ZXMoaW5wdXQpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJ5dGVzKHVuY29tcHJlc3NlZERhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/zipEntry.js\n\n}");

/***/ }),

/***/ "./node_modules/adm-zip/zipFile.js":
/*!*****************************************!*\
  !*** ./node_modules/adm-zip/zipFile.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const ZipEntry = __webpack_require__(/*! ./zipEntry */ \"./node_modules/adm-zip/zipEntry.js\");\nconst Headers = __webpack_require__(/*! ./headers */ \"./node_modules/adm-zip/headers/index.js\");\nconst Utils = __webpack_require__(/*! ./util */ \"./node_modules/adm-zip/util/index.js\");\n\nmodule.exports = function (/*Buffer|null*/ inBuffer, /** object */ options) {\n    var entryList = [],\n        entryTable = {},\n        _comment = Buffer.alloc(0),\n        mainHeader = new Headers.MainHeader(),\n        loadedEntries = false;\n    var password = null;\n    const temporary = new Set();\n\n    // assign options\n    const opts = options;\n\n    const { noSort, decoder } = opts;\n\n    if (inBuffer) {\n        // is a memory buffer\n        readMainHeader(opts.readEntries);\n    } else {\n        // none. is a new file\n        loadedEntries = true;\n    }\n\n    function makeTemporaryFolders() {\n        const foldersList = new Set();\n\n        // Make list of all folders in file\n        for (const elem of Object.keys(entryTable)) {\n            const elements = elem.split(\"/\");\n            elements.pop(); // filename\n            if (!elements.length) continue; // no folders\n            for (let i = 0; i < elements.length; i++) {\n                const sub = elements.slice(0, i + 1).join(\"/\") + \"/\";\n                foldersList.add(sub);\n            }\n        }\n\n        // create missing folders as temporary\n        for (const elem of foldersList) {\n            if (!(elem in entryTable)) {\n                const tempfolder = new ZipEntry(opts);\n                tempfolder.entryName = elem;\n                tempfolder.attr = 0x10;\n                tempfolder.temporary = true;\n                entryList.push(tempfolder);\n                entryTable[tempfolder.entryName] = tempfolder;\n                temporary.add(tempfolder);\n            }\n        }\n    }\n\n    function readEntries() {\n        loadedEntries = true;\n        entryTable = {};\n        if (mainHeader.diskEntries > (inBuffer.length - mainHeader.offset) / Utils.Constants.CENHDR) {\n            throw Utils.Errors.DISK_ENTRY_TOO_LARGE();\n        }\n        entryList = new Array(mainHeader.diskEntries); // total number of entries\n        var index = mainHeader.offset; // offset of first CEN header\n        for (var i = 0; i < entryList.length; i++) {\n            var tmp = index,\n                entry = new ZipEntry(opts, inBuffer);\n            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));\n\n            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));\n\n            if (entry.header.extraLength) {\n                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));\n            }\n\n            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n\n            index += entry.header.centralHeaderSize;\n\n            entryList[i] = entry;\n            entryTable[entry.entryName] = entry;\n        }\n        temporary.clear();\n        makeTemporaryFolders();\n    }\n\n    function readMainHeader(/*Boolean*/ readNow) {\n        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\n            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length\n            n = max,\n            endStart = inBuffer.length,\n            endOffset = -1, // Start offset of the END header\n            commentEnd = 0;\n\n        // option to search header form entire file\n        const trailingSpace = typeof opts.trailingSpace === \"boolean\" ? opts.trailingSpace : false;\n        if (trailingSpace) max = 0;\n\n        for (i; i >= n; i--) {\n            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n                // \"PK\\005\\006\"\n                endOffset = i;\n                commentEnd = i;\n                endStart = i + Utils.Constants.ENDHDR;\n                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n                n = i - Utils.Constants.END64HDR;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n                // Found a zip64 signature, let's continue reading the whole zip64 record\n                n = max;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n                // Found the zip64 record, let's determine it's size\n                endOffset = i;\n                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n                break;\n            }\n        }\n\n        if (endOffset == -1) throw Utils.Errors.INVALID_FORMAT();\n\n        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n        if (mainHeader.commentLength) {\n            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n        }\n        if (readNow) readEntries();\n    }\n\n    function sortEntries() {\n        if (entryList.length > 1 && !noSort) {\n            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n        }\n    }\n\n    return {\n        /**\n         * Returns an array of ZipEntry objects existent in the current opened archive\n         * @return Array\n         */\n        get entries() {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryList.filter((e) => !temporary.has(e));\n        },\n\n        /**\n         * Archive comment\n         * @return {String}\n         */\n        get comment() {\n            return decoder.decode(_comment);\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val, decoder.encode);\n            mainHeader.commentLength = _comment.length;\n        },\n\n        getEntryCount: function () {\n            if (!loadedEntries) {\n                return mainHeader.diskEntries;\n            }\n\n            return entryList.length;\n        },\n\n        forEach: function (callback) {\n            this.entries.forEach(callback);\n        },\n\n        /**\n         * Returns a reference to the entry with the given name or null if entry is inexistent\n         *\n         * @param entryName\n         * @return ZipEntry\n         */\n        getEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryTable[entryName] || null;\n        },\n\n        /**\n         * Adds the given entry to the entry list\n         *\n         * @param entry\n         */\n        setEntry: function (/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            entryList.push(entry);\n            entryTable[entry.entryName] = entry;\n            mainHeader.totalEntries = entryList.length;\n        },\n\n        /**\n         * Removes the file with the given name from the entry list.\n         *\n         * If the entry is a directory, then all nested files and directories will be removed\n         * @param entryName\n         * @returns {void}\n         */\n        deleteFile: function (/*String*/ entryName, withsubfolders = true) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            const entry = entryTable[entryName];\n            const list = this.getEntryChildren(entry, withsubfolders).map((child) => child.entryName);\n\n            list.forEach(this.deleteEntry);\n        },\n\n        /**\n         * Removes the entry with the given name from the entry list.\n         *\n         * @param {string} entryName\n         * @returns {void}\n         */\n        deleteEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            const entry = entryTable[entryName];\n            const index = entryList.indexOf(entry);\n            if (index >= 0) {\n                entryList.splice(index, 1);\n                delete entryTable[entryName];\n                mainHeader.totalEntries = entryList.length;\n            }\n        },\n\n        /**\n         *  Iterates and returns all nested files and directories of the given entry\n         *\n         * @param entry\n         * @return Array\n         */\n        getEntryChildren: function (/*ZipEntry*/ entry, subfolders = true) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            if (typeof entry === \"object\") {\n                if (entry.isDirectory && subfolders) {\n                    const list = [];\n                    const name = entry.entryName;\n\n                    for (const zipEntry of entryList) {\n                        if (zipEntry.entryName.startsWith(name)) {\n                            list.push(zipEntry);\n                        }\n                    }\n                    return list;\n                } else {\n                    return [entry];\n                }\n            }\n            return [];\n        },\n\n        /**\n         *  How many child elements entry has\n         *\n         * @param {ZipEntry} entry\n         * @return {integer}\n         */\n        getChildCount: function (entry) {\n            if (entry && entry.isDirectory) {\n                const list = this.getEntryChildren(entry);\n                return list.includes(entry) ? list.length - 1 : list.length;\n            }\n            return 0;\n        },\n\n        /**\n         * Returns the zip file\n         *\n         * @return Buffer\n         */\n        compressToBuffer: function () {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            sortEntries();\n\n            const dataBlock = [];\n            const headerBlocks = [];\n            let totalSize = 0;\n            let dindex = 0;\n\n            mainHeader.size = 0;\n            mainHeader.offset = 0;\n            let totalEntries = 0;\n\n            for (const entry of this.entries) {\n                // compress data and set local and entry header accordingly. Reason why is called first\n                const compressedData = entry.getCompressedData();\n                entry.header.offset = dindex;\n\n                // 1. construct local header\n                const localHeader = entry.packLocalHeader();\n\n                // 2. offsets\n                const dataLength = localHeader.length + compressedData.length;\n                dindex += dataLength;\n\n                // 3. store values in sequence\n                dataBlock.push(localHeader);\n                dataBlock.push(compressedData);\n\n                // 4. construct central header\n                const centralHeader = entry.packCentralHeader();\n                headerBlocks.push(centralHeader);\n                // 5. update main header\n                mainHeader.size += centralHeader.length;\n                totalSize += dataLength + centralHeader.length;\n                totalEntries++;\n            }\n\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n            // point to end of data and beginning of central directory first record\n            mainHeader.offset = dindex;\n            mainHeader.totalEntries = totalEntries;\n\n            dindex = 0;\n            const outBuffer = Buffer.alloc(totalSize);\n            // write data blocks\n            for (const content of dataBlock) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write central directory entries\n            for (const content of headerBlocks) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write main header\n            const mh = mainHeader.toBinary();\n            if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n            }\n            mh.copy(outBuffer, dindex);\n\n            // Since we update entry and main header offsets,\n            // they are no longer valid and we have to reset content\n            // (Issue 64)\n\n            inBuffer = outBuffer;\n            loadedEntries = false;\n\n            return outBuffer;\n        },\n\n        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {\n            try {\n                if (!loadedEntries) {\n                    readEntries();\n                }\n                sortEntries();\n\n                const dataBlock = [];\n                const centralHeaders = [];\n                let totalSize = 0;\n                let dindex = 0;\n                let totalEntries = 0;\n\n                mainHeader.size = 0;\n                mainHeader.offset = 0;\n\n                const compress2Buffer = function (entryLists) {\n                    if (entryLists.length > 0) {\n                        const entry = entryLists.shift();\n                        const name = entry.entryName + entry.extra.toString();\n                        if (onItemStart) onItemStart(name);\n                        entry.getCompressedDataAsync(function (compressedData) {\n                            if (onItemEnd) onItemEnd(name);\n                            entry.header.offset = dindex;\n\n                            // 1. construct local header\n                            const localHeader = entry.packLocalHeader();\n\n                            // 2. offsets\n                            const dataLength = localHeader.length + compressedData.length;\n                            dindex += dataLength;\n\n                            // 3. store values in sequence\n                            dataBlock.push(localHeader);\n                            dataBlock.push(compressedData);\n\n                            // central header\n                            const centalHeader = entry.packCentralHeader();\n                            centralHeaders.push(centalHeader);\n                            mainHeader.size += centalHeader.length;\n                            totalSize += dataLength + centalHeader.length;\n                            totalEntries++;\n\n                            compress2Buffer(entryLists);\n                        });\n                    } else {\n                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n                        // point to end of data and beginning of central directory first record\n                        mainHeader.offset = dindex;\n                        mainHeader.totalEntries = totalEntries;\n\n                        dindex = 0;\n                        const outBuffer = Buffer.alloc(totalSize);\n                        dataBlock.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write data blocks\n                            dindex += content.length;\n                        });\n                        centralHeaders.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write central directory entries\n                            dindex += content.length;\n                        });\n\n                        const mh = mainHeader.toBinary();\n                        if (_comment) {\n                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n                        }\n\n                        mh.copy(outBuffer, dindex); // write main header\n\n                        // Since we update entry and main header offsets, they are no\n                        // longer valid and we have to reset content using our new buffer\n                        // (Issue 64)\n\n                        inBuffer = outBuffer;\n                        loadedEntries = false;\n\n                        onSuccess(outBuffer);\n                    }\n                };\n\n                compress2Buffer(Array.from(this.entries));\n            } catch (e) {\n                onFail(e);\n            }\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWRtLXppcC96aXBGaWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHNEQUFZO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFXO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxvREFBUTs7QUFFOUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNENBQTRDO0FBQzVDLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELHVDQUF1QztBQUN2Qyx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QixnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFOztBQUVBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hZG0temlwL3ppcEZpbGUuanM/YzA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBaaXBFbnRyeSA9IHJlcXVpcmUoXCIuL3ppcEVudHJ5XCIpO1xuY29uc3QgSGVhZGVycyA9IHJlcXVpcmUoXCIuL2hlYWRlcnNcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyfG51bGwqLyBpbkJ1ZmZlciwgLyoqIG9iamVjdCAqLyBvcHRpb25zKSB7XG4gICAgdmFyIGVudHJ5TGlzdCA9IFtdLFxuICAgICAgICBlbnRyeVRhYmxlID0ge30sXG4gICAgICAgIF9jb21tZW50ID0gQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBtYWluSGVhZGVyID0gbmV3IEhlYWRlcnMuTWFpbkhlYWRlcigpLFxuICAgICAgICBsb2FkZWRFbnRyaWVzID0gZmFsc2U7XG4gICAgdmFyIHBhc3N3b3JkID0gbnVsbDtcbiAgICBjb25zdCB0ZW1wb3JhcnkgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgeyBub1NvcnQsIGRlY29kZXIgfSA9IG9wdHM7XG5cbiAgICBpZiAoaW5CdWZmZXIpIHtcbiAgICAgICAgLy8gaXMgYSBtZW1vcnkgYnVmZmVyXG4gICAgICAgIHJlYWRNYWluSGVhZGVyKG9wdHMucmVhZEVudHJpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbmUuIGlzIGEgbmV3IGZpbGVcbiAgICAgICAgbG9hZGVkRW50cmllcyA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVRlbXBvcmFyeUZvbGRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlcnNMaXN0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgbGlzdCBvZiBhbGwgZm9sZGVycyBpbiBmaWxlXG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBPYmplY3Qua2V5cyhlbnRyeVRhYmxlKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbGVtLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnBvcCgpOyAvLyBmaWxlbmFtZVxuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIGNvbnRpbnVlOyAvLyBubyBmb2xkZXJzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gZWxlbWVudHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gICAgICAgICAgICAgICAgZm9sZGVyc0xpc3QuYWRkKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgbWlzc2luZyBmb2xkZXJzIGFzIHRlbXBvcmFyeVxuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgZm9sZGVyc0xpc3QpIHtcbiAgICAgICAgICAgIGlmICghKGVsZW0gaW4gZW50cnlUYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wZm9sZGVyID0gbmV3IFppcEVudHJ5KG9wdHMpO1xuICAgICAgICAgICAgICAgIHRlbXBmb2xkZXIuZW50cnlOYW1lID0gZWxlbTtcbiAgICAgICAgICAgICAgICB0ZW1wZm9sZGVyLmF0dHIgPSAweDEwO1xuICAgICAgICAgICAgICAgIHRlbXBmb2xkZXIudGVtcG9yYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbnRyeUxpc3QucHVzaCh0ZW1wZm9sZGVyKTtcbiAgICAgICAgICAgICAgICBlbnRyeVRhYmxlW3RlbXBmb2xkZXIuZW50cnlOYW1lXSA9IHRlbXBmb2xkZXI7XG4gICAgICAgICAgICAgICAgdGVtcG9yYXJ5LmFkZCh0ZW1wZm9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRFbnRyaWVzKCkge1xuICAgICAgICBsb2FkZWRFbnRyaWVzID0gdHJ1ZTtcbiAgICAgICAgZW50cnlUYWJsZSA9IHt9O1xuICAgICAgICBpZiAobWFpbkhlYWRlci5kaXNrRW50cmllcyA+IChpbkJ1ZmZlci5sZW5ndGggLSBtYWluSGVhZGVyLm9mZnNldCkgLyBVdGlscy5Db25zdGFudHMuQ0VOSERSKSB7XG4gICAgICAgICAgICB0aHJvdyBVdGlscy5FcnJvcnMuRElTS19FTlRSWV9UT09fTEFSR0UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeUxpc3QgPSBuZXcgQXJyYXkobWFpbkhlYWRlci5kaXNrRW50cmllcyk7IC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgIHZhciBpbmRleCA9IG1haW5IZWFkZXIub2Zmc2V0OyAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGluZGV4LFxuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IFppcEVudHJ5KG9wdHMsIGluQnVmZmVyKTtcbiAgICAgICAgICAgIGVudHJ5LmhlYWRlciA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBVdGlscy5Db25zdGFudHMuQ0VOSERSKSk7XG5cbiAgICAgICAgICAgIGVudHJ5LmVudHJ5TmFtZSA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBlbnRyeS5oZWFkZXIuZmlsZU5hbWVMZW5ndGgpKTtcblxuICAgICAgICAgICAgaWYgKGVudHJ5LmhlYWRlci5leHRyYUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVudHJ5LmV4dHJhID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IGVudHJ5LmhlYWRlci5leHRyYUxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkuaGVhZGVyLmNvbW1lbnRMZW5ndGgpIGVudHJ5LmNvbW1lbnQgPSBpbkJ1ZmZlci5zbGljZSh0bXAsIHRtcCArIGVudHJ5LmhlYWRlci5jb21tZW50TGVuZ3RoKTtcblxuICAgICAgICAgICAgaW5kZXggKz0gZW50cnkuaGVhZGVyLmNlbnRyYWxIZWFkZXJTaXplO1xuXG4gICAgICAgICAgICBlbnRyeUxpc3RbaV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5VGFibGVbZW50cnkuZW50cnlOYW1lXSA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRlbXBvcmFyeS5jbGVhcigpO1xuICAgICAgICBtYWtlVGVtcG9yYXJ5Rm9sZGVycygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRNYWluSGVhZGVyKC8qQm9vbGVhbiovIHJlYWROb3cpIHtcbiAgICAgICAgdmFyIGkgPSBpbkJ1ZmZlci5sZW5ndGggLSBVdGlscy5Db25zdGFudHMuRU5ESERSLCAvLyBFTkQgaGVhZGVyIHNpemVcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KDAsIGkgLSAweGZmZmYpLCAvLyAweEZGRkYgaXMgdGhlIG1heCB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICAgICAgbiA9IG1heCxcbiAgICAgICAgICAgIGVuZFN0YXJ0ID0gaW5CdWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gLTEsIC8vIFN0YXJ0IG9mZnNldCBvZiB0aGUgRU5EIGhlYWRlclxuICAgICAgICAgICAgY29tbWVudEVuZCA9IDA7XG5cbiAgICAgICAgLy8gb3B0aW9uIHRvIHNlYXJjaCBoZWFkZXIgZm9ybSBlbnRpcmUgZmlsZVxuICAgICAgICBjb25zdCB0cmFpbGluZ1NwYWNlID0gdHlwZW9mIG9wdHMudHJhaWxpbmdTcGFjZSA9PT0gXCJib29sZWFuXCIgPyBvcHRzLnRyYWlsaW5nU3BhY2UgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRyYWlsaW5nU3BhY2UpIG1heCA9IDA7XG5cbiAgICAgICAgZm9yIChpOyBpID49IG47IGktLSkge1xuICAgICAgICAgICAgaWYgKGluQnVmZmVyW2ldICE9PSAweDUwKSBjb250aW51ZTsgLy8gcXVpY2sgY2hlY2sgdGhhdCB0aGUgYnl0ZSBpcyAnUCdcbiAgICAgICAgICAgIGlmIChpbkJ1ZmZlci5yZWFkVUludDMyTEUoaSkgPT09IFV0aWxzLkNvbnN0YW50cy5FTkRTSUcpIHtcbiAgICAgICAgICAgICAgICAvLyBcIlBLXFwwMDVcXDAwNlwiXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0gaTtcbiAgICAgICAgICAgICAgICBlbmRTdGFydCA9IGkgKyBVdGlscy5Db25zdGFudHMuRU5ESERSO1xuICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgZm91bmQgYSByZWd1bGFyIHNpZ25hdHVyZSwgbGV0J3MgbG9vayBqdXN0IGEgYml0IGZ1cnRoZXIgdG8gY2hlY2sgaWYgdGhlcmUncyBhbnkgemlwNjQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgbiA9IGkgLSBVdGlscy5Db25zdGFudHMuRU5ENjRIRFI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkJ1ZmZlci5yZWFkVUludDMyTEUoaSkgPT09IFV0aWxzLkNvbnN0YW50cy5FTkQ2NFNJRykge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgemlwNjQgc2lnbmF0dXJlLCBsZXQncyBjb250aW51ZSByZWFkaW5nIHRoZSB3aG9sZSB6aXA2NCByZWNvcmRcbiAgICAgICAgICAgICAgICBuID0gbWF4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5CdWZmZXIucmVhZFVJbnQzMkxFKGkpID09PSBVdGlscy5Db25zdGFudHMuWklQNjRTSUcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCB0aGUgemlwNjQgcmVjb3JkLCBsZXQncyBkZXRlcm1pbmUgaXQncyBzaXplXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBlbmRTdGFydCA9IGkgKyBVdGlscy5yZWFkQmlnVUludDY0TEUoaW5CdWZmZXIsIGkgKyBVdGlscy5Db25zdGFudHMuWklQNjRTSVpFKSArIFV0aWxzLkNvbnN0YW50cy5aSVA2NExFQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kT2Zmc2V0ID09IC0xKSB0aHJvdyBVdGlscy5FcnJvcnMuSU5WQUxJRF9GT1JNQVQoKTtcblxuICAgICAgICBtYWluSGVhZGVyLmxvYWRGcm9tQmluYXJ5KGluQnVmZmVyLnNsaWNlKGVuZE9mZnNldCwgZW5kU3RhcnQpKTtcbiAgICAgICAgaWYgKG1haW5IZWFkZXIuY29tbWVudExlbmd0aCkge1xuICAgICAgICAgICAgX2NvbW1lbnQgPSBpbkJ1ZmZlci5zbGljZShjb21tZW50RW5kICsgVXRpbHMuQ29uc3RhbnRzLkVOREhEUik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWROb3cpIHJlYWRFbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEVudHJpZXMoKSB7XG4gICAgICAgIGlmIChlbnRyeUxpc3QubGVuZ3RoID4gMSAmJiAhbm9Tb3J0KSB7XG4gICAgICAgICAgICBlbnRyeUxpc3Quc29ydCgoYSwgYikgPT4gYS5lbnRyeU5hbWUudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKGIuZW50cnlOYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIFppcEVudHJ5IG9iamVjdHMgZXhpc3RlbnQgaW4gdGhlIGN1cnJlbnQgb3BlbmVkIGFyY2hpdmVcbiAgICAgICAgICogQHJldHVybiBBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGVudHJpZXMoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5TGlzdC5maWx0ZXIoKGUpID0+ICF0ZW1wb3JhcnkuaGFzKGUpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXJjaGl2ZSBjb21tZW50XG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjb21tZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKF9jb21tZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnQodmFsKSB7XG4gICAgICAgICAgICBfY29tbWVudCA9IFV0aWxzLnRvQnVmZmVyKHZhbCwgZGVjb2Rlci5lbmNvZGUpO1xuICAgICAgICAgICAgbWFpbkhlYWRlci5jb21tZW50TGVuZ3RoID0gX2NvbW1lbnQubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVudHJ5Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWluSGVhZGVyLmRpc2tFbnRyaWVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnlMaXN0Lmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciBudWxsIGlmIGVudHJ5IGlzIGluZXhpc3RlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVudHJ5TmFtZVxuICAgICAgICAgKiBAcmV0dXJuIFppcEVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKC8qU3RyaW5nKi8gZW50cnlOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5VGFibGVbZW50cnlOYW1lXSB8fCBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoZSBnaXZlbiBlbnRyeSB0byB0aGUgZW50cnkgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW50cnlcbiAgICAgICAgICovXG4gICAgICAgIHNldEVudHJ5OiBmdW5jdGlvbiAoLypaaXBFbnRyeSovIGVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnlMaXN0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgZW50cnlUYWJsZVtlbnRyeS5lbnRyeU5hbWVdID0gZW50cnk7XG4gICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IGVudHJ5TGlzdC5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGZpbGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBlbnRyeSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIHRoZW4gYWxsIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgd2lsbCBiZSByZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeU5hbWVcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVGaWxlOiBmdW5jdGlvbiAoLypTdHJpbmcqLyBlbnRyeU5hbWUsIHdpdGhzdWJmb2xkZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlUYWJsZVtlbnRyeU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0RW50cnlDaGlsZHJlbihlbnRyeSwgd2l0aHN1YmZvbGRlcnMpLm1hcCgoY2hpbGQpID0+IGNoaWxkLmVudHJ5TmFtZSk7XG5cbiAgICAgICAgICAgIGxpc3QuZm9yRWFjaCh0aGlzLmRlbGV0ZUVudHJ5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgZW50cnkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBmcm9tIHRoZSBlbnRyeSBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlOYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlUYWJsZVtlbnRyeU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBlbnRyeUxpc3QuaW5kZXhPZihlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGVudHJ5TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeVRhYmxlW2VudHJ5TmFtZV07XG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci50b3RhbEVudHJpZXMgPSBlbnRyeUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSXRlcmF0ZXMgYW5kIHJldHVybnMgYWxsIG5lc3RlZCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgb2YgdGhlIGdpdmVuIGVudHJ5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJuIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeUNoaWxkcmVuOiBmdW5jdGlvbiAoLypaaXBFbnRyeSovIGVudHJ5LCBzdWJmb2xkZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkgJiYgc3ViZm9sZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5lbnRyeU5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB6aXBFbnRyeSBvZiBlbnRyeUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6aXBFbnRyeS5lbnRyeU5hbWUuc3RhcnRzV2l0aChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh6aXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbnRyeV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgSG93IG1hbnkgY2hpbGQgZWxlbWVudHMgZW50cnkgaGFzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7WmlwRW50cnl9IGVudHJ5XG4gICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldEVudHJ5Q2hpbGRyZW4oZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0LmluY2x1ZGVzKGVudHJ5KSA/IGxpc3QubGVuZ3RoIC0gMSA6IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHppcCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyXG4gICAgICAgICAqL1xuICAgICAgICBjb21wcmVzc1RvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJCbG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgbGV0IGRpbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSA9IDA7XG4gICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgdG90YWxFbnRyaWVzID0gMDtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wcmVzcyBkYXRhIGFuZCBzZXQgbG9jYWwgYW5kIGVudHJ5IGhlYWRlciBhY2NvcmRpbmdseS4gUmVhc29uIHdoeSBpcyBjYWxsZWQgZmlyc3RcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkRGF0YSA9IGVudHJ5LmdldENvbXByZXNzZWREYXRhKCk7XG4gICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLm9mZnNldCA9IGRpbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBsb2NhbCBoZWFkZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEhlYWRlciA9IGVudHJ5LnBhY2tMb2NhbEhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gMi4gb2Zmc2V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBsb2NhbEhlYWRlci5sZW5ndGggKyBjb21wcmVzc2VkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGluZGV4ICs9IGRhdGFMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyAzLiBzdG9yZSB2YWx1ZXMgaW4gc2VxdWVuY2VcbiAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChsb2NhbEhlYWRlcik7XG4gICAgICAgICAgICAgICAgZGF0YUJsb2NrLnB1c2goY29tcHJlc3NlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8gNC4gY29uc3RydWN0IGNlbnRyYWwgaGVhZGVyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgaGVhZGVyQmxvY2tzLnB1c2goY2VudHJhbEhlYWRlcik7XG4gICAgICAgICAgICAgICAgLy8gNS4gdXBkYXRlIG1haW4gaGVhZGVyXG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci5zaXplICs9IGNlbnRyYWxIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgY2VudHJhbEhlYWRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdG90YWxFbnRyaWVzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBtYWluSGVhZGVyLm1haW5IZWFkZXJTaXplOyAvLyBhbHNvIGluY2x1ZGVzIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICAvLyBwb2ludCB0byBlbmQgb2YgZGF0YSBhbmQgYmVnaW5uaW5nIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGZpcnN0IHJlY29yZFxuICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSBkaW5kZXg7XG4gICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IHRvdGFsRW50cmllcztcblxuICAgICAgICAgICAgZGluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyh0b3RhbFNpemUpO1xuICAgICAgICAgICAgLy8gd3JpdGUgZGF0YSBibG9ja3NcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBkYXRhQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuICAgICAgICAgICAgICAgIGRpbmRleCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd3JpdGUgY2VudHJhbCBkaXJlY3RvcnkgZW50cmllc1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhlYWRlckJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7XG4gICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3cml0ZSBtYWluIGhlYWRlclxuICAgICAgICAgICAgY29uc3QgbWggPSBtYWluSGVhZGVyLnRvQmluYXJ5KCk7XG4gICAgICAgICAgICBpZiAoX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBfY29tbWVudC5jb3B5KG1oLCBVdGlscy5Db25zdGFudHMuRU5ESERSKTsgLy8gYWRkIHppcCBmaWxlIGNvbW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1oLmNvcHkob3V0QnVmZmVyLCBkaW5kZXgpO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSB1cGRhdGUgZW50cnkgYW5kIG1haW4gaGVhZGVyIG9mZnNldHMsXG4gICAgICAgICAgICAvLyB0aGV5IGFyZSBubyBsb25nZXIgdmFsaWQgYW5kIHdlIGhhdmUgdG8gcmVzZXQgY29udGVudFxuICAgICAgICAgICAgLy8gKElzc3VlIDY0KVxuXG4gICAgICAgICAgICBpbkJ1ZmZlciA9IG91dEJ1ZmZlcjtcbiAgICAgICAgICAgIGxvYWRlZEVudHJpZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dEJ1ZmZlcjtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0FzeW5jQnVmZmVyOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIG9uU3VjY2VzcywgLypGdW5jdGlvbiovIG9uRmFpbCwgLypGdW5jdGlvbiovIG9uSXRlbVN0YXJ0LCAvKkZ1bmN0aW9uKi8gb25JdGVtRW5kKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3J0RW50cmllcygpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudHJhbEhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgZGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxFbnRyaWVzID0gMDtcblxuICAgICAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci5vZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3MyQnVmZmVyID0gZnVuY3Rpb24gKGVudHJ5TGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5TGlzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyeUxpc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZW50cnkuZW50cnlOYW1lICsgZW50cnkuZXh0cmEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkl0ZW1TdGFydCkgb25JdGVtU3RhcnQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5nZXRDb21wcmVzc2VkRGF0YUFzeW5jKGZ1bmN0aW9uIChjb21wcmVzc2VkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkl0ZW1FbmQpIG9uSXRlbUVuZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5oZWFkZXIub2Zmc2V0ID0gZGluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gY29uc3RydWN0IGxvY2FsIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVyID0gZW50cnkucGFja0xvY2FsSGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBvZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGxvY2FsSGVhZGVyLmxlbmd0aCArIGNvbXByZXNzZWREYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gZGF0YUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIHN0b3JlIHZhbHVlcyBpbiBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGxvY2FsSGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2sucHVzaChjb21wcmVzc2VkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjZW50cmFsIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRhbEhlYWRlciA9IGVudHJ5LnBhY2tDZW50cmFsSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudHJhbEhlYWRlcnMucHVzaChjZW50YWxIZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSArPSBjZW50YWxIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgY2VudGFsSGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEVudHJpZXMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzMkJ1ZmZlcihlbnRyeUxpc3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxTaXplICs9IG1haW5IZWFkZXIubWFpbkhlYWRlclNpemU7IC8vIGFsc28gaW5jbHVkZXMgemlwIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IHRvIGVuZCBvZiBkYXRhIGFuZCBiZWdpbm5pbmcgb2YgY2VudHJhbCBkaXJlY3RvcnkgZmlyc3QgcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IGRpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIudG90YWxFbnRyaWVzID0gdG90YWxFbnRyaWVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2suZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50cmFsSGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudC5jb3B5KG91dEJ1ZmZlciwgZGluZGV4KTsgLy8gd3JpdGUgY2VudHJhbCBkaXJlY3RvcnkgZW50cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbmRleCArPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaCA9IG1haW5IZWFkZXIudG9CaW5hcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb21tZW50LmNvcHkobWgsIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIpOyAvLyBhZGQgemlwIGZpbGUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaC5jb3B5KG91dEJ1ZmZlciwgZGluZGV4KTsgLy8gd3JpdGUgbWFpbiBoZWFkZXJcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2UgdXBkYXRlIGVudHJ5IGFuZCBtYWluIGhlYWRlciBvZmZzZXRzLCB0aGV5IGFyZSBub1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHZhbGlkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IGNvbnRlbnQgdXNpbmcgb3VyIG5ldyBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChJc3N1ZSA2NClcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5CdWZmZXIgPSBvdXRCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWRFbnRyaWVzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhvdXRCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXByZXNzMkJ1ZmZlcihBcnJheS5mcm9tKHRoaXMuZW50cmllcykpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG9uRmFpbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/adm-zip/zipFile.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv-formats/dist/formats.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv-formats/dist/formats.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatNames = exports.fastFormats = exports.fullFormats = void 0;\nfunction fmtDef(validate, compare) {\n    return { validate, compare };\n}\nexports.fullFormats = {\n    // date: http://tools.ietf.org/html/rfc3339#section-5.6\n    date: fmtDef(date, compareDate),\n    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n    time: fmtDef(getTime(true), compareTime),\n    \"date-time\": fmtDef(getDateTime(true), compareDateTime),\n    \"iso-time\": fmtDef(getTime(), compareIsoTime),\n    \"iso-date-time\": fmtDef(getDateTime(), compareIsoDateTime),\n    // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n    duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n    uri,\n    \"uri-reference\": /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n    // uri-template: https://tools.ietf.org/html/rfc6570\n    \"uri-template\": /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n    // For the source: https://gist.github.com/dperini/729294\n    // For test cases: https://mathiasbynens.be/demo/url-regex\n    url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n    hostname: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n    regex,\n    // uuid: http://tools.ietf.org/html/rfc4122\n    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n    // JSON-pointer: https://tools.ietf.org/html/rfc6901\n    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n    \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n    \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n    \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n    // byte: https://github.com/miguelmota/is-base64\n    byte,\n    // signed 32 bit integer\n    int32: { type: \"number\", validate: validateInt32 },\n    // signed 64 bit integer\n    int64: { type: \"number\", validate: validateInt64 },\n    // C-type float\n    float: { type: \"number\", validate: validateNumber },\n    // C-type double\n    double: { type: \"number\", validate: validateNumber },\n    // hint to the UI to hide input strings\n    password: true,\n    // unchecked string payload\n    binary: true,\n};\nexports.fastFormats = {\n    ...exports.fullFormats,\n    date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n    time: fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareTime),\n    \"date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\dt(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareDateTime),\n    \"iso-time\": fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoTime),\n    \"iso-date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareIsoDateTime),\n    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n    uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n    \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n    // email (sources from jsen validator):\n    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n};\nexports.formatNames = Object.keys(exports.fullFormats);\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = DATE.exec(str);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction compareDate(d1, d2) {\n    if (!(d1 && d2))\n        return undefined;\n    if (d1 > d2)\n        return 1;\n    if (d1 < d2)\n        return -1;\n    return 0;\n}\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i;\nfunction getTime(strictTimeZone) {\n    return function time(str) {\n        const matches = TIME.exec(str);\n        if (!matches)\n            return false;\n        const hr = +matches[1];\n        const min = +matches[2];\n        const sec = +matches[3];\n        const tz = matches[4];\n        const tzSign = matches[5] === \"-\" ? -1 : 1;\n        const tzH = +(matches[6] || 0);\n        const tzM = +(matches[7] || 0);\n        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))\n            return false;\n        if (hr <= 23 && min <= 59 && sec < 60)\n            return true;\n        // leap second\n        const utcMin = min - tzM * tzSign;\n        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);\n        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;\n    };\n}\nfunction compareTime(s1, s2) {\n    if (!(s1 && s2))\n        return undefined;\n    const t1 = new Date(\"2020-01-01T\" + s1).valueOf();\n    const t2 = new Date(\"2020-01-01T\" + s2).valueOf();\n    if (!(t1 && t2))\n        return undefined;\n    return t1 - t2;\n}\nfunction compareIsoTime(t1, t2) {\n    if (!(t1 && t2))\n        return undefined;\n    const a1 = TIME.exec(t1);\n    const a2 = TIME.exec(t2);\n    if (!(a1 && a2))\n        return undefined;\n    t1 = a1[1] + a1[2] + a1[3];\n    t2 = a2[1] + a2[2] + a2[3];\n    if (t1 > t2)\n        return 1;\n    if (t1 < t2)\n        return -1;\n    return 0;\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction getDateTime(strictTimeZone) {\n    const time = getTime(strictTimeZone);\n    return function date_time(str) {\n        // http://tools.ietf.org/html/rfc3339#section-5.6\n        const dateTime = str.split(DATE_TIME_SEPARATOR);\n        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);\n    };\n}\nfunction compareDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const d1 = new Date(dt1).valueOf();\n    const d2 = new Date(dt2).valueOf();\n    if (!(d1 && d2))\n        return undefined;\n    return d1 - d2;\n}\nfunction compareIsoDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);\n    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);\n    const res = compareDate(d1, d2);\n    if (res === undefined)\n        return undefined;\n    return res || compareTime(t1, t2);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;\nfunction byte(str) {\n    BYTE.lastIndex = 0;\n    return BYTE.test(str);\n}\nconst MIN_INT32 = -(2 ** 31);\nconst MAX_INT32 = 2 ** 31 - 1;\nfunction validateInt32(value) {\n    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;\n}\nfunction validateInt64(value) {\n    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n    return Number.isInteger(value);\n}\nfunction validateNumber() {\n    return true;\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n//# sourceMappingURL=formats.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQjtBQUMvRDtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixjQUFjLEVBQUUsK0JBQStCLElBQUksR0FBRyxFQUFFLGVBQWUsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxpQkFBaUIsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGlCQUFpQixJQUFJLFVBQVUsSUFBSSx1Q0FBdUMsRUFBRSxnREFBZ0QsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLDJDQUEyQyw4Q0FBOEMsRUFBRSwwREFBMEQsYUFBYSxFQUFFLDJDQUEyQyxlQUFlLEVBQUUsb0NBQW9DLGVBQWUsRUFBRSxpQ0FBaUMsZUFBZSxFQUFFLGlDQUFpQyxlQUFlLEVBQUUsaUNBQWlDLGVBQWUsRUFBRSxxQ0FBcUMsaUJBQWlCLEVBQUUsa0NBQWtDLGlCQUFpQixFQUFFO0FBQ3RwQztBQUNBLGlEQUFpRCxFQUFFLFlBQVksRUFBRSxJQUFJLE1BQU0sZ0NBQWdDLEVBQUUsaUJBQWlCLElBQUksZ0NBQWdDLEVBQUUsaUJBQWlCLElBQUksU0FBUztBQUNsTTtBQUNBO0FBQ0Esd0VBQXdFLElBQUks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Z0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxhQUFhLElBQUksaUJBQWlCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxpQkFBaUIsSUFBSSxVQUFVLElBQUksdUNBQXVDLEVBQUUsZ0RBQWdELElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSxhQUFhLElBQUksZ0JBQWdCLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSSwyQ0FBMkMsOENBQThDLEVBQUUseURBQXlELGFBQWEsRUFBRSwwQ0FBMEMsZUFBZSxFQUFFLG1DQUFtQyxlQUFlLEVBQUUsZ0NBQWdDLGVBQWUsRUFBRSxnQ0FBZ0MsZUFBZSxFQUFFLGdDQUFnQyxlQUFlLEVBQUUsbUNBQW1DLGlCQUFpQixFQUFFLGlDQUFpQyxpQkFBaUIsRUFBRTtBQUNub0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzP2M1YmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICAgIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICAgIHJlZ2V4LFxuICAgIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gICAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gICAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAgIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICAgIGJ5dGUsXG4gICAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gICAgaW50MzI6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzIgfSxcbiAgICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgICBpbnQ2NDogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NCB9LFxuICAgIC8vIEMtdHlwZSBmbG9hdFxuICAgIGZsb2F0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIC8vIEMtdHlwZSBkb3VibGVcbiAgICBkb3VibGU6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gICAgYmluYXJ5OiB0cnVlLFxufTtcbmV4cG9ydHMuZmFzdEZvcm1hdHMgPSB7XG4gICAgLi4uZXhwb3J0cy5mdWxsRm9ybWF0cyxcbiAgICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICAgIHRpbWU6IGZtdERlZigvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLCBjb21wYXJlRGF0ZVRpbWUpLFxuICAgIFwiaXNvLXRpbWVcIjogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlSXNvVGltZSksXG4gICAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gICAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAgIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn07XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5mdWxsRm9ybWF0cyk7XG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5mdW5jdGlvbiBkYXRlKHN0cikge1xuICAgIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBtYXRjaGVzID0gREFURS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxLCBkMikge1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoZDEgPiBkMilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGQxIDwgZDIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn1cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaTtcbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFRJTUUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyID0gK21hdGNoZXNbMV07XG4gICAgICAgIGNvbnN0IG1pbiA9ICttYXRjaGVzWzJdO1xuICAgICAgICBjb25zdCBzZWMgPSArbWF0Y2hlc1szXTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaGVzWzRdO1xuICAgICAgICBjb25zdCB0elNpZ24gPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdHpIID0gKyhtYXRjaGVzWzZdIHx8IDApO1xuICAgICAgICBjb25zdCB0ek0gPSArKG1hdGNoZXNbN10gfHwgMCk7XG4gICAgICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBsZWFwIHNlY29uZFxuICAgICAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ247XG4gICAgICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczEsIHMyKSB7XG4gICAgaWYgKCEoczEgJiYgczIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKCk7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0MSAtIHQyO1xufVxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmUpIHtcbiAgICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgICAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpO1xuICAgIGlmICghKGQxICYmIGQyKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZDEgLSBkMjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDEsIGR0Mikge1xuICAgIGlmICghKGR0MSAmJiBkdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMik7XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICAgIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtO1xuZnVuY3Rpb24gYnl0ZShzdHIpIHtcbiAgICBCWVRFLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIEJZVEUudGVzdChzdHIpO1xufVxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKTtcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxO1xuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZSkge1xuICAgIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovO1xuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gICAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv-formats/dist/formats.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv-formats/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/ajv-formats/dist/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst formats_1 = __webpack_require__(/*! ./formats */ \"./node_modules/ajv-formats/dist/formats.js\");\nconst limit_1 = __webpack_require__(/*! ./limit */ \"./node_modules/ajv-formats/dist/limit.js\");\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst fullName = new codegen_1.Name(\"fullFormats\");\nconst fastName = new codegen_1.Name(\"fastFormats\");\nconst formatsPlugin = (ajv, opts = { keywords: true }) => {\n    if (Array.isArray(opts)) {\n        addFormats(ajv, opts, formats_1.fullFormats, fullName);\n        return ajv;\n    }\n    const [formats, exportName] = opts.mode === \"fast\" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];\n    const list = opts.formats || formats_1.formatNames;\n    addFormats(ajv, list, formats, exportName);\n    if (opts.keywords)\n        (0, limit_1.default)(ajv);\n    return ajv;\n};\nformatsPlugin.get = (name, mode = \"full\") => {\n    const formats = mode === \"fast\" ? formats_1.fastFormats : formats_1.fullFormats;\n    const f = formats[name];\n    if (!f)\n        throw new Error(`Unknown format \"${name}\"`);\n    return f;\n};\nfunction addFormats(ajv, list, fs, exportName) {\n    var _a;\n    var _b;\n    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require(\"ajv-formats/dist/formats\").${exportName}`);\n    for (const f of list)\n        ajv.addFormat(f, fs[f]);\n}\nmodule.exports = exports = formatsPlugin;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = formatsPlugin;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw2REFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDcEQ7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSSxXQUFXO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2luZGV4LmpzPzk4MGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRzXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuY29uc3QgbGltaXRfMSA9IHJlcXVpcmUoXCIuL2xpbWl0XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGZ1bGxOYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZnVsbEZvcm1hdHNcIik7XG5jb25zdCBmYXN0TmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZhc3RGb3JtYXRzXCIpO1xuY29uc3QgZm9ybWF0c1BsdWdpbiA9IChhanYsIG9wdHMgPSB7IGtleXdvcmRzOiB0cnVlIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZSk7XG4gICAgICAgIHJldHVybiBhanY7XG4gICAgfVxuICAgIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9IG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZm9ybWF0c18xLmZhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZV07XG4gICAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXRzXzEuZm9ybWF0TmFtZXM7XG4gICAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICAoMCwgbGltaXRfMS5kZWZhdWx0KShhanYpO1xuICAgIHJldHVybiBhanY7XG59O1xuZm9ybWF0c1BsdWdpbi5nZXQgPSAobmFtZSwgbW9kZSA9IFwiZnVsbFwiKSA9PiB7XG4gICAgY29uc3QgZm9ybWF0cyA9IG1vZGUgPT09IFwiZmFzdFwiID8gZm9ybWF0c18xLmZhc3RGb3JtYXRzIDogZm9ybWF0c18xLmZ1bGxGb3JtYXRzO1xuICAgIGNvbnN0IGYgPSBmb3JtYXRzW25hbWVdO1xuICAgIGlmICghZilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZvcm1hdCBcIiR7bmFtZX1cImApO1xuICAgIHJldHVybiBmO1xufTtcbmZ1bmN0aW9uIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmcywgZXhwb3J0TmFtZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2I7XG4gICAgKF9hID0gKF9iID0gYWp2Lm9wdHMuY29kZSkuZm9ybWF0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iLmZvcm1hdHMgPSAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbGlzdClcbiAgICAgICAgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv-formats/dist/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv-formats/dist/limit.js":
/*!************************************************!*\
  !*** ./node_modules/ajv-formats/dist/limit.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = __webpack_require__(/*! ajv */ \"./node_modules/ajv/dist/ajv.js\");\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != \"object\"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports[\"default\"] = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9saW1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLDJDQUFLO0FBQzNCLGtCQUFrQixtQkFBTyxDQUFDLGtGQUEwQjtBQUNwRDtBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RCxxQkFBcUIsd0NBQXdDO0FBQzdELDhCQUE4Qix1Q0FBdUM7QUFDckUsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQixxQ0FBcUMscUJBQXFCLEVBQUUsV0FBVztBQUM1RyxlQUFlLHFCQUFxQix3QkFBd0IsY0FBYyxvQkFBb0IsV0FBVyxZQUFZO0FBQ3JIO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2REFBNkQsS0FBSyxHQUFHLGdCQUFnQjtBQUNyRix1RUFBdUUsS0FBSyxrQ0FBa0MsS0FBSywrQ0FBK0MsSUFBSTtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUSxhQUFhLE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCLEVBQUUsbUNBQW1DO0FBQ3JILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxXQUFXLEtBQUssSUFBSSxXQUFXLElBQUksb0JBQW9CO0FBQ2xHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9kaXN0L2xpbWl0LmpzPzUzNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYHNob3VsZCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHtcbiAgICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZDeHQgPSBuZXcgYWp2XzEuS2V5d29yZEN4dChpdCwgc2VsZi5SVUxFUy5hbGwuZm9ybWF0LmRlZmluaXRpb24sIFwiZm9ybWF0XCIpO1xuICAgICAgICBpZiAoZkN4dC4kZGF0YSlcbiAgICAgICAgICAgIHZhbGlkYXRlJERhdGFGb3JtYXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsaWRhdGVGb3JtYXQoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uY29uc3QoXCJmbXRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEub3IpKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2ZtdH0gIT0gXCJvYmplY3RcImAsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2ZtdH0uY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJgLCBjb21wYXJlQ29kZShmbXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmQ3h0LnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGZtdERlZiA9IHNlbGYuZm9ybWF0c1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKCFmbXREZWYgfHwgZm10RGVmID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm10RGVmICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZm10RGVmLmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5d29yZH1cIjogZm9ybWF0IFwiJHtmb3JtYXR9XCIgZG9lcyBub3QgZGVmaW5lIFwiY29tcGFyZVwiIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICAgICAgICAgIGtleTogZm9ybWF0LFxuICAgICAgICAgICAgICAgIHJlZjogZm10RGVmLFxuICAgICAgICAgICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtvcHRzLmNvZGUuZm9ybWF0c30keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdH0uY29tcGFyZSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KSAke0tXRHNba2V5d29yZF0uZmFpbH0gMGA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1wiZm9ybWF0XCJdLFxufTtcbmNvbnN0IGZvcm1hdExpbWl0UGx1Z2luID0gKGFqdikgPT4ge1xuICAgIGFqdi5hZGRLZXl3b3JkKGV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uKTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdExpbWl0UGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv-formats/dist/limit.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/2020.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/dist/2020.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv2020 = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"./node_modules/ajv/dist/core.js\");\nconst draft2020_1 = __webpack_require__(/*! ./vocabularies/draft2020 */ \"./node_modules/ajv/dist/vocabularies/draft2020.js\");\nconst discriminator_1 = __webpack_require__(/*! ./vocabularies/discriminator */ \"./node_modules/ajv/dist/vocabularies/discriminator/index.js\");\nconst json_schema_2020_12_1 = __webpack_require__(/*! ./refs/json-schema-2020-12 */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/index.js\");\nconst META_SCHEMA_ID = \"https://json-schema.org/draft/2020-12/schema\";\nclass Ajv2020 extends core_1.default {\n    constructor(opts = {}) {\n        super({\n            ...opts,\n            dynamicRef: true,\n            next: true,\n            unevaluated: true,\n        });\n    }\n    _addVocabularies() {\n        super._addVocabularies();\n        draft2020_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        const { $data, meta } = this.opts;\n        if (!meta)\n            return;\n        json_schema_2020_12_1.default.call(this, $data);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv2020 = Ajv2020;\nmodule.exports = exports = Ajv2020;\nmodule.exports.Ajv2020 = Ajv2020;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = Ajv2020;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"./node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nvar validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"./node_modules/ajv/dist/runtime/validation_error.js\");\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return validation_error_1.default; } }));\nvar ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"./node_modules/ajv/dist/compile/ref_error.js\");\nObject.defineProperty(exports, \"MissingRefError\", ({ enumerable: true, get: function () { return ref_error_1.default; } }));\n//# sourceMappingURL=2020.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvMjAyMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLFdBQVcsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsU0FBUyxHQUFHLGtCQUFrQixHQUFHLGVBQWU7QUFDckwsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLG1GQUEwQjtBQUN0RCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBOEI7QUFDOUQsOEJBQThCLG1CQUFPLENBQUMsNkZBQTRCO0FBQ2xFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLHNCQUFzQjtBQUN0Qiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDN0MsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILGdCQUFnQixtQkFBTyxDQUFDLDJFQUFtQjtBQUMzQyxxQ0FBb0MsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDbkcsdUNBQXNDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3ZHLDZDQUE0QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNuSCx1Q0FBc0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDdkcsd0NBQXVDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQ3pHLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRyx5QkFBeUIsbUJBQU8sQ0FBQyx1RkFBNEI7QUFDN0QsbURBQWtELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2hJLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFxQjtBQUMvQyxtREFBa0QsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDekgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC8yMDIwLmpzPzc3ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pc3NpbmdSZWZFcnJvciA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy5BanYyMDIwID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0MjAyMF8xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0MjAyMFwiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QganNvbl9zY2hlbWFfMjAyMF8xMl8xID0gcmVxdWlyZShcIi4vcmVmcy9qc29uLXNjaGVtYS0yMDIwLTEyXCIpO1xuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCI7XG5jbGFzcyBBanYyMDIwIGV4dGVuZHMgY29yZV8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgZHluYW1pY1JlZjogdHJ1ZSxcbiAgICAgICAgICAgIG5leHQ6IHRydWUsXG4gICAgICAgICAgICB1bmV2YWx1YXRlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRWb2NhYnVsYXJpZXMoKSB7XG4gICAgICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgZHJhZnQyMDIwXzEuZGVmYXVsdC5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcl8xLmRlZmF1bHQpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpO1xuICAgICAgICBjb25zdCB7ICRkYXRhLCBtZXRhIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmICghbWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAganNvbl9zY2hlbWFfMjAyMF8xMl8xLmRlZmF1bHQuY2FsbCh0aGlzLCAkZGF0YSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2MjAyMCA9IEFqdjIwMjA7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBBanYyMDIwO1xubW9kdWxlLmV4cG9ydHMuQWp2MjAyMCA9IEFqdjIwMjA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBanYyMDIwO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD0yMDIwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/2020.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/ajv.js":
/*!**************************************!*\
  !*** ./node_modules/ajv/dist/ajv.js ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"./node_modules/ajv/dist/core.js\");\nconst draft7_1 = __webpack_require__(/*! ./vocabularies/draft7 */ \"./node_modules/ajv/dist/vocabularies/draft7.js\");\nconst discriminator_1 = __webpack_require__(/*! ./vocabularies/discriminator */ \"./node_modules/ajv/dist/vocabularies/discriminator/index.js\");\nconst draft7MetaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"./node_modules/ajv/dist/refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = Ajv;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"./node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nvar validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"./node_modules/ajv/dist/runtime/validation_error.js\");\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return validation_error_1.default; } }));\nvar ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"./node_modules/ajv/dist/compile/ref_error.js\");\nObject.defineProperty(exports, \"MissingRefError\", ({ enumerable: true, get: function () { return ref_error_1.default; } }));\n//# sourceMappingURL=ajv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvYWp2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLGlCQUFpQixHQUFHLFdBQVcsR0FBRyxTQUFTLEdBQUcsa0JBQWtCLEdBQUcsV0FBVztBQUNqTCxlQUFlLG1CQUFPLENBQUMsK0NBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNkVBQXVCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLGlHQUE4QjtBQUM5RCx5QkFBeUIsbUJBQU8sQ0FBQyxnR0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0JBQWtCO0FBQ2xCLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBZTtBQUNmLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFvQjtBQUM3Qyw4Q0FBNkMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdEgsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzNDLHFDQUFvQyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUNuRyx1Q0FBc0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDdkcsNkNBQTRDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ25ILHVDQUFzQyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN2Ryx3Q0FBdUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDekcsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLHlCQUF5QixtQkFBTyxDQUFDLHVGQUE0QjtBQUM3RCxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksa0JBQWtCLG1CQUFPLENBQUMseUVBQXFCO0FBQy9DLG1EQUFrRCxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUN6SCIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2Fqdi5qcz9lNTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaXNzaW5nUmVmRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMuQWp2ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWp2ID0gQWp2O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2O1xubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWp2O1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbnZhciB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWxpZGF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUmVmRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZl9lcnJvcl8xLmRlZmF1bHQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/ajv.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/code.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/dist/compile/codegen/code.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2NvZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLFNBQVMsR0FBRyxXQUFXLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDMVE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csRUFBRSxFQUFFLEVBQUU7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLEVBQUUsRUFBRTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsRUFBRSxXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxHQUFHLEVBQUUsR0FBRztBQUNwRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtGQUFrRixJQUFJLFdBQVcsSUFBSTtBQUNyRztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBLHFEQUFxRCxJQUFJO0FBQ3pEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzPzg0OWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xuY2xhc3MgX0NvZGVPck5hbWUge1xufVxuZXhwb3J0cy5fQ29kZU9yTmFtZSA9IF9Db2RlT3JOYW1lO1xuZXhwb3J0cy5JREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5jbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCFleHBvcnRzLklERU5USUZJRVIudGVzdChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIik7XG4gICAgICAgIHRoaXMuc3RyID0gcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cjtcbiAgICB9XG4gICAgZW1wdHlTdHIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4geyBbdGhpcy5zdHJdOiAxIH07XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lID0gTmFtZTtcbmNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIic7XG4gICAgfVxuICAgIGdldCBzdHIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9zdHIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9zdHIgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHMsIGMpID0+IGAke3N9JHtjfWAsIFwiXCIpKSk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX25hbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fbmFtZXMgPSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzLCBjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgICAgIH0sIHt9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuX0NvZGUgPSBfQ29kZTtcbmV4cG9ydHMubmlsID0gbmV3IF9Db2RlKFwiXCIpO1xuZnVuY3Rpb24gXyhzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgY29kZSA9IFtzdHJzWzBdXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pO1xuICAgICAgICBjb2RlLnB1c2goc3Ryc1srK2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKTtcbn1cbmV4cG9ydHMuXyA9IF87XG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKTtcbmZ1bmN0aW9uIHN0cihzdHJzLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZXhwciA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICBleHByLnB1c2gocGx1cyk7XG4gICAgICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSk7XG4gICAgICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShleHByKTtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpO1xufVxuZXhwb3J0cy5zdHIgPSBzdHI7XG5mdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGUsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSlcbiAgICAgICAgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpO1xuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpXG4gICAgICAgIGNvZGUucHVzaChhcmcpO1xuICAgIGVsc2VcbiAgICAgICAgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpO1xufVxuZXhwb3J0cy5hZGRDb2RlQXJnID0gYWRkQ29kZUFyZztcbmZ1bmN0aW9uIG9wdGltaXplKGV4cHIpIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJbaSsrXSA9IFwiK1wiO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhLCBiKSB7XG4gICAgaWYgKGIgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKGEgPT09ICdcIlwiJylcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYDtcbiAgICAgICAgaWYgKGJbMF0gPT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpXG4gICAgICAgIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gc3RyQ29uY2F0KGMxLCBjMikge1xuICAgIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHIgYCR7YzF9JHtjMn1gO1xufVxuZXhwb3J0cy5zdHJDb25jYXQgPSBzdHJDb25jYXQ7XG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICAgICAgPyB4XG4gICAgICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIik7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5O1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBleHBvcnRzLklERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfIGBbJHtrZXl9XWA7XG59XG5leHBvcnRzLmdldFByb3BlcnR5ID0gZ2V0UHJvcGVydHk7XG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5mdW5jdGlvbiBnZXRFc21FeHBvcnROYW1lKGtleSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2RlKGAke2tleX1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYCk7XG59XG5leHBvcnRzLmdldEVzbUV4cG9ydE5hbWUgPSBnZXRFc21FeHBvcnROYW1lO1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/codegen/code.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/dist/compile/codegen/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"./node_modules/ajv/dist/compile/codegen/code.js\");\nconst scope_1 = __webpack_require__(/*! ./scope */ \"./node_modules/ajv/dist/compile/codegen/scope.js\");\nvar code_2 = __webpack_require__(/*! ./code */ \"./node_modules/ajv/dist/compile/codegen/code.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return code_2._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return code_2.str; } }));\nObject.defineProperty(exports, \"strConcat\", ({ enumerable: true, get: function () { return code_2.strConcat; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return code_2.nil; } }));\nObject.defineProperty(exports, \"getProperty\", ({ enumerable: true, get: function () { return code_2.getProperty; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return code_2.stringify; } }));\nObject.defineProperty(exports, \"regexpCode\", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return code_2.Name; } }));\nvar scope_2 = __webpack_require__(/*! ./scope */ \"./node_modules/ajv/dist/compile/codegen/scope.js\");\nObject.defineProperty(exports, \"Scope\", ({ enumerable: true, get: function () { return scope_2.Scope; } }));\nObject.defineProperty(exports, \"ValueScope\", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));\nObject.defineProperty(exports, \"ValueScopeName\", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));\nObject.defineProperty(exports, \"varKinds\", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVUsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLFdBQVcsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsU0FBUztBQUN2UyxlQUFlLG1CQUFPLENBQUMsK0RBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLCtEQUFRO0FBQzdCLHFDQUFvQyxFQUFFLHFDQUFxQyxvQkFBb0IsRUFBQztBQUNoRyx1Q0FBc0MsRUFBRSxxQ0FBcUMsc0JBQXNCLEVBQUM7QUFDcEcsNkNBQTRDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2hILHVDQUFzQyxFQUFFLHFDQUFxQyxzQkFBc0IsRUFBQztBQUNwRywrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2hILDhDQUE2QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNsSCx3Q0FBdUMsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdEcsY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9CLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6Ryw4Q0FBNkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbkgsa0RBQWlELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzNILDRDQUEyQyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUMvRyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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UUFBUSxHQUFHLFFBQVEsWUFBWTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csT0FBTztBQUN2RztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxRkFBcUYsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPO0FBQzVHO0FBQ0E7QUFDQSw0REFBNEQsRUFBRTtBQUM5RDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL2luZGV4LmpzP2IxNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9yID0gZXhwb3J0cy5hbmQgPSBleHBvcnRzLm5vdCA9IGV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMub3BlcmF0b3JzID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlZhbHVlU2NvcGUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5yZWdleHBDb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gdm9pZCAwO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbmNvbnN0IHNjb3BlXzEgPSByZXF1aXJlKFwiLi9zY29wZVwiKTtcbnZhciBjb2RlXzIgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLl87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJDb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5zdHJDb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuaWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5uaWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLmdldFByb3BlcnR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnZXhwQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnJlZ2V4cENvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuTmFtZTsgfSB9KTtcbnZhciBzY29wZV8yID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5TY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuVmFsdWVTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhbHVlU2NvcGVOYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGVOYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFyS2luZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIudmFyS2luZHM7IH0gfSk7XG5leHBvcnRzLm9wZXJhdG9ycyA9IHtcbiAgICBHVDogbmV3IGNvZGVfMS5fQ29kZShcIj5cIiksXG4gICAgR1RFOiBuZXcgY29kZV8xLl9Db2RlKFwiPj1cIiksXG4gICAgTFQ6IG5ldyBjb2RlXzEuX0NvZGUoXCI8XCIpLFxuICAgIExURTogbmV3IGNvZGVfMS5fQ29kZShcIjw9XCIpLFxuICAgIEVROiBuZXcgY29kZV8xLl9Db2RlKFwiPT09XCIpLFxuICAgIE5FUTogbmV3IGNvZGVfMS5fQ29kZShcIiE9PVwiKSxcbiAgICBOT1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCIhXCIpLFxuICAgIE9SOiBuZXcgY29kZV8xLl9Db2RlKFwifHxcIiksXG4gICAgQU5EOiBuZXcgY29kZV8xLl9Db2RlKFwiJiZcIiksXG4gICAgQUREOiBuZXcgY29kZV8xLl9Db2RlKFwiK1wiKSxcbn07XG5jbGFzcyBOb2RlIHtcbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhfbmFtZXMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IodmFyS2luZCwgbmFtZSwgcmhzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgIH1cbiAgICByZW5kZXIoeyBlczUsIF9uIH0pIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWA7XG4gICAgICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucmhzKVxuICAgICAgICAgICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMuc2lkZUVmZmVjdHMgPSBzaWRlRWZmZWN0cztcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8ge30gOiB7IC4uLnRoaXMubGhzLm5hbWVzIH07XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobGhzLCBvcCwgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsYWJlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX247XG4gICAgfVxufVxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfbjtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lcztcbiAgICB9XG59XG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge307XG4gICAgfVxufVxuY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGVzID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIik7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pO1xuICAgICAgICAgICAgZWxzZSBpZiAobilcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKTtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSk7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fbjtcbiAgICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7XG59XG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbn1cbkVsc2Uua2luZCA9IFwiZWxzZVwiO1xuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmRpdGlvbiwgbm9kZXMpIHtcbiAgICAgICAgc3VwZXIobm9kZXMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uO1xuICAgICAgICBpZiAoY29uZCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzOyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgICAgICBsZXQgZSA9IHRoaXMuZWxzZTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiBucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxzZSA9IChfYSA9IHRoaXMuZWxzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzO1xuICAgICAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuZWxzZSlcbiAgICAgICAgICAgIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpO1xuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxufVxuSWYua2luZCA9IFwiaWZcIjtcbmNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5Gb3Iua2luZCA9IFwiZm9yXCI7XG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSBpdGVyYXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmQ7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZnJvbSwgdG8gfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKTtcbiAgICAgICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IobG9vcCwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgdGhpcy52YXJLaW5kID0gdmFyS2luZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcyk7XG4gICAgfVxufVxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgYXN5bmMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hc3luYyA9IGFzeW5jO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZ1bmMua2luZCA9IFwiZnVuY1wiO1xuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cblJldHVybi5raW5kID0gXCJyZXR1cm5cIjtcbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5jYXRjaClcbiAgICAgICAgICAgIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYSA9IHRoaXMuY2F0Y2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9iID0gdGhpcy5maW5hbGx5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsbHkpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkNhdGNoLmtpbmQgPSBcImNhdGNoXCI7XG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxufVxuRmluYWxseS5raW5kID0gXCJmaW5hbGx5XCI7XG5jbGFzcyBDb2RlR2VuIHtcbiAgICBjb25zdHJ1Y3RvcihleHRTY29wZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwiIH07XG4gICAgICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGU7XG4gICAgICAgIHRoaXMuX3Njb3BlID0gbmV3IHNjb3BlXzEuU2NvcGUoeyBwYXJlbnQ6IGV4dFNjb3BlIH0pO1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICAgIHNjb3BlTmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KTtcbiAgICB9XG4gICAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gICAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKTtcbiAgICAgICAgdnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0U2NvcGVWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAgIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICAgIHNjb3BlUmVmcyhzY29wZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuICAgIHNjb3BlQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBfZGVmKHZhcktpbmQsIG5hbWVPclByZWZpeCwgcmhzLCBjb25zdGFudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudClcbiAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHM7XG4gICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgICBjb25zdChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgbGV0KG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZihzY29wZV8xLnZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCk7XG4gICAgfVxuICAgIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICAgIHZhcihuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgICBhc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpO1xuICAgIH1cbiAgICAvLyBgKz1gIGNvZGVcbiAgICBhZGQobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIGV4cG9ydHMub3BlcmF0b3JzLkFERCwgcmhzKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgICBjb2RlKGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGMoKTtcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gY29kZV8xLm5pbClcbiAgICAgICAgICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgICBvYmplY3QoLi4ua2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBbXCJ7XCJdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiLFwiKTtcbiAgICAgICAgICAgIGNvZGUucHVzaChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIjpcIik7XG4gICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5hZGRDb2RlQXJnKShjb2RlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29kZS5wdXNoKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoY29kZSk7XG4gICAgfVxuICAgIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgICBpZihjb25kaXRpb24sIHRoZW5Cb2R5LCBlbHNlQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpO1xuICAgICAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiBib2R5IHdpdGhvdXQgXCJ0aGVuXCIgYm9keScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZWxzZSBpZmAgY2xhdXNlIC0gaW52YWxpZCB3aXRob3V0IGBpZmAgb3IgYWZ0ZXIgYGVsc2VgIGNsYXVzZXNcbiAgICBlbHNlSWYoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgfVxuICAgIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgICBlbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICAgIGVuZElmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKTtcbiAgICB9XG4gICAgX2Zvcihub2RlLCBmb3JCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgaWYgKGZvckJvZHkpXG4gICAgICAgICAgICB0aGlzLmNvZGUoZm9yQm9keSkuZW5kRm9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgICBmb3IoaXRlcmF0aW9uLCBmb3JCb2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckxvb3AoaXRlcmF0aW9uKSwgZm9yQm9keSk7XG4gICAgfVxuICAgIC8vIGBmb3JgIHN0YXRlbWVudCBmb3IgYSByYW5nZSBvZiB2YWx1ZXNcbiAgICBmb3JSYW5nZShuYW1lT3JQcmVmaXgsIGZyb20sIHRvLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5sZXQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgICBmb3JPZihuYW1lT3JQcmVmaXgsIGl0ZXJhYmxlLCBmb3JCb2R5LCB2YXJLaW5kID0gc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yUmFuZ2UoXCJfaVwiLCAwLCAoMCwgY29kZV8xLl8pIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCAoMCwgY29kZV8xLl8pIGAke2Fycn1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBmb3JCb2R5KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gICAgZm9ySW4obmFtZU9yUHJlZml4LCBvYmosIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCAoMCwgY29kZV8xLl8pIGBPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwiaW5cIiwgdmFyS2luZCwgbmFtZSwgb2JqKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGVuZCBgZm9yYCBsb29wXG4gICAgZW5kRm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZvcik7XG4gICAgfVxuICAgIC8vIGBsYWJlbGAgc3RhdGVtZW50XG4gICAgbGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBMYWJlbChsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgYnJlYWtgIHN0YXRlbWVudFxuICAgIGJyZWFrKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKTtcbiAgICB9XG4gICAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInJldHVyblwiIHNob3VsZCBoYXZlIG9uZSBub2RlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKTtcbiAgICB9XG4gICAgLy8gYHRyeWAgc3RhdGVtZW50XG4gICAgdHJ5KHRyeUJvZHksIGNhdGNoQ29kZSwgZmluYWxseUNvZGUpIHtcbiAgICAgICAgaWYgKCFjYXRjaENvZGUgJiYgIWZpbmFsbHlDb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRyeSgpO1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuY29kZSh0cnlCb2R5KTtcbiAgICAgICAgaWYgKGNhdGNoQ29kZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLm5hbWUoXCJlXCIpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIGNhdGNoQ29kZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvZGUoZmluYWxseUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoQ2F0Y2gsIEZpbmFsbHkpO1xuICAgIH1cbiAgICAvLyBgdGhyb3dgIHN0YXRlbWVudFxuICAgIHRocm93KGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgVGhyb3coZXJyb3IpKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBibG9jayhib2R5LCBub2RlQ291bnQpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIHRoZSBjdXJyZW50IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gICAgZW5kQmxvY2sobm9kZUNvdW50KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2Jsb2NrU3RhcnRzLnBvcCgpO1xuICAgICAgICBpZiAobGVuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBub3QgaW4gc2VsZi1iYWxhbmNpbmcgYmxvY2tcIik7XG4gICAgICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW47XG4gICAgICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gYGZ1bmN0aW9uYCBoZWFkaW5nIChvciBkZWZpbml0aW9uIGlmIGZ1bmNCb2R5IGlzIHBhc3NlZClcbiAgICBmdW5jKG5hbWUsIGFyZ3MgPSBjb2RlXzEubmlsLCBhc3luYywgZnVuY0JvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSk7XG4gICAgICAgIGlmIChmdW5jQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZW5kIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICBlbmRGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZ1bmMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZShuID0gMSkge1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbGVhZk5vZGUobm9kZSkge1xuICAgICAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2Jsb2NrTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIF9lbmRCbG9ja05vZGUoTjEsIE4yKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBOMSB8fCAoTjIgJiYgbiBpbnN0YW5jZW9mIE4yKSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKTtcbiAgICB9XG4gICAgX2Vsc2VOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAoIShuIGluc3RhbmNlb2YgSWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIHdpdGhvdXQgXCJpZlwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3Vyck5vZGUgPSBuLmVsc2UgPSBub2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF07XG4gICAgfVxuICAgIGdldCBfY3Vyck5vZGUoKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IF9jdXJyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXM7XG4gICAgICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVHZW4gPSBDb2RlR2VuO1xuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IG4gaW4gZnJvbSlcbiAgICAgICAgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgKyAoZnJvbVtuXSB8fCAwKTtcbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXMsIGZyb20pIHtcbiAgICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IGFkZE5hbWVzKG5hbWVzLCBmcm9tLm5hbWVzKSA6IG5hbWVzO1xufVxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHIsIG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcik7XG4gICAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSlcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgcmV0dXJuIG5ldyBjb2RlXzEuX0NvZGUoZXhwci5faXRlbXMucmVkdWNlKChpdGVtcywgYykgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lKVxuICAgICAgICAgICAgYyA9IHJlcGxhY2VOYW1lKGMpO1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSlcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwgW10pKTtcbiAgICBmdW5jdGlvbiByZXBsYWNlTmFtZShuKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdO1xuICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzW24uc3RyXSAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBkZWxldGUgbmFtZXNbbi5zdHJdO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZSkge1xuICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBjb2RlXzEuX0NvZGUgJiZcbiAgICAgICAgICAgIGUuX2l0ZW1zLnNvbWUoKGMpID0+IGMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3VidHJhY3ROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApO1xufVxuZnVuY3Rpb24gbm90KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB4ID09PSBudWxsID8gIXggOiAoMCwgY29kZV8xLl8pIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6ICgwLCBjb2RlXzEuXykgYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKTtcbn1cbmZ1bmN0aW9uIHBhcih4KSB7XG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHggOiAoMCwgY29kZV8xLl8pIGAoJHt4fSlgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/codegen/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/codegen/scope.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/dist/compile/codegen/scope.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"./node_modules/ajv/dist/compile/codegen/code.js\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuL3Njb3BlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLGFBQWEsR0FBRyxnQkFBZ0IsR0FBRyxzQkFBc0I7QUFDdkcsZUFBZSxtQkFBTyxDQUFDLCtEQUFRO0FBQy9CO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU8sRUFBRSxXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQSwyQ0FBMkMsMEJBQTBCLEdBQUcsVUFBVTtBQUNsRjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQsb0NBQW9DLFVBQVUsRUFBRSxlQUFlO0FBQy9ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxJQUFJLEdBQUcsRUFBRSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSyxFQUFFLEVBQUUsRUFBRSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vc2NvcGUuanM/NTZlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlIHx8IChleHBvcnRzLlVzZWRWYWx1ZVN0YXRlID0gVXNlZFZhbHVlU3RhdGUgPSB7fSkpO1xuZXhwb3J0cy52YXJLaW5kcyA9IHtcbiAgICBjb25zdDogbmV3IGNvZGVfMS5OYW1lKFwiY29uc3RcIiksXG4gICAgbGV0OiBuZXcgY29kZV8xLk5hbWUoXCJsZXRcIiksXG4gICAgdmFyOiBuZXcgY29kZV8xLk5hbWUoXCJ2YXJcIiksXG59O1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4ZXMsIHBhcmVudCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5fbmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJlZml4ZXMgPSBwcmVmaXhlcztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICB0b05hbWUobmFtZU9yUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuYW1lT3JQcmVmaXggaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5OYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIF9uZXdOYW1lKHByZWZpeCkge1xuICAgICAgICBjb25zdCBuZyA9IHRoaXMuX25hbWVzW3ByZWZpeF0gfHwgdGhpcy5fbmFtZUdyb3VwKHByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuZy5pbmRleCsrfWA7XG4gICAgfVxuICAgIF9uYW1lR3JvdXAocHJlZml4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5fcGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3ByZWZpeGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzKHByZWZpeCkpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7IHByZWZpeCwgaW5kZXg6IDAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TY29wZSA9IFNjb3BlO1xuY2xhc3MgVmFsdWVTY29wZU5hbWUgZXh0ZW5kcyBjb2RlXzEuTmFtZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4LCBuYW1lU3RyKSB7XG4gICAgICAgIHN1cGVyKG5hbWVTdHIpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHksIGl0ZW1JbmRleCB9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY29wZVBhdGggPSAoMCwgY29kZV8xLl8pIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gKDAsIGNvZGVfMS5fKSBgXFxuYDtcbmNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZTtcbiAgICAgICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBjb2RlXzEubmlsIH07XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlO1xuICAgIH1cbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgdmFsdWUobmFtZU9yUHJlZml4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4IH0gPSBuYW1lO1xuICAgICAgICBjb25zdCB2YWx1ZUtleSA9IChfYSA9IHZhbHVlLmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUucmVmO1xuICAgICAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgaWYgKHZzKSB7XG4gICAgICAgICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSk7XG4gICAgICAgICAgICBpZiAoX25hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpO1xuICAgICAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKTtcbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGg7XG4gICAgICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZjtcbiAgICAgICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXggfSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKSB7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpO1xuICAgIH1cbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lLCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVfMS5fKSBgJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NvcGVDb2RlKHZhbHVlcyA9IHRoaXMuX3ZhbHVlcywgdXNlZFZhbHVlcywgZ2V0Q29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUuY29kZTtcbiAgICAgICAgfSwgdXNlZFZhbHVlcywgZ2V0Q29kZSk7XG4gICAgfVxuICAgIF9yZWR1Y2VWYWx1ZXModmFsdWVzLCB2YWx1ZUNvZGUsIHVzZWRWYWx1ZXMgPSB7fSwgZ2V0Q29kZSkge1xuICAgICAgICBsZXQgY29kZSA9IGNvZGVfMS5uaWw7XG4gICAgICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XTtcbiAgICAgICAgICAgIGlmICghdnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lU2V0ID0gKHVzZWRWYWx1ZXNbcHJlZml4XSA9IHVzZWRWYWx1ZXNbcHJlZml4XSB8fCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgdnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3B0cy5lczUgPyBleHBvcnRzLnZhcktpbmRzLnZhciA6IGV4cG9ydHMudmFyS2luZHMuY29uc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoMCwgY29kZV8xLl8pIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKDAsIGNvZGVfMS5fKSBgJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGUgPSBWYWx1ZVNjb3BlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/codegen/scope.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/dist/compile/errors.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"./node_modules/ajv/dist/compile/names.js\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CO0FBQ25KLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFXO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx1REFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBUztBQUNqQyxvQkFBb0I7QUFDcEIsZ0JBQWdCLFNBQVMsc0NBQXNDLFFBQVE7QUFDdkU7QUFDQSx5QkFBeUI7QUFDekIsZ0JBQWdCLHFCQUFxQjtBQUNyQyxpQ0FBaUMsUUFBUSxvQkFBb0IsWUFBWTtBQUN6RSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5Qix3RUFBd0Usd0JBQXdCO0FBQ3hKO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0IsR0FBRyxFQUFFO0FBQ3hFLG1DQUFtQyxJQUFJLG1FQUFtRSxJQUFJO0FBQzlHLHVDQUF1QyxJQUFJLG9DQUFvQyxpQkFBaUIsR0FBRyxRQUFRO0FBQzNHO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0MsMkNBQTJDLElBQUk7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsMEVBQTBFLElBQUkseUJBQXlCLHdCQUF3QixRQUFRLElBQUk7QUFDbk0saUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQSwwQ0FBMEMsbUJBQW1CLEdBQUcsS0FBSztBQUNyRTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVyxJQUFJLGNBQWM7QUFDMUQ7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFLHdEQUF3RDtBQUNwRztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZSxpQkFBaUIsSUFBSSwwQkFBMEI7QUFDekYsdUVBQXVFLGNBQWMsR0FBRyxRQUFRO0FBQ2hHO0FBQ0Esd0NBQXdDLFFBQVEsRUFBRSxzREFBc0Q7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRCxZQUFZLGlDQUFpQztBQUM3QyxZQUFZLCtDQUErQztBQUMzRCw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYSxFQUFFLFdBQVc7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvZXJyb3JzLmpzPzJhNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4cG9ydHMucmVzZXRFcnJvcnNDb3VudCA9IGV4cG9ydHMucmVwb3J0RXh0cmFFcnJvciA9IGV4cG9ydHMucmVwb3J0RXJyb3IgPSBleHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmV4cG9ydHMua2V5d29yZEVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuc3RyKSBgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn07XG5mdW5jdGlvbiByZXBvcnRFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnMgfSA9IGl0O1xuICAgIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbiAgICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgIT09IG51bGwgJiYgb3ZlcnJpZGVBbGxFcnJvcnMgIT09IHZvaWQgMCA/IG92ZXJyaWRlQWxsRXJyb3JzIDogKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgICAgICBhZGRFcnJvcihnZW4sIGVyck9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5FcnJvcnMoaXQsICgwLCBjb2RlZ2VuXzEuXykgYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT4gZ2VuLmlmKGVycnNDb3VudCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBudWxsKSkpO1xufVxuZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gcmVzZXRFcnJvcnNDb3VudDtcbmZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7IGdlbiwga2V5d29yZCwgc2NoZW1hVmFsdWUsIGRhdGEsIGVycnNDb3VudCwgaXQsIH0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKTtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKGkpID0+IHtcbiAgICAgICAgZ2VuLmNvbnN0KGVyciwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9Lmluc3RhbmNlUGF0aGAsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJ9LnNjaGVtYVBhdGhgLCAoMCwgY29kZWdlbl8xLnN0cikgYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApO1xuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyfS5kYXRhYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXh0ZW5kRXJyb3JzO1xuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuLCBlcnJPYmopIHtcbiAgICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGxgLCAoKSA9PiBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtlcnJ9XWApLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgKTtcbiAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9KytgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudiB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAgICAgZ2VuLnRocm93KCgwLCBjb2RlZ2VuXzEuXykgYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpO1xuICAgICAgICBnZW4ucmV0dXJuKGZhbHNlKTtcbiAgICB9XG59XG5jb25zdCBFID0ge1xuICAgIGtleXdvcmQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImtleXdvcmRcIiksXG4gICAgc2NoZW1hUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgICBwYXJhbXM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmFtc1wiKSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgICBtZXNzYWdlOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJtZXNzYWdlXCIpLFxuICAgIHNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NoZW1hXCIpLFxuICAgIHBhcmVudFNjaGVtYTogbmV3IGNvZGVnZW5fMS5OYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufTtcbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKSB7XG4gICAgY29uc3QgeyBjcmVhdGVFcnJvcnMgfSA9IGN4dC5pdDtcbiAgICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYHt9YDtcbiAgICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocyk7XG59XG5mdW5jdGlvbiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzID0ge30pIHtcbiAgICBjb25zdCB7IGdlbiwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBbXG4gICAgICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICAgICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gICAgXTtcbiAgICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKTtcbiAgICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpO1xufVxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoeyBlcnJvclBhdGggfSwgeyBpbnN0YW5jZVBhdGggfSkge1xuICAgIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgICAgID8gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShpbnN0YW5jZVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YFxuICAgICAgICA6IGVycm9yUGF0aDtcbiAgICByZXR1cm4gW25hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsICgwLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KShuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldO1xufVxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKHsga2V5d29yZCwgaXQ6IHsgZXJyU2NoZW1hUGF0aCB9IH0sIHsgc2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hIH0pIHtcbiAgICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9ICgwLCBjb2RlZ2VuXzEuc3RyKSBgJHtzY2hQYXRofSR7KDAsIHV0aWxfMS5nZXRFcnJvclBhdGgpKHNjaGVtYVBhdGgsIHV0aWxfMS5UeXBlLlN0cil9YDtcbiAgICB9XG4gICAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdO1xufVxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKGN4dCwgeyBwYXJhbXMsIG1lc3NhZ2UgfSwga2V5VmFsdWVzKSB7XG4gICAgY29uc3QgeyBrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB7IG9wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoIH0gPSBpdDtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5rZXl3b3JkLCBrZXl3b3JkXSwgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8ICgwLCBjb2RlZ2VuXzEuXykgYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCAoMCwgY29kZWdlbl8xLl8pIGAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sIFtuYW1lc18xLmRlZmF1bHQuZGF0YSwgZGF0YV0pO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlOYW1lKVxuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/errors.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/index.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/dist/compile/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst validation_error_1 = __webpack_require__(/*! ../runtime/validation_error */ \"./node_modules/ajv/dist/runtime/validation_error.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"./node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./node_modules/ajv/dist/compile/validate/index.js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDbkgsa0JBQWtCLG1CQUFPLENBQUMsbUVBQVc7QUFDckMsMkJBQTJCLG1CQUFPLENBQUMsd0ZBQTZCO0FBQ2hFLGdCQUFnQixtQkFBTyxDQUFDLHlEQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFXO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx1REFBUTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxxRUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGLFlBQVksYUFBYTtBQUN6QixZQUFZLGdCQUFnQjtBQUM1QixvREFBb0QsMkJBQTJCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDLFNBQVMsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUIsTUFBTSxzQkFBc0I7QUFDOUY7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvaW5kZXguanM/Yjc4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY2xhc3MgU2NoZW1hRW52IHtcbiAgICBjb25zdHJ1Y3RvcihlbnYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5keW5hbWljQW5jaG9ycyA9IHt9O1xuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZDtcbiAgICAgICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpcztcbiAgICAgICAgdGhpcy5iYXNlSWQgPSAoX2EgPSBlbnYuYmFzZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWFbZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGg7XG4gICAgICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmcztcbiAgICAgICAgdGhpcy5tZXRhID0gZW52Lm1ldGE7XG4gICAgICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLiRhc3luYztcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxufVxuZXhwb3J0cy5TY2hlbWFFbnYgPSBTY2hlbWFFbnY7XG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYShzY2gpIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICAgIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgIGlmIChfc2NoKVxuICAgICAgICByZXR1cm4gX3NjaDtcbiAgICBjb25zdCByb290SWQgPSAoMCwgcmVzb2x2ZV8xLmdldEZ1bGxQYXRoKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCk7IC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gICAgY29uc3QgeyBlczUsIGxpbmVzIH0gPSB0aGlzLm9wdHMuY29kZTtcbiAgICBjb25zdCB7IG93blByb3BlcnRpZXMgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBnZW4gPSBuZXcgY29kZWdlbl8xLkNvZGVHZW4odGhpcy5zY29wZSwgeyBlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzIH0pO1xuICAgIGxldCBfVmFsaWRhdGlvbkVycm9yO1xuICAgIGlmIChzY2guJGFzeW5jKSB7XG4gICAgICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgICAgICAgIHJlZjogdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpO1xuICAgIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hQ3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICAgICAgZGF0YTogbmFtZXNfMS5kZWZhdWx0LmRhdGEsXG4gICAgICAgIHBhcmVudERhdGE6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLFxuICAgICAgICBwYXJlbnREYXRhUHJvcGVydHk6IG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgICAgIGRhdGFOYW1lczogW25hbWVzXzEuZGVmYXVsdC5kYXRhXSxcbiAgICAgICAgZGF0YVBhdGhBcnI6IFtjb2RlZ2VuXzEubmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICAgICAgZGF0YUxldmVsOiAwLFxuICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldCgpLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyB7IHJlZjogc2NoLnNjaGVtYSwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCxcbiAgICAgICAgb3B0czogdGhpcy5vcHRzLFxuICAgICAgICBzZWxmOiB0aGlzLFxuICAgIH07XG4gICAgbGV0IHNvdXJjZUNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpO1xuICAgICAgICAoMCwgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZSkoc2NoZW1hQ3h0KTtcbiAgICAgICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKTtcbiAgICAgICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpO1xuICAgICAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhuYW1lc18xLmRlZmF1bHQuc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2VzcylcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICAgICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfWAsIGAke25hbWVzXzEuZGVmYXVsdC5zY29wZX1gLCBzb3VyY2VDb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSk7XG4gICAgICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7IHJlZjogdmFsaWRhdGUgfSk7XG4gICAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWE7XG4gICAgICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaDtcbiAgICAgICAgaWYgKHNjaC4kYXN5bmMpXG4gICAgICAgICAgICB2YWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7IHZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBpdGVtcyB9ID0gc2NoZW1hQ3h0O1xuICAgICAgICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9ICgwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpO1xuICAgIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdO1xuICAgIGlmIChzY2hPckZ1bmMpXG4gICAgICAgIHJldHVybiBzY2hPckZ1bmM7XG4gICAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IChfYSA9IHJvb3QubG9jYWxSZWZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcmVmXTsgLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIF9zY2ggPSBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUoc2NoKSB7XG4gICAgaWYgKCgwLCByZXNvbHZlXzEuaW5saW5lUmVmKShzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSAoMCwgcmVzb2x2ZV8xLl9nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKTtcbiAgICBsZXQgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5nZXRGdWxsUGF0aCkodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKTtcbiAgICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkocmVmKSkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gc2NoT3JSZWY7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICBpZiAoc2NoSWQpXG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVsoMCwgdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQpKHBhcnQpXTtcbiAgICAgICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2NoZW1hID0gcGFydFNjaGVtYTtcbiAgICAgICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgICAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudjtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gKDAsIHJlc29sdmVfMS5yZXNvbHZlVXJsKSh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSlcbiAgICAgICAgcmV0dXJuIGVudjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/names.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/dist/compile/names.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports[\"default\"] = names;\n//# sourceMappingURL=names.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9uYW1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanM/ODJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lcyA9IHtcbiAgICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgIGRhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICBkeW5hbWljQW5jaG9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIGVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAgdGhpczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidGhpc1wiKSxcbiAgICAvLyBcImdsb2JhbHNcIlxuICAgIHNlbGY6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNlbGZcIiksXG4gICAgc2NvcGU6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjb3BlXCIpLFxuICAgIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gICAganNvbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblwiKSxcbiAgICBqc29uUG9zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uUG9zXCIpLFxuICAgIGpzb25MZW46IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25MZW5cIiksXG4gICAganNvblBhcnQ6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25QYXJ0XCIpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5hbWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/names.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/ref_error.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/dist/compile/ref_error.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"./node_modules/ajv/dist/compile/resolve.js\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports[\"default\"] = MissingRefError;\n//# sourceMappingURL=ref_error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZWZfZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsNkRBQVc7QUFDckM7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLFVBQVUsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcz9kYTc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZVwiKTtcbmNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlciwgYmFzZUlkLCByZWYsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApO1xuICAgICAgICB0aGlzLm1pc3NpbmdSZWYgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKHJlc29sdmVyLCBiYXNlSWQsIHJlZik7XG4gICAgICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9ICgwLCByZXNvbHZlXzEubm9ybWFsaXplSWQpKCgwLCByZXNvbHZlXzEuZ2V0RnVsbFBhdGgpKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaXNzaW5nUmVmRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZfZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/ref_error.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/resolve.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/dist/compile/resolve.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\nconst traverse = __webpack_require__(/*! json-schema-traverse */ \"./node_modules/json-schema-traverse/index.js\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9yZXNvbHZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQjtBQUNqSSxlQUFlLG1CQUFPLENBQUMsdURBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdFQUFpQjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlELHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcz8zMjAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZXhwb3J0cy5yZXNvbHZlVXJsID0gZXhwb3J0cy5ub3JtYWxpemVJZCA9IGV4cG9ydHMuX2dldEZ1bGxQYXRoID0gZXhwb3J0cy5nZXRGdWxsUGF0aCA9IGV4cG9ydHMuaW5saW5lUmVmID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmNvbnN0IHRyYXZlcnNlID0gcmVxdWlyZShcImpzb24tc2NoZW1hLXRyYXZlcnNlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZCk7XG4gICAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEsIGJhc2VJZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBzY2hlbWFJZCwgdXJpUmVzb2x2ZXIgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKTtcbiAgICBjb25zdCBiYXNlSWRzID0geyBcIlwiOiBzY2hJZCB9O1xuICAgIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKTtcbiAgICBjb25zdCBsb2NhbFJlZnMgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFSZWZzID0gbmV3IFNldCgpO1xuICAgIHRyYXZlcnNlKHNjaGVtYSwgeyBhbGxLZXlzOiB0cnVlIH0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICAgICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0cjtcbiAgICAgICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZDtcbiAgICAgICAgZnVuY3Rpb24gYWRkUmVmKHJlZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZTtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpXG4gICAgICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICAgICAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEFuY2hvcihhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApO1xuICAgICAgICAgICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxSZWZzO1xuICAgIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMSwgc2NoMiwgcmVmKSB7XG4gICAgICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKVxuICAgICAgICAgICAgdGhyb3cgYW1iaWd1b3MocmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW1iaWd1b3MocmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTY2hlbWFSZWZzID0gZ2V0U2NoZW1hUmVmcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/resolve.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/rules.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/dist/compile/rules.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9ydWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QyxrQkFBa0IsMkJBQTJCO0FBQzdDLGlCQUFpQiwwQkFBMEI7QUFDM0Msa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0EsaUJBQWlCLHFEQUFxRDtBQUN0RSxrQkFBa0IsV0FBVztBQUM3QixnQkFBZ0IsV0FBVztBQUMzQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3J1bGVzLmpzP2Y0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJ1bGVzID0gZXhwb3J0cy5pc0pTT05UeXBlID0gdm9pZCAwO1xuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdO1xuY29uc3QganNvblR5cGVzID0gbmV3IFNldChfanNvblR5cGVzKTtcbmZ1bmN0aW9uIGlzSlNPTlR5cGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcInN0cmluZ1wiICYmIGpzb25UeXBlcy5oYXMoeCk7XG59XG5leHBvcnRzLmlzSlNPTlR5cGUgPSBpc0pTT05UeXBlO1xuZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgY29uc3QgZ3JvdXBzID0ge1xuICAgICAgICBudW1iZXI6IHsgdHlwZTogXCJudW1iZXJcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIHN0cmluZzogeyB0eXBlOiBcInN0cmluZ1wiLCBydWxlczogW10gfSxcbiAgICAgICAgYXJyYXk6IHsgdHlwZTogXCJhcnJheVwiLCBydWxlczogW10gfSxcbiAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFwib2JqZWN0XCIsIHJ1bGVzOiBbXSB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZXM6IHsgLi4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlIH0sXG4gICAgICAgIHJ1bGVzOiBbeyBydWxlczogW10gfSwgZ3JvdXBzLm51bWJlciwgZ3JvdXBzLnN0cmluZywgZ3JvdXBzLmFycmF5LCBncm91cHMub2JqZWN0XSxcbiAgICAgICAgcG9zdDogeyBydWxlczogW10gfSxcbiAgICAgICAgYWxsOiB7fSxcbiAgICAgICAga2V5d29yZHM6IHt9LFxuICAgIH07XG59XG5leHBvcnRzLmdldFJ1bGVzID0gZ2V0UnVsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydWxlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/rules.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/util.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/dist/compile/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst code_1 = __webpack_require__(/*! ./codegen/code */ \"./node_modules/ajv/dist/compile/codegen/code.js\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsY0FBYztBQUN6YixrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBVztBQUNyQyxlQUFlLG1CQUFPLENBQUMsdUVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQSwrQkFBK0IsYUFBYSxFQUFFLFdBQVcsRUFBRSxvQ0FBb0M7QUFDL0Y7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDhCQUE4QixxREFBcUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtFQUFrRSxJQUFJLGNBQWMsTUFBTTtBQUMxRix1Q0FBdUMsTUFBTSxnRkFBZ0YsSUFBSSxLQUFLLDBDQUEwQyxHQUFHLElBQUksS0FBSztBQUM1TCxTQUFTO0FBQ1QsbUVBQW1FLElBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxLQUFLO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtFQUFrRSxJQUFJLGNBQWMsTUFBTSx5REFBeUQsTUFBTSxvQkFBb0IsSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSztBQUM1TSxtRUFBbUUsSUFBSSwyRUFBMkUsSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksS0FBSztBQUNqTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0VBQWtFLE1BQU0sRUFBRSw4QkFBOEI7QUFDeEc7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsV0FBVyxZQUFZLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCw0Q0FBNEMsU0FBUyw2Q0FBNkM7QUFDbEc7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzPzNlMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy51c2VGdW5jID0gZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBleHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IGV4cG9ydHMuZWFjaEl0ZW0gPSBleHBvcnRzLnVuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXhwb3J0cy5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMudW5lc2NhcGVGcmFnbWVudCA9IGV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IGV4cG9ydHMuY2hlY2tVbmtub3duUnVsZXMgPSBleHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gZXhwb3J0cy50b0hhc2ggPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4vY29kZWdlbi9jb2RlXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gICAgY29uc3QgaGFzaCA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpXG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIHJldHVybiBoYXNoO1xufVxuZXhwb3J0cy50b0hhc2ggPSB0b0hhc2g7XG5mdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKTtcbiAgICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpO1xufVxuZXhwb3J0cy5hbHdheXNWYWxpZFNjaGVtYSA9IGFsd2F5c1ZhbGlkU2NoZW1hO1xuZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSA9IGl0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3JkcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFydWxlc1trZXldKVxuICAgICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGNoZWNrVW5rbm93blJ1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBydWxlcykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChydWxlc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlcyA9IHNjaGVtYUhhc1J1bGVzO1xuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0J1dFJlZiA9IHNjaGVtYUhhc1J1bGVzQnV0UmVmO1xuZnVuY3Rpb24gc2NoZW1hUmVmT3JWYWwoeyB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSwgc2NoZW1hLCBrZXl3b3JkLCAkZGF0YSkge1xuICAgIGlmICghJGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YDtcbn1cbmV4cG9ydHMuc2NoZW1hUmVmT3JWYWwgPSBzY2hlbWFSZWZPclZhbDtcbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gdW5lc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSk7XG59XG5leHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXNjYXBlRnJhZ21lbnQ7XG5mdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7c3RyfWA7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG5leHBvcnRzLmVzY2FwZUpzb25Qb2ludGVyID0gZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IHVuZXNjYXBlSnNvblBvaW50ZXI7XG5mdW5jdGlvbiBlYWNoSXRlbSh4cywgZikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgeHMpXG4gICAgICAgICAgICBmKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZih4cyk7XG4gICAgfVxufVxuZXhwb3J0cy5lYWNoSXRlbSA9IGVhY2hJdGVtO1xuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkKHsgbWVyZ2VOYW1lcywgbWVyZ2VUb05hbWUsIG1lcmdlVmFsdWVzLCByZXN1bHRUb05hbWUsIH0pIHtcbiAgICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGZyb21cbiAgICAgICAgICAgIDogdG8gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgICAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgICAgICAgICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdG9OYW1lID09PSBjb2RlZ2VuXzEuTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSA/IHJlc3VsdFRvTmFtZShnZW4sIHJlcykgOiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydHMubWVyZ2VFdmFsdWF0ZWQgPSB7XG4gICAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWVgLCAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSwgKCkgPT4gZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKS5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih0bywgKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gfHwge31gKTtcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCB0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7IC4uLmZyb20sIC4uLnRvIH0pLFxuICAgICAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICAgIH0pLFxuICAgIGl0ZW1zOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgICAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT4gZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sICgwLCBjb2RlZ2VuXzEuXykgYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3RvfSAhPT0gdHJ1ZWAsICgpID0+IGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogKDAsIGNvZGVnZW5fMS5fKSBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgKDAsIGNvZGVnZW5fMS5fKSBge31gKTtcbiAgICBpZiAocHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLmV2YWx1YXRlZFByb3BzVG9OYW1lID0gZXZhbHVhdGVkUHJvcHNUb05hbWU7XG5mdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlIHx8IChleHBvcnRzLlR5cGUgPSBUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldEVycm9yUGF0aChkYXRhUHJvcCwgZGF0YVByb3BUeXBlLCBqc1Byb3BlcnR5U3ludGF4KSB7XG4gICAgLy8gbGV0IHBhdGhcbiAgICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkge1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW07XG4gICAgICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICAgICAgICA/IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/ICgwLCBjb2RlZ2VuXzEuXykgYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyAoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApO1xufVxuZXhwb3J0cy5nZXRFcnJvclBhdGggPSBnZXRFcnJvclBhdGg7XG5mdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgbW9kZSA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gO1xuICAgIGlmIChtb2RlID09PSB0cnVlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZyk7XG59XG5leHBvcnRzLmNoZWNrU3RyaWN0TW9kZSA9IGNoZWNrU3RyaWN0TW9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/util.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/applicability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/applicability.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLDZCQUE2QjtBQUM5RSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkuanM/MmY1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IGV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZSh7IHNjaGVtYSwgc2VsZiB9LCB0eXBlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBzZWxmLlJVTEVTLnR5cGVzW3R5cGVdO1xuICAgIHJldHVybiBncm91cCAmJiBncm91cCAhPT0gdHJ1ZSAmJiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKTtcbn1cbmV4cG9ydHMuc2NoZW1hSGFzUnVsZXNGb3JUeXBlID0gc2NoZW1hSGFzUnVsZXNGb3JUeXBlO1xuZnVuY3Rpb24gc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5ydWxlcy5zb21lKChydWxlKSA9PiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VHcm91cCA9IHNob3VsZFVzZUdyb3VwO1xuZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChzY2hlbWFbcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2EgPSBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGt3ZCkgPT4gc2NoZW1hW2t3ZF0gIT09IHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlUnVsZSA9IHNob3VsZFVzZVJ1bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhYmlsaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/applicability.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/boolSchema.js":
/*!**************************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/boolSchema.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDRCQUE0QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVztBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvYm9vbFNjaGVtYS5qcz84OWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGV4cG9ydHMudG9wQm9vbE9yRW1wdHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vbmFtZXNcIik7XG5jb25zdCBib29sRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufTtcbmZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbCk7XG4gICAgICAgIGdlbi5yZXR1cm4odHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b3BCb29sT3JFbXB0eVNjaGVtYSA9IHRvcEJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpOyAvLyBUT0RPIHZhclxuICAgICAgICBmYWxzZVNjaGVtYUVycm9yKGl0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgIH1cbn1cbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBib29sT3JFbXB0eVNjaGVtYTtcbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQsIG92ZXJyaWRlQWxsRXJyb3JzKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEgfSA9IGl0O1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gICAgY29uc3QgY3h0ID0ge1xuICAgICAgICBnZW4sXG4gICAgICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogZmFsc2UsXG4gICAgICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgICAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGl0LFxuICAgIH07XG4gICAgKDAsIGVycm9yc18xLnJlcG9ydEVycm9yKShjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/boolSchema.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/dataType.js":
/*!************************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/dataType.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = __webpack_require__(/*! ../rules */ \"./node_modules/ajv/dist/compile/rules.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"./node_modules/ajv/dist/compile/validate/applicability.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/ajv/dist/compile/util.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxnQkFBZ0I7QUFDNUssZ0JBQWdCLG1CQUFPLENBQUMsMERBQVU7QUFDbEMsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLDREQUFXO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFZO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx3REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZSxnQkFBZ0IsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLCtCQUErQixLQUFLLE9BQU8sS0FBSztBQUM3Riw4Q0FBOEMsS0FBSztBQUNuRCx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxpQkFBaUIsVUFBVTtBQUNyRiw4REFBOEQsS0FBSztBQUNuRSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVLGtCQUFrQixNQUFNO0FBQ2xGLG9CQUFvQixVQUFVLGlCQUFpQixNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUs7QUFDM0UsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsbUJBQW1CLE1BQU07QUFDbkYsb0JBQW9CLFVBQVUsa0JBQWtCLE1BQU0sS0FBSyxNQUFNLE1BQU0sTUFBTSxPQUFPLE1BQU07QUFDMUYsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU0saUJBQWlCLE1BQU0sV0FBVyxNQUFNO0FBQzlGO0FBQ0EsZ0RBQWdELE1BQU0sZ0JBQWdCLE1BQU07QUFDNUU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU0sWUFBWSxNQUFNLFdBQVcsTUFBTTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVLGtCQUFrQixVQUFVO0FBQ3RGLG1CQUFtQixVQUFVLG1CQUFtQixNQUFNO0FBQ3RELDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQSwrQkFBK0IsWUFBWSxxREFBcUQsV0FBVyxHQUFHLG1CQUFtQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxFQUFFLElBQUk7QUFDbkQ7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0EsdUNBQXVDLE1BQU0sWUFBWSxNQUFNLGdDQUFnQyxLQUFLO0FBQ3BHO0FBQ0E7QUFDQSxpREFBaUQsTUFBTSxpQkFBaUIsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsTUFBTSwrREFBK0QsS0FBSztBQUN2STtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQsMERBQTBELE1BQU0sS0FBSyxPQUFPO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsZ0JBQWdCLFFBQVEsZ0JBQWdCLE9BQU87QUFDL0MsZUFBZSxxQkFBcUIsb0RBQW9ELFFBQVEsUUFBUSx1QkFBdUIsUUFBUSxhQUFhO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlLmpzPzNmNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlcG9ydFR5cGVFcnJvciA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZXMgPSBleHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBleHBvcnRzLmdldEpTT05UeXBlcyA9IGV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuLi9ydWxlc1wiKTtcbmNvbnN0IGFwcGxpY2FiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2FiaWxpdHlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIERhdGFUeXBlO1xuKGZ1bmN0aW9uIChEYXRhVHlwZSkge1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiQ29ycmVjdFwiXSA9IDBdID0gXCJDb3JyZWN0XCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXcm9uZ1wiXSA9IDFdID0gXCJXcm9uZ1wiO1xufSkoRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWEpIHtcbiAgICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSk7XG4gICAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKTtcbiAgICBpZiAoaGFzTnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChcIm51bGxcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmV4cG9ydHMuZ2V0U2NoZW1hVHlwZXMgPSBnZXRTY2hlbWFUeXBlcztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zY2hlbWFIYXNSdWxlc0ZvclR5cGUpKGl0LCB0eXBlc1swXSkpO1xuICAgIGlmIChjaGVja1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKTtcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tUeXBlcztcbn1cbmV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGU7XG5jb25zdCBDT0VSQ0lCTEUgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzLCBjb2VyY2VUeXBlcykge1xuICAgIHJldHVybiBjb2VyY2VUeXBlc1xuICAgICAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgICAgICA6IFtdO1xufVxuZnVuY3Rpb24gY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YCk7XG4gICAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+IGdlblxuICAgICAgICAgICAgLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9WzBdYClcbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YVR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCk7XG4gICAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbi5lbHNlKCk7XG4gICAgcmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICBnZW4uZW5kSWYoKTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICBnZW4uYXNzaWduKGRhdGEsIGNvZXJjZWQpO1xuICAgICAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBjb2VyY2VTcGVjaWZpY1R5cGUodCkge1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsICgwLCBjb2RlZ2VuXzEuXykgYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgKDAsIGNvZGVnZW5fMS5fKSBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwiZmFsc2VcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiIHx8ICR7ZGF0YVR5cGV9ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgIHx8ICR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCAoMCwgY29kZWdlbl8xLl8pIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcikpO1xufVxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3QpIHtcbiAgICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkVRIDogY29kZWdlbl8xLm9wZXJhdG9ycy5ORVE7XG4gICAgbGV0IGNvbmQ7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9ICgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ICYmIHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoJHtkYXRhfSlgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgoMCwgY29kZWdlbl8xLl8pIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiAoMCwgY29kZWdlbl8xLm5vdCkoY29uZCk7XG4gICAgZnVuY3Rpb24gbnVtQ29uZChfY29uZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuYW5kKSgoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyAoMCwgY29kZWdlbl8xLl8pIGBpc0Zpbml0ZSgke2RhdGF9KWAgOiBjb2RlZ2VuXzEubmlsKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRGF0YVR5cGUgPSBjaGVja0RhdGFUeXBlO1xuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSB7XG4gICAgaWYgKGRhdGFUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KTtcbiAgICB9XG4gICAgbGV0IGNvbmQ7XG4gICAgY29uc3QgdHlwZXMgPSAoMCwgdXRpbF8xLnRvSGFzaCkoZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9ICgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgO1xuICAgICAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6ICgwLCBjb2RlZ2VuXzEuXykgYCEke2RhdGF9IHx8ICR7bm90T2JqfWA7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kID0gY29kZWdlbl8xLm5pbDtcbiAgICB9XG4gICAgaWYgKHR5cGVzLm51bWJlcilcbiAgICAgICAgZGVsZXRlIHR5cGVzLmludGVnZXI7XG4gICAgZm9yIChjb25zdCB0IGluIHR5cGVzKVxuICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5hbmQpKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWF9fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn07XG5mdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQpIHtcbiAgICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KTtcbiAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSAoMCwgdXRpbF8xLnNjaGVtYVJlZk9yVmFsKShpdCwgc2NoZW1hLCBcInR5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuLFxuICAgICAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICAgICAgc2NoZW1hQ29kZSxcbiAgICAgICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBpdCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVR5cGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/dataType.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/defaults.js":
/*!************************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/defaults.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assignDefaults = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/ajv/dist/compile/util.js\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsa0JBQWtCLG1CQUFPLENBQUMsb0VBQVk7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLHdEQUFTO0FBQ2hDO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBLDBDQUEwQyxLQUFLLEVBQUUsaUNBQWlDO0FBQ2xGO0FBQ0EsbUVBQW1FLFVBQVU7QUFDN0U7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0Esd0NBQXdDLFdBQVcsS0FBSyxXQUFXLGNBQWMsV0FBVztBQUM1RjtBQUNBLFVBQVUsV0FBVztBQUNyQiw4Q0FBOEMsV0FBVyxjQUFjLFdBQVc7QUFDbEYsMENBQTBDLFdBQVcsSUFBSSx1Q0FBdUM7QUFDaEc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMuanM/NDM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQsIHR5KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBpdGVtcyB9ID0gaXQuc2NoZW1hO1xuICAgIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzaWduRGVmYXVsdHMgPSBhc3NpZ25EZWZhdWx0cztcbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHsgZ2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBjaGlsZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wKX1gO1xuICAgIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSAoMCwgY29kZWdlbl8xLl8pIGAke2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImA7XG4gICAgfVxuICAgIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAgIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgICBnZW4uaWYoY29uZGl0aW9uLCAoMCwgY29kZWdlbl8xLl8pIGAke2NoaWxkRGF0YX0gPSAkeygwLCBjb2RlZ2VuXzEuc3RyaW5naWZ5KShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/defaults.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = __webpack_require__(/*! ./boolSchema */ \"./node_modules/ajv/dist/compile/validate/boolSchema.js\");\nconst dataType_1 = __webpack_require__(/*! ./dataType */ \"./node_modules/ajv/dist/compile/validate/dataType.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"./node_modules/ajv/dist/compile/validate/applicability.js\");\nconst dataType_2 = __webpack_require__(/*! ./dataType */ \"./node_modules/ajv/dist/compile/validate/dataType.js\");\nconst defaults_1 = __webpack_require__(/*! ./defaults */ \"./node_modules/ajv/dist/compile/validate/defaults.js\");\nconst keyword_1 = __webpack_require__(/*! ./keyword */ \"./node_modules/ajv/dist/compile/validate/keyword.js\");\nconst subschema_1 = __webpack_require__(/*! ./subschema */ \"./node_modules/ajv/dist/compile/validate/subschema.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ../resolve */ \"./node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/ajv/dist/compile/errors.js\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsNEJBQTRCO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLDRFQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFZO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLGtGQUFpQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBWTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBVTtBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyw4REFBWTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsd0RBQVM7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0EsbURBQW1ELHFCQUFxQixJQUFJLHVCQUF1QjtBQUNuRyxxREFBcUQsRUFBRSw0QkFBNEI7QUFDbkY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQixJQUFJLHdCQUF3QjtBQUNwRztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSw2QkFBNkIsT0FBTywyQkFBMkIsSUFBSSxtQ0FBbUMsSUFBSSx5QkFBeUIsR0FBRyxxQkFBcUIsRUFBRSx3Q0FBd0MsK0JBQStCLEdBQUcsbUJBQW1CLEdBQUc7QUFDN1I7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHVCQUF1QixHQUFHLDZCQUE2QjtBQUN6SCxn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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpR0FBaUc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx5QkFBeUIsR0FBRztBQUN4Ryw0Q0FBNEMsa0JBQWtCLEdBQUcsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLEVBQUUscUVBQXFFO0FBQ25ILHVDQUF1QyxNQUFNLEtBQUssS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLEVBQUUsSUFBSSw4QkFBOEIsVUFBVTtBQUMzRjtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9pbmRleC5qcz8yOGJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXREYXRhID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGJvb2xTY2hlbWFfMSA9IHJlcXVpcmUoXCIuL2Jvb2xTY2hlbWFcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vZGF0YVR5cGVcIik7XG5jb25zdCBhcHBsaWNhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhYmlsaXR5XCIpO1xuY29uc3QgZGF0YVR5cGVfMiA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgZGVmYXVsdHNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuY29uc3Qga2V5d29yZF8xID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTtcbmNvbnN0IHN1YnNjaGVtYV8xID0gcmVxdWlyZShcIi4vc3Vic2NoZW1hXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQpIHtcbiAgICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgICAgIGNoZWNrS2V5d29yZHMoaXQpO1xuICAgICAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICAgICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiAoMCwgYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKShpdCkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUZ1bmN0aW9uQ29kZSA9IHZhbGlkYXRlRnVuY3Rpb25Db2RlO1xuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbih7IGdlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0cyB9LCBib2R5KSB7XG4gICAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKTtcbiAgICAgICAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cyk7XG4gICAgICAgICAgICBnZW4uY29kZShib2R5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyAoMCwgY29kZWdlbl8xLl8pIGAsICR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfT17fWAgOiBjb2RlZ2VuXzEubmlsfX09e31gO1xufVxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKSB7XG4gICAgZ2VuLmlmKG5hbWVzXzEuZGVmYXVsdC52YWxDeHQsICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aH1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5yb290RGF0YX1gKTtcbiAgICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLl8pIGBcIlwiYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIG9wdHMsIGdlbiB9ID0gaXQ7XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgICAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgICAgIGNoZWNrTm9EZWZhdWx0KGl0KTtcbiAgICAgICAgZ2VuLmxldChuYW1lc18xLmRlZmF1bHQudkVycm9ycywgbnVsbCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LmVycm9ycywgMCk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmVzZXRFdmFsdWF0ZWQoaXQpO1xuICAgICAgICB0eXBlQW5kS2V5d29yZHMoaXQpO1xuICAgICAgICByZXR1cm5SZXN1bHRzKGl0KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdCkge1xuICAgIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgICBjb25zdCB7IGdlbiwgdmFsaWRhdGVOYW1lIH0gPSBpdDtcbiAgICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApO1xuICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbigoMCwgY29kZWdlbl8xLl8pIGAke2l0LmV2YWx1YXRlZH0ucHJvcHNgLCAoMCwgY29kZWdlbl8xLl8pIGB1bmRlZmluZWRgKSk7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsICgwLCBjb2RlZ2VuXzEuXykgYHVuZGVmaW5lZGApKTtcbn1cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSB7XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdO1xuICAgIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyAoMCwgY29kZWdlbl8xLl8pIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBib29sU2NoZW1hXzEuYm9vbE9yRW1wdHlTY2hlbWEpKGl0LCB2YWxpZCk7XG59XG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7IHNjaGVtYSwgc2VsZiB9KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgZ2VuLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpXG4gICAgICAgIGNvbW1lbnRLZXl3b3JkKGl0KTtcbiAgICB1cGRhdGVDb250ZXh0KGl0KTtcbiAgICBjaGVja0FzeW5jU2NoZW1hKGl0KTtcbiAgICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudCk7XG4gICAgLy8gVE9ETyB2YXJcbiAgICBnZW4udmFyKHZhbGlkLCAoMCwgY29kZWdlbl8xLl8pIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQpIHtcbiAgICAoMCwgdXRpbF8xLmNoZWNrVW5rbm93blJ1bGVzKShpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gKDAsIGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMpKGl0LnNjaGVtYSk7XG4gICAgY29uc3QgY2hlY2tlZFR5cGVzID0gKDAsIGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSkoaXQsIHR5cGVzKTtcbiAgICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudCk7XG59XG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgKDAsIHV0aWxfMS5zY2hlbWFIYXNSdWxlc0J1dFJlZikoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0KSB7XG4gICAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF07XG4gICAgaWYgKHNjaElkKVxuICAgICAgICBpdC5iYXNlSWQgPSAoMCwgcmVzb2x2ZV8xLnJlc29sdmVVcmwpKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdCkge1xuICAgIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG59XG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7IGdlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMgfSkge1xuICAgIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudDtcbiAgICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSAoMCwgY29kZWdlbl8xLnN0cikgYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgO1xuICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogc2NoZW1hRW52LnJvb3QgfSk7XG4gICAgICAgIGdlbi5jb2RlKCgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coKDAsIGNvZGVnZW5fMS5fKSBgbmV3ICR7VmFsaWRhdGlvbkVycm9yfSgke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSlgKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgYXNzaWduRXZhbHVhdGVkKGl0KTtcbiAgICAgICAgZ2VuLnJldHVybigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpO1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKVxuICAgICAgICBnZW4uYXNzaWduKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgdHlwZUVycm9ycywgZXJyc0NvdW50KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSBzZWxmO1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgISgwLCB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYpKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCEoMCwgYXBwbGljYWJpbGl0eV8xLnNob3VsZFVzZUdyb3VwKShzY2hlbWEsIGdyb3VwKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKTtcbiAgICAgICAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgICAgICAoMCwgZGF0YVR5cGVfMi5yZXBvcnRUeXBlRXJyb3IpKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBvcHRzOiB7IHVzZURlZmF1bHRzIH0sIH0gPSBpdDtcbiAgICBpZiAodXNlRGVmYXVsdHMpXG4gICAgICAgICgwLCBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKShpdCwgZ3JvdXAudHlwZSk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcyk7XG59XG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQsIHRzKSB7XG4gICAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0LCB0cykge1xuICAgIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGw7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgKDAsIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHMsIGt3ZFQpIHtcbiAgICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0cywgdCkge1xuICAgIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpO1xufVxuZnVuY3Rpb24gbmFycm93U2NoZW1hVHlwZXMoaXQsIHdpdGhUeXBlcykge1xuICAgIGNvbnN0IHRzID0gW107XG4gICAgZm9yIChjb25zdCB0IG9mIGl0LmRhdGFUeXBlcykge1xuICAgICAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpXG4gICAgICAgICAgICB0cy5wdXNoKHQpO1xuICAgICAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0cy5wdXNoKFwiaW50ZWdlclwiKTtcbiAgICB9XG4gICAgaXQuZGF0YVR5cGVzID0gdHM7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpO1xufVxuY2xhc3MgS2V5d29yZEN4dCB7XG4gICAgY29uc3RydWN0b3IoaXQsIGRlZiwga2V5d29yZCkge1xuICAgICAgICAoMCwga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKShpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICAgICAgdGhpcy5nZW4gPSBpdC5nZW47XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzO1xuICAgICAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmRhdGEgPSBpdC5kYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhO1xuICAgICAgICB0aGlzLnNjaGVtYVZhbHVlID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCEoMCwga2V5d29yZF8xLnZhbGlkU2NoZW1hVHlwZSkodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KCgwLCBjb2RlZ2VuXzEubm90KShjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbFJlc3VsdChjb25kaXRpb24sIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGZhaWxBY3Rpb24pXG4gICAgICAgICAgICBmYWlsQWN0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NBY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhc3MoY29uZGl0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdCgoMCwgY29kZWdlbl8xLm5vdCkoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgkeygwLCBjb2RlZ2VuXzEub3IpKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApO1xuICAgIH1cbiAgICBlcnJvcihhcHBlbmQsIGVycm9yUGFyYW1zLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICBfZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKSB7XG4gICAgICAgIDtcbiAgICAgICAgKGFwcGVuZCA/IGVycm9yc18xLnJlcG9ydEV4dHJhRXJyb3IgOiBlcnJvcnNfMS5yZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIH1cbiAgICAkZGF0YUVycm9yKCkge1xuICAgICAgICAoMCwgZXJyb3JzXzEucmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5yZXNldEVycm9yc0NvdW50KSh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpO1xuICAgIH1cbiAgICBvayhjb25kKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICB0aGlzLmdlbi5pZihjb25kKTtcbiAgICB9XG4gICAgc2V0UGFyYW1zKG9iaiwgYXNzaWduKSB7XG4gICAgICAgIGlmIChhc3NpZ24pXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9iajtcbiAgICB9XG4gICAgYmxvY2skZGF0YSh2YWxpZCwgY29kZUJsb2NrLCAkZGF0YVZhbGlkID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpO1xuICAgICAgICAgICAgY29kZUJsb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVjayRkYXRhKHZhbGlkID0gY29kZWdlbl8xLm5pbCwgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRkYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmIH0gPSB0aGlzO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5vcikoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5vcikod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpO1xuICAgICAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBkYXRhVHlwZV8yLmNoZWNrRGF0YVR5cGVzKShzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGAhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NoZW1hKGFwcGwsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYSA9ICgwLCBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEpKHRoaXMuaXQsIGFwcGwpO1xuICAgICAgICAoMCwgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hRGF0YSkoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgKDAsIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYU1vZGUpKHN1YnNjaGVtYSwgYXBwbCk7XG4gICAgICAgIGNvbnN0IG5leHRDb250ZXh0ID0geyAuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpO1xuICAgICAgICByZXR1cm4gbmV4dENvbnRleHQ7XG4gICAgfVxuICAgIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgdG9OYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dCwgdmFsaWQpIHtcbiAgICAgICAgY29uc3QgeyBpdCwgZ2VuIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICAgICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBjb2RlZ2VuXzEuTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLktleXdvcmRDeHQgPSBLZXl3b3JkQ3h0O1xuZnVuY3Rpb24ga2V5d29yZENvZGUoaXQsIGtleXdvcmQsIGRlZiwgcnVsZVR5cGUpIHtcbiAgICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKTtcbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgICgwLCBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICAgICAgKDAsIGtleXdvcmRfMS5tYWNyb0tleXdvcmRDb2RlKShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICAoMCwga2V5d29yZF8xLmZ1bmNLZXl3b3JkQ29kZSkoY3h0LCBkZWYpO1xuICAgIH1cbn1cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC87XG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kLztcbmZ1bmN0aW9uIGdldERhdGEoJGRhdGEsIHsgZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyIH0pIHtcbiAgICBsZXQganNvblBvaW50ZXI7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKCRkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApO1xuICAgICAgICBqc29uUG9pbnRlciA9ICRkYXRhO1xuICAgICAgICBkYXRhID0gbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAgY29uc3QgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAodXAgPj0gZGF0YUxldmVsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cCA+IGRhdGFMZXZlbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKTtcbiAgICAgICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF07XG4gICAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgbGV0IGV4cHIgPSBkYXRhO1xuICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgZGF0YSA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKCgwLCB1dGlsXzEudW5lc2NhcGVKc29uUG9pbnRlcikoc2VnbWVudCkpfWA7XG4gICAgICAgICAgICBleHByID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtleHByfSAmJiAke2RhdGF9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZSwgdXApIHtcbiAgICAgICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0RGF0YSA9IGdldERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/keyword.js":
/*!***********************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/keyword.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst code_1 = __webpack_require__(/*! ../../vocabularies/code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/ajv/dist/compile/errors.js\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9rZXl3b3JkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QjtBQUMzRyxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBVTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsNkVBQXlCO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLDREQUFXO0FBQ3BDO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUIsR0FBRyxRQUFRO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsWUFBWSxnREFBZ0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUgsR0FBRyxhQUFhLG1CQUFtQixrREFBa0QsRUFBRTtBQUM1TTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPLEVBQUUsb0VBQW9FO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLHFFQUFxRSxjQUFjLEdBQUcsc0JBQXNCO0FBQzVHO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQSxpRUFBaUUseUJBQXlCLGFBQWEsTUFBTSxJQUFJLHdCQUF3QixVQUFVLEtBQUs7QUFDeEosZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QyxxRUFBcUUsY0FBYyxJQUFJLHFEQUFxRDtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxRQUFRLElBQUksZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLDhCQUE4QixjQUFjO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanM/MDFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVLZXl3b3JkVXNhZ2UgPSBleHBvcnRzLnZhbGlkU2NoZW1hVHlwZSA9IGV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZXhwb3J0cy5tYWNyb0tleXdvcmRDb2RlID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpXG4gICAgICAgIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgICAgc2NoZW1hUGF0aDogY29kZWdlbl8xLm5pbCxcbiAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sIHZhbGlkKTtcbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbn1cbmV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IG1hY3JvS2V5d29yZENvZGU7XG5mdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9ICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZTtcbiAgICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSk7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZCk7XG4gICAgY3h0Lm9rKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpIHtcbiAgICAgICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhc3NpZ25WYWxpZCgpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpO1xuICAgICAgICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpXG4gICAgICAgICAgICAgICAgbW9kaWZ5RGF0YShjeHQpO1xuICAgICAgICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKTtcbiAgICAgICAgZ2VuLnRyeSgoKSA9PiBhc3NpZ25WYWxpZCgoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgKSwgKGUpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZigoMCwgY29kZWdlbl8xLl8pIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtlfS5lcnJvcnNgKSwgKCkgPT4gZ2VuLnRocm93KGUpKSk7XG4gICAgICAgIHJldHVybiBydWxlRXJycztcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSAoMCwgY29kZWdlbl8xLl8pIGAke3ZhbGlkYXRlUmVmfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKHZhbGlkYXRlRXJycywgbnVsbCk7XG4gICAgICAgIGFzc2lnblZhbGlkKGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVFcnJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQgPSBkZWYuYXN5bmMgPyAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7X2F3YWl0fSR7KDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLCBkZWYubW9kaWZ5aW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSk7XG59XG5mdW5jdGlvbiBhZGRFcnJzKGN4dCwgZXJycykge1xuICAgIGNvbnN0IHsgZ2VuIH0gPSBjeHQ7XG4gICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLCAoKSA9PiB7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgLmFzc2lnbihuYW1lc18xLmRlZmF1bHQudkVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgKDAsIGNvZGVnZW5fMS5fKSBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ubGVuZ3RoYCk7XG4gICAgICAgICgwLCBlcnJvcnNfMS5leHRlbmRFcnJvcnMpKGN4dCk7XG4gICAgfSwgKCkgPT4gY3h0LmVycm9yKCkpO1xufVxuZnVuY3Rpb24gY2hlY2tBc3luY0tleXdvcmQoeyBzY2hlbWFFbnYgfSwgZGVmKSB7XG4gICAgaWYgKGRlZi5hc3luYyAmJiAhc2NoZW1hRW52LiRhc3luYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApO1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImtleXdvcmRcIiwgdHlwZW9mIHJlc3VsdCA9PSBcImZ1bmN0aW9uXCIgPyB7IHJlZjogcmVzdWx0IH0gOiB7IHJlZjogcmVzdWx0LCBjb2RlOiAoMCwgY29kZWdlbl8xLnN0cmluZ2lmeSkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/keyword.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/compile/validate/subschema.js":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/dist/compile/validate/subschema.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./node_modules/ajv/dist/compile/util.js\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsb0JBQW9CO0FBQ2hGLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFZO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyx3REFBUztBQUNoQyw0QkFBNEIsc0VBQXNFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxFQUFFLG9DQUFvQztBQUNwRyxrQ0FBa0MsaUJBQWlCLEdBQUcsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYyxFQUFFLG9DQUFvQyxFQUFFLHVDQUF1QztBQUM3SSxrQ0FBa0MsaUJBQWlCLEdBQUcsUUFBUSxHQUFHLHVDQUF1QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsOENBQThDLCtEQUErRDtBQUM3RztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLDZEQUE2RCxRQUFRLEVBQUUscUNBQXFDO0FBQzVHO0FBQ0Esb0RBQW9ELFVBQVUsRUFBRSxrRUFBa0U7QUFDbEksMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBDQUEwQyx1RUFBdUU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHlDQUF5QztBQUN6QztBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLmpzPzE5NzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHBvcnRzLmV4dGVuZFN1YnNjaGVtYURhdGEgPSBleHBvcnRzLmdldFN1YnNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBnZXRTdWJzY2hlbWEoaXQsIHsga2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWYgfSkge1xuICAgIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aDogKDAsIGNvZGVnZW5fMS5fKSBgJHtpdC5zY2hlbWFQYXRofSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6ICgwLCBjb2RlZ2VuXzEuXykgYCR7aXQuc2NoZW1hUGF0aH0keygwLCBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkpKGtleXdvcmQpfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7KDAsIHV0aWxfMS5lc2NhcGVGcmFnbWVudCkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpO1xufVxuZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgaXQsIHsgZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZSB9KSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGdlbiB9ID0gaXQ7XG4gICAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2l0LmRhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gKDAsIGNvZGVnZW5fMS5zdHIpIGAke2Vycm9yUGF0aH0keygwLCB1dGlsXzEuZ2V0RXJyb3JQYXRoKShkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWA7XG4gICAgICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHkgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/compile/validate/subschema.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/core.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/dist/core.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"./node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nconst validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"./node_modules/ajv/dist/runtime/validation_error.js\");\nconst ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"./node_modules/ajv/dist/compile/ref_error.js\");\nconst rules_1 = __webpack_require__(/*! ./compile/rules */ \"./node_modules/ajv/dist/compile/rules.js\");\nconst compile_1 = __webpack_require__(/*! ./compile */ \"./node_modules/ajv/dist/compile/index.js\");\nconst codegen_2 = __webpack_require__(/*! ./compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst resolve_1 = __webpack_require__(/*! ./compile/resolve */ \"./node_modules/ajv/dist/compile/resolve.js\");\nconst dataType_1 = __webpack_require__(/*! ./compile/validate/dataType */ \"./node_modules/ajv/dist/compile/validate/dataType.js\");\nconst util_1 = __webpack_require__(/*! ./compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst $dataRefSchema = __webpack_require__(/*! ./refs/data.json */ \"./node_modules/ajv/dist/refs/data.json\");\nconst uri_1 = __webpack_require__(/*! ./runtime/uri */ \"./node_modules/ajv/dist/runtime/uri.js\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports[\"default\"] = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVcsSUFBSSxJQUFJLGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQiw0REFBNEQsU0FBUztBQUNyRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29yZS5qcz9lMmE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xudmFyIHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2V5d29yZEN4dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVfMS5LZXl3b3JkQ3h0OyB9IH0pO1xudmFyIGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvY29kZWdlblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuc3RyaW5naWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLk5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2RlR2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuQ29kZUdlbjsgfSB9KTtcbmNvbnN0IHZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4vY29tcGlsZS9ydWxlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGVcIik7XG5jb25zdCBjb2RlZ2VuXzIgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3Jlc29sdmVcIik7XG5jb25zdCBkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0ICRkYXRhUmVmU2NoZW1hID0gcmVxdWlyZShcIi4vcmVmcy9kYXRhLmpzb25cIik7XG5jb25zdCB1cmlfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWUvdXJpXCIpO1xuY29uc3QgZGVmYXVsdFJlZ0V4cCA9IChzdHIsIGZsYWdzKSA9PiBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpO1xuZGVmYXVsdFJlZ0V4cC5jb2RlID0gXCJuZXcgUmVnRXhwXCI7XG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TID0gW1wicmVtb3ZlQWRkaXRpb25hbFwiLCBcInVzZURlZmF1bHRzXCIsIFwiY29lcmNlVHlwZXNcIl07XG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgICBcInZhbGlkYXRlXCIsXG4gICAgXCJzZXJpYWxpemVcIixcbiAgICBcInBhcnNlXCIsXG4gICAgXCJ3cmFwcGVyXCIsXG4gICAgXCJyb290XCIsXG4gICAgXCJzY2hlbWFcIixcbiAgICBcImtleXdvcmRcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImZvcm1hdHNcIixcbiAgICBcInZhbGlkYXRlJGRhdGFcIixcbiAgICBcImZ1bmNcIixcbiAgICBcIm9ialwiLFxuICAgIFwiRXJyb3JcIixcbl0pO1xuY29uc3QgcmVtb3ZlZE9wdGlvbnMgPSB7XG4gICAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgICBmb3JtYXQ6IFwiYHZhbGlkYXRlRm9ybWF0czogZmFsc2VgIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICAgIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgICBleHRlbmRSZWZzOiBcIkRlcHJlY2F0ZWQgaWdub3JlS2V5d29yZHNXaXRoUmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICAgIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gICAgc291cmNlQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7c291cmNlOiB0cnVlfWBcIixcbiAgICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgICB1bmlxdWVJdGVtczogJ1widW5pcXVlSXRlbXNcIiBrZXl3b3JkIGlzIGFsd2F5cyB2YWxpZGF0ZWQuJyxcbiAgICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gICAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIHNlcmlhbGl6ZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gICAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufTtcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0ge1xuICAgIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAgICBqc1Byb3BlcnR5U3ludGF4OiBcIlwiLFxuICAgIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn07XG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfciwgX3MsIF90LCBfdSwgX3YsIF93LCBfeCwgX3ksIF96LCBfMDtcbiAgICBjb25zdCBzID0gby5zdHJpY3Q7XG4gICAgY29uc3QgX29wdHogPSAoX2EgPSBvLmNvZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZTtcbiAgICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMDtcbiAgICBjb25zdCByZWdFeHAgPSAoX2MgPSAoX2IgPSBvLmNvZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdFeHApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZWdFeHA7XG4gICAgY29uc3QgdXJpUmVzb2x2ZXIgPSAoX2QgPSBvLnVyaVJlc29sdmVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1cmlfMS5kZWZhdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0cmljdFNjaGVtYTogKF9mID0gKF9lID0gby5zdHJpY3RTY2hlbWEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRydWUsXG4gICAgICAgIHN0cmljdE51bWJlcnM6IChfaCA9IChfZyA9IG8uc3RyaWN0TnVtYmVycykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0VHlwZXM6IChfayA9IChfaiA9IG8uc3RyaWN0VHlwZXMpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IHMpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFR1cGxlczogKF9tID0gKF9sID0gby5zdHJpY3RUdXBsZXMpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHMpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IFwibG9nXCIsXG4gICAgICAgIHN0cmljdFJlcXVpcmVkOiAoX3AgPSAoX28gPSBvLnN0cmljdFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBzKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiBmYWxzZSxcbiAgICAgICAgY29kZTogby5jb2RlID8geyAuLi5vLmNvZGUsIG9wdGltaXplLCByZWdFeHAgfSA6IHsgb3B0aW1pemUsIHJlZ0V4cCB9LFxuICAgICAgICBsb29wUmVxdWlyZWQ6IChfcSA9IG8ubG9vcFJlcXVpcmVkKSAhPT0gbnVsbCAmJiBfcSAhPT0gdm9pZCAwID8gX3EgOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbG9vcEVudW06IChfciA9IG8ubG9vcEVudW0pICE9PSBudWxsICYmIF9yICE9PSB2b2lkIDAgPyBfciA6IE1BWF9FWFBSRVNTSU9OLFxuICAgICAgICBtZXRhOiAoX3MgPSBvLm1ldGEpICE9PSBudWxsICYmIF9zICE9PSB2b2lkIDAgPyBfcyA6IHRydWUsXG4gICAgICAgIG1lc3NhZ2VzOiAoX3QgPSBvLm1lc3NhZ2VzKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiB0cnVlLFxuICAgICAgICBpbmxpbmVSZWZzOiAoX3UgPSBvLmlubGluZVJlZnMpICE9PSBudWxsICYmIF91ICE9PSB2b2lkIDAgPyBfdSA6IHRydWUsXG4gICAgICAgIHNjaGVtYUlkOiAoX3YgPSBvLnNjaGVtYUlkKSAhPT0gbnVsbCAmJiBfdiAhPT0gdm9pZCAwID8gX3YgOiBcIiRpZFwiLFxuICAgICAgICBhZGRVc2VkU2NoZW1hOiAoX3cgPSBvLmFkZFVzZWRTY2hlbWEpICE9PSBudWxsICYmIF93ICE9PSB2b2lkIDAgPyBfdyA6IHRydWUsXG4gICAgICAgIHZhbGlkYXRlU2NoZW1hOiAoX3ggPSBvLnZhbGlkYXRlU2NoZW1hKSAhPT0gbnVsbCAmJiBfeCAhPT0gdm9pZCAwID8gX3ggOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZUZvcm1hdHM6IChfeSA9IG8udmFsaWRhdGVGb3JtYXRzKSAhPT0gbnVsbCAmJiBfeSAhPT0gdm9pZCAwID8gX3kgOiB0cnVlLFxuICAgICAgICB1bmljb2RlUmVnRXhwOiAoX3ogPSBvLnVuaWNvZGVSZWdFeHApICE9PSBudWxsICYmIF96ICE9PSB2b2lkIDAgPyBfeiA6IHRydWUsXG4gICAgICAgIGludDMycmFuZ2U6IChfMCA9IG8uaW50MzJyYW5nZSkgIT09IG51bGwgJiYgXzAgIT09IHZvaWQgMCA/IF8wIDogdHJ1ZSxcbiAgICAgICAgdXJpUmVzb2x2ZXI6IHVyaVJlc29sdmVyLFxuICAgIH07XG59XG5jbGFzcyBBanYge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZm9ybWF0cyA9IHt9O1xuICAgICAgICB0aGlzLl9jb21waWxhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIG9wdHMgPSB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKSB9O1xuICAgICAgICBjb25zdCB7IGVzNSwgbGluZXMgfSA9IHRoaXMub3B0cy5jb2RlO1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IGNvZGVnZW5fMi5WYWx1ZVNjb3BlKHsgc2NvcGU6IHt9LCBwcmVmaXhlczogRVhUX1NDT1BFX05BTUVTLCBlczUsIGxpbmVzIH0pO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihvcHRzLmxvZ2dlcik7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLlJVTEVTID0gKDAsIHJ1bGVzXzEuZ2V0UnVsZXMpKCk7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIik7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpO1xuICAgICAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmZvcm1hdHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICAgICAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdDtcbiAgICB9XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IHsgJGRhdGEsIG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGxldCBfZGF0YVJlZlNjaGVtYSA9ICRkYXRhUmVmU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7IC4uLiRkYXRhUmVmU2NoZW1hIH07XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgJiYgJGRhdGEpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgICBkYXRhIC8vIHRvIGJlIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmNvbXBpbGUoc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSk7XG4gICAgICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpXG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSk7XG4gICAgfVxuICAgIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxvYWRTY2hlbWEgfSA9IHRoaXMub3B0cztcbiAgICAgICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhfc2NoZW1hLCBfbWV0YSkge1xuICAgICAgICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEoJHJlZikge1xuICAgICAgICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyAkcmVmIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiByZWZfZXJyb3JfMS5kZWZhdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQoeyBtaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWYgfSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYShyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgICBhZGRTY2hlbWEoc2NoZW1hLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleSwgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YSwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoa2V5IHx8IGlkKTtcbiAgICAgICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gICAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCAvLyBzY2hlbWEga2V5XG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAgICApIHtcbiAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAgVmFsaWRhdGUgc2NoZW1hIGFnYWluc3QgaXRzIG1ldGEtc2NoZW1hXG4gICAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0ICRzY2hlbWE7XG4gICAgICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgICAgICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKTtcbiAgICAgICAgaWYgKCEkc2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWV0YS1zY2hlbWEgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gICAgLy8gKGBrZXlgIHRoYXQgd2FzIHBhc3NlZCB0byBgYWRkU2NoZW1hYCBvciBmdWxsIHNjaGVtYSByZWZlcmVuY2UgLSBgc2NoZW1hLiRpZGAgb3IgcmVzb2x2ZWQgaWQpXG4gICAgZ2V0U2NoZW1hKGtleVJlZikge1xuICAgICAgICBsZXQgc2NoO1xuICAgICAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAga2V5UmVmID0gc2NoO1xuICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgY29tcGlsZV8xLlNjaGVtYUVudih7IHNjaGVtYToge30sIHNjaGVtYUlkIH0pO1xuICAgICAgICAgICAgc2NoID0gY29tcGlsZV8xLnJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCFzY2gpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gICAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAgIC8vIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAgICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgdHlwZTogKDAsIGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKShkZWYudHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIHV0aWxfMS5lYWNoSXRlbSkoa2V5d29yZCwgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgICByZW1vdmVLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgICAgICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKTtcbiAgICAgICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICAgICAgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgZm9ybWF0XG4gICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlcnJvcnNUZXh0KGVycm9ycyA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHsgc2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCIgfSA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgICApIHtcbiAgICAgICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgICAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpO1xuICAgIH1cbiAgICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYSwga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbDtcbiAgICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKTsgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cylcbiAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRkYXRhIH0gPSBydWxlLmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFTY2hlbWE7XG4gICAgfVxuICAgIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFNjaGVtYShzY2hlbWEsIG1ldGEsIGJhc2VJZCwgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmp0ZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICAgICAgYmFzZUlkID0gKDAsIHJlc29sdmVfMS5ub3JtYWxpemVJZCkoaWQgfHwgYmFzZUlkKTtcbiAgICAgICAgY29uc3QgbG9jYWxSZWZzID0gcmVzb2x2ZV8xLmdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSAoMCwgcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKShrZXlSZWYpOyAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl07XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpXG4gICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKVxuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgICAgaWYgKGZvcm1hdClcbiAgICAgICAgICAgIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKGRlZnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgICAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKTtcbiAgICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgICAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdO1xuICAgICAgICBpZiAoIWRlZi5rZXl3b3JkKVxuICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucygpIHtcbiAgICBjb25zdCBtZXRhT3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG4gICAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUylcbiAgICAgICAgZGVsZXRlIG1ldGFPcHRzW29wdF07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xufVxuY29uc3Qgbm9Mb2dzID0geyBsb2coKSB7IH0sIHdhcm4oKSB7IH0sIGVycm9yKCkgeyB9IH07XG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBub0xvZ3M7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gY29uc29sZTtcbiAgICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKTtcbn1cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2k7XG5mdW5jdGlvbiBjaGVja0tleXdvcmQoa2V5d29yZCwgZGVmKSB7XG4gICAgY29uc3QgeyBSVUxFUyB9ID0gdGhpcztcbiAgICAoMCwgdXRpbF8xLmVhY2hJdGVtKShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICAgICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBoYXMgaW52YWxpZCBuYW1lYCk7XG4gICAgfSk7XG4gICAgaWYgKCFkZWYpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZGVmLiRkYXRhICYmICEoXCJjb2RlXCIgaW4gZGVmIHx8IFwidmFsaWRhdGVcIiBpbiBkZWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkUnVsZShrZXl3b3JkLCBkZWZpbml0aW9uLCBkYXRhVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbiA9PT0gbnVsbCB8fCBkZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZpbml0aW9uLnBvc3Q7XG4gICAgaWYgKGRhdGFUeXBlICYmIHBvc3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKTtcbiAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHsgdHlwZTogdCB9KSA9PiB0ID09PSBkYXRhVHlwZSk7XG4gICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdIH07XG4gICAgICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKTtcbiAgICB9XG4gICAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlO1xuICAgIGlmICghZGVmaW5pdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICAgICAgICB0eXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiAoMCwgZGF0YVR5cGVfMS5nZXRKU09OVHlwZXMpKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpXG4gICAgICAgIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKTtcbiAgICBlbHNlXG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGU7XG4gICAgKF9hID0gZGVmaW5pdGlvbi5pbXBsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSk7XG59XG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHJ1bGVHcm91cCwgcnVsZSwgYmVmb3JlKSB7XG4gICAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKGRlZikge1xuICAgIGxldCB7IG1ldGFTY2hlbWEgfSA9IGRlZjtcbiAgICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpXG4gICAgICAgIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSk7XG4gICAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xufVxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn07XG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHsgYW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/core.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/refs/data.json":
/*!**********************************************!*\
  !*** ./node_modules/ajv/dist/refs/data.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst metaSchema = __webpack_require__(/*! ./schema.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/schema.json\");\nconst applicator = __webpack_require__(/*! ./meta/applicator.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json\");\nconst unevaluated = __webpack_require__(/*! ./meta/unevaluated.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json\");\nconst content = __webpack_require__(/*! ./meta/content.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json\");\nconst core = __webpack_require__(/*! ./meta/core.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json\");\nconst format = __webpack_require__(/*! ./meta/format-annotation.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json\");\nconst metadata = __webpack_require__(/*! ./meta/meta-data.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json\");\nconst validation = __webpack_require__(/*! ./meta/validation.json */ \"./node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nfunction addMetaSchema2020($data) {\n    ;\n    [\n        metaSchema,\n        applicator,\n        unevaluated,\n        content,\n        core,\n        with$data(this, format),\n        metadata,\n        with$data(this, validation),\n    ].forEach((sch) => this.addMetaSchema(sch, undefined, false));\n    return this;\n    function with$data(ajv, sch) {\n        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;\n    }\n}\nexports[\"default\"] = addMetaSchema2020;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcmVmcy9qc29uLXNjaGVtYS0yMDIwLTEyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLG1GQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHFHQUF3QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBeUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsK0ZBQXFCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBa0I7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLG1IQUErQjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBdUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMscUdBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9yZWZzL2pzb24tc2NoZW1hLTIwMjAtMTIvaW5kZXguanM/YjcwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG1ldGFTY2hlbWEgPSByZXF1aXJlKFwiLi9zY2hlbWEuanNvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3IgPSByZXF1aXJlKFwiLi9tZXRhL2FwcGxpY2F0b3IuanNvblwiKTtcbmNvbnN0IHVuZXZhbHVhdGVkID0gcmVxdWlyZShcIi4vbWV0YS91bmV2YWx1YXRlZC5qc29uXCIpO1xuY29uc3QgY29udGVudCA9IHJlcXVpcmUoXCIuL21ldGEvY29udGVudC5qc29uXCIpO1xuY29uc3QgY29yZSA9IHJlcXVpcmUoXCIuL21ldGEvY29yZS5qc29uXCIpO1xuY29uc3QgZm9ybWF0ID0gcmVxdWlyZShcIi4vbWV0YS9mb3JtYXQtYW5ub3RhdGlvbi5qc29uXCIpO1xuY29uc3QgbWV0YWRhdGEgPSByZXF1aXJlKFwiLi9tZXRhL21ldGEtZGF0YS5qc29uXCIpO1xuY29uc3QgdmFsaWRhdGlvbiA9IHJlcXVpcmUoXCIuL21ldGEvdmFsaWRhdGlvbi5qc29uXCIpO1xuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXTtcbmZ1bmN0aW9uIGFkZE1ldGFTY2hlbWEyMDIwKCRkYXRhKSB7XG4gICAgO1xuICAgIFtcbiAgICAgICAgbWV0YVNjaGVtYSxcbiAgICAgICAgYXBwbGljYXRvcixcbiAgICAgICAgdW5ldmFsdWF0ZWQsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNvcmUsXG4gICAgICAgIHdpdGgkZGF0YSh0aGlzLCBmb3JtYXQpLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgd2l0aCRkYXRhKHRoaXMsIHZhbGlkYXRpb24pLFxuICAgIF0uZm9yRWFjaCgoc2NoKSA9PiB0aGlzLmFkZE1ldGFTY2hlbWEoc2NoLCB1bmRlZmluZWQsIGZhbHNlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gICAgZnVuY3Rpb24gd2l0aCRkYXRhKGFqdiwgc2NoKSB7XG4gICAgICAgIHJldHVybiAkZGF0YSA/IGFqdi4kZGF0YU1ldGFTY2hlbWEoc2NoLCBNRVRBX1NVUFBPUlRfREFUQSkgOiBzY2g7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gYWRkTWV0YVNjaGVtYTIwMjA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/refs/json-schema-2020-12/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/applicator","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/applicator":true},"$dynamicAnchor":"meta","title":"Applicator vocabulary meta-schema","type":["object","boolean"],"properties":{"prefixItems":{"$ref":"#/$defs/schemaArray"},"items":{"$dynamicRef":"#meta"},"contains":{"$dynamicRef":"#meta"},"additionalProperties":{"$dynamicRef":"#meta"},"properties":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"propertyNames":{"format":"regex"},"default":{}},"dependentSchemas":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"default":{}},"propertyNames":{"$dynamicRef":"#meta"},"if":{"$dynamicRef":"#meta"},"then":{"$dynamicRef":"#meta"},"else":{"$dynamicRef":"#meta"},"allOf":{"$ref":"#/$defs/schemaArray"},"anyOf":{"$ref":"#/$defs/schemaArray"},"oneOf":{"$ref":"#/$defs/schemaArray"},"not":{"$dynamicRef":"#meta"}},"$defs":{"schemaArray":{"type":"array","minItems":1,"items":{"$dynamicRef":"#meta"}}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json":
/*!**************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/content","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/content":true},"$dynamicAnchor":"meta","title":"Content vocabulary meta-schema","type":["object","boolean"],"properties":{"contentEncoding":{"type":"string"},"contentMediaType":{"type":"string"},"contentSchema":{"$dynamicRef":"#meta"}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json":
/*!***********************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/core","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/core":true},"$dynamicAnchor":"meta","title":"Core vocabulary meta-schema","type":["object","boolean"],"properties":{"$id":{"$ref":"#/$defs/uriReferenceString","$comment":"Non-empty fragments not allowed.","pattern":"^[^#]*#?$"},"$schema":{"$ref":"#/$defs/uriString"},"$ref":{"$ref":"#/$defs/uriReferenceString"},"$anchor":{"$ref":"#/$defs/anchorString"},"$dynamicRef":{"$ref":"#/$defs/uriReferenceString"},"$dynamicAnchor":{"$ref":"#/$defs/anchorString"},"$vocabulary":{"type":"object","propertyNames":{"$ref":"#/$defs/uriString"},"additionalProperties":{"type":"boolean"}},"$comment":{"type":"string"},"$defs":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"}}},"$defs":{"anchorString":{"type":"string","pattern":"^[A-Za-z_][-A-Za-z0-9._]*$"},"uriString":{"type":"string","format":"uri"},"uriReferenceString":{"type":"string","format":"uri-reference"}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json":
/*!************************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/format-annotation","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/format-annotation":true},"$dynamicAnchor":"meta","title":"Format vocabulary meta-schema for annotation results","type":["object","boolean"],"properties":{"format":{"type":"string"}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json":
/*!****************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/meta-data","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/meta-data":true},"$dynamicAnchor":"meta","title":"Meta-data vocabulary meta-schema","type":["object","boolean"],"properties":{"title":{"type":"string"},"description":{"type":"string"},"default":true,"deprecated":{"type":"boolean","default":false},"readOnly":{"type":"boolean","default":false},"writeOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json":
/*!******************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/unevaluated","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/unevaluated":true},"$dynamicAnchor":"meta","title":"Unevaluated applicator vocabulary meta-schema","type":["object","boolean"],"properties":{"unevaluatedItems":{"$dynamicRef":"#meta"},"unevaluatedProperties":{"$dynamicRef":"#meta"}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/validation","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/validation":true},"$dynamicAnchor":"meta","title":"Validation vocabulary meta-schema","type":["object","boolean"],"properties":{"type":{"anyOf":[{"$ref":"#/$defs/simpleTypes"},{"type":"array","items":{"$ref":"#/$defs/simpleTypes"},"minItems":1,"uniqueItems":true}]},"const":true,"enum":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/$defs/nonNegativeInteger"},"minLength":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"maxItems":{"$ref":"#/$defs/nonNegativeInteger"},"minItems":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxContains":{"$ref":"#/$defs/nonNegativeInteger"},"minContains":{"$ref":"#/$defs/nonNegativeInteger","default":1},"maxProperties":{"$ref":"#/$defs/nonNegativeInteger"},"minProperties":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"required":{"$ref":"#/$defs/stringArray"},"dependentRequired":{"type":"object","additionalProperties":{"$ref":"#/$defs/stringArray"}}},"$defs":{"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"$ref":"#/$defs/nonNegativeInteger","default":0},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-2020-12/schema.json":
/*!********************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-2020-12/schema.json ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/schema","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/core":true,"https://json-schema.org/draft/2020-12/vocab/applicator":true,"https://json-schema.org/draft/2020-12/vocab/unevaluated":true,"https://json-schema.org/draft/2020-12/vocab/validation":true,"https://json-schema.org/draft/2020-12/vocab/meta-data":true,"https://json-schema.org/draft/2020-12/vocab/format-annotation":true,"https://json-schema.org/draft/2020-12/vocab/content":true},"$dynamicAnchor":"meta","title":"Core and Validation specifications meta-schema","allOf":[{"$ref":"meta/core"},{"$ref":"meta/applicator"},{"$ref":"meta/unevaluated"},{"$ref":"meta/validation"},{"$ref":"meta/meta-data"},{"$ref":"meta/format-annotation"},{"$ref":"meta/content"}],"type":["object","boolean"],"$comment":"This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.","properties":{"definitions":{"$comment":"\\"definitions\\" has been replaced by \\"$defs\\".","type":"object","additionalProperties":{"$dynamicRef":"#meta"},"deprecated":true,"default":{}},"dependencies":{"$comment":"\\"dependencies\\" has been split and replaced by \\"dependentSchemas\\" and \\"dependentRequired\\" in order to serve their differing semantics.","type":"object","additionalProperties":{"anyOf":[{"$dynamicRef":"#meta"},{"$ref":"meta/validation#/$defs/stringArray"}]},"deprecated":true,"default":{}},"$recursiveAnchor":{"$comment":"\\"$recursiveAnchor\\" has been replaced by \\"$dynamicAnchor\\".","$ref":"meta/core#/$defs/anchorString","deprecated":true},"$recursiveRef":{"$comment":"\\"$recursiveRef\\" has been replaced by \\"$dynamicRef\\".","$ref":"meta/core#/$defs/uriReferenceString","deprecated":true}}}');

/***/ }),

/***/ "./node_modules/ajv/dist/refs/json-schema-draft-07.json":
/*!**************************************************************!*\
  !*** ./node_modules/ajv/dist/refs/json-schema-draft-07.json ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

/***/ }),

/***/ "./node_modules/ajv/dist/runtime/equal.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/dist/runtime/equal.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports[\"default\"] = equal;\n//# sourceMappingURL=equal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDdkM7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcz9hNzJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmNvbnN0IGVxdWFsID0gcmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKTtcbmVxdWFsLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSBlcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVxdWFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/runtime/equal.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/runtime/ucs2length.js":
/*!*****************************************************!*\
  !*** ./node_modules/ajv/dist/runtime/ucs2length.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports[\"default\"] = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGguanM/N2FmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/runtime/ucs2length.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/runtime/uri.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/dist/runtime/uri.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uri = __webpack_require__(/*! fast-uri */ \"./node_modules/fast-uri/index.js\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports[\"default\"] = uri;\n//# sourceMappingURL=uri.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91cmkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxtQkFBTyxDQUFDLGtEQUFVO0FBQzlCO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdXJpLmpzPzVjNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1cmkgPSByZXF1aXJlKFwiZmFzdC11cmlcIik7XG51cmkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCc7XG5leHBvcnRzLmRlZmF1bHQgPSB1cmk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/runtime/uri.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/runtime/validation_error.js":
/*!***********************************************************!*\
  !*** ./node_modules/ajv/dist/runtime/validation_error.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports[\"default\"] = ValidationError;\n//# sourceMappingURL=validation_error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcz81NWUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/runtime/validation_error.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalItems.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBLGdCQUFnQixVQUFVLE9BQU8sbURBQW1ELEtBQUs7QUFDekYsZUFBZSxVQUFVLE9BQU8sd0JBQXdCLFNBQVMsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxxQ0FBcUMsS0FBSyxLQUFLLGFBQWE7QUFDNUQ7QUFDQTtBQUNBLDJEQUEyRCxLQUFLLEtBQUssYUFBYSxJQUFJO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLmpzPzczNWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMubGVuZ3RoIH0pO1xuICAgICAgICBjeHQucGFzcygoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApOyAvLyBUT0RPIHZhclxuICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSB7XG4gICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHsga2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuTnVtIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalProperties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBcUI7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBO0FBQ0EsZUFBZSxRQUFRLHdCQUF3QixzQkFBc0IsMkJBQTJCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxNQUFNLHVCQUF1QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLEtBQUssTUFBTSxFQUFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csK0JBQStCLFFBQVEsSUFBSTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLEdBQUcsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hZGRpdGlvbmFsUHJvcGVydGllcy5qcz83NDRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3QgcGF0UHJvcHMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xuICAgICAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZFByb3A7XG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gKDAsIHV0aWxfMS5zY2hlbWFSZWZPclZhbCkoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIik7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSAoMCwgY29kZV8xLmlzT3duUHJvcGVydHkpKGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9ICgwLCBjb2RlZ2VuXzEub3IpKC4uLnByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHtrZXl9ID09PSAke3B9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEubmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmluZWRQcm9wID0gKDAsIGNvZGVnZW5fMS5vcikoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgY29kZV8xLnVzZVBhdHRlcm4pKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm5vdCkoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZSgoMCwgY29kZWdlbl8xLl8pIGBkZWxldGUgJHtkYXRhfVske2tleX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBhZGRpdGlvbmFsUHJvcGVydHk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJmYWlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5TdHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkaXRpb25hbFByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/allOf.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/allOf.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=allOf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDO0FBQzVFO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FsbE9mLmpzP2VmODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIHNjaGVtYS5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGxPZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/allOf.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/anyOf.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/anyOf.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=anyOf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9hbnlPZi5qcz85MjM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhbnlPZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlOiBjb2RlXzEudmFsaWRhdGVVbmlvbixcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggYSBzY2hlbWEgaW4gYW55T2ZcIiB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFueU9mLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/anyOf.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/contains.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/contains.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=contains.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQSxnQkFBZ0IsVUFBVSxZQUFZO0FBQ3RDLHNEQUFzRCxLQUFLO0FBQzNELHNEQUFzRCxLQUFLLG1CQUFtQixLQUFLO0FBQ25GLGVBQWUsVUFBVSxZQUFZLDRDQUE0QyxlQUFlLEtBQUssdUJBQXVCLGVBQWUsSUFBSSxpQkFBaUIsS0FBSztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyxLQUFLLElBQUk7QUFDekQ7QUFDQSwyQ0FBMkMsTUFBTSxLQUFLLEtBQUssS0FBSyxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0EsMkNBQTJDLE9BQU8sS0FBSyxJQUFJO0FBQzNEO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTyxJQUFJLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU8sS0FBSyxJQUFJO0FBQy9EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanM/OGYwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZCA/ICgwLCBjb2RlZ2VuXzEuXykgYHttaW5Db250YWluczogJHttaW59fWAgOiAoMCwgY29kZWdlbl8xLl8pIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgbWluLCBtYXggfSk7XG4gICAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwibWluQ29udGFpbnNcIiA9PSAwIHdpdGhvdXQgXCJtYXhDb250YWluc1wiOiBcImNvbnRhaW5zXCIga2V5d29yZCBpZ25vcmVkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgbGV0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPj0gJHttaW59YDtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGggPiAwYCwgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApO1xuICAgICAgICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZCwgYmxvY2spIHtcbiAgICAgICAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMS5UeXBlLk51bSxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgICAgIGJsb2NrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudCkge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtjb3VudH0rK2ApO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/contains.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/dependencies.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/dependencies.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports[\"default\"] = def;\n//# sourceMappingURL=dependencies.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLGFBQWE7QUFDekUsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDLGFBQWE7QUFDYixnQkFBZ0IsVUFBVSw2QkFBNkI7QUFDdkQ7QUFDQSwrQ0FBK0MsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLFVBQVU7QUFDL0YsS0FBSztBQUNMLGVBQWUsVUFBVSw4Q0FBOEMsd0JBQXdCLFlBQVksU0FBUztBQUNwSCx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLGlCQUFpQixVQUFVO0FBQzNCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsTUFBTSxpREFBaUQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9kZXBlbmRlbmNpZXMuanM/NDE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5IH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcjogZXhwb3J0cy5lcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KTtcbiAgICAgICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcyk7XG4gICAgICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoeyBzY2hlbWEgfSkge1xuICAgIGNvbnN0IHByb3BlcnR5RGVwcyA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYURlcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzO1xuICAgICAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wZXJ0eURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICAgICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXTtcbiAgICAgICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gKDAsIGNvZGVfMS5wcm9wZXJ0eUluRGF0YSkoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNvZGVfMS5jaGVja1JlcG9ydE1pc3NpbmdQcm9wKShjeHQsIGRlcFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7aGFzUHJvcGVydHl9ICYmICgkeygwLCBjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcCkoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICAoMCwgY29kZV8xLnJlcG9ydE1pc3NpbmdQcm9wKShjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9wZXJ0eURlcHMgPSB2YWxpZGF0ZVByb3BlcnR5RGVwcztcbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaGVtYURlcHMgPSBjeHQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hRGVwc1twcm9wXSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/dependencies.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dependencies_1 = __webpack_require__(/*! ./dependencies */ \"./node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst def = {\n    keyword: \"dependentSchemas\",\n    type: \"object\",\n    schemaType: \"object\",\n    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=dependentSchemas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW50U2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVudFNjaGVtYXMuanM/ZDU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW50U2NoZW1hc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlOiAoY3h0KSA9PiAoMCwgZGVwZW5kZW5jaWVzXzEudmFsaWRhdGVTY2hlbWFEZXBzKShjeHQpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVudFNjaGVtYXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/if.js":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/if.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports[\"default\"] = def;\n//# sourceMappingURL=if.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQSxnQkFBZ0IsUUFBUSx1Q0FBdUMsZ0JBQWdCO0FBQy9FLGVBQWUsUUFBUSx3QkFBd0Isa0JBQWtCLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLmpzPzhmZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggXCIke3BhcmFtcy5pZkNsYXVzZX1cIiBzY2hlbWFgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpO1xuICAgICAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIik7XG4gICAgICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIHZhbGlkYXRlSWYoKTtcbiAgICAgICAgY3h0LnJlc2V0KCk7XG4gICAgICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGlmQ2xhdXNlIH0pO1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHNjaFZhbGlkKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQsIGlmQ2xhdXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGlmQ2xhdXNlKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKGlmQ2xhdXNlLCAoMCwgY29kZWdlbl8xLl8pIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICEoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlmLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/if.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst prefixItems_1 = __webpack_require__(/*! ./prefixItems */ \"./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\");\nconst items_1 = __webpack_require__(/*! ./items */ \"./node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst items2020_1 = __webpack_require__(/*! ./items2020 */ \"./node_modules/ajv/dist/vocabularies/applicator/items2020.js\");\nconst contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/ajv/dist/vocabularies/applicator/contains.js\");\nconst dependencies_1 = __webpack_require__(/*! ./dependencies */ \"./node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst propertyNames_1 = __webpack_require__(/*! ./propertyNames */ \"./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst properties_1 = __webpack_require__(/*! ./properties */ \"./node_modules/ajv/dist/vocabularies/applicator/properties.js\");\nconst patternProperties_1 = __webpack_require__(/*! ./patternProperties */ \"./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\");\nconst not_1 = __webpack_require__(/*! ./not */ \"./node_modules/ajv/dist/vocabularies/applicator/not.js\");\nconst anyOf_1 = __webpack_require__(/*! ./anyOf */ \"./node_modules/ajv/dist/vocabularies/applicator/anyOf.js\");\nconst oneOf_1 = __webpack_require__(/*! ./oneOf */ \"./node_modules/ajv/dist/vocabularies/applicator/oneOf.js\");\nconst allOf_1 = __webpack_require__(/*! ./allOf */ \"./node_modules/ajv/dist/vocabularies/applicator/allOf.js\");\nconst if_1 = __webpack_require__(/*! ./if */ \"./node_modules/ajv/dist/vocabularies/applicator/if.js\");\nconst thenElse_1 = __webpack_require__(/*! ./thenElse */ \"./node_modules/ajv/dist/vocabularies/applicator/thenElse.js\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports[\"default\"] = getApplicator;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHFGQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3ZDLHVCQUF1QixtQkFBTyxDQUFDLHVGQUFnQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDakQsK0JBQStCLG1CQUFPLENBQUMsdUdBQXdCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLG1GQUFjO0FBQzNDLDRCQUE0QixtQkFBTyxDQUFDLGlHQUFxQjtBQUN6RCxjQUFjLG1CQUFPLENBQUMscUVBQU87QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLG1FQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pbmRleC5qcz84YmIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBwcmVmaXhJdGVtc18xID0gcmVxdWlyZShcIi4vcHJlZml4SXRlbXNcIik7XG5jb25zdCBpdGVtc18xID0gcmVxdWlyZShcIi4vaXRlbXNcIik7XG5jb25zdCBpdGVtczIwMjBfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zMjAyMFwiKTtcbmNvbnN0IGNvbnRhaW5zXzEgPSByZXF1aXJlKFwiLi9jb250YWluc1wiKTtcbmNvbnN0IGRlcGVuZGVuY2llc18xID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzXCIpO1xuY29uc3QgcHJvcGVydHlOYW1lc18xID0gcmVxdWlyZShcIi4vcHJvcGVydHlOYW1lc1wiKTtcbmNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBwYXR0ZXJuUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcGF0dGVyblByb3BlcnRpZXNcIik7XG5jb25zdCBub3RfMSA9IHJlcXVpcmUoXCIuL25vdFwiKTtcbmNvbnN0IGFueU9mXzEgPSByZXF1aXJlKFwiLi9hbnlPZlwiKTtcbmNvbnN0IG9uZU9mXzEgPSByZXF1aXJlKFwiLi9vbmVPZlwiKTtcbmNvbnN0IGFsbE9mXzEgPSByZXF1aXJlKFwiLi9hbGxPZlwiKTtcbmNvbnN0IGlmXzEgPSByZXF1aXJlKFwiLi9pZlwiKTtcbmNvbnN0IHRoZW5FbHNlXzEgPSByZXF1aXJlKFwiLi90aGVuRWxzZVwiKTtcbmZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpIHtcbiAgICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgICAgICAvLyBhbnlcbiAgICAgICAgbm90XzEuZGVmYXVsdCxcbiAgICAgICAgYW55T2ZfMS5kZWZhdWx0LFxuICAgICAgICBvbmVPZl8xLmRlZmF1bHQsXG4gICAgICAgIGFsbE9mXzEuZGVmYXVsdCxcbiAgICAgICAgaWZfMS5kZWZhdWx0LFxuICAgICAgICB0aGVuRWxzZV8xLmRlZmF1bHQsXG4gICAgICAgIC8vIG9iamVjdFxuICAgICAgICBwcm9wZXJ0eU5hbWVzXzEuZGVmYXVsdCxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgICAgICBkZXBlbmRlbmNpZXNfMS5kZWZhdWx0LFxuICAgICAgICBwcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcGF0dGVyblByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIF07XG4gICAgLy8gYXJyYXlcbiAgICBpZiAoZHJhZnQyMDIwKVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXNfMS5kZWZhdWx0LCBpdGVtczIwMjBfMS5kZWZhdWx0KTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXNfMS5kZWZhdWx0LCBpdGVtc18xLmRlZmF1bHQpO1xuICAgIGFwcGxpY2F0b3IucHVzaChjb250YWluc18xLmRlZmF1bHQpO1xuICAgIHJldHVybiBhcHBsaWNhdG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXBwbGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/items.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/items.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateTuple = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports[\"default\"] = def;\n//# sourceMappingURL=items.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw2REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSyxJQUFJLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxPQUFPLEVBQUUsbUNBQW1DLFlBQVksMENBQTBDLGNBQWM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zLmpzPzIxZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpO1xuICAgICAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKCgwLCBjb2RlXzEudmFsaWRhdGVBcnJheSkoY3h0KSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKGN4dCwgZXh0cmFJdGVtcywgc2NoQXJyID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICBzY2hBcnIuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA+ICR7aX1gLCAoKSA9PiBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sIHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2gpIHtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoIH0gPSBpdDtcbiAgICAgICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYDtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgbXNnLCBvcHRzLnN0cmljdFR1cGxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHVwbGUgPSB2YWxpZGF0ZVR1cGxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/items.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/items2020.js":
/*!********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/items2020.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=items2020.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw2REFBUztBQUNoQywwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDckQ7QUFDQSxnQkFBZ0IsVUFBVSxPQUFPLG1EQUFtRCxLQUFLO0FBQ3pGLGVBQWUsVUFBVSxPQUFPLHdCQUF3QixTQUFTLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaXRlbXMyMDIwLmpzPzlhZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGxlbiB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtsZW59fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IHByZWZpeEl0ZW1zIH0gPSBwYXJlbnRTY2hlbWE7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICAoMCwgYWRkaXRpb25hbEl0ZW1zXzEudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMpKGN4dCwgcHJlZml4SXRlbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjeHQub2soKDAsIGNvZGVfMS52YWxpZGF0ZUFycmF5KShjeHQpKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW1zMjAyMC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/items2020.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/not.js":
/*!**************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/not.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=not.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivbm90LmpzP2UxN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/not.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/oneOf.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/oneOf.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=oneOf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQTtBQUNBLGVBQWUsUUFBUSx3QkFBd0Isa0JBQWtCLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxLQUFLLE1BQU07QUFDckU7QUFDQSw4REFBOEQsUUFBUSxJQUFJLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL29uZU9mLmpzPzMwMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEFyciA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwYXNzaW5nIH0pO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuICAgICAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZik7XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCkge1xuICAgICAgICAgICAgc2NoQXJyLmZvckVhY2goKHNjaCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzY2hDeHQ7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAuaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsICgwLCBjb2RlZ2VuXzEuXykgYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuZWxzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hDeHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25lT2YuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/oneOf.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst util_2 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=patternProperties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcGF0dGVyblByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsTUFBTSxrQkFBa0IsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlDQUFpQyxRQUFRLElBQUk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHVEQUF1RCxNQUFNLEdBQUcsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLmpzPzhhOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzIH0gPSBpdDtcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSAoMCwgY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMpKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+ICgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9IG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9ICgwLCB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUpKGdlbiwgaXQucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGl0O1xuICAgICAgICB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdCBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpOyAvLyBUT0RPIHZhclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKHZhbGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAkeygwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBwYXQpfS50ZXN0KCR7a2V5fSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsd2F5c1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzIuVHlwZS5TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgcHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oKDAsIGNvZGVnZW5fMS5fKSBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm5Qcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst items_1 = __webpack_require__(/*! ./items */ \"./node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=prefixItems.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMuanM/MmMxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+ICgwLCBpdGVtc18xLnZhbGlkYXRlVHVwbGUpKGN4dCwgXCJpdGVtc1wiKSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhJdGVtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/properties.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/properties.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ../../compile/validate */ \"./node_modules/ajv/dist/compile/validate/index.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=properties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBd0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0MsK0JBQStCLG1CQUFPLENBQUMsdUdBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0NBQXNDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0aWVzLmpzPzFjYWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LmNvZGUobmV3IHZhbGlkYXRlXzEuS2V5d29yZEN4dChpdCwgYWRkaXRpb25hbFByb3BlcnRpZXNfMS5kZWZhdWx0LCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxQcm9wcyA9ICgwLCBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcykoc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICAgICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sICgwLCB1dGlsXzEudG9IYXNoKShhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYVtwXSkpO1xuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpO1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHByb3AsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IHByb3AsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/properties.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js":
/*!************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=propertyNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBO0FBQ0EsZUFBZSxRQUFRLHdCQUF3QixnQkFBZ0IscUJBQXFCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcm9wZXJ0eU5hbWVzLmpzPzhjNWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEpKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcHJvcGVydHlOYW1lOiBrZXkgfSk7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/applicator/thenElse.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/applicator/thenElse.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=thenElse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBLGdEQUFnRCxRQUFRO0FBQ3hELEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS5qcz80ZjViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGNvZGUoeyBrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0IH0pIHtcbiAgICAgICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhlbkVsc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/applicator/thenElse.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/code.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/code.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = __webpack_require__(/*! ../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst util_2 = __webpack_require__(/*! ../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsOEJBQThCO0FBQ2hWLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFvQjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsZ0VBQWlCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFrQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsZ0VBQWlCO0FBQ3hDO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSx3QkFBd0IscUNBQXFDLEtBQUssR0FBRztBQUNyRTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEIsaUJBQWlCLFFBQVE7QUFDckQsdUpBQXVKLFNBQVMsSUFBSSxLQUFLO0FBQ3pLO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwrQkFBK0IsaUJBQWlCLFFBQVEsS0FBSyxJQUFJLFNBQVM7QUFDMUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQ0FBcUMsS0FBSyxFQUFFLHNDQUFzQztBQUNsRiwrQ0FBK0MsTUFBTSxLQUFLLG1DQUFtQztBQUM3RjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFDQUFxQyxLQUFLLEVBQUUsc0NBQXNDO0FBQ2xGO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw0QkFBNEIsd0JBQXdCLDBDQUEwQyxNQUFNO0FBQ3BHLDJEQUEyRCxXQUFXLElBQUksS0FBSyxJQUFJLGFBQWEsRUFBRSxXQUFXO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYyxJQUFJLHNCQUFzQjtBQUM3RSwyREFBMkQsS0FBSyxRQUFRLFFBQVEsSUFBSSxLQUFLLHlCQUF5QixLQUFLLEdBQUcsS0FBSztBQUMvSDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQixXQUFXLFFBQVE7QUFDekM7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEVBQTRFLEdBQUcsUUFBUSxJQUFJLEVBQUU7QUFDL0gsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4Q0FBOEMsT0FBTyxLQUFLLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvZGUuanM/ZGQ3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVVbmlvbiA9IGV4cG9ydHMudmFsaWRhdGVBcnJheSA9IGV4cG9ydHMudXNlUGF0dGVybiA9IGV4cG9ydHMuY2FsbFZhbGlkYXRlQ29kZSA9IGV4cG9ydHMuc2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IGV4cG9ydHMucHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLmlzT3duUHJvcGVydHkgPSBleHBvcnRzLmhhc1Byb3BGdW5jID0gZXhwb3J0cy5yZXBvcnRNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tNaXNzaW5nUHJvcCA9IGV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgdXRpbF8yID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cHJvcH1gIH0sIHRydWUpO1xuICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCA9IGNoZWNrUmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKHsgZ2VuLCBkYXRhLCBpdDogeyBvcHRzIH0gfSwgcHJvcGVydGllcywgbWlzc2luZykge1xuICAgIHJldHVybiAoMCwgY29kZWdlbl8xLm9yKSguLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gKDAsIGNvZGVnZW5fMS5hbmQpKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoMCwgY29kZWdlbl8xLl8pIGAke21pc3Npbmd9ID0gJHtwcm9wfWApKSk7XG59XG5leHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBjaGVja01pc3NpbmdQcm9wO1xuZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9LCB0cnVlKTtcbiAgICBjeHQuZXJyb3IoKTtcbn1cbmV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSByZXBvcnRNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbikge1xuICAgIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgY29kZTogKDAsIGNvZGVnZW5fMS5fKSBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gICAgfSk7XG59XG5leHBvcnRzLmhhc1Byb3BGdW5jID0gaGFzUHJvcEZ1bmM7XG5mdW5jdGlvbiBpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9JHsoMCwgY29kZWdlbl8xLmdldFByb3BlcnR5KShwcm9wZXJ0eSl9ICE9PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYDtcbiAgICByZXR1cm4gb3duUHJvcGVydGllcyA/ICgwLCBjb2RlZ2VuXzEub3IpKGNvbmQsICgwLCBjb2RlZ2VuXzEubm90KShpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kO1xufVxuZXhwb3J0cy5ub1Byb3BlcnR5SW5EYXRhID0gbm9Qcm9wZXJ0eUluRGF0YTtcbmZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKSB7XG4gICAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdO1xufVxuZXhwb3J0cy5hbGxTY2hlbWFQcm9wZXJ0aWVzID0gYWxsU2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQsIHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYU1hcFtwXSkpO1xufVxuZXhwb3J0cy5zY2hlbWFQcm9wZXJ0aWVzID0gc2NoZW1hUHJvcGVydGllcztcbmZ1bmN0aW9uIGNhbGxWYWxpZGF0ZUNvZGUoeyBzY2hlbWFDb2RlLCBkYXRhLCBpdDogeyBnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRoIH0sIGl0IH0sIGZ1bmMsIGNvbnRleHQsIHBhc3NTY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/ICgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCAoMCwgY29kZWdlbl8xLnN0ckNvbmNhdCkobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhLCBuYW1lc18xLmRlZmF1bHQucm9vdERhdGFdLFxuICAgIF07XG4gICAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZilcbiAgICAgICAgdmFsQ3h0LnB1c2goW25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9ycywgbmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzXSk7XG4gICAgY29uc3QgYXJncyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWA7XG4gICAgcmV0dXJuIGNvbnRleHQgIT09IGNvZGVnZW5fMS5uaWwgPyAoMCwgY29kZWdlbl8xLl8pIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmdW5jfSgke2FyZ3N9KWA7XG59XG5leHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBjYWxsVmFsaWRhdGVDb2RlO1xuY29uc3QgbmV3UmVnRXhwID0gKDAsIGNvZGVnZW5fMS5fKSBgbmV3IFJlZ0V4cGA7XG5mdW5jdGlvbiB1c2VQYXR0ZXJuKHsgZ2VuLCBpdDogeyBvcHRzIH0gfSwgcGF0dGVybikge1xuICAgIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgY29uc3QgeyByZWdFeHAgfSA9IG9wdHMuY29kZTtcbiAgICBjb25zdCByeCA9IHJlZ0V4cChwYXR0ZXJuLCB1KTtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiByeC50b1N0cmluZygpLFxuICAgICAgICByZWY6IHJ4LFxuICAgICAgICBjb2RlOiAoMCwgY29kZWdlbl8xLl8pIGAke3JlZ0V4cC5jb2RlID09PSBcIm5ldyBSZWdFeHBcIiA/IG5ld1JlZ0V4cCA6ICgwLCB1dGlsXzIudXNlRnVuYykoZ2VuLCByZWdFeHApfSgke3BhdHRlcm59LCAke3V9KWAsXG4gICAgfSk7XG59XG5leHBvcnRzLnVzZVBhdHRlcm4gPSB1c2VQYXR0ZXJuO1xuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdmFsaWRBcnI7XG4gICAgfVxuICAgIGdlbi52YXIodmFsaWQsIHRydWUpO1xuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKG5vdFZhbGlkKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgbm90VmFsaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQXJyYXkgPSB2YWxpZGF0ZUFycmF5O1xuZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoKSA9PiAoMCwgdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKShpdCwgc2NoKSk7XG4gICAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIik7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHNjaGVtYS5mb3JFYWNoKChfc2NoLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlZ2VuXzEuXykgYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLm5vdCkodmFsaWQpKTtcbiAgICB9KSk7XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCksICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSB2YWxpZGF0ZVVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/code.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/id.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/core/id.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanM/ZWRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImlkXCIsXG4gICAgY29kZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/core/id.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/core/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst id_1 = __webpack_require__(/*! ./id */ \"./node_modules/ajv/dist/vocabularies/core/id.js\");\nconst ref_1 = __webpack_require__(/*! ./ref */ \"./node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports[\"default\"] = core;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDZEQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQywrREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQkFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaW5kZXguanM/ZmU4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGlkXzEgPSByZXF1aXJlKFwiLi9pZFwiKTtcbmNvbnN0IHJlZl8xID0gcmVxdWlyZShcIi4vcmVmXCIpO1xuY29uc3QgY29yZSA9IFtcbiAgICBcIiRzY2hlbWFcIixcbiAgICBcIiRpZFwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcIiR2b2NhYnVsYXJ5XCIsXG4gICAgeyBrZXl3b3JkOiBcIiRjb21tZW50XCIgfSxcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgaWRfMS5kZWZhdWx0LFxuICAgIHJlZl8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/core/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/core/ref.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/core/ref.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"./node_modules/ajv/dist/compile/ref_error.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"./node_modules/ajv/dist/compile/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports[\"default\"] = def;\n//# sourceMappingURL=ref.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxtQkFBbUI7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQXlCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyw2REFBUztBQUNoQyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscUVBQXFCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFlO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGdCQUFnQixtREFBbUQ7QUFDbkUsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixnREFBZ0QsSUFBSSxVQUFVO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRCw4QkFBOEIsNEJBQTRCLFVBQVUsRUFBRTtBQUN0RTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4Q0FBOEM7QUFDN0YsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUNBQXlDLEdBQUcsYUFBYSxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hELGdFQUFnRSx5QkFBeUIsYUFBYSxNQUFNLElBQUksd0JBQXdCLFVBQVUsS0FBSyxLQUFLO0FBQzVKLCtEQUErRCx3QkFBd0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzPzEyODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGxSZWYgPSBleHBvcnRzLmdldFZhbGlkYXRlID0gdm9pZCAwO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCIkcmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hOiAkcmVmLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IGJhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZiB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IHsgcm9vdCB9ID0gZW52O1xuICAgICAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZClcbiAgICAgICAgICAgIHJldHVybiBjYWxsUm9vdFJlZigpO1xuICAgICAgICBjb25zdCBzY2hPckVudiA9IGNvbXBpbGVfMS5yZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmX2Vycm9yXzEuZGVmYXVsdChpdC5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsICRyZWYpO1xuICAgICAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudik7XG4gICAgICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpO1xuICAgICAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpIHtcbiAgICAgICAgICAgIGlmIChlbnYgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYyk7XG4gICAgICAgICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7IHJlZjogcm9vdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IGdldFZhbGlkYXRlKGN4dCwgc2NoKTtcbiAgICAgICAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInNjaGVtYVwiLCBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8geyByZWY6IHNjaCwgY29kZTogKDAsIGNvZGVnZW5fMS5zdHJpbmdpZnkpKHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwgeyByZWY6IHNjaCB9KX0udmFsaWRhdGVgO1xufVxuZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IGdldFZhbGlkYXRlO1xuZnVuY3Rpb24gY2FsbFJlZihjeHQsIHYsIHNjaCwgJGFzeW5jKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBhbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogY29kZWdlbl8xLm5pbDtcbiAgICBpZiAoJGFzeW5jKVxuICAgICAgICBjYWxsQXN5bmNSZWYoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhbGxTeW5jUmVmKCk7XG4gICAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCkge1xuICAgICAgICBpZiAoIWVudi4kYXN5bmMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGdlbi50cnkoKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgYXdhaXQgJHsoMCwgY29kZV8xLmNhbGxWYWxpZGF0ZUNvZGUpKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9KWAsICgpID0+IGdlbi50aHJvdyhlKSk7XG4gICAgICAgICAgICBhZGRFcnJvcnNGcm9tKGUpO1xuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKSB7XG4gICAgICAgIGN4dC5yZXN1bHQoKDAsIGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKShjeHQsIHYsIHBhc3NDeHQpLCAoKSA9PiBhZGRFdmFsdWF0ZWRGcm9tKHYpLCAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgZXJycyA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKTsgLy8gVE9ETyB0YWdnZWRcbiAgICAgICAgZ2VuLmFzc2lnbihuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoMCwgY29kZWdlbl8xLl8pIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfS5sZW5ndGhgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IChfYSA9IHNjaCA9PT0gbnVsbCB8fCBzY2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaC52YWxpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2YWx1YXRlZDtcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvclxuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hFdmFsdWF0ZWQucHJvcHMsIGl0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCAoMCwgY29kZWdlbl8xLl8pIGAke3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYCk7XG4gICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY2FsbFJlZiA9IGNhbGxSZWY7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/core/ref.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/discriminator/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/discriminator/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst types_1 = __webpack_require__(/*! ../discriminator/types */ \"./node_modules/ajv/dist/vocabularies/discriminator/types.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"./node_modules/ajv/dist/compile/index.js\");\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"./node_modules/ajv/dist/compile/ref_error.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDJGQUF3QjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQywrREFBZTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBeUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQztBQUNBLGdCQUFnQixVQUFVLHVCQUF1QjtBQUNqRCxrQkFBa0IsUUFBUTtBQUMxQiwyQkFBMkIsUUFBUTtBQUNuQyxlQUFlLFVBQVUsNEJBQTRCLHdCQUF3QixTQUFTLFdBQVcsU0FBUyxRQUFRLGNBQWMsS0FBSztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLLEVBQUUsb0NBQW9DO0FBQ3BHLDBDQUEwQyxLQUFLLGdFQUFnRSxrREFBa0Q7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLLE1BQU0sU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQXNEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILFFBQVE7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcz8zMDA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiKTtcbmNvbnN0IGNvbXBpbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlXCIpO1xuY29uc3QgcmVmX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZ05hbWUgfSB9KSA9PiBkaXNjckVycm9yID09PSB0eXBlc18xLkRpc2NyRXJyb3IuVGFnXG4gICAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgICAgOiBgdmFsdWUgb2YgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgaW4gb25lT2ZgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IGRpc2NyRXJyb3IsIHRhZywgdGFnTmFtZSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkodGFnTmFtZSl9YCk7XG4gICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZigoMCwgY29kZWdlbl8xLl8pIGAke3RhZ30gPT09ICR7dGFnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICBjeHQuZXJyb3IoZmFsc2UsIHsgZGlzY3JFcnJvcjogdHlwZXNfMS5EaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZSB9KTtcbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHsga2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wIH0sIF92YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBvbmVPZk1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLiRyZWYpICYmICEoMCwgdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKShzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNjaC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHJlZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2ggaW5zdGFuY2VvZiBjb21waWxlXzEuU2NoZW1hRW52KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoID0gc2NoLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCByZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wU2NoID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0YWdOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSk7XG4gICAgICAgICAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhZ1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApO1xuICAgICAgICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZztcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHsgcmVxdWlyZWQgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/discriminator/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/discriminator/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/discriminator/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3IvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUIsa0JBQWtCLGtCQUFrQjtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLmpzP2FiZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpc2NyRXJyb3IgPSB2b2lkIDA7XG52YXIgRGlzY3JFcnJvcjtcbihmdW5jdGlvbiAoRGlzY3JFcnJvcikge1xuICAgIERpc2NyRXJyb3JbXCJUYWdcIl0gPSBcInRhZ1wiO1xuICAgIERpc2NyRXJyb3JbXCJNYXBwaW5nXCJdID0gXCJtYXBwaW5nXCI7XG59KShEaXNjckVycm9yIHx8IChleHBvcnRzLkRpc2NyRXJyb3IgPSBEaXNjckVycm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/discriminator/types.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/draft2020.js":
/*!*********************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/draft2020.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core_1 = __webpack_require__(/*! ./core */ \"./node_modules/ajv/dist/vocabularies/core/index.js\");\nconst validation_1 = __webpack_require__(/*! ./validation */ \"./node_modules/ajv/dist/vocabularies/validation/index.js\");\nconst applicator_1 = __webpack_require__(/*! ./applicator */ \"./node_modules/ajv/dist/vocabularies/applicator/index.js\");\nconst dynamic_1 = __webpack_require__(/*! ./dynamic */ \"./node_modules/ajv/dist/vocabularies/dynamic/index.js\");\nconst next_1 = __webpack_require__(/*! ./next */ \"./node_modules/ajv/dist/vocabularies/next.js\");\nconst unevaluated_1 = __webpack_require__(/*! ./unevaluated */ \"./node_modules/ajv/dist/vocabularies/unevaluated/index.js\");\nconst format_1 = __webpack_require__(/*! ./format */ \"./node_modules/ajv/dist/vocabularies/format/index.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"./node_modules/ajv/dist/vocabularies/metadata.js\");\nconst draft2020Vocabularies = [\n    dynamic_1.default,\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(true),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n    next_1.default,\n    unevaluated_1.default,\n];\nexports[\"default\"] = draft2020Vocabularies;\n//# sourceMappingURL=draft2020.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0MjAyMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsa0VBQVE7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsd0VBQVc7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDREQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFlO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0MjAyMC5qcz8yZjI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBhcHBsaWNhdG9yXzEgPSByZXF1aXJlKFwiLi9hcHBsaWNhdG9yXCIpO1xuY29uc3QgZHluYW1pY18xID0gcmVxdWlyZShcIi4vZHluYW1pY1wiKTtcbmNvbnN0IG5leHRfMSA9IHJlcXVpcmUoXCIuL25leHRcIik7XG5jb25zdCB1bmV2YWx1YXRlZF8xID0gcmVxdWlyZShcIi4vdW5ldmFsdWF0ZWRcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0MjAyMFZvY2FidWxhcmllcyA9IFtcbiAgICBkeW5hbWljXzEuZGVmYXVsdCxcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKHRydWUpLFxuICAgIGZvcm1hdF8xLmRlZmF1bHQsXG4gICAgbWV0YWRhdGFfMS5tZXRhZGF0YVZvY2FidWxhcnksXG4gICAgbWV0YWRhdGFfMS5jb250ZW50Vm9jYWJ1bGFyeSxcbiAgICBuZXh0XzEuZGVmYXVsdCxcbiAgICB1bmV2YWx1YXRlZF8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gZHJhZnQyMDIwVm9jYWJ1bGFyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZnQyMDIwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/draft2020.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/draft7.js":
/*!******************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/draft7.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core_1 = __webpack_require__(/*! ./core */ \"./node_modules/ajv/dist/vocabularies/core/index.js\");\nconst validation_1 = __webpack_require__(/*! ./validation */ \"./node_modules/ajv/dist/vocabularies/validation/index.js\");\nconst applicator_1 = __webpack_require__(/*! ./applicator */ \"./node_modules/ajv/dist/vocabularies/applicator/index.js\");\nconst format_1 = __webpack_require__(/*! ./format */ \"./node_modules/ajv/dist/vocabularies/format/index.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"./node_modules/ajv/dist/vocabularies/metadata.js\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports[\"default\"] = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsa0VBQVE7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsOEVBQWM7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZHJhZnQ3LmpzPzAwNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbmNvbnN0IGFwcGxpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0b3JcIik7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllcyA9IFtcbiAgICBjb3JlXzEuZGVmYXVsdCxcbiAgICB2YWxpZGF0aW9uXzEuZGVmYXVsdCxcbiAgICAoMCwgYXBwbGljYXRvcl8xLmRlZmF1bHQpKCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/draft7.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dynamicAnchor = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"./node_modules/ajv/dist/compile/index.js\");\nconst ref_1 = __webpack_require__(/*! ../core/ref */ \"./node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst def = {\n    keyword: \"$dynamicAnchor\",\n    schemaType: \"string\",\n    code: (cxt) => dynamicAnchor(cxt, cxt.schema),\n};\nfunction dynamicAnchor(cxt, anchor) {\n    const { gen, it } = cxt;\n    it.schemaEnv.root.dynamicAnchors[anchor] = true;\n    const v = (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;\n    const validate = it.errSchemaPath === \"#\" ? it.validateName : _getValidate(cxt);\n    gen.if((0, codegen_1._) `!${v}`, () => gen.assign(v, validate));\n}\nexports.dynamicAnchor = dynamicAnchor;\nfunction _getValidate(cxt) {\n    const { schemaEnv, schema, self } = cxt.it;\n    const { root, baseId, localRefs, meta } = schemaEnv.root;\n    const { schemaId } = self.opts;\n    const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });\n    compile_1.compileSchema.call(self, sch);\n    return (0, ref_1.getValidate)(cxt, sch);\n}\nexports[\"default\"] = def;\n//# sourceMappingURL=dynamicAnchor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvZHluYW1pY0FuY2hvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHFFQUFxQjtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQywrREFBZTtBQUN6QyxjQUFjLG1CQUFPLENBQUMscUVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0Esa0NBQWtDLCtCQUErQixFQUFFLG1DQUFtQztBQUN0RztBQUNBLGdDQUFnQyxFQUFFO0FBQ2xDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEMsWUFBWSxnQ0FBZ0M7QUFDNUMsWUFBWSxXQUFXO0FBQ3ZCLDBDQUEwQyxpREFBaUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9keW5hbWljL2R5bmFtaWNBbmNob3IuanM/MWY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZHluYW1pY0FuY2hvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZVwiKTtcbmNvbnN0IHJlZl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcmVmXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJGR5bmFtaWNBbmNob3JcIixcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgIGNvZGU6IChjeHQpID0+IGR5bmFtaWNBbmNob3IoY3h0LCBjeHQuc2NoZW1hKSxcbn07XG5mdW5jdGlvbiBkeW5hbWljQW5jaG9yKGN4dCwgYW5jaG9yKSB7XG4gICAgY29uc3QgeyBnZW4sIGl0IH0gPSBjeHQ7XG4gICAgaXQuc2NoZW1hRW52LnJvb3QuZHluYW1pY0FuY2hvcnNbYW5jaG9yXSA9IHRydWU7XG4gICAgY29uc3QgdiA9ICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoYW5jaG9yKX1gO1xuICAgIGNvbnN0IHZhbGlkYXRlID0gaXQuZXJyU2NoZW1hUGF0aCA9PT0gXCIjXCIgPyBpdC52YWxpZGF0ZU5hbWUgOiBfZ2V0VmFsaWRhdGUoY3h0KTtcbiAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgISR7dn1gLCAoKSA9PiBnZW4uYXNzaWduKHYsIHZhbGlkYXRlKSk7XG59XG5leHBvcnRzLmR5bmFtaWNBbmNob3IgPSBkeW5hbWljQW5jaG9yO1xuZnVuY3Rpb24gX2dldFZhbGlkYXRlKGN4dCkge1xuICAgIGNvbnN0IHsgc2NoZW1hRW52LCBzY2hlbWEsIHNlbGYgfSA9IGN4dC5pdDtcbiAgICBjb25zdCB7IHJvb3QsIGJhc2VJZCwgbG9jYWxSZWZzLCBtZXRhIH0gPSBzY2hlbWFFbnYucm9vdDtcbiAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSBzZWxmLm9wdHM7XG4gICAgY29uc3Qgc2NoID0gbmV3IGNvbXBpbGVfMS5TY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQsIGxvY2FsUmVmcywgbWV0YSB9KTtcbiAgICBjb21waWxlXzEuY29tcGlsZVNjaGVtYS5jYWxsKHNlbGYsIHNjaCk7XG4gICAgcmV0dXJuICgwLCByZWZfMS5nZXRWYWxpZGF0ZSkoY3h0LCBzY2gpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pY0FuY2hvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js":
/*!******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dynamicRef = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst ref_1 = __webpack_require__(/*! ../core/ref */ \"./node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst def = {\n    keyword: \"$dynamicRef\",\n    schemaType: \"string\",\n    code: (cxt) => dynamicRef(cxt, cxt.schema),\n};\nfunction dynamicRef(cxt, ref) {\n    const { gen, keyword, it } = cxt;\n    if (ref[0] !== \"#\")\n        throw new Error(`\"${keyword}\" only supports hash fragment reference`);\n    const anchor = ref.slice(1);\n    if (it.allErrors) {\n        _dynamicRef();\n    }\n    else {\n        const valid = gen.let(\"valid\", false);\n        _dynamicRef(valid);\n        cxt.ok(valid);\n    }\n    function _dynamicRef(valid) {\n        // TODO the assumption here is that `recursiveRef: #` always points to the root\n        // of the schema object, which is not correct, because there may be $id that\n        // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n        // Because of that 2 tests in recursiveRef.json fail.\n        // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n        // (This problem is not tested in JSON-Schema-Test-Suite)\n        if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n            const v = gen.let(\"_v\", (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);\n            gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));\n        }\n        else {\n            _callRef(it.validateName, valid)();\n        }\n    }\n    function _callRef(validate, valid) {\n        return valid\n            ? () => gen.block(() => {\n                (0, ref_1.callRef)(cxt, validate);\n                gen.let(valid, true);\n            })\n            : () => (0, ref_1.callRef)(cxt, validate);\n    }\n}\nexports.dynamicRef = dynamicRef;\nexports[\"default\"] = def;\n//# sourceMappingURL=dynamicRef.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvZHluYW1pY1JlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHFFQUFxQjtBQUM3QyxjQUFjLG1CQUFPLENBQUMscUVBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTtBQUNBLHdEQUF3RCwrQkFBK0IsRUFBRSxtQ0FBbUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9keW5hbWljL2R5bmFtaWNSZWYuanM/MWM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZHluYW1pY1JlZiA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCByZWZfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3JlZlwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIiRkeW5hbWljUmVmXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICBjb2RlOiAoY3h0KSA9PiBkeW5hbWljUmVmKGN4dCwgY3h0LnNjaGVtYSksXG59O1xuZnVuY3Rpb24gZHluYW1pY1JlZihjeHQsIHJlZikge1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGlmIChyZWZbMF0gIT09IFwiI1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl3b3JkfVwiIG9ubHkgc3VwcG9ydHMgaGFzaCBmcmFnbWVudCByZWZlcmVuY2VgKTtcbiAgICBjb25zdCBhbmNob3IgPSByZWYuc2xpY2UoMSk7XG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICBfZHluYW1pY1JlZigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBfZHluYW1pY1JlZih2YWxpZCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9keW5hbWljUmVmKHZhbGlkKSB7XG4gICAgICAgIC8vIFRPRE8gdGhlIGFzc3VtcHRpb24gaGVyZSBpcyB0aGF0IGByZWN1cnNpdmVSZWY6ICNgIGFsd2F5cyBwb2ludHMgdG8gdGhlIHJvb3RcbiAgICAgICAgLy8gb2YgdGhlIHNjaGVtYSBvYmplY3QsIHdoaWNoIGlzIG5vdCBjb3JyZWN0LCBiZWNhdXNlIHRoZXJlIG1heSBiZSAkaWQgdGhhdFxuICAgICAgICAvLyBtYWtlcyAjIHBvaW50IHRvIGl0LCBhbmQgdGhlIHRhcmdldCBzY2hlbWEgbWF5IG5vdCBjb250YWluIGR5bmFtaWMvcmVjdXJzaXZlQW5jaG9yLlxuICAgICAgICAvLyBCZWNhdXNlIG9mIHRoYXQgMiB0ZXN0cyBpbiByZWN1cnNpdmVSZWYuanNvbiBmYWlsLlxuICAgICAgICAvLyBUaGlzIGlzIGEgc2ltaWxhciBwcm9ibGVtIHRvICM4MTUgKGAkaWRgIGRvZXNuJ3QgYWx0ZXIgcmVzb2x1dGlvbiBzY29wZSBmb3IgYHsgXCIkcmVmXCI6IFwiI1wiIH1gKS5cbiAgICAgICAgLy8gKFRoaXMgcHJvYmxlbSBpcyBub3QgdGVzdGVkIGluIEpTT04tU2NoZW1hLVRlc3QtU3VpdGUpXG4gICAgICAgIGlmIChpdC5zY2hlbWFFbnYucm9vdC5keW5hbWljQW5jaG9yc1thbmNob3JdKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2VuLmxldChcIl92XCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoYW5jaG9yKX1gKTtcbiAgICAgICAgICAgIGdlbi5pZih2LCBfY2FsbFJlZih2LCB2YWxpZCksIF9jYWxsUmVmKGl0LnZhbGlkYXRlTmFtZSwgdmFsaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9jYWxsUmVmKGl0LnZhbGlkYXRlTmFtZSwgdmFsaWQpKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2NhbGxSZWYodmFsaWRhdGUsIHZhbGlkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZFxuICAgICAgICAgICAgPyAoKSA9PiBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCByZWZfMS5jYWxsUmVmKShjeHQsIHZhbGlkYXRlKTtcbiAgICAgICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6ICgpID0+ICgwLCByZWZfMS5jYWxsUmVmKShjeHQsIHZhbGlkYXRlKTtcbiAgICB9XG59XG5leHBvcnRzLmR5bmFtaWNSZWYgPSBkeW5hbWljUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pY1JlZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/dynamic/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/dynamic/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dynamicAnchor_1 = __webpack_require__(/*! ./dynamicAnchor */ \"./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js\");\nconst dynamicRef_1 = __webpack_require__(/*! ./dynamicRef */ \"./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js\");\nconst recursiveAnchor_1 = __webpack_require__(/*! ./recursiveAnchor */ \"./node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js\");\nconst recursiveRef_1 = __webpack_require__(/*! ./recursiveRef */ \"./node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js\");\nconst dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];\nexports[\"default\"] = dynamic;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0M7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvaW5kZXguanM/MGY4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGR5bmFtaWNBbmNob3JfMSA9IHJlcXVpcmUoXCIuL2R5bmFtaWNBbmNob3JcIik7XG5jb25zdCBkeW5hbWljUmVmXzEgPSByZXF1aXJlKFwiLi9keW5hbWljUmVmXCIpO1xuY29uc3QgcmVjdXJzaXZlQW5jaG9yXzEgPSByZXF1aXJlKFwiLi9yZWN1cnNpdmVBbmNob3JcIik7XG5jb25zdCByZWN1cnNpdmVSZWZfMSA9IHJlcXVpcmUoXCIuL3JlY3Vyc2l2ZVJlZlwiKTtcbmNvbnN0IGR5bmFtaWMgPSBbZHluYW1pY0FuY2hvcl8xLmRlZmF1bHQsIGR5bmFtaWNSZWZfMS5kZWZhdWx0LCByZWN1cnNpdmVBbmNob3JfMS5kZWZhdWx0LCByZWN1cnNpdmVSZWZfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGR5bmFtaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/dynamic/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dynamicAnchor_1 = __webpack_require__(/*! ./dynamicAnchor */ \"./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"$recursiveAnchor\",\n    schemaType: \"boolean\",\n    code(cxt) {\n        if (cxt.schema)\n            (0, dynamicAnchor_1.dynamicAnchor)(cxt, \"\");\n        else\n            (0, util_1.checkStrictMode)(cxt.it, \"$recursiveAnchor: false is ignored\");\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=recursiveAnchor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvcmVjdXJzaXZlQW5jaG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvcmVjdXJzaXZlQW5jaG9yLmpzPzczZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkeW5hbWljQW5jaG9yXzEgPSByZXF1aXJlKFwiLi9keW5hbWljQW5jaG9yXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIiRyZWN1cnNpdmVBbmNob3JcIixcbiAgICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBpZiAoY3h0LnNjaGVtYSlcbiAgICAgICAgICAgICgwLCBkeW5hbWljQW5jaG9yXzEuZHluYW1pY0FuY2hvcikoY3h0LCBcIlwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgKDAsIHV0aWxfMS5jaGVja1N0cmljdE1vZGUpKGN4dC5pdCwgXCIkcmVjdXJzaXZlQW5jaG9yOiBmYWxzZSBpcyBpZ25vcmVkXCIpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjdXJzaXZlQW5jaG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js":
/*!********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dynamicRef_1 = __webpack_require__(/*! ./dynamicRef */ \"./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js\");\nconst def = {\n    keyword: \"$recursiveRef\",\n    schemaType: \"string\",\n    code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=recursiveRef.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvcmVjdXJzaXZlUmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2R5bmFtaWMvcmVjdXJzaXZlUmVmLmpzPzg1ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkeW5hbWljUmVmXzEgPSByZXF1aXJlKFwiLi9keW5hbWljUmVmXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZTogKGN4dCkgPT4gKDAsIGR5bmFtaWNSZWZfMS5keW5hbWljUmVmKShjeHQsIGN4dC5zY2hlbWEpLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY3Vyc2l2ZVJlZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/format/format.js":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/format/format.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=format.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pEO0FBQ0EsZ0JBQWdCLFlBQVksOENBQThDLFdBQVc7QUFDckYsZUFBZSxZQUFZLHdCQUF3QixVQUFVLFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0QsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrREFBK0QsS0FBSyxHQUFHLFdBQVc7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sbUJBQW1CLE1BQU0saUVBQWlFLEtBQUssdURBQXVELEtBQUs7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWSxNQUFNLE9BQU87QUFDcEU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEtBQUssaUJBQWlCLE9BQU8sR0FBRyxLQUFLLE1BQU0sT0FBTyxHQUFHLEtBQUs7QUFDckcsMENBQTBDLE9BQU8sR0FBRyxLQUFLO0FBQ3pELDhEQUE4RCxRQUFRLGtCQUFrQixZQUFZLElBQUksT0FBTyxRQUFRLEtBQUs7QUFDNUgsMkNBQTJDLFFBQVEsS0FBSyxRQUFRLGNBQWMsT0FBTyxNQUFNLFVBQVUsTUFBTSxVQUFVO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTywrQkFBK0IsY0FBYztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCLEVBQUUsbUNBQW1DO0FBQ3JHO0FBQ0Esd0RBQXdELGdDQUFnQztBQUN4RjtBQUNBLDBGQUEwRixJQUFJO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU8sR0FBRyxLQUFLO0FBQ3BFO0FBQ0EseUVBQXlFLE9BQU8sR0FBRyxLQUFLLHlCQUF5QixPQUFPLFFBQVEsS0FBSztBQUNySTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LmpzPzZlYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICAgIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0LCBydWxlVHlwZSkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGYgfSA9IGl0O1xuICAgICAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoJGRhdGEpXG4gICAgICAgICAgICB2YWxpZGF0ZSREYXRhRm9ybWF0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbGlkYXRlRm9ybWF0KCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRzfVske3NjaGVtYUNvZGV9XWApO1xuICAgICAgICAgICAgY29uc3QgZlR5cGUgPSBnZW4ubGV0KFwiZlR5cGVcIik7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgKDAsIGNvZGVnZW5fMS5fKSBgJHtmRGVmfS52YWxpZGF0ZWApLCAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCAoMCwgY29kZWdlbl8xLl8pIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLm9yKSh1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLm5pbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRGbXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZERhdGEgPSAoMCwgY29kZWdlbl8xLl8pIGAodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNvZGVnZW5fMS5fKSBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLnJlZ2V4cENvZGUpKGZtdERlZilcbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgY29kZWdlbl8xLl8pIGAke29wdHMuY29kZS5mb3JtYXRzfSR7KDAsIGNvZGVnZW5fMS5nZXRQcm9wZXJ0eSkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsICgwLCBjb2RlZ2VuXzEuXykgYCR7Zm10fS52YWxpZGF0ZWBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLl8pIGBhd2FpdCAke2ZtdFJlZn0oJHtkYXRhfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyAoMCwgY29kZWdlbl8xLl8pIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/format/format.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/format/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/format/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst format_1 = __webpack_require__(/*! ./format */ \"./node_modules/ajv/dist/vocabularies/format/format.js\");\nconst format = [format_1.default];\nexports[\"default\"] = format;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBVTtBQUNuQztBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LmpzPzc0MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcbmNvbnN0IGZvcm1hdCA9IFtmb3JtYXRfMS5kZWZhdWx0XTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZvcm1hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/format/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/metadata.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/metadata.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDBCQUEwQjtBQUN0RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL21ldGFkYXRhLmpzPzM3YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gZXhwb3J0cy5tZXRhZGF0YVZvY2FidWxhcnkgPSB2b2lkIDA7XG5leHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IFtcbiAgICBcInRpdGxlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVwcmVjYXRlZFwiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcIndyaXRlT25seVwiLFxuICAgIFwiZXhhbXBsZXNcIixcbl07XG5leHBvcnRzLmNvbnRlbnRWb2NhYnVsYXJ5ID0gW1xuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/metadata.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/next.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/next.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dependentRequired_1 = __webpack_require__(/*! ./validation/dependentRequired */ \"./node_modules/ajv/dist/vocabularies/validation/dependentRequired.js\");\nconst dependentSchemas_1 = __webpack_require__(/*! ./applicator/dependentSchemas */ \"./node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js\");\nconst limitContains_1 = __webpack_require__(/*! ./validation/limitContains */ \"./node_modules/ajv/dist/vocabularies/validation/limitContains.js\");\nconst next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];\nexports[\"default\"] = next;\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL25leHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLG1CQUFPLENBQUMsNEdBQWdDO0FBQ3BFLDJCQUEyQixtQkFBTyxDQUFDLDBHQUErQjtBQUNsRSx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDNUQ7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL25leHQuanM/YjFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlcGVuZGVudFJlcXVpcmVkXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uL2RlcGVuZGVudFJlcXVpcmVkXCIpO1xuY29uc3QgZGVwZW5kZW50U2NoZW1hc18xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvci9kZXBlbmRlbnRTY2hlbWFzXCIpO1xuY29uc3QgbGltaXRDb250YWluc18xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvbi9saW1pdENvbnRhaW5zXCIpO1xuY29uc3QgbmV4dCA9IFtkZXBlbmRlbnRSZXF1aXJlZF8xLmRlZmF1bHQsIGRlcGVuZGVudFNjaGVtYXNfMS5kZWZhdWx0LCBsaW1pdENvbnRhaW5zXzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBuZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/next.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/unevaluated/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/unevaluated/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst unevaluatedProperties_1 = __webpack_require__(/*! ./unevaluatedProperties */ \"./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js\");\nconst unevaluatedItems_1 = __webpack_require__(/*! ./unevaluatedItems */ \"./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js\");\nconst unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];\nexports[\"default\"] = unevaluated;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3VuZXZhbHVhdGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLDBHQUF5QjtBQUNqRSwyQkFBMkIsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDdkQ7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3VuZXZhbHVhdGVkL2luZGV4LmpzPzFjZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1bmV2YWx1YXRlZFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3VuZXZhbHVhdGVkUHJvcGVydGllc1wiKTtcbmNvbnN0IHVuZXZhbHVhdGVkSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuZXZhbHVhdGVkSXRlbXNcIik7XG5jb25zdCB1bmV2YWx1YXRlZCA9IFt1bmV2YWx1YXRlZFByb3BlcnRpZXNfMS5kZWZhdWx0LCB1bmV2YWx1YXRlZEl0ZW1zXzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSB1bmV2YWx1YXRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/unevaluated/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"unevaluatedItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        const items = it.items || 0;\n        if (items === true)\n            return;\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        if (schema === false) {\n            cxt.setParams({ len: items });\n            cxt.fail((0, codegen_1._) `${len} > ${items}`);\n        }\n        else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n            const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items}`);\n            gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));\n            cxt.ok(valid);\n        }\n        it.items = true;\n        function validateItems(valid, from) {\n            gen.forRange(\"i\", from, len, (i) => {\n                cxt.subschema({ keyword: \"unevaluatedItems\", dataProp: i, dataPropType: util_1.Type.Num }, valid);\n                if (!it.allErrors)\n                    gen.if((0, codegen_1.not)(valid), () => gen.break());\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=unevaluatedItems.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3VuZXZhbHVhdGVkL3VuZXZhbHVhdGVkSXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0M7QUFDQSxnQkFBZ0IsVUFBVSxPQUFPLG1EQUFtRCxLQUFLO0FBQ3pGLGVBQWUsVUFBVSxPQUFPLHdCQUF3QixTQUFTLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMseUNBQXlDLEtBQUssSUFBSSxNQUFNO0FBQ3hEO0FBQ0E7QUFDQSwrREFBK0QsS0FBSyxLQUFLLE1BQU07QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlFQUF5RTtBQUN6RztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy91bmV2YWx1YXRlZC91bmV2YWx1YXRlZEl0ZW1zLmpzP2VmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJ1bmV2YWx1YXRlZEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBpdC5pdGVtcyB8fCAwO1xuICAgICAgICBpZiAoaXRlbXMgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGxlbjogaXRlbXMgfSk7XG4gICAgICAgICAgICBjeHQuZmFpbCgoMCwgY29kZWdlbl8xLl8pIGAke2xlbn0gPiAke2l0ZW1zfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLnZhcihcInZhbGlkXCIsICgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSA8PSAke2l0ZW1zfWApO1xuICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQsIGl0ZW1zKSk7XG4gICAgICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZCwgZnJvbSkge1xuICAgICAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBmcm9tLCBsZW4sIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwidW5ldmFsdWF0ZWRJdGVtc1wiLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5ub3QpKHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXZhbHVhdGVkSXRlbXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"./node_modules/ajv/dist/compile/names.js\");\nconst error = {\n    message: \"must NOT have unevaluated properties\",\n    params: ({ params }) => (0, codegen_1._) `{unevaluatedProperty: ${params.unevaluatedProperty}}`,\n};\nconst def = {\n    keyword: \"unevaluatedProperties\",\n    type: \"object\",\n    schemaType: [\"boolean\", \"object\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, props } = it;\n        if (props instanceof codegen_1.Name) {\n            gen.if((0, codegen_1._) `${props} !== true`, () => gen.forIn(\"key\", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));\n        }\n        else if (props !== true) {\n            gen.forIn(\"key\", data, (key) => props === undefined\n                ? unevaluatedPropCode(key)\n                : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));\n        }\n        it.props = true;\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function unevaluatedPropCode(key) {\n            if (schema === false) {\n                cxt.setParams({ unevaluatedProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (!(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                cxt.subschema({\n                    keyword: \"unevaluatedProperties\",\n                    dataProp: key,\n                    dataPropType: util_1.Type.Str,\n                }, valid);\n                if (!allErrors)\n                    gen.if((0, codegen_1.not)(valid), () => gen.break());\n            }\n        }\n        function unevaluatedDynamic(evaluatedProps, key) {\n            return (0, codegen_1._) `!${evaluatedProps} || !${evaluatedProps}[${key}]`;\n        }\n        function unevaluatedStatic(evaluatedProps, key) {\n            const ps = [];\n            for (const p in evaluatedProps) {\n                if (evaluatedProps[p] === true)\n                    ps.push((0, codegen_1._) `${key} !== ${p}`);\n            }\n            return (0, codegen_1.and)(...ps);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=unevaluatedProperties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3VuZXZhbHVhdGVkL3VuZXZhbHVhdGVkUHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBcUI7QUFDN0M7QUFDQTtBQUNBLGVBQWUsUUFBUSx3QkFBd0IsdUJBQXVCLDRCQUE0QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxNQUFNLHVCQUF1QjtBQUMzRTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCLE1BQU0sZUFBZSxHQUFHLElBQUk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLE1BQU0sRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3VuZXZhbHVhdGVkL3VuZXZhbHVhdGVkUHJvcGVydGllcy5qcz84M2E3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgdW5ldmFsdWF0ZWQgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHt1bmV2YWx1YXRlZFByb3BlcnR5OiAke3BhcmFtcy51bmV2YWx1YXRlZFByb3BlcnR5fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuZXZhbHVhdGVkUHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWVycnNDb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgeyBhbGxFcnJvcnMsIHByb3BzIH0gPSBpdDtcbiAgICAgICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpIHtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke3Byb3BzfSAhPT0gdHJ1ZWAsICgpID0+IGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiBnZW4uaWYodW5ldmFsdWF0ZWREeW5hbWljKHByb3BzLCBrZXkpLCAoKSA9PiB1bmV2YWx1YXRlZFByb3BDb2RlKGtleSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiBwcm9wcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB1bmV2YWx1YXRlZFByb3BDb2RlKGtleSlcbiAgICAgICAgICAgICAgICA6IGdlbi5pZih1bmV2YWx1YXRlZFN0YXRpYyhwcm9wcywga2V5KSwgKCkgPT4gdW5ldmFsdWF0ZWRQcm9wQ29kZShrZXkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXQucHJvcHMgPSB0cnVlO1xuICAgICAgICBjeHQub2soKDAsIGNvZGVnZW5fMS5fKSBgJHtlcnJzQ291bnR9ID09PSAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9YCk7XG4gICAgICAgIGZ1bmN0aW9uIHVuZXZhbHVhdGVkUHJvcENvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyB1bmV2YWx1YXRlZFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYSkoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bmV2YWx1YXRlZER5bmFtaWMoZXZhbHVhdGVkUHJvcHMsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuXykgYCEke2V2YWx1YXRlZFByb3BzfSB8fCAhJHtldmFsdWF0ZWRQcm9wc31bJHtrZXl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5ldmFsdWF0ZWRTdGF0aWMoZXZhbHVhdGVkUHJvcHMsIGtleSkge1xuICAgICAgICAgICAgY29uc3QgcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBldmFsdWF0ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChldmFsdWF0ZWRQcm9wc1twXSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcHMucHVzaCgoMCwgY29kZWdlbl8xLl8pIGAke2tleX0gIT09ICR7cH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLmFuZCkoLi4ucHMpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmV2YWx1YXRlZFByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/const.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/const.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"./node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=const.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vY29uc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMscUVBQXFCO0FBQzdDO0FBQ0E7QUFDQSxlQUFlLFlBQVksd0JBQXdCLGdCQUFnQixZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQSwrQ0FBK0MsMENBQTBDLEdBQUcsS0FBSyxJQUFJLFdBQVc7QUFDaEg7QUFDQTtBQUNBLHlDQUF5QyxRQUFRLE1BQU0sS0FBSztBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcz9hNTcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcXVhbF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YSgoMCwgY29kZWdlbl8xLl8pIGAhJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCgwLCBjb2RlZ2VuXzEuXykgYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/const.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/dependentRequired.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/dependentRequired.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dependencies_1 = __webpack_require__(/*! ../applicator/dependencies */ \"./node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst def = {\n    keyword: \"dependentRequired\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: dependencies_1.error,\n    code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=dependentRequired.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZGVwZW5kZW50UmVxdWlyZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsbUdBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2RlcGVuZGVudFJlcXVpcmVkLmpzP2FkNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuLi9hcHBsaWNhdG9yL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImRlcGVuZGVudFJlcXVpcmVkXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBkZXBlbmRlbmNpZXNfMS5lcnJvcixcbiAgICBjb2RlOiAoY3h0KSA9PiAoMCwgZGVwZW5kZW5jaWVzXzEudmFsaWRhdGVQcm9wZXJ0eURlcHMpKGN4dCksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwZW5kZW50UmVxdWlyZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/dependentRequired.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/enum.js":
/*!***************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/enum.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"./node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vZW51bS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLG1FQUFvQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBcUI7QUFDN0M7QUFDQTtBQUNBLGVBQWUsWUFBWSx3QkFBd0IsaUJBQWlCLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsU0FBUyxHQUFHLEtBQUssSUFBSSxFQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVMsR0FBRyxLQUFLLElBQUksUUFBUSxHQUFHLEVBQUU7QUFDeEUsc0NBQXNDLE1BQU0sTUFBTSxJQUFJO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2VudW0uanM/Y2U5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJlbnVtXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIik7XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW07XG4gICAgICAgIGxldCBlcWw7XG4gICAgICAgIGNvbnN0IGdldEVxbCA9ICgpID0+IChlcWwgIT09IG51bGwgJiYgZXFsICE9PSB2b2lkIDAgPyBlcWwgOiAoZXFsID0gKDAsIHV0aWxfMS51c2VGdW5jKShnZW4sIGVxdWFsXzEuZGVmYXVsdCkpKTtcbiAgICAgICAgbGV0IHZhbGlkO1xuICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKTtcbiAgICAgICAgICAgIHZhbGlkID0gKDAsIGNvZGVnZW5fMS5vcikoLi4uc2NoZW1hLm1hcCgoX3gsIGkpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gbG9vcEVudW0oKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUsICh2KSA9PiBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWEsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9ID09PSAke3NjaH1gO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/enum.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst limitNumber_1 = __webpack_require__(/*! ./limitNumber */ \"./node_modules/ajv/dist/vocabularies/validation/limitNumber.js\");\nconst multipleOf_1 = __webpack_require__(/*! ./multipleOf */ \"./node_modules/ajv/dist/vocabularies/validation/multipleOf.js\");\nconst limitLength_1 = __webpack_require__(/*! ./limitLength */ \"./node_modules/ajv/dist/vocabularies/validation/limitLength.js\");\nconst pattern_1 = __webpack_require__(/*! ./pattern */ \"./node_modules/ajv/dist/vocabularies/validation/pattern.js\");\nconst limitProperties_1 = __webpack_require__(/*! ./limitProperties */ \"./node_modules/ajv/dist/vocabularies/validation/limitProperties.js\");\nconst required_1 = __webpack_require__(/*! ./required */ \"./node_modules/ajv/dist/vocabularies/validation/required.js\");\nconst limitItems_1 = __webpack_require__(/*! ./limitItems */ \"./node_modules/ajv/dist/vocabularies/validation/limitItems.js\");\nconst uniqueItems_1 = __webpack_require__(/*! ./uniqueItems */ \"./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\");\nconst const_1 = __webpack_require__(/*! ./const */ \"./node_modules/ajv/dist/vocabularies/validation/const.js\");\nconst enum_1 = __webpack_require__(/*! ./enum */ \"./node_modules/ajv/dist/vocabularies/validation/enum.js\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports[\"default\"] = validation;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMscUZBQWU7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsbUZBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMscUZBQWU7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsNkVBQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLG1GQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLHFGQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFTO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBa0Q7QUFDeEQsTUFBTSw0Q0FBNEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzP2EyMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsaW1pdE51bWJlcl8xID0gcmVxdWlyZShcIi4vbGltaXROdW1iZXJcIik7XG5jb25zdCBtdWx0aXBsZU9mXzEgPSByZXF1aXJlKFwiLi9tdWx0aXBsZU9mXCIpO1xuY29uc3QgbGltaXRMZW5ndGhfMSA9IHJlcXVpcmUoXCIuL2xpbWl0TGVuZ3RoXCIpO1xuY29uc3QgcGF0dGVybl8xID0gcmVxdWlyZShcIi4vcGF0dGVyblwiKTtcbmNvbnN0IGxpbWl0UHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vbGltaXRQcm9wZXJ0aWVzXCIpO1xuY29uc3QgcmVxdWlyZWRfMSA9IHJlcXVpcmUoXCIuL3JlcXVpcmVkXCIpO1xuY29uc3QgbGltaXRJdGVtc18xID0gcmVxdWlyZShcIi4vbGltaXRJdGVtc1wiKTtcbmNvbnN0IHVuaXF1ZUl0ZW1zXzEgPSByZXF1aXJlKFwiLi91bmlxdWVJdGVtc1wiKTtcbmNvbnN0IGNvbnN0XzEgPSByZXF1aXJlKFwiLi9jb25zdFwiKTtcbmNvbnN0IGVudW1fMSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5jb25zdCB2YWxpZGF0aW9uID0gW1xuICAgIC8vIG51bWJlclxuICAgIGxpbWl0TnVtYmVyXzEuZGVmYXVsdCxcbiAgICBtdWx0aXBsZU9mXzEuZGVmYXVsdCxcbiAgICAvLyBzdHJpbmdcbiAgICBsaW1pdExlbmd0aF8xLmRlZmF1bHQsXG4gICAgcGF0dGVybl8xLmRlZmF1bHQsXG4gICAgLy8gb2JqZWN0XG4gICAgbGltaXRQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICByZXF1aXJlZF8xLmRlZmF1bHQsXG4gICAgLy8gYXJyYXlcbiAgICBsaW1pdEl0ZW1zXzEuZGVmYXVsdCxcbiAgICB1bmlxdWVJdGVtc18xLmRlZmF1bHQsXG4gICAgLy8gYW55XG4gICAgeyBrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl0gfSxcbiAgICB7IGtleXdvcmQ6IFwibnVsbGFibGVcIiwgc2NoZW1hVHlwZTogXCJib29sZWFuXCIgfSxcbiAgICBjb25zdF8xLmRlZmF1bHQsXG4gICAgZW51bV8xLmRlZmF1bHQsXG5dO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/index.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitContains.js":
/*!************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/limitContains.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: [\"maxContains\", \"minContains\"],\n    type: \"array\",\n    schemaType: \"number\",\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.contains === undefined) {\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"contains\" is ignored`);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitContains.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRDb250YWlucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdENvbnRhaW5zLmpzP2I5YTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heENvbnRhaW5zXCIsIFwibWluQ29udGFpbnNcIl0sXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgY29kZSh7IGtleXdvcmQsIHBhcmVudFNjaGVtYSwgaXQgfSkge1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hLmNvbnRhaW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJjb250YWluc1wiIGlzIGlnbm9yZWRgKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRDb250YWlucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/limitContains.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitItems.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/limitItems.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitItems.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQ7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLG1EQUFtRCxNQUFNLE9BQU8sWUFBWTtBQUM1RSxLQUFLO0FBQ0wsZUFBZSxZQUFZLHdCQUF3QixTQUFTLFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQSwwQ0FBMEMsS0FBSyxVQUFVLElBQUksRUFBRSxXQUFXO0FBQzFFLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdEl0ZW1zLmpzPzlmYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZSh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkge1xuICAgICAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuXykgYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0SXRlbXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/limitItems.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitLength.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/limitLength.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst ucs2length_1 = __webpack_require__(/*! ../../runtime/ucs2length */ \"./node_modules/ajv/dist/runtime/ucs2length.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitLength.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRMZW5ndGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBb0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsK0VBQTBCO0FBQ3ZEO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxtREFBbUQsTUFBTSxPQUFPLFlBQVk7QUFDNUUsS0FBSztBQUNMLGVBQWUsWUFBWSx3QkFBd0IsU0FBUyxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0Esb0VBQW9FLEtBQUssK0JBQStCLG1EQUFtRCxHQUFHLEtBQUs7QUFDbkssMENBQTBDLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVztBQUNsRSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRMZW5ndGguanM/MzA0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjb25zdCBsZW4gPSBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfS5sZW5ndGhgIDogKDAsIGNvZGVnZW5fMS5fKSBgJHsoMCwgdXRpbF8xLnVzZUZ1bmMpKGN4dC5nZW4sIHVjczJsZW5ndGhfMS5kZWZhdWx0KX0oJHtkYXRhfSlgO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/limitLength.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitNumber.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/limitNumber.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitNumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXROdW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pEO0FBQ0E7QUFDQSxlQUFlLHdDQUF3QztBQUN2RCxlQUFlLHdDQUF3QztBQUN2RCx3QkFBd0IsdUNBQXVDO0FBQy9ELHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUIsbUNBQW1DLHFCQUFxQixFQUFFLFdBQVc7QUFDMUcsZUFBZSxxQkFBcUIsd0JBQXdCLGNBQWMsb0JBQW9CLFdBQVcsWUFBWTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QywwQ0FBMEMsTUFBTSxFQUFFLG9CQUFvQixFQUFFLFlBQVksV0FBVyxLQUFLO0FBQ3BHLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci5qcz84MjlmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IG9wcyA9IGNvZGVnZW5fMS5vcGVyYXRvcnM7XG5jb25zdCBLV0RzID0ge1xuICAgIG1heGltdW06IHsgb2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVCB9LFxuICAgIG1pbmltdW06IHsgb2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVCB9LFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IHsgb2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFIH0sXG4gICAgZXhjbHVzaXZlTWluaW11bTogeyBva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEUgfSxcbn07XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmRdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSB9ID0gY3h0O1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCR7ZGF0YX0gJHtLV0RzW2tleXdvcmRdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0TnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/limitNumber.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/limitProperties.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/limitProperties.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitProperties.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRDtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsbURBQW1ELE1BQU0sT0FBTyxZQUFZO0FBQzVFLEtBQUs7QUFDTCxlQUFlLFlBQVksd0JBQXdCLFNBQVMsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBLHNEQUFzRCxLQUFLLFdBQVcsSUFBSSxFQUFFLFdBQVc7QUFDdkYsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0UHJvcGVydGllcy5qcz84NGZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gcHJvcGVydGllc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdFByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/limitProperties.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/multipleOf.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/multipleOf.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=multipleOf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBdUI7QUFDakQ7QUFDQSxnQkFBZ0IsWUFBWSwrQ0FBK0MsV0FBVztBQUN0RixlQUFlLFlBQVksd0JBQXdCLGNBQWMsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxJQUFJLE1BQU0sSUFBSSxTQUFTLEtBQUs7QUFDbEYsa0NBQWtDLEtBQUssZUFBZSxJQUFJO0FBQzFELDJDQUEyQyxZQUFZLFlBQVksS0FBSyxJQUFJLEtBQUssR0FBRyxXQUFXLElBQUksUUFBUTtBQUMzRyxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi5qcz8wMmRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICAgICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgICAgICAgID8gKDAsIGNvZGVnZW5fMS5fKSBgTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICAgICAgICA6ICgwLCBjb2RlZ2VuXzEuXykgYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoKDAsIGNvZGVnZW5fMS5fKSBgKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZU9mLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/multipleOf.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/pattern.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsNkRBQVM7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2pEO0FBQ0EsZ0JBQWdCLFlBQVksK0NBQStDLFdBQVc7QUFDdEYsZUFBZSxZQUFZLHdCQUF3QixXQUFXLFlBQVk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBLCtEQUErRCxXQUFXLElBQUksRUFBRTtBQUNoRiwyQ0FBMkMsT0FBTyxRQUFRLEtBQUs7QUFDL0QsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanM/M2FmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gKDAsIGNvZGVnZW5fMS5zdHIpIGBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gKDAsIGNvZGVnZW5fMS5fKSBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6ICgwLCBjb2RlXzEudXNlUGF0dGVybikoY3h0LCBzY2hlbWEpO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKCgwLCBjb2RlZ2VuXzEuXykgYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/pattern.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/required.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/required.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"./node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=required.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcmVxdWlyZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLDZEQUFTO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDO0FBQ0EsZ0JBQWdCLFVBQVUsbUJBQW1CLHdEQUF3RCxnQkFBZ0I7QUFDckgsZUFBZSxVQUFVLG1CQUFtQix3QkFBd0IsbUJBQW1CLGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZLHVCQUF1QixXQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzPzZkYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+ICgwLCBjb2RlZ2VuXzEuc3RyKSBgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiAoMCwgY29kZWdlbl8xLl8pIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZSkoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKSB7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKGNvZGVnZW5fMS5uaWwsIGxvb3BBbGxSZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCkoY3h0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCkge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpO1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpO1xuICAgICAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5jaGVja01pc3NpbmdQcm9wKShjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgICgwLCBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3ApKGN4dCwgbWlzc2luZyk7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKSB7XG4gICAgICAgICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogcHJvcCB9KTtcbiAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgpID0+IGN4dC5lcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSk7XG4gICAgICAgICAgICBnZW4uZm9yT2YobWlzc2luZywgc2NoZW1hQ29kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsICgwLCBjb2RlXzEucHJvcGVydHlJbkRhdGEpKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKCgwLCBjb2RlZ2VuXzEubm90KSh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVpcmVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/required.js\n\n}");

/***/ }),

/***/ "./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dataType_1 = __webpack_require__(/*! ../../compile/validate/dataType */ \"./node_modules/ajv/dist/compile/validate/dataType.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"./node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"./node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"./node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=uniqueItems.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsNkZBQWlDO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLCtFQUF1QjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsbUVBQW9CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHFFQUFxQjtBQUM3QztBQUNBLGdCQUFnQixVQUFVLFFBQVEsbUVBQW1FLEdBQUcsTUFBTSxHQUFHO0FBQ2pILGVBQWUsVUFBVSxRQUFRLHdCQUF3QixLQUFLLEVBQUUsT0FBTyxHQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFlBQVk7QUFDbkY7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSx1Q0FBdUMsRUFBRSxFQUFFLEdBQUc7QUFDOUMsa0RBQWtELEtBQUssR0FBRyxFQUFFO0FBQzVEO0FBQ0E7QUFDQSxzREFBc0QsTUFBTSxrQ0FBa0MsTUFBTTtBQUNwRztBQUNBLG1EQUFtRCxRQUFRLEdBQUcsS0FBSztBQUNuRSxzREFBc0QsUUFBUSxHQUFHLEtBQUs7QUFDdEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw4Q0FBOEMsUUFBUSxHQUFHLEtBQUssTUFBTSxFQUFFO0FBQ3RFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFLEVBQUUsR0FBRyxxQ0FBcUMsR0FBRyxJQUFJLElBQUksRUFBRSxFQUFFLEdBQUcsb0NBQW9DLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRSxLQUFLLEtBQUssR0FBRyxFQUFFO0FBQ3RMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMuanM/Y2Q4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiAoMCwgY29kZWdlbl8xLnN0cikgYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBpLCBqIH0gfSkgPT4gKDAsIGNvZGVnZW5fMS5fKSBge2k6ICR7aX0sIGo6ICR7an19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICBpZiAoISRkYXRhICYmICFzY2hlbWEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyAoMCwgZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcykocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgKDAsIGNvZGVnZW5fMS5fKSBgJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCAoMCwgY29kZWdlbl8xLl8pIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpO1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IGksIGogfSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgIGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gKDAsIGRhdGFUeXBlXzEuY2hlY2tEYXRhVHlwZXMpKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8xLkRhdGFUeXBlLldyb25nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsICgwLCBjb2RlZ2VuXzEuXykgYHt9YCk7XG4gICAgICAgICAgICBnZW4uZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgKDAsIGNvZGVnZW5fMS5fKSBgJHtkYXRhfVske2l9XWApO1xuICAgICAgICAgICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgwLCBjb2RlZ2VuXzEuXykgYGNvbnRpbnVlYCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoKDAsIGNvZGVnZW5fMS5fKSBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsICgwLCBjb2RlZ2VuXzEuXykgYCR7aXRlbX0gKz0gXCJfXCJgKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmlmKCgwLCBjb2RlZ2VuXzEuXykgYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaiwgKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoKDAsIGNvZGVnZW5fMS5fKSBgJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BOMihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBlcWwgPSAoMCwgdXRpbF8xLnVzZUZ1bmMpKGdlbiwgZXF1YWxfMS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKTtcbiAgICAgICAgICAgIGdlbi5sYWJlbChvdXRlcikuZm9yKCgwLCBjb2RlZ2VuXzEuXykgYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcigoMCwgY29kZWdlbl8xLl8pIGAke2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+IGdlbi5pZigoMCwgY29kZWdlbl8xLl8pIGAke2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZUl0ZW1zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\n\n}");

/***/ }),

/***/ "./node_modules/atomically/dist/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/atomically/dist/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_ENCODING: () => (/* binding */ DEFAULT_ENCODING),\n/* harmony export */   DEFAULT_FILE_MODE: () => (/* binding */ DEFAULT_FILE_MODE),\n/* harmony export */   DEFAULT_FOLDER_MODE: () => (/* binding */ DEFAULT_FOLDER_MODE),\n/* harmony export */   DEFAULT_READ_OPTIONS: () => (/* binding */ DEFAULT_READ_OPTIONS),\n/* harmony export */   DEFAULT_TIMEOUT_ASYNC: () => (/* binding */ DEFAULT_TIMEOUT_ASYNC),\n/* harmony export */   DEFAULT_TIMEOUT_SYNC: () => (/* binding */ DEFAULT_TIMEOUT_SYNC),\n/* harmony export */   DEFAULT_USER_GID: () => (/* binding */ DEFAULT_USER_GID),\n/* harmony export */   DEFAULT_USER_UID: () => (/* binding */ DEFAULT_USER_UID),\n/* harmony export */   DEFAULT_WRITE_OPTIONS: () => (/* binding */ DEFAULT_WRITE_OPTIONS),\n/* harmony export */   IS_POSIX: () => (/* binding */ IS_POSIX),\n/* harmony export */   IS_USER_ROOT: () => (/* binding */ IS_USER_ROOT),\n/* harmony export */   LIMIT_BASENAME_LENGTH: () => (/* binding */ LIMIT_BASENAME_LENGTH),\n/* harmony export */   LIMIT_FILES_DESCRIPTORS: () => (/* binding */ LIMIT_FILES_DESCRIPTORS),\n/* harmony export */   NOOP: () => (/* binding */ NOOP)\n/* harmony export */ });\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:os */ \"node:os\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* IMPORT */\n\n\n/* MAIN */\nconst DEFAULT_ENCODING = 'utf8';\nconst DEFAULT_FILE_MODE = 0o666;\nconst DEFAULT_FOLDER_MODE = 0o777;\nconst DEFAULT_READ_OPTIONS = {};\nconst DEFAULT_WRITE_OPTIONS = {};\nconst DEFAULT_USER_UID = node_os__WEBPACK_IMPORTED_MODULE_0__.userInfo().uid;\nconst DEFAULT_USER_GID = node_os__WEBPACK_IMPORTED_MODULE_0__.userInfo().gid;\nconst DEFAULT_TIMEOUT_ASYNC = 7500;\nconst DEFAULT_TIMEOUT_SYNC = 1000;\nconst IS_POSIX = !!node_process__WEBPACK_IMPORTED_MODULE_1__.getuid;\nconst IS_USER_ROOT = node_process__WEBPACK_IMPORTED_MODULE_1__.getuid ? !node_process__WEBPACK_IMPORTED_MODULE_1__.getuid() : false;\nconst LIMIT_BASENAME_LENGTH = 128; //TODO: Fetch the real limit from the filesystem //TODO: Fetch the whole-path length limit too\nconst LIMIT_FILES_DESCRIPTORS = 10000; //TODO: Fetch the real limit from the filesystem\nconst NOOP = () => { };\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDeUI7QUFDVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVc7QUFDcEMseUJBQXlCLDZDQUFXO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWM7QUFDakMscUJBQXFCLGdEQUFjLElBQUksZ0RBQWM7QUFDckQsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2QztBQUNBO0FBQ2dSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2NvbnN0YW50cy5qcz81NTlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IG9zIGZyb20gJ25vZGU6b3MnO1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbi8qIE1BSU4gKi9cbmNvbnN0IERFRkFVTFRfRU5DT0RJTkcgPSAndXRmOCc7XG5jb25zdCBERUZBVUxUX0ZJTEVfTU9ERSA9IDBvNjY2O1xuY29uc3QgREVGQVVMVF9GT0xERVJfTU9ERSA9IDBvNzc3O1xuY29uc3QgREVGQVVMVF9SRUFEX09QVElPTlMgPSB7fTtcbmNvbnN0IERFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IHt9O1xuY29uc3QgREVGQVVMVF9VU0VSX1VJRCA9IG9zLnVzZXJJbmZvKCkudWlkO1xuY29uc3QgREVGQVVMVF9VU0VSX0dJRCA9IG9zLnVzZXJJbmZvKCkuZ2lkO1xuY29uc3QgREVGQVVMVF9USU1FT1VUX0FTWU5DID0gNzUwMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9TWU5DID0gMTAwMDtcbmNvbnN0IElTX1BPU0lYID0gISFwcm9jZXNzLmdldHVpZDtcbmNvbnN0IElTX1VTRVJfUk9PVCA9IHByb2Nlc3MuZ2V0dWlkID8gIXByb2Nlc3MuZ2V0dWlkKCkgOiBmYWxzZTtcbmNvbnN0IExJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IDEyODsgLy9UT0RPOiBGZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtIC8vVE9ETzogRmV0Y2ggdGhlIHdob2xlLXBhdGggbGVuZ3RoIGxpbWl0IHRvb1xuY29uc3QgTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSAxMDAwMDsgLy9UT0RPOiBGZXRjaCB0aGUgcmVhbCBsaW1pdCBmcm9tIHRoZSBmaWxlc3lzdGVtXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuLyogRVhQT1JUICovXG5leHBvcnQgeyBERUZBVUxUX0VOQ09ESU5HLCBERUZBVUxUX0ZJTEVfTU9ERSwgREVGQVVMVF9GT0xERVJfTU9ERSwgREVGQVVMVF9SRUFEX09QVElPTlMsIERFRkFVTFRfV1JJVEVfT1BUSU9OUywgREVGQVVMVF9VU0VSX1VJRCwgREVGQVVMVF9VU0VSX0dJRCwgREVGQVVMVF9USU1FT1VUX0FTWU5DLCBERUZBVUxUX1RJTUVPVVRfU1lOQywgSVNfUE9TSVgsIElTX1VTRVJfUk9PVCwgTElNSVRfQkFTRU5BTUVfTEVOR1RILCBMSU1JVF9GSUxFU19ERVNDUklQVE9SUywgTk9PUCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/atomically/dist/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/atomically/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/atomically/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   readFile: () => (/* binding */ readFile),\n/* harmony export */   readFileSync: () => (/* binding */ readFileSync),\n/* harmony export */   writeFile: () => (/* binding */ writeFile),\n/* harmony export */   writeFileSync: () => (/* binding */ writeFileSync)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var stubborn_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stubborn-fs */ \"./node_modules/stubborn-fs/dist/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/atomically/dist/constants.js\");\n/* harmony import */ var _utils_lang_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/lang.js */ \"./node_modules/atomically/dist/utils/lang.js\");\n/* harmony import */ var _utils_scheduler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/scheduler.js */ \"./node_modules/atomically/dist/utils/scheduler.js\");\n/* harmony import */ var _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/temp.js */ \"./node_modules/atomically/dist/utils/temp.js\");\n/* IMPORT */\n\n\n\n\n\n\nfunction readFile(filePath, options = _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_READ_OPTIONS) {\n    if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(options))\n        return readFile(filePath, { encoding: options });\n    const timeout = Date.now() + ((options.timeout ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TIMEOUT_ASYNC) || -1);\n    return stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.readFile(timeout)(filePath, options);\n}\nfunction readFileSync(filePath, options = _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_READ_OPTIONS) {\n    if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(options))\n        return readFileSync(filePath, { encoding: options });\n    const timeout = Date.now() + ((options.timeout ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TIMEOUT_SYNC) || -1);\n    return stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.readFileSync(timeout)(filePath, options);\n}\nfunction writeFile(filePath, data, options, callback) {\n    if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isFunction)(options))\n        return writeFile(filePath, data, _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WRITE_OPTIONS, options);\n    const promise = writeFileAsync(filePath, data, options);\n    if (callback)\n        promise.then(callback, callback);\n    return promise;\n}\nasync function writeFileAsync(filePath, data, options = _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WRITE_OPTIONS) {\n    if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(options))\n        return writeFileAsync(filePath, data, { encoding: options });\n    const timeout = Date.now() + ((options.timeout ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TIMEOUT_ASYNC) || -1);\n    let schedulerCustomDisposer = null;\n    let schedulerDisposer = null;\n    let tempDisposer = null;\n    let tempPath = null;\n    let fd = null;\n    try {\n        if (options.schedule)\n            schedulerCustomDisposer = await options.schedule(filePath);\n        schedulerDisposer = await _utils_scheduler_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].schedule(filePath);\n        const filePathReal = await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.realpath(filePath);\n        const filePathExists = !!filePathReal;\n        filePath = filePathReal || filePath;\n        [tempPath, tempDisposer] = _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(filePath, options.tmpCreate || _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create, !(options.tmpPurge === false));\n        const useStatChown = _constants_js__WEBPACK_IMPORTED_MODULE_2__.IS_POSIX && (0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(options.chown);\n        const useStatMode = (0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(options.mode);\n        if (filePathExists && (useStatChown || useStatMode)) {\n            const stats = await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.stat(filePath);\n            if (stats) {\n                options = { ...options };\n                if (useStatChown) {\n                    options.chown = { uid: stats.uid, gid: stats.gid };\n                }\n                if (useStatMode) {\n                    options.mode = stats.mode;\n                }\n            }\n        }\n        if (!filePathExists) {\n            const parentPath = node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(filePath);\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.mkdir(parentPath, {\n                mode: _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FOLDER_MODE,\n                recursive: true\n            });\n        }\n        fd = await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.open(timeout)(tempPath, 'w', options.mode || _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FILE_MODE);\n        if (options.tmpCreated) {\n            options.tmpCreated(tempPath);\n        }\n        if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(data)) {\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.write(timeout)(fd, data, 0, options.encoding || _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ENCODING);\n        }\n        else if (!(0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data)) {\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.write(timeout)(fd, data, 0, data.length, 0);\n        }\n        if (options.fsync !== false) {\n            if (options.fsyncWait !== false) {\n                await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.fsync(timeout)(fd);\n            }\n            else {\n                stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.fsync(fd);\n            }\n        }\n        await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.close(timeout)(fd);\n        fd = null;\n        if (options.chown && (options.chown.uid !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_USER_UID || options.chown.gid !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_USER_GID)) {\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.chown(tempPath, options.chown.uid, options.chown.gid);\n        }\n        if (options.mode && options.mode !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FILE_MODE) {\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.chmod(tempPath, options.mode);\n        }\n        try {\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.rename(timeout)(tempPath, filePath);\n        }\n        catch (error) {\n            if (!(0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isException)(error))\n                throw error;\n            if (error.code !== 'ENAMETOOLONG')\n                throw error;\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.rename(timeout)(tempPath, _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].truncate(filePath));\n        }\n        tempDisposer();\n        tempPath = null;\n    }\n    finally {\n        if (fd)\n            await stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.close(fd);\n        if (tempPath)\n            _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].purge(tempPath);\n        if (schedulerCustomDisposer)\n            schedulerCustomDisposer();\n        if (schedulerDisposer)\n            schedulerDisposer();\n    }\n}\nfunction writeFileSync(filePath, data, options = _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WRITE_OPTIONS) {\n    if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(options))\n        return writeFileSync(filePath, data, { encoding: options });\n    const timeout = Date.now() + ((options.timeout ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_TIMEOUT_SYNC) || -1);\n    let tempDisposer = null;\n    let tempPath = null;\n    let fd = null;\n    try {\n        const filePathReal = stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.realpathSync(filePath);\n        const filePathExists = !!filePathReal;\n        filePath = filePathReal || filePath;\n        [tempPath, tempDisposer] = _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].get(filePath, options.tmpCreate || _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].create, !(options.tmpPurge === false));\n        const useStatChown = _constants_js__WEBPACK_IMPORTED_MODULE_2__.IS_POSIX && (0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(options.chown);\n        const useStatMode = (0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(options.mode);\n        if (filePathExists && (useStatChown || useStatMode)) {\n            const stats = stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.statSync(filePath);\n            if (stats) {\n                options = { ...options };\n                if (useStatChown) {\n                    options.chown = { uid: stats.uid, gid: stats.gid };\n                }\n                if (useStatMode) {\n                    options.mode = stats.mode;\n                }\n            }\n        }\n        if (!filePathExists) {\n            const parentPath = node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(filePath);\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.mkdirSync(parentPath, {\n                mode: _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FOLDER_MODE,\n                recursive: true\n            });\n        }\n        fd = stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.openSync(timeout)(tempPath, 'w', options.mode || _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FILE_MODE);\n        if (options.tmpCreated) {\n            options.tmpCreated(tempPath);\n        }\n        if ((0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isString)(data)) {\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.writeSync(timeout)(fd, data, 0, options.encoding || _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ENCODING);\n        }\n        else if (!(0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(data)) {\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.writeSync(timeout)(fd, data, 0, data.length, 0);\n        }\n        if (options.fsync !== false) {\n            if (options.fsyncWait !== false) {\n                stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.fsyncSync(timeout)(fd);\n            }\n            else {\n                stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.fsync(fd);\n            }\n        }\n        stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.closeSync(timeout)(fd);\n        fd = null;\n        if (options.chown && (options.chown.uid !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_USER_UID || options.chown.gid !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_USER_GID)) {\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.chownSync(tempPath, options.chown.uid, options.chown.gid);\n        }\n        if (options.mode && options.mode !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_FILE_MODE) {\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.chmodSync(tempPath, options.mode);\n        }\n        try {\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.renameSync(timeout)(tempPath, filePath);\n        }\n        catch (error) {\n            if (!(0,_utils_lang_js__WEBPACK_IMPORTED_MODULE_3__.isException)(error))\n                throw error;\n            if (error.code !== 'ENAMETOOLONG')\n                throw error;\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].retry.renameSync(timeout)(tempPath, _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].truncate(filePath));\n        }\n        tempDisposer();\n        tempPath = null;\n    }\n    finally {\n        if (fd)\n            stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.closeSync(fd);\n        if (tempPath)\n            _utils_temp_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].purge(tempPath);\n    }\n}\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFLDJEQUEyRCwyREFBZ0I7QUFDekY7QUFDQSxrQkFBa0IsMkRBQVc7QUFDN0IsWUFBWSxtREFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBRTtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFFO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLG1EQUFFO0FBQ1Y7QUFDQSxvREFBb0QsMkRBQWdCLDBCQUEwQiwyREFBZ0I7QUFDOUcsWUFBWSxtREFBRTtBQUNkO0FBQ0EsNkNBQTZDLDREQUFpQjtBQUM5RCxZQUFZLG1EQUFFO0FBQ2Q7QUFDQTtBQUNBLFlBQVksbURBQUU7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQUUscUNBQXFDLHNEQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQUU7QUFDZDtBQUNBLFlBQVksc0RBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQzREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzPzE0NjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ3N0dWJib3JuLWZzJztcbmltcG9ydCB7IERFRkFVTFRfRU5DT0RJTkcsIERFRkFVTFRfRklMRV9NT0RFLCBERUZBVUxUX0ZPTERFUl9NT0RFLCBERUZBVUxUX1JFQURfT1BUSU9OUywgREVGQVVMVF9XUklURV9PUFRJT05TLCBERUZBVUxUX1VTRVJfVUlELCBERUZBVUxUX1VTRVJfR0lELCBERUZBVUxUX1RJTUVPVVRfQVNZTkMsIERFRkFVTFRfVElNRU9VVF9TWU5DLCBJU19QT1NJWCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGlzRXhjZXB0aW9uLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL2xhbmcuanMnO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuL3V0aWxzL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgVGVtcCBmcm9tICcuL3V0aWxzL3RlbXAuanMnO1xuZnVuY3Rpb24gcmVhZEZpbGUoZmlsZVBhdGgsIG9wdGlvbnMgPSBERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIGlmIChpc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWxlKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChvcHRpb25zLnRpbWVvdXQgPz8gREVGQVVMVF9USU1FT1VUX0FTWU5DKSB8fCAtMSk7XG4gICAgcmV0dXJuIGZzLnJldHJ5LnJlYWRGaWxlKHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgb3B0aW9ucyA9IERFRkFVTFRfUkVBRF9PUFRJT05TKSB7XG4gICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGVTeW5jKGZpbGVQYXRoLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChvcHRpb25zLnRpbWVvdXQgPz8gREVGQVVMVF9USU1FT1VUX1NZTkMpIHx8IC0xKTtcbiAgICByZXR1cm4gZnMucmV0cnkucmVhZEZpbGVTeW5jKHRpbWVvdXQpKGZpbGVQYXRoLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgREVGQVVMVF9XUklURV9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlID0gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IERFRkFVTFRfV1JJVEVfT1BUSU9OUykge1xuICAgIGlmIChpc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZUFzeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChvcHRpb25zLnRpbWVvdXQgPz8gREVGQVVMVF9USU1FT1VUX0FTWU5DKSB8fCAtMSk7XG4gICAgbGV0IHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gbnVsbDtcbiAgICBsZXQgc2NoZWR1bGVyRGlzcG9zZXIgPSBudWxsO1xuICAgIGxldCB0ZW1wRGlzcG9zZXIgPSBudWxsO1xuICAgIGxldCB0ZW1wUGF0aCA9IG51bGw7XG4gICAgbGV0IGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlZHVsZSlcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gYXdhaXQgb3B0aW9ucy5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyID0gYXdhaXQgU2NoZWR1bGVyLnNjaGVkdWxlKGZpbGVQYXRoKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGhSZWFsID0gYXdhaXQgZnMuYXR0ZW1wdC5yZWFscGF0aChmaWxlUGF0aCk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoRXhpc3RzID0gISFmaWxlUGF0aFJlYWw7XG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGhSZWFsIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSBUZW1wLmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgVGVtcC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gSVNfUE9TSVggJiYgaXNVbmRlZmluZWQob3B0aW9ucy5jaG93bik7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRNb2RlID0gaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKGZpbGVQYXRoRXhpc3RzICYmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLmF0dGVtcHQuc3RhdChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNob3duID0geyB1aWQ6IHN0YXRzLnVpZCwgZ2lkOiBzdGF0cy5naWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IHN0YXRzLm1vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmlsZVBhdGhFeGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgYXdhaXQgZnMuYXR0ZW1wdC5ta2RpcihwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICAgICAgbW9kZTogREVGQVVMVF9GT0xERVJfTU9ERSxcbiAgICAgICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZkID0gYXdhaXQgZnMucmV0cnkub3Blbih0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgYXdhaXQgZnMucmV0cnkud3JpdGUodGltZW91dCkoZmQsIGRhdGEsIDAsIG9wdGlvbnMuZW5jb2RpbmcgfHwgREVGQVVMVF9FTkNPRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5yZXRyeS53cml0ZSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZzLnJldHJ5LmZzeW5jKHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzLmF0dGVtcHQuZnN5bmMoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZzLnJldHJ5LmNsb3NlKHRpbWVvdXQpKGZkKTtcbiAgICAgICAgZmQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5jaG93biAmJiAob3B0aW9ucy5jaG93bi51aWQgIT09IERFRkFVTFRfVVNFUl9VSUQgfHwgb3B0aW9ucy5jaG93bi5naWQgIT09IERFRkFVTFRfVVNFUl9HSUQpKSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5hdHRlbXB0LmNob3duKHRlbXBQYXRoLCBvcHRpb25zLmNob3duLnVpZCwgb3B0aW9ucy5jaG93bi5naWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUgJiYgb3B0aW9ucy5tb2RlICE9PSBERUZBVUxUX0ZJTEVfTU9ERSkge1xuICAgICAgICAgICAgYXdhaXQgZnMuYXR0ZW1wdC5jaG1vZCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMucmV0cnkucmVuYW1lKHRpbWVvdXQpKHRlbXBQYXRoLCBmaWxlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXhjZXB0aW9uKGVycm9yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGF3YWl0IGZzLnJldHJ5LnJlbmFtZSh0aW1lb3V0KSh0ZW1wUGF0aCwgVGVtcC50cnVuY2F0ZShmaWxlUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBEaXNwb3NlcigpO1xuICAgICAgICB0ZW1wUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBpZiAoZmQpXG4gICAgICAgICAgICBhd2FpdCBmcy5hdHRlbXB0LmNsb3NlKGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgVGVtcC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJDdXN0b21EaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChzY2hlZHVsZXJEaXNwb3NlcilcbiAgICAgICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IERFRkFVTFRfV1JJVEVfT1BUSU9OUykge1xuICAgIGlmIChpc1N0cmluZyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKG9wdGlvbnMudGltZW91dCA/PyBERUZBVUxUX1RJTUVPVVRfU1lOQykgfHwgLTEpO1xuICAgIGxldCB0ZW1wRGlzcG9zZXIgPSBudWxsO1xuICAgIGxldCB0ZW1wUGF0aCA9IG51bGw7XG4gICAgbGV0IGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aFJlYWwgPSBmcy5hdHRlbXB0LnJlYWxwYXRoU3luYyhmaWxlUGF0aCk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoRXhpc3RzID0gISFmaWxlUGF0aFJlYWw7XG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGhSZWFsIHx8IGZpbGVQYXRoO1xuICAgICAgICBbdGVtcFBhdGgsIHRlbXBEaXNwb3Nlcl0gPSBUZW1wLmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgVGVtcC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gSVNfUE9TSVggJiYgaXNVbmRlZmluZWQob3B0aW9ucy5jaG93bik7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRNb2RlID0gaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKGZpbGVQYXRoRXhpc3RzICYmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGZzLmF0dGVtcHQuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0Q2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0cy51aWQsIGdpZDogc3RhdHMuZ2lkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBzdGF0cy5tb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpbGVQYXRoRXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGZzLmF0dGVtcHQubWtkaXJTeW5jKHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgICAgICBtb2RlOiBERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmQgPSBmcy5yZXRyeS5vcGVuU3luYyh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgZnMucmV0cnkud3JpdGVTeW5jKHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBvcHRpb25zLmVuY29kaW5nIHx8IERFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgZnMucmV0cnkud3JpdGVTeW5jKHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZnMucmV0cnkuZnN5bmNTeW5jKHRpbWVvdXQpKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZzLmF0dGVtcHQuZnN5bmMoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZzLnJldHJ5LmNsb3NlU3luYyh0aW1lb3V0KShmZCk7XG4gICAgICAgIGZkID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hvd24gJiYgKG9wdGlvbnMuY2hvd24udWlkICE9PSBERUZBVUxUX1VTRVJfVUlEIHx8IG9wdGlvbnMuY2hvd24uZ2lkICE9PSBERUZBVUxUX1VTRVJfR0lEKSkge1xuICAgICAgICAgICAgZnMuYXR0ZW1wdC5jaG93blN5bmModGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSAmJiBvcHRpb25zLm1vZGUgIT09IERFRkFVTFRfRklMRV9NT0RFKSB7XG4gICAgICAgICAgICBmcy5hdHRlbXB0LmNobW9kU3luYyh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMucmV0cnkucmVuYW1lU3luYyh0aW1lb3V0KSh0ZW1wUGF0aCwgZmlsZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFpc0V4Y2VwdGlvbihlcnJvcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gJ0VOQU1FVE9PTE9ORycpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBmcy5yZXRyeS5yZW5hbWVTeW5jKHRpbWVvdXQpKHRlbXBQYXRoLCBUZW1wLnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGZzLmF0dGVtcHQuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgVGVtcC5wdXJnZSh0ZW1wUGF0aCk7XG4gICAgfVxufVxuLyogRVhQT1JUICovXG5leHBvcnQgeyByZWFkRmlsZSwgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGUsIHdyaXRlRmlsZVN5bmMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/atomically/dist/index.js\n\n}");

/***/ }),

/***/ "./node_modules/atomically/dist/utils/lang.js":
/*!****************************************************!*\
  !*** ./node_modules/atomically/dist/utils/lang.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isException: () => (/* binding */ isException),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined)\n/* harmony export */ });\n/* IMPORT */\n/* MAIN */\nconst isException = (value) => {\n    return (value instanceof Error) && ('code' in value);\n};\nconst isFunction = (value) => {\n    return (typeof value === 'function');\n};\nconst isString = (value) => {\n    return (typeof value === 'string');\n};\nconst isUndefined = (value) => {\n    return (value === undefined);\n};\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2xhbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzP2M3YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG4vKiBNQUlOICovXG5jb25zdCBpc0V4Y2VwdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgJiYgKCdjb2RlJyBpbiB2YWx1ZSk7XG59O1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcbn07XG5jb25zdCBpc1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG59O1xuY29uc3QgaXNVbmRlZmluZWQgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKHZhbHVlID09PSB1bmRlZmluZWQpO1xufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IHsgaXNFeGNlcHRpb24sIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/atomically/dist/utils/lang.js\n\n}");

/***/ }),

/***/ "./node_modules/atomically/dist/utils/scheduler.js":
/*!*********************************************************!*\
  !*** ./node_modules/atomically/dist/utils/scheduler.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* IMPORT */\n/* HELPERS */\nconst Queues = {};\n/* MAIN */\n//TODO: Maybe publish this as a standalone package\nconst Scheduler = {\n    /* API */\n    next: (id) => {\n        const queue = Queues[id];\n        if (!queue)\n            return;\n        queue.shift();\n        const job = queue[0];\n        if (job) {\n            job(() => Scheduler.next(id));\n        }\n        else {\n            delete Queues[id];\n        }\n    },\n    schedule: (id) => {\n        return new Promise(resolve => {\n            let queue = Queues[id];\n            if (!queue)\n                queue = Queues[id] = [];\n            queue.push(resolve);\n            if (queue.length > 1)\n                return;\n            resolve(() => Scheduler.next(id));\n        });\n    }\n};\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Scheduler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3NjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFNBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanM/OThhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBJTVBPUlQgKi9cbi8qIEhFTFBFUlMgKi9cbmNvbnN0IFF1ZXVlcyA9IHt9O1xuLyogTUFJTiAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFNjaGVkdWxlciA9IHtcbiAgICAvKiBBUEkgKi9cbiAgICBuZXh0OiAoaWQpID0+IHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICBpZiAoIXF1ZXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVswXTtcbiAgICAgICAgaWYgKGpvYikge1xuICAgICAgICAgICAgam9iKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgUXVldWVzW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NoZWR1bGU6IChpZCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcXVldWUgPSBRdWV1ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IFF1ZXVlc1tpZF0gPSBbXTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IFNjaGVkdWxlci5uZXh0KGlkKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydCBkZWZhdWx0IFNjaGVkdWxlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/atomically/dist/utils/scheduler.js\n\n}");

/***/ }),

/***/ "./node_modules/atomically/dist/utils/temp.js":
/*!****************************************************!*\
  !*** ./node_modules/atomically/dist/utils/temp.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var stubborn_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stubborn-fs */ \"./node_modules/stubborn-fs/dist/index.js\");\n/* harmony import */ var when_exit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! when-exit */ \"./node_modules/when-exit/dist/node/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants.js */ \"./node_modules/atomically/dist/constants.js\");\n/* IMPORT */\n\n\n\n\n/* MAIN */\n//TODO: Maybe publish this as a standalone package\nconst Temp = {\n    /* VARIABLES */\n    store: {},\n    /* API */\n    create: (filePath) => {\n        const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6); // 6 random-enough hex characters\n        const timestamp = Date.now().toString().slice(-10); // 10 precise timestamp digits\n        const prefix = 'tmp-';\n        const suffix = `.${prefix}${timestamp}${randomness}`;\n        const tempPath = `${filePath}${suffix}`;\n        return tempPath;\n    },\n    get: (filePath, creator, purge = true) => {\n        const tempPath = Temp.truncate(creator(filePath));\n        if (tempPath in Temp.store)\n            return Temp.get(filePath, creator, purge); // Collision found, try again\n        Temp.store[tempPath] = purge;\n        const disposer = () => delete Temp.store[tempPath];\n        return [tempPath, disposer];\n    },\n    purge: (filePath) => {\n        if (!Temp.store[filePath])\n            return;\n        delete Temp.store[filePath];\n        stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.unlink(filePath);\n    },\n    purgeSync: (filePath) => {\n        if (!Temp.store[filePath])\n            return;\n        delete Temp.store[filePath];\n        stubborn_fs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].attempt.unlinkSync(filePath);\n    },\n    purgeSyncAll: () => {\n        for (const filePath in Temp.store) {\n            Temp.purgeSync(filePath);\n        }\n    },\n    truncate: (filePath) => {\n        const basename = node_path__WEBPACK_IMPORTED_MODULE_0__.basename(filePath);\n        if (basename.length <= _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIMIT_BASENAME_LENGTH)\n            return filePath; //FIXME: Rough and quick attempt at detecting ok lengths\n        const truncable = /^(\\.?)(.*?)((?:\\.[^.]+)?(?:\\.tmp-\\d{10}[a-f0-9]{6})?)$/.exec(basename);\n        if (!truncable)\n            return filePath; //FIXME: No truncable part detected, can't really do much without also changing the parent path, which is unsafe, hoping for the best here\n        const truncationLength = basename.length - _constants_js__WEBPACK_IMPORTED_MODULE_3__.LIMIT_BASENAME_LENGTH;\n        return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`; //FIXME: The truncable part might be shorter than needed here\n    }\n};\n/* INIT */\n(0,when_exit__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Temp.purgeSyncAll); // Ensuring purgeable temp files are purged on exit\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Temp);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUM2QjtBQUNBO0FBQ0k7QUFDdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQyxrREFBa0QsYUFBYTtBQUNuRyw0REFBNEQ7QUFDNUQ7QUFDQSwyQkFBMkIsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXO0FBQzNELDRCQUE0QixTQUFTLEVBQUUsT0FBTztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBRTtBQUNWLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQUU7QUFDVixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIsK0NBQWE7QUFDdEMsK0JBQStCLGdFQUFxQjtBQUNwRCw2QkFBNkI7QUFDN0IsK0RBQStELEdBQUcsU0FBUyxFQUFFO0FBQzdFO0FBQ0EsNkJBQTZCO0FBQzdCLG1EQUFtRCxnRUFBcUI7QUFDeEUsa0JBQWtCLG9DQUFvQyxFQUFFLGFBQWEsRUFBRSx5Q0FBeUMsRUFBRSxhQUFhLEdBQUc7QUFDbEk7QUFDQTtBQUNBO0FBQ0EscURBQVEscUJBQXFCO0FBQzdCO0FBQ0EsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanM/ZDMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBJTVBPUlQgKi9cbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnc3R1YmJvcm4tZnMnO1xuaW1wb3J0IHdoZW5FeGl0IGZyb20gJ3doZW4tZXhpdCc7XG5pbXBvcnQgeyBMSU1JVF9CQVNFTkFNRV9MRU5HVEggfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuLyogTUFJTiAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFRlbXAgPSB7XG4gICAgLyogVkFSSUFCTEVTICovXG4gICAgc3RvcmU6IHt9LFxuICAgIC8qIEFQSSAqL1xuICAgIGNyZWF0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBgMDAwMDAwJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTYpOyAvLyA2IHJhbmRvbS1lbm91Z2ggaGV4IGNoYXJhY3RlcnNcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpLnNsaWNlKC0xMCk7IC8vIDEwIHByZWNpc2UgdGltZXN0YW1wIGRpZ2l0c1xuICAgICAgICBjb25zdCBwcmVmaXggPSAndG1wLSc7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGAuJHtwcmVmaXh9JHt0aW1lc3RhbXB9JHtyYW5kb21uZXNzfWA7XG4gICAgICAgIGNvbnN0IHRlbXBQYXRoID0gYCR7ZmlsZVBhdGh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRlbXBQYXRoO1xuICAgIH0sXG4gICAgZ2V0OiAoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IFRlbXAudHJ1bmNhdGUoY3JlYXRvcihmaWxlUGF0aCkpO1xuICAgICAgICBpZiAodGVtcFBhdGggaW4gVGVtcC5zdG9yZSlcbiAgICAgICAgICAgIHJldHVybiBUZW1wLmdldChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UpOyAvLyBDb2xsaXNpb24gZm91bmQsIHRyeSBhZ2FpblxuICAgICAgICBUZW1wLnN0b3JlW3RlbXBQYXRoXSA9IHB1cmdlO1xuICAgICAgICBjb25zdCBkaXNwb3NlciA9ICgpID0+IGRlbGV0ZSBUZW1wLnN0b3JlW3RlbXBQYXRoXTtcbiAgICAgICAgcmV0dXJuIFt0ZW1wUGF0aCwgZGlzcG9zZXJdO1xuICAgIH0sXG4gICAgcHVyZ2U6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzLmF0dGVtcHQudW5saW5rKGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luYzogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnMuYXR0ZW1wdC51bmxpbmtTeW5jKGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luY0FsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIGluIFRlbXAuc3RvcmUpIHtcbiAgICAgICAgICAgIFRlbXAucHVyZ2VTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJ1bmNhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoYmFzZW5hbWUubGVuZ3RoIDw9IExJTUlUX0JBU0VOQU1FX0xFTkdUSClcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogUm91Z2ggYW5kIHF1aWNrIGF0dGVtcHQgYXQgZGV0ZWN0aW5nIG9rIGxlbmd0aHNcbiAgICAgICAgY29uc3QgdHJ1bmNhYmxlID0gL14oXFwuPykoLio/KSgoPzpcXC5bXi5dKyk/KD86XFwudG1wLVxcZHsxMH1bYS1mMC05XXs2fSk/KSQvLmV4ZWMoYmFzZW5hbWUpO1xuICAgICAgICBpZiAoIXRydW5jYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogTm8gdHJ1bmNhYmxlIHBhcnQgZGV0ZWN0ZWQsIGNhbid0IHJlYWxseSBkbyBtdWNoIHdpdGhvdXQgYWxzbyBjaGFuZ2luZyB0aGUgcGFyZW50IHBhdGgsIHdoaWNoIGlzIHVuc2FmZSwgaG9waW5nIGZvciB0aGUgYmVzdCBoZXJlXG4gICAgICAgIGNvbnN0IHRydW5jYXRpb25MZW5ndGggPSBiYXNlbmFtZS5sZW5ndGggLSBMSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG4gICAgICAgIHJldHVybiBgJHtmaWxlUGF0aC5zbGljZSgwLCAtYmFzZW5hbWUubGVuZ3RoKX0ke3RydW5jYWJsZVsxXX0ke3RydW5jYWJsZVsyXS5zbGljZSgwLCAtdHJ1bmNhdGlvbkxlbmd0aCl9JHt0cnVuY2FibGVbM119YDsgLy9GSVhNRTogVGhlIHRydW5jYWJsZSBwYXJ0IG1pZ2h0IGJlIHNob3J0ZXIgdGhhbiBuZWVkZWQgaGVyZVxuICAgIH1cbn07XG4vKiBJTklUICovXG53aGVuRXhpdChUZW1wLnB1cmdlU3luY0FsbCk7IC8vIEVuc3VyaW5nIHB1cmdlYWJsZSB0ZW1wIGZpbGVzIGFyZSBwdXJnZWQgb24gZXhpdFxuLyogRVhQT1JUICovXG5leHBvcnQgZGVmYXVsdCBUZW1wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/atomically/dist/utils/temp.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/dist/source/index.js":
/*!************************************************!*\
  !*** ./node_modules/conf/dist/source/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Conf)\n/* harmony export */ });\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:assert */ \"node:assert\");\n/* harmony import */ var dot_prop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! dot-prop */ \"./node_modules/dot-prop/index.js\");\n/* harmony import */ var env_paths__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! env-paths */ \"./node_modules/conf/node_modules/env-paths/index.js\");\n/* harmony import */ var atomically__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! atomically */ \"./node_modules/atomically/dist/index.js\");\n/* harmony import */ var ajv_dist_2020_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ajv/dist/2020.js */ \"./node_modules/ajv/dist/2020.js\");\n/* harmony import */ var ajv_formats__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ajv-formats */ \"./node_modules/ajv-formats/dist/index.js\");\n/* harmony import */ var debounce_fn__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! debounce-fn */ \"./node_modules/debounce-fn/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! semver */ \"./node_modules/conf/node_modules/semver/index.js\");\n/* harmony import */ var uint8array_extras__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uint8array-extras */ \"./node_modules/uint8array-extras/index.js\");\n/* eslint-disable @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-return */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// FIXME: https://github.com/ajv-validator/ajv/issues/2047\nconst ajvFormats = ajv_formats__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\nconst encryptionAlgorithm = 'aes-256-cbc';\nconst createPlainObject = () => Object.create(null);\nconst isExist = (data) => data !== undefined && data !== null;\nconst checkValueType = (key, value) => {\n    const nonJsonTypes = new Set([\n        'undefined',\n        'symbol',\n        'function',\n    ]);\n    const type = typeof value;\n    if (nonJsonTypes.has(type)) {\n        throw new TypeError(`Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`);\n    }\n};\nconst INTERNAL_KEY = '__internal__';\nconst MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;\nclass Conf {\n    path;\n    events;\n    #validator;\n    #encryptionKey;\n    #options;\n    #defaultValues = {};\n    constructor(partialOptions = {}) {\n        const options = {\n            configName: 'config',\n            fileExtension: 'json',\n            projectSuffix: 'nodejs',\n            clearInvalidConfig: false,\n            accessPropertiesByDotNotation: true,\n            configFileMode: 0o666,\n            ...partialOptions,\n        };\n        if (!options.cwd) {\n            if (!options.projectName) {\n                throw new Error('Please specify the `projectName` option.');\n            }\n            options.cwd = (0,env_paths__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(options.projectName, { suffix: options.projectSuffix }).config;\n        }\n        this.#options = options;\n        if (options.schema ?? options.ajvOptions ?? options.rootSchema) {\n            if (options.schema && typeof options.schema !== 'object') {\n                throw new TypeError('The `schema` option must be an object.');\n            }\n            const ajv = new ajv_dist_2020_js__WEBPACK_IMPORTED_MODULE_8__.Ajv2020({\n                allErrors: true,\n                useDefaults: true,\n                ...options.ajvOptions,\n            });\n            ajvFormats(ajv);\n            const schema = {\n                ...options.rootSchema,\n                type: 'object',\n                properties: options.schema,\n            };\n            this.#validator = ajv.compile(schema);\n            for (const [key, value] of Object.entries(options.schema ?? {})) { // TODO: Remove the `as any`.\n                if (value?.default) {\n                    this.#defaultValues[key] = value.default; // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                }\n            }\n        }\n        if (options.defaults) {\n            this.#defaultValues = {\n                ...this.#defaultValues,\n                ...options.defaults,\n            };\n        }\n        if (options.serialize) {\n            this._serialize = options.serialize;\n        }\n        if (options.deserialize) {\n            this._deserialize = options.deserialize;\n        }\n        this.events = new EventTarget();\n        this.#encryptionKey = options.encryptionKey;\n        const fileExtension = options.fileExtension ? `.${options.fileExtension}` : '';\n        this.path = node_path__WEBPACK_IMPORTED_MODULE_3__.resolve(options.cwd, `${options.configName ?? 'config'}${fileExtension}`);\n        const fileStore = this.store;\n        const store = Object.assign(createPlainObject(), options.defaults, fileStore);\n        if (options.migrations) {\n            if (!options.projectVersion) {\n                throw new Error('Please specify the `projectVersion` option.');\n            }\n            this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);\n        }\n        // We defer validation until after migrations are applied so that the store can be updated to the current schema.\n        this._validate(store);\n        try {\n            node_assert__WEBPACK_IMPORTED_MODULE_5__.deepEqual(fileStore, store);\n        }\n        catch {\n            this.store = store;\n        }\n        if (options.watch) {\n            this._watch();\n        }\n    }\n    get(key, defaultValue) {\n        if (this.#options.accessPropertiesByDotNotation) {\n            return this._get(key, defaultValue);\n        }\n        const { store } = this;\n        return key in store ? store[key] : defaultValue;\n    }\n    set(key, value) {\n        if (typeof key !== 'string' && typeof key !== 'object') {\n            throw new TypeError(`Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`);\n        }\n        if (typeof key !== 'object' && value === undefined) {\n            throw new TypeError('Use `delete()` to clear values');\n        }\n        if (this._containsReservedKey(key)) {\n            throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);\n        }\n        const { store } = this;\n        const set = (key, value) => {\n            checkValueType(key, value);\n            if (this.#options.accessPropertiesByDotNotation) {\n                (0,dot_prop__WEBPACK_IMPORTED_MODULE_11__.setProperty)(store, key, value);\n            }\n            else {\n                store[key] = value;\n            }\n        };\n        if (typeof key === 'object') {\n            const object = key;\n            for (const [key, value] of Object.entries(object)) {\n                set(key, value);\n            }\n        }\n        else {\n            set(key, value);\n        }\n        this.store = store;\n    }\n    has(key) {\n        if (this.#options.accessPropertiesByDotNotation) {\n            return (0,dot_prop__WEBPACK_IMPORTED_MODULE_11__.hasProperty)(this.store, key);\n        }\n        return key in this.store;\n    }\n    /**\n    Reset items to their default values, as defined by the `defaults` or `schema` option.\n\n    @see `clear()` to reset all items.\n\n    @param keys - The keys of the items to reset.\n    */\n    reset(...keys) {\n        for (const key of keys) {\n            if (isExist(this.#defaultValues[key])) {\n                this.set(key, this.#defaultValues[key]);\n            }\n        }\n    }\n    delete(key) {\n        const { store } = this;\n        if (this.#options.accessPropertiesByDotNotation) {\n            (0,dot_prop__WEBPACK_IMPORTED_MODULE_11__.deleteProperty)(store, key);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete store[key];\n        }\n        this.store = store;\n    }\n    /**\n    Delete all items.\n\n    This resets known items to their default values, if defined by the `defaults` or `schema` option.\n    */\n    clear() {\n        this.store = createPlainObject();\n        for (const key of Object.keys(this.#defaultValues)) {\n            this.reset(key);\n        }\n    }\n    onDidChange(key, callback) {\n        if (typeof key !== 'string') {\n            throw new TypeError(`Expected \\`key\\` to be of type \\`string\\`, got ${typeof key}`);\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.get(key), callback);\n    }\n    /**\n    Watches the whole config object, calling `callback` on any changes.\n\n    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n    @returns A function, that when called, will unsubscribe.\n    */\n    onDidAnyChange(callback) {\n        if (typeof callback !== 'function') {\n            throw new TypeError(`Expected \\`callback\\` to be of type \\`function\\`, got ${typeof callback}`);\n        }\n        return this._handleChange(() => this.store, callback);\n    }\n    get size() {\n        return Object.keys(this.store).length;\n    }\n    /**\n    Get all the config as an object or replace the current config with an object.\n\n    @example\n    ```\n    console.log(config.store);\n    //=> {name: 'John', age: 30}\n    ```\n\n    @example\n    ```\n    config.store = {\n        hello: 'world'\n    };\n    ```\n    */\n    get store() {\n        try {\n            const data = node_fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(this.path, this.#encryptionKey ? null : 'utf8');\n            const dataString = this._encryptData(data);\n            const deserializedData = this._deserialize(dataString);\n            this._validate(deserializedData);\n            return Object.assign(createPlainObject(), deserializedData);\n        }\n        catch (error) {\n            if (error?.code === 'ENOENT') {\n                this._ensureDirectory();\n                return createPlainObject();\n            }\n            if (this.#options.clearInvalidConfig && error.name === 'SyntaxError') {\n                return createPlainObject();\n            }\n            throw error;\n        }\n    }\n    set store(value) {\n        this._ensureDirectory();\n        this._validate(value);\n        this._write(value);\n        this.events.dispatchEvent(new Event('change'));\n    }\n    *[Symbol.iterator]() {\n        for (const [key, value] of Object.entries(this.store)) {\n            yield [key, value];\n        }\n    }\n    _encryptData(data) {\n        if (!this.#encryptionKey) {\n            return typeof data === 'string' ? data : (0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.uint8ArrayToString)(data);\n        }\n        // Check if an initialization vector has been used to encrypt the data.\n        try {\n            const initializationVector = data.slice(0, 16);\n            const password = node_crypto__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Sync(this.#encryptionKey, initializationVector.toString(), 10_000, 32, 'sha512');\n            const decipher = node_crypto__WEBPACK_IMPORTED_MODULE_4__.createDecipheriv(encryptionAlgorithm, password, initializationVector);\n            const slice = data.slice(17);\n            const dataUpdate = typeof slice === 'string' ? (0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.stringToUint8Array)(slice) : slice;\n            return (0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.uint8ArrayToString)((0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.concatUint8Arrays)([decipher.update(dataUpdate), decipher.final()]));\n        }\n        catch { }\n        return data.toString();\n    }\n    _handleChange(getter, callback) {\n        let currentValue = getter();\n        const onChange = () => {\n            const oldValue = currentValue;\n            const newValue = getter();\n            if ((0,node_util__WEBPACK_IMPORTED_MODULE_0__.isDeepStrictEqual)(newValue, oldValue)) {\n                return;\n            }\n            currentValue = newValue;\n            callback.call(this, newValue, oldValue);\n        };\n        this.events.addEventListener('change', onChange);\n        return () => {\n            this.events.removeEventListener('change', onChange);\n        };\n    }\n    _deserialize = value => JSON.parse(value);\n    _serialize = value => JSON.stringify(value, undefined, '\\t');\n    _validate(data) {\n        if (!this.#validator) {\n            return;\n        }\n        const valid = this.#validator(data);\n        if (valid || !this.#validator.errors) {\n            return;\n        }\n        const errors = this.#validator.errors\n            .map(({ instancePath, message = '' }) => `\\`${instancePath.slice(1)}\\` ${message}`);\n        throw new Error('Config schema violation: ' + errors.join('; '));\n    }\n    _ensureDirectory() {\n        // Ensure the directory exists as it could have been deleted in the meantime.\n        node_fs__WEBPACK_IMPORTED_MODULE_2__.mkdirSync(node_path__WEBPACK_IMPORTED_MODULE_3__.dirname(this.path), { recursive: true });\n    }\n    _write(value) {\n        let data = this._serialize(value);\n        if (this.#encryptionKey) {\n            const initializationVector = node_crypto__WEBPACK_IMPORTED_MODULE_4__.randomBytes(16);\n            const password = node_crypto__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Sync(this.#encryptionKey, initializationVector.toString(), 10_000, 32, 'sha512');\n            const cipher = node_crypto__WEBPACK_IMPORTED_MODULE_4__.createCipheriv(encryptionAlgorithm, password, initializationVector);\n            data = (0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.concatUint8Arrays)([initializationVector, (0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.stringToUint8Array)(':'), cipher.update((0,uint8array_extras__WEBPACK_IMPORTED_MODULE_12__.stringToUint8Array)(data)), cipher.final()]);\n        }\n        // Temporary workaround for Conf being packaged in a Ubuntu Snap app.\n        // See https://github.com/sindresorhus/conf/pull/82\n        if (node_process__WEBPACK_IMPORTED_MODULE_1__.env.SNAP) {\n            node_fs__WEBPACK_IMPORTED_MODULE_2__.writeFileSync(this.path, data, { mode: this.#options.configFileMode });\n        }\n        else {\n            try {\n                (0,atomically__WEBPACK_IMPORTED_MODULE_7__.writeFileSync)(this.path, data, { mode: this.#options.configFileMode });\n            }\n            catch (error) {\n                // Fix for https://github.com/sindresorhus/electron-store/issues/106\n                // Sometimes on Windows, we will get an EXDEV error when atomic writing\n                // (even though to the same directory), so we fall back to non atomic write\n                if (error?.code === 'EXDEV') {\n                    node_fs__WEBPACK_IMPORTED_MODULE_2__.writeFileSync(this.path, data, { mode: this.#options.configFileMode });\n                    return;\n                }\n                throw error;\n            }\n        }\n    }\n    _watch() {\n        this._ensureDirectory();\n        if (!node_fs__WEBPACK_IMPORTED_MODULE_2__.existsSync(this.path)) {\n            this._write(createPlainObject());\n        }\n        if (node_process__WEBPACK_IMPORTED_MODULE_1__.platform === 'win32') {\n            node_fs__WEBPACK_IMPORTED_MODULE_2__.watch(this.path, { persistent: false }, (0,debounce_fn__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(() => {\n                // On Linux and Windows, writing to the config file emits a `rename` event, so we skip checking the event type.\n                this.events.dispatchEvent(new Event('change'));\n            }, { wait: 100 }));\n        }\n        else {\n            node_fs__WEBPACK_IMPORTED_MODULE_2__.watchFile(this.path, { persistent: false }, (0,debounce_fn__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(() => {\n                this.events.dispatchEvent(new Event('change'));\n            }, { wait: 5000 }));\n        }\n    }\n    _migrate(migrations, versionToMigrate, beforeEachMigration) {\n        let previousMigratedVersion = this._get(MIGRATION_KEY, '0.0.0');\n        const newerVersions = Object.keys(migrations)\n            .filter(candidateVersion => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));\n        let storeBackup = { ...this.store };\n        for (const version of newerVersions) {\n            try {\n                if (beforeEachMigration) {\n                    beforeEachMigration(this, {\n                        fromVersion: previousMigratedVersion,\n                        toVersion: version,\n                        finalVersion: versionToMigrate,\n                        versions: newerVersions,\n                    });\n                }\n                const migration = migrations[version];\n                migration?.(this);\n                this._set(MIGRATION_KEY, version);\n                previousMigratedVersion = version;\n                storeBackup = { ...this.store };\n            }\n            catch (error) {\n                this.store = storeBackup;\n                throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);\n            }\n        }\n        if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver__WEBPACK_IMPORTED_MODULE_10__.eq(previousMigratedVersion, versionToMigrate)) {\n            this._set(MIGRATION_KEY, versionToMigrate);\n        }\n    }\n    _containsReservedKey(key) {\n        if (typeof key === 'object') {\n            const firstKey = Object.keys(key)[0];\n            if (firstKey === INTERNAL_KEY) {\n                return true;\n            }\n        }\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (this.#options.accessPropertiesByDotNotation) {\n            if (key.startsWith(`${INTERNAL_KEY}.`)) {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n    _isVersionInRangeFormat(version) {\n        return semver__WEBPACK_IMPORTED_MODULE_10__.clean(version) === null;\n    }\n    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {\n        if (this._isVersionInRangeFormat(candidateVersion)) {\n            if (previousMigratedVersion !== '0.0.0' && semver__WEBPACK_IMPORTED_MODULE_10__.satisfies(previousMigratedVersion, candidateVersion)) {\n                return false;\n            }\n            return semver__WEBPACK_IMPORTED_MODULE_10__.satisfies(versionToMigrate, candidateVersion);\n        }\n        if (semver__WEBPACK_IMPORTED_MODULE_10__.lte(candidateVersion, previousMigratedVersion)) {\n            return false;\n        }\n        if (semver__WEBPACK_IMPORTED_MODULE_10__.gt(candidateVersion, versionToMigrate)) {\n            return false;\n        }\n        return true;\n    }\n    _get(key, defaultValue) {\n        return (0,dot_prop__WEBPACK_IMPORTED_MODULE_11__.getProperty)(this.store, key, defaultValue);\n    }\n    _set(key, value) {\n        const { store } = this;\n        (0,dot_prop__WEBPACK_IMPORTED_MODULE_11__.setProperty)(store, key, value);\n        this.store = store;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNYO0FBQ1Y7QUFDSTtBQUNJO0FBQ0E7QUFDaUQ7QUFDakQ7QUFDaUM7QUFDaEI7QUFDUDtBQUNOO0FBQ1Q7QUFDbUU7QUFDL0Y7QUFDQSxtQkFBbUIsbURBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSyxlQUFlLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdkI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVEsd0JBQXdCLCtCQUErQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQUc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEtBQUs7QUFDL0U7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEYsb0JBQW9CLDhDQUFZLGlCQUFpQiwrQkFBK0IsRUFBRSxjQUFjO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Is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Q3JFO0FBQ0EsYUFBYSxJQUFJLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5SkFBeUosTUFBTTtBQUMvSjtBQUNBO0FBQ0Esc0VBQXNFLHVDQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDhDQUFnQjtBQUN2RTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFnQjtBQUNuQztBQUNBLFlBQVksd0NBQVU7QUFDdEI7QUFDQTtBQUNBLFlBQVksdUNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVc7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLFFBQVEsc0RBQVc7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9kaXN0L3NvdXJjZS9pbmRleC5qcz85M2I4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbmltcG9ydCB7IGlzRGVlcFN0cmljdEVxdWFsIH0gZnJvbSAnbm9kZTp1dGlsJztcbmltcG9ydCBwcm9jZXNzIGZyb20gJ25vZGU6cHJvY2Vzcyc7XG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ25vZGU6YXNzZXJ0JztcbmltcG9ydCB7IGdldFByb3BlcnR5LCBoYXNQcm9wZXJ0eSwgc2V0UHJvcGVydHksIGRlbGV0ZVByb3BlcnR5LCB9IGZyb20gJ2RvdC1wcm9wJztcbmltcG9ydCBlbnZQYXRocyBmcm9tICdlbnYtcGF0aHMnO1xuaW1wb3J0IHsgd3JpdGVGaWxlU3luYyBhcyBhdG9taWNXcml0ZUZpbGVTeW5jIH0gZnJvbSAnYXRvbWljYWxseSc7XG5pbXBvcnQgeyBBanYyMDIwIGFzIEFqdiB9IGZyb20gJ2Fqdi9kaXN0LzIwMjAuanMnO1xuaW1wb3J0IGFqdkZvcm1hdHNNb2R1bGUgZnJvbSAnYWp2LWZvcm1hdHMnO1xuaW1wb3J0IGRlYm91bmNlRm4gZnJvbSAnZGVib3VuY2UtZm4nO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgY29uY2F0VWludDhBcnJheXMsIHN0cmluZ1RvVWludDhBcnJheSwgdWludDhBcnJheVRvU3RyaW5nLCB9IGZyb20gJ3VpbnQ4YXJyYXktZXh0cmFzJztcbi8vIEZJWE1FOiBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzIwNDdcbmNvbnN0IGFqdkZvcm1hdHMgPSBhanZGb3JtYXRzTW9kdWxlLmRlZmF1bHQ7XG5jb25zdCBlbmNyeXB0aW9uQWxnb3JpdGhtID0gJ2Flcy0yNTYtY2JjJztcbmNvbnN0IGNyZWF0ZVBsYWluT2JqZWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGlzRXhpc3QgPSAoZGF0YSkgPT4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG5jb25zdCBjaGVja1ZhbHVlVHlwZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgbm9uSnNvblR5cGVzID0gbmV3IFNldChbXG4gICAgICAgICd1bmRlZmluZWQnLFxuICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgJ2Z1bmN0aW9uJyxcbiAgICBdKTtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmIChub25Kc29uVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNldHRpbmcgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAgZm9yIGtleSBcXGAke2tleX1cXGAgaXMgbm90IGFsbG93ZWQgYXMgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IEpTT05gKTtcbiAgICB9XG59O1xuY29uc3QgSU5URVJOQUxfS0VZID0gJ19faW50ZXJuYWxfXyc7XG5jb25zdCBNSUdSQVRJT05fS0VZID0gYCR7SU5URVJOQUxfS0VZfS5taWdyYXRpb25zLnZlcnNpb25gO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZiB7XG4gICAgcGF0aDtcbiAgICBldmVudHM7XG4gICAgI3ZhbGlkYXRvcjtcbiAgICAjZW5jcnlwdGlvbktleTtcbiAgICAjb3B0aW9ucztcbiAgICAjZGVmYXVsdFZhbHVlcyA9IHt9O1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbmZpZ05hbWU6ICdjb25maWcnLFxuICAgICAgICAgICAgZmlsZUV4dGVuc2lvbjogJ2pzb24nLFxuICAgICAgICAgICAgcHJvamVjdFN1ZmZpeDogJ25vZGVqcycsXG4gICAgICAgICAgICBjbGVhckludmFsaWRDb25maWc6IGZhbHNlLFxuICAgICAgICAgICAgYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb246IHRydWUsXG4gICAgICAgICAgICBjb25maWdGaWxlTW9kZTogMG82NjYsXG4gICAgICAgICAgICAuLi5wYXJ0aWFsT3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmN3ZCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSB0aGUgYHByb2plY3ROYW1lYCBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmN3ZCA9IGVudlBhdGhzKG9wdGlvbnMucHJvamVjdE5hbWUsIHsgc3VmZml4OiBvcHRpb25zLnByb2plY3RTdWZmaXggfSkuY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgPz8gb3B0aW9ucy5hanZPcHRpb25zID8/IG9wdGlvbnMucm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hICYmIHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IEFqdih7XG4gICAgICAgICAgICAgICAgYWxsRXJyb3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZURlZmF1bHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuYWp2T3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWp2Rm9ybWF0cyhhanYpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMucm9vdFNjaGVtYSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRpb25zLnNjaGVtYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLiN2YWxpZGF0b3IgPSBhanYuY29tcGlsZShzY2hlbWEpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zY2hlbWEgPz8ge30pKSB7IC8vIFRPRE86IFJlbW92ZSB0aGUgYGFzIGFueWAuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlPy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRWYWx1ZXNba2V5XSA9IHZhbHVlLmRlZmF1bHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICB0aGlzLiNkZWZhdWx0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuI2RlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSBvcHRpb25zLnNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSBvcHRpb25zLmRlc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuI2VuY3J5cHRpb25LZXkgPSBvcHRpb25zLmVuY3J5cHRpb25LZXk7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBvcHRpb25zLmZpbGVFeHRlbnNpb24gPyBgLiR7b3B0aW9ucy5maWxlRXh0ZW5zaW9ufWAgOiAnJztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBgJHtvcHRpb25zLmNvbmZpZ05hbWUgPz8gJ2NvbmZpZyd9JHtmaWxlRXh0ZW5zaW9ufWApO1xuICAgICAgICBjb25zdCBmaWxlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgICBjb25zdCBzdG9yZSA9IE9iamVjdC5hc3NpZ24oY3JlYXRlUGxhaW5PYmplY3QoKSwgb3B0aW9ucy5kZWZhdWx0cywgZmlsZVN0b3JlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnByb2plY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSB0aGUgYHByb2plY3RWZXJzaW9uYCBvcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9taWdyYXRlKG9wdGlvbnMubWlncmF0aW9ucywgb3B0aW9ucy5wcm9qZWN0VmVyc2lvbiwgb3B0aW9ucy5iZWZvcmVFYWNoTWlncmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkZWZlciB2YWxpZGF0aW9uIHVudGlsIGFmdGVyIG1pZ3JhdGlvbnMgYXJlIGFwcGxpZWQgc28gdGhhdCB0aGUgc3RvcmUgY2FuIGJlIHVwZGF0ZWQgdG8gdGhlIGN1cnJlbnQgc2NoZW1hLlxuICAgICAgICB0aGlzLl92YWxpZGF0ZShzdG9yZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKGZpbGVTdG9yZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBrZXkgaW4gc3RvcmUgPyBzdG9yZVtrZXldIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCBvciBcXGBvYmplY3RcXGAsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzZSBgZGVsZXRlKClgIHRvIGNsZWFyIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1Jlc2VydmVkS2V5KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBsZWFzZSBkb24ndCB1c2UgdGhlICR7SU5URVJOQUxfS0VZfSBrZXksIGFzIGl0J3MgdXNlZCB0byBtYW5hZ2UgdGhpcyBtb2R1bGUgaW50ZXJuYWwgb3BlcmF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZXQgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2hlY2tWYWx1ZVR5cGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy4jb3B0aW9ucy5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHNldFByb3BlcnR5KHN0b3JlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSBrZXk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucy5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BlcnR5KHRoaXMuc3RvcmUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCBpdGVtcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcywgYXMgZGVmaW5lZCBieSB0aGUgYGRlZmF1bHRzYCBvciBgc2NoZW1hYCBvcHRpb24uXG5cbiAgICBAc2VlIGBjbGVhcigpYCB0byByZXNldCBhbGwgaXRlbXMuXG5cbiAgICBAcGFyYW0ga2V5cyAtIFRoZSBrZXlzIG9mIHRoZSBpdGVtcyB0byByZXNldC5cbiAgICAqL1xuICAgIHJlc2V0KC4uLmtleXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKGlzRXhpc3QodGhpcy4jZGVmYXVsdFZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdGhpcy4jZGVmYXVsdFZhbHVlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy4jZGVmYXVsdFZhbHVlcykpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRpZENoYW5nZShrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxga2V5XFxgIHRvIGJlIG9mIHR5cGUgXFxgc3RyaW5nXFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGNhbGxiYWNrXFxgIHRvIGJlIG9mIHR5cGUgXFxgZnVuY3Rpb25cXGAsIGdvdCAke3R5cGVvZiBjYWxsYmFja31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQ2hhbmdlKCgpID0+IHRoaXMuZ2V0KGtleSksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgd2hvbGUgY29uZmlnIG9iamVjdCwgY2FsbGluZyBgY2FsbGJhY2tgIG9uIGFueSBjaGFuZ2VzLlxuXG4gICAgQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBhbnkgY2hhbmdlcy4gV2hlbiBhIGBrZXlgIGlzIGZpcnN0IHNldCBgb2xkVmFsdWVgIHdpbGwgYmUgYHVuZGVmaW5lZGAsIGFuZCB3aGVuIGEga2V5IGlzIGRlbGV0ZWQgYG5ld1ZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICAgIEByZXR1cm5zIEEgZnVuY3Rpb24sIHRoYXQgd2hlbiBjYWxsZWQsIHdpbGwgdW5zdWJzY3JpYmUuXG4gICAgKi9cbiAgICBvbkRpZEFueUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLnN0b3JlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yZSkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRoZSBjb25maWcgYXMgYW4gb2JqZWN0IG9yIHJlcGxhY2UgdGhlIGN1cnJlbnQgY29uZmlnIHdpdGggYW4gb2JqZWN0LlxuXG4gICAgQGV4YW1wbGVcbiAgICBgYGBcbiAgICBjb25zb2xlLmxvZyhjb25maWcuc3RvcmUpO1xuICAgIC8vPT4ge25hbWU6ICdKb2huJywgYWdlOiAzMH1cbiAgICBgYGBcblxuICAgIEBleGFtcGxlXG4gICAgYGBgXG4gICAgY29uZmlnLnN0b3JlID0ge1xuICAgICAgICBoZWxsbzogJ3dvcmxkJ1xuICAgIH07XG4gICAgYGBgXG4gICAgKi9cbiAgICBnZXQgc3RvcmUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHRoaXMucGF0aCwgdGhpcy4jZW5jcnlwdGlvbktleSA/IG51bGwgOiAndXRmOCcpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVN0cmluZyA9IHRoaXMuX2VuY3J5cHREYXRhKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRGF0YSA9IHRoaXMuX2Rlc2VyaWFsaXplKGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNvcHRpb25zLmNsZWFySW52YWxpZENvbmZpZyAmJiBlcnJvci5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgc3RvcmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fd3JpdGUodmFsdWUpO1xuICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgIH1cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3RvcmUpKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VuY3J5cHREYXRhKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNlbmNyeXB0aW9uS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IHVpbnQ4QXJyYXlUb1N0cmluZyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmModGhpcy4jZW5jcnlwdGlvbktleSwgaW5pdGlhbGl6YXRpb25WZWN0b3IudG9TdHJpbmcoKSwgMTBfMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBkYXRhLnNsaWNlKDE3KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFVcGRhdGUgPSB0eXBlb2Ygc2xpY2UgPT09ICdzdHJpbmcnID8gc3RyaW5nVG9VaW50OEFycmF5KHNsaWNlKSA6IHNsaWNlO1xuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb1N0cmluZyhjb25jYXRVaW50OEFycmF5cyhbZGVjaXBoZXIudXBkYXRlKGRhdGFVcGRhdGUpLCBkZWNpcGhlci5maW5hbCgpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBfaGFuZGxlQ2hhbmdlKGdldHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgIGlmIChpc0RlZXBTdHJpY3RFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2Rlc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgX3NlcmlhbGl6ZSA9IHZhbHVlID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlLCB1bmRlZmluZWQsICdcXHQnKTtcbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuI3ZhbGlkYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy4jdmFsaWRhdG9yKGRhdGEpO1xuICAgICAgICBpZiAodmFsaWQgfHwgIXRoaXMuI3ZhbGlkYXRvci5lcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLiN2YWxpZGF0b3IuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy4jZW5jcnlwdGlvbktleSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpO1xuICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBjcnlwdG8ucGJrZGYyU3luYyh0aGlzLiNlbmNyeXB0aW9uS2V5LCBpbml0aWFsaXphdGlvblZlY3Rvci50b1N0cmluZygpLCAxMF8wMDAsIDMyLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoZW5jcnlwdGlvbkFsZ29yaXRobSwgcGFzc3dvcmQsIGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRVaW50OEFycmF5cyhbaW5pdGlhbGl6YXRpb25WZWN0b3IsIHN0cmluZ1RvVWludDhBcnJheSgnOicpLCBjaXBoZXIudXBkYXRlKHN0cmluZ1RvVWludDhBcnJheShkYXRhKSksIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIENvbmYgYmVpbmcgcGFja2FnZWQgaW4gYSBVYnVudHUgU25hcCBhcHAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2NvbmYvcHVsbC84MlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuU05BUCkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEsIHsgbW9kZTogdGhpcy4jb3B0aW9ucy5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljV3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEsIHsgbW9kZTogdGhpcy4jb3B0aW9ucy5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9lbGVjdHJvbi1zdG9yZS9pc3N1ZXMvMTA2XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIG9uIFdpbmRvd3MsIHdlIHdpbGwgZ2V0IGFuIEVYREVWIGVycm9yIHdoZW4gYXRvbWljIHdyaXRpbmdcbiAgICAgICAgICAgICAgICAvLyAoZXZlbiB0aG91Z2ggdG8gdGhlIHNhbWUgZGlyZWN0b3J5KSwgc28gd2UgZmFsbCBiYWNrIHRvIG5vbiBhdG9taWMgd3JpdGVcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09ICdFWERFVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEsIHsgbW9kZTogdGhpcy4jb3B0aW9ucy5jb25maWdGaWxlTW9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfd2F0Y2goKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZURpcmVjdG9yeSgpO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmModGhpcy5wYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGUoY3JlYXRlUGxhaW5PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICAgIGZzLndhdGNoKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBPbiBMaW51eCBhbmQgV2luZG93cywgd3JpdGluZyB0byB0aGUgY29uZmlnIGZpbGUgZW1pdHMgYSBgcmVuYW1lYCBldmVudCwgc28gd2Ugc2tpcCBjaGVja2luZyB0aGUgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiA1MDAwIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbWlncmF0ZShtaWdyYXRpb25zLCB2ZXJzaW9uVG9NaWdyYXRlLCBiZWZvcmVFYWNoTWlncmF0aW9uKSB7XG4gICAgICAgIGxldCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHRoaXMuX2dldChNSUdSQVRJT05fS0VZLCAnMC4wLjAnKTtcbiAgICAgICAgY29uc3QgbmV3ZXJWZXJzaW9ucyA9IE9iamVjdC5rZXlzKG1pZ3JhdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGNhbmRpZGF0ZVZlcnNpb24gPT4gdGhpcy5fc2hvdWxkUGVyZm9ybU1pZ3JhdGlvbihjYW5kaWRhdGVWZXJzaW9uLCBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpO1xuICAgICAgICBsZXQgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIG5ld2VyVmVyc2lvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZUVhY2hNaWdyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaE1pZ3JhdGlvbih0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tVmVyc2lvbjogcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1ZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZlcnNpb246IHZlcnNpb25Ub01pZ3JhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uczogbmV3ZXJWZXJzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uPy4odGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBzdG9yZUJhY2t1cCA9IHsgLi4udGhpcy5zdG9yZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlQmFja3VwO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHRoZSBtaWdyYXRpb24hIENoYW5nZXMgYXBwbGllZCB0byB0aGUgc3RvcmUgdW50aWwgdGhpcyBmYWlsZWQgbWlncmF0aW9uIHdpbGwgYmUgcmVzdG9yZWQuICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQocHJldmlvdXNNaWdyYXRlZFZlcnNpb24pIHx8ICFzZW12ZXIuZXEocHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXQoTUlHUkFUSU9OX0tFWSwgdmVyc2lvblRvTWlncmF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnRhaW5zUmVzZXJ2ZWRLZXkoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0S2V5ID09PSBJTlRFUk5BTF9LRVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucy5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHkodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgc2V0UHJvcGVydHkoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/dist/source/index.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/env-paths/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/conf/node_modules/env-paths/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ envPaths)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:os */ \"node:os\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:process */ \"node:process\");\n\n\n\n\nconst homedir = node_os__WEBPACK_IMPORTED_MODULE_1__.homedir();\nconst tmpdir = node_os__WEBPACK_IMPORTED_MODULE_1__.tmpdir();\nconst {env} = node_process__WEBPACK_IMPORTED_MODULE_2__;\n\nconst macos = name => {\n\tconst library = node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, 'Library');\n\n\treturn {\n\t\tdata: node_path__WEBPACK_IMPORTED_MODULE_0__.join(library, 'Application Support', name),\n\t\tconfig: node_path__WEBPACK_IMPORTED_MODULE_0__.join(library, 'Preferences', name),\n\t\tcache: node_path__WEBPACK_IMPORTED_MODULE_0__.join(library, 'Caches', name),\n\t\tlog: node_path__WEBPACK_IMPORTED_MODULE_0__.join(library, 'Logs', name),\n\t\ttemp: node_path__WEBPACK_IMPORTED_MODULE_0__.join(tmpdir, name),\n\t};\n};\n\nconst windows = name => {\n\tconst appData = env.APPDATA || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, 'AppData', 'Roaming');\n\tconst localAppData = env.LOCALAPPDATA || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, 'AppData', 'Local');\n\n\treturn {\n\t\t// Data/config/cache/log are invented by me as Windows isn't opinionated about this\n\t\tdata: node_path__WEBPACK_IMPORTED_MODULE_0__.join(localAppData, name, 'Data'),\n\t\tconfig: node_path__WEBPACK_IMPORTED_MODULE_0__.join(appData, name, 'Config'),\n\t\tcache: node_path__WEBPACK_IMPORTED_MODULE_0__.join(localAppData, name, 'Cache'),\n\t\tlog: node_path__WEBPACK_IMPORTED_MODULE_0__.join(localAppData, name, 'Log'),\n\t\ttemp: node_path__WEBPACK_IMPORTED_MODULE_0__.join(tmpdir, name),\n\t};\n};\n\n// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nconst linux = name => {\n\tconst username = node_path__WEBPACK_IMPORTED_MODULE_0__.basename(homedir);\n\n\treturn {\n\t\tdata: node_path__WEBPACK_IMPORTED_MODULE_0__.join(env.XDG_DATA_HOME || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, '.local', 'share'), name),\n\t\tconfig: node_path__WEBPACK_IMPORTED_MODULE_0__.join(env.XDG_CONFIG_HOME || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, '.config'), name),\n\t\tcache: node_path__WEBPACK_IMPORTED_MODULE_0__.join(env.XDG_CACHE_HOME || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, '.cache'), name),\n\t\t// https://wiki.debian.org/XDGBaseDirectorySpecification#state\n\t\tlog: node_path__WEBPACK_IMPORTED_MODULE_0__.join(env.XDG_STATE_HOME || node_path__WEBPACK_IMPORTED_MODULE_0__.join(homedir, '.local', 'state'), name),\n\t\ttemp: node_path__WEBPACK_IMPORTED_MODULE_0__.join(tmpdir, username, name),\n\t};\n};\n\nfunction envPaths(name, {suffix = 'nodejs'} = {}) {\n\tif (typeof name !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof name}`);\n\t}\n\n\tif (suffix) {\n\t\t// Add suffix to prevent possible conflict with native apps\n\t\tname += `-${suffix}`;\n\t}\n\n\tif (node_process__WEBPACK_IMPORTED_MODULE_2__.platform === 'darwin') {\n\t\treturn macos(name);\n\t}\n\n\tif (node_process__WEBPACK_IMPORTED_MODULE_2__.platform === 'win32') {\n\t\treturn windows(name);\n\t}\n\n\treturn linux(name);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDSjtBQUNVOztBQUVuQyxnQkFBZ0IsNENBQVU7QUFDMUIsZUFBZSwyQ0FBUztBQUN4QixPQUFPLEtBQUssRUFBRSx5Q0FBTzs7QUFFckI7QUFDQSxpQkFBaUIsMkNBQVM7O0FBRTFCO0FBQ0EsUUFBUSwyQ0FBUztBQUNqQixVQUFVLDJDQUFTO0FBQ25CLFNBQVMsMkNBQVM7QUFDbEIsT0FBTywyQ0FBUztBQUNoQixRQUFRLDJDQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsMkNBQVM7QUFDekMsMENBQTBDLDJDQUFTOztBQUVuRDtBQUNBO0FBQ0EsUUFBUSwyQ0FBUztBQUNqQixVQUFVLDJDQUFTO0FBQ25CLFNBQVMsMkNBQVM7QUFDbEIsT0FBTywyQ0FBUztBQUNoQixRQUFRLDJDQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBYTs7QUFFL0I7QUFDQSxRQUFRLDJDQUFTLHNCQUFzQiwyQ0FBUztBQUNoRCxVQUFVLDJDQUFTLHdCQUF3QiwyQ0FBUztBQUNwRCxTQUFTLDJDQUFTLHVCQUF1QiwyQ0FBUztBQUNsRDtBQUNBLE9BQU8sMkNBQVMsdUJBQXVCLDJDQUFTO0FBQ2hELFFBQVEsMkNBQVM7QUFDakI7QUFDQTs7QUFFZSx5QkFBeUIsbUJBQW1CLElBQUk7QUFDL0Q7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBLEtBQUssa0RBQWdCO0FBQ3JCO0FBQ0E7O0FBRUEsS0FBSyxrREFBZ0I7QUFDckI7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzPzRmNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCBvcyBmcm9tICdub2RlOm9zJztcbmltcG9ydCBwcm9jZXNzIGZyb20gJ25vZGU6cHJvY2Vzcyc7XG5cbmNvbnN0IGhvbWVkaXIgPSBvcy5ob21lZGlyKCk7XG5jb25zdCB0bXBkaXIgPSBvcy50bXBkaXIoKTtcbmNvbnN0IHtlbnZ9ID0gcHJvY2VzcztcblxuY29uc3QgbWFjb3MgPSBuYW1lID0+IHtcblx0Y29uc3QgbGlicmFyeSA9IHBhdGguam9pbihob21lZGlyLCAnTGlicmFyeScpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGxpYnJhcnksICdBcHBsaWNhdGlvbiBTdXBwb3J0JywgbmFtZSksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4obGlicmFyeSwgJ1ByZWZlcmVuY2VzJywgbmFtZSksXG5cdFx0Y2FjaGU6IHBhdGguam9pbihsaWJyYXJ5LCAnQ2FjaGVzJywgbmFtZSksXG5cdFx0bG9nOiBwYXRoLmpvaW4obGlicmFyeSwgJ0xvZ3MnLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKSxcblx0fTtcbn07XG5cbmNvbnN0IHdpbmRvd3MgPSBuYW1lID0+IHtcblx0Y29uc3QgYXBwRGF0YSA9IGVudi5BUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJyk7XG5cdGNvbnN0IGxvY2FsQXBwRGF0YSA9IGVudi5MT0NBTEFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ0xvY2FsJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvLyBEYXRhL2NvbmZpZy9jYWNoZS9sb2cgYXJlIGludmVudGVkIGJ5IG1lIGFzIFdpbmRvd3MgaXNuJ3Qgb3BpbmlvbmF0ZWQgYWJvdXQgdGhpc1xuXHRcdGRhdGE6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdEYXRhJyksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oYXBwRGF0YSwgbmFtZSwgJ0NvbmZpZycpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnQ2FjaGUnKSxcblx0XHRsb2c6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdMb2cnKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKSxcblx0fTtcbn07XG5cbi8vIGh0dHBzOi8vc3BlY2lmaWNhdGlvbnMuZnJlZWRlc2t0b3Aub3JnL2Jhc2VkaXItc3BlYy9iYXNlZGlyLXNwZWMtbGF0ZXN0Lmh0bWxcbmNvbnN0IGxpbnV4ID0gbmFtZSA9PiB7XG5cdGNvbnN0IHVzZXJuYW1lID0gcGF0aC5iYXNlbmFtZShob21lZGlyKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihlbnYuWERHX0RBVEFfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzaGFyZScpLCBuYW1lKSxcblx0XHRjb25maWc6IHBhdGguam9pbihlbnYuWERHX0NPTkZJR19IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNvbmZpZycpLCBuYW1lKSxcblx0XHRjYWNoZTogcGF0aC5qb2luKGVudi5YREdfQ0FDSEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5jYWNoZScpLCBuYW1lKSxcblx0XHQvLyBodHRwczovL3dpa2kuZGViaWFuLm9yZy9YREdCYXNlRGlyZWN0b3J5U3BlY2lmaWNhdGlvbiNzdGF0ZVxuXHRcdGxvZzogcGF0aC5qb2luKGVudi5YREdfU1RBVEVfSE9NRSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgJy5sb2NhbCcsICdzdGF0ZScpLCBuYW1lKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCB1c2VybmFtZSwgbmFtZSksXG5cdH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbnZQYXRocyhuYW1lLCB7c3VmZml4ID0gJ25vZGVqcyd9ID0ge30pIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbmFtZX1gKTtcblx0fVxuXG5cdGlmIChzdWZmaXgpIHtcblx0XHQvLyBBZGQgc3VmZml4IHRvIHByZXZlbnQgcG9zc2libGUgY29uZmxpY3Qgd2l0aCBuYXRpdmUgYXBwc1xuXHRcdG5hbWUgKz0gYC0ke3N1ZmZpeH1gO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0cmV0dXJuIG1hY29zKG5hbWUpO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gd2luZG93cyhuYW1lKTtcblx0fVxuXG5cdHJldHVybiBsaW51eChuYW1lKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/env-paths/index.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/classes/comparator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/classes/comparator.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/conf/node_modules/semver/internal/parse-options.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/conf/node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"./node_modules/conf/node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/conf/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLG9HQUEyQjtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsOEVBQWdCO0FBQ2xELFlBQVksbUJBQU8sQ0FBQyxrRkFBa0I7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLG9GQUFtQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsMkVBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHlFQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvY29tcGFyYXRvci5qcz9jM2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXAgPSBjb21wLnZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcCA9IGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbignICcpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5wYXJzZShjb21wKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb25cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcCcsIHRoaXMpXG4gIH1cblxuICBwYXJzZSAoY29tcCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgbSA9IGNvbXAubWF0Y2gocilcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2NvbXB9YClcbiAgICB9XG5cbiAgICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgdGhpcy5vcGVyYXRvciA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gICAgaWYgKCFtWzJdKSB7XG4gICAgICB0aGlzLnNlbXZlciA9IEFOWVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSB8fCB2ZXJzaW9uID09PSBBTlkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW50ZXJzZWN0cyAoY29tcCwgb3B0aW9ucykge1xuICAgIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21wLnZhbHVlLCBvcHRpb25zKS50ZXN0KHRoaXMudmFsdWUpXG4gICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpLnRlc3QoY29tcC5zZW12ZXIpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSBub3RoaW5nIGNhbiBwb3NzaWJseSBiZSBsb3dlclxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgICAodGhpcy52YWx1ZSA9PT0gJzwwLjAuMC0wJyB8fCBjb21wLnZhbHVlID09PSAnPDAuMC4wLTAnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykgfHwgY29tcC52YWx1ZS5zdGFydHNXaXRoKCc8MC4wLjAnKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFNhbWUgZGlyZWN0aW9uIGluY3JlYXNpbmcgKD4gb3IgPj0pXG4gICAgaWYgKHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBkZWNyZWFzaW5nICg8IG9yIDw9KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gc2FtZSBTZW1WZXIgYW5kIGJvdGggc2lkZXMgYXJlIGluY2x1c2l2ZSAoPD0gb3IgPj0pXG4gICAgaWYgKFxuICAgICAgKHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb24pICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLmluY2x1ZGVzKCc9JykgJiYgY29tcC5vcGVyYXRvci5pbmNsdWRlcygnPScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBvcHBvc2l0ZSBkaXJlY3Rpb25zIGxlc3MgdGhhblxuICAgIGlmIChjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICB0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBncmVhdGVyIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGFyYXRvclxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgc2FmZVJlOiByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/classes/comparator.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/classes/range.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/classes/range.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = __webpack_require__(/*! ../internal/lrucache */ \"./node_modules/conf/node_modules/semver/internal/lrucache.js\")\nconst cache = new LRU()\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/conf/node_modules/semver/internal/parse-options.js\")\nconst Comparator = __webpack_require__(/*! ./comparator */ \"./node_modules/conf/node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/conf/node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/conf/node_modules/semver/internal/re.js\")\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(/*! ../internal/constants */ \"./node_modules/conf/node_modules/semver/internal/constants.js\")\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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Z0JBQWdCLEdBQUcsR0FBRyxHQUFHLElBQUksa0JBQWtCO0FBQy9DLElBQUk7QUFDSixnQkFBZ0IsS0FBSztBQUNyQixJQUFJO0FBQ0osZ0JBQWdCLEtBQUssRUFBRSxrQkFBa0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhLFFBQVE7QUFDckIsSUFBSTtBQUNKLGFBQWEsR0FBRyxHQUFHLFFBQVE7QUFDM0IsSUFBSTtBQUNKLGNBQWMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSTtBQUNwQyxJQUFJO0FBQ0osYUFBYSxHQUFHLEdBQUcsR0FBRyxHQUFHLFFBQVE7QUFDakMsSUFBSTtBQUNKLGNBQWMsR0FBRztBQUNqQjs7QUFFQSxZQUFZLE1BQU0sRUFBRSxHQUFHO0FBQ3ZCOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzPzQ2ODkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNQQUNFX0NIQVJBQ1RFUlMgPSAvXFxzKy9nXG5cbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLmluY2x1ZGVQcmVyZWxlYXNlID0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG5cbiAgICAvLyBGaXJzdCByZWR1Y2UgYWxsIHdoaXRlc3BhY2UgYXMgbXVjaCBhcyBwb3NzaWJsZSBzbyB3ZSBkbyBub3QgaGF2ZSB0byByZWx5XG4gICAgLy8gb24gcG90ZW50aWFsbHkgc2xvdyByZWdleGVzIGxpa2UgXFxzKi4gVGhpcyBpcyB0aGVuIHN0b3JlZCBhbmQgdXNlZCBmb3JcbiAgICAvLyBmdXR1cmUgZXJyb3IgbWVzc2FnZXMgYXMgd2VsbC5cbiAgICB0aGlzLnJhdyA9IHJhbmdlLnRyaW0oKS5yZXBsYWNlKFNQQUNFX0NIQVJBQ1RFUlMsICcgJylcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBvbiB8fFxuICAgIHRoaXMuc2V0ID0gdGhpcy5yYXdcbiAgICAgIC5zcGxpdCgnfHwnKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHIgPT4gdGhpcy5wYXJzZVJhbmdlKHIudHJpbSgpKSlcbiAgICAgIC8vIHRocm93IG91dCBhbnkgY29tcGFyYXRvciBsaXN0cyB0aGF0IGFyZSBlbXB0eVxuICAgICAgLy8gdGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCBpdCB3YXMgbm90IGEgdmFsaWQgcmFuZ2UsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgIC8vIGluIGxvb3NlIG1vZGUsIGJ1dCB3aWxsIHN0aWxsIHRocm93IGlmIHRoZSBXSE9MRSByYW5nZSBpcyBpbnZhbGlkLlxuICAgICAgLmZpbHRlcihjID0+IGMubGVuZ3RoKVxuXG4gICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke3RoaXMucmF3fWApXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgbm90IHRoZSBudWxsIHNldCwgdGhyb3cgb3V0IG51bGwgc2V0cy5cbiAgICBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgLy8ga2VlcCB0aGUgZmlyc3Qgb25lLCBpbiBjYXNlIHRoZXkncmUgYWxsIG51bGwgc2V0c1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLnNldFswXVxuICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5maWx0ZXIoYyA9PiAhaXNOdWxsU2V0KGNbMF0pKVxuICAgICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdHRlZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IHJhbmdlICgpIHtcbiAgICBpZiAodGhpcy5mb3JtYXR0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mb3JtYXR0ZWQgPSAnJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlZCArPSAnfHwnXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnNldFtpXVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNvbXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKGsgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCArPSAnICdcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gY29tcHNba10udG9TdHJpbmcoKS50cmltKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgcGFyc2VSYW5nZSAocmFuZ2UpIHtcbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9XG4gICAgICAodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIEZMQUdfSU5DTFVERV9QUkVSRUxFQVNFKSB8XG4gICAgICAodGhpcy5vcHRpb25zLmxvb3NlICYmIEZMQUdfTE9PU0UpXG4gICAgY29uc3QgbWVtb0tleSA9IG1lbW9PcHRzICsgJzonICsgcmFuZ2VcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQobWVtb0tleSlcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkXG4gICAgfVxuXG4gICAgY29uc3QgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBjb25zdCBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpXG4gICAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpXG5cbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCd0aWxkZSB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjYXJldCB0cmltJywgcmFuZ2UpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBsZXQgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgaWYgKGxvb3NlKSB7XG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgcmFuZ2VMaXN0ID0gcmFuZ2VMaXN0LmZpbHRlcihjb21wID0+IHtcbiAgICAgICAgZGVidWcoJ2xvb3NlIGludmFsaWQgZmlsdGVyJywgY29tcCwgdGhpcy5vcHRpb25zKVxuICAgICAgICByZXR1cm4gISFjb21wLm1hdGNoKHJlW3QuQ09NUEFSQVRPUkxPT1NFXSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGRlYnVnKCdyYW5nZSBsaXN0JywgcmFuZ2VMaXN0KVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZUxpc3QubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgIGlmIChpc051bGxTZXQoY29tcCkpIHtcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgfVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKSB7XG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvbHJ1Y2FjaGUnKVxuY29uc3QgY2FjaGUgPSBuZXcgTFJVKClcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jb21wYXJhdG9yJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3Qge1xuICBzYWZlUmU6IHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2UsXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgeyBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSwgRkxBR19MT09TRSB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvY29uc3RhbnRzJylcblxuY29uc3QgaXNOdWxsU2V0ID0gYyA9PiBjLnZhbHVlID09PSAnPDAuMC4wLTAnXG5jb25zdCBpc0FueSA9IGMgPT4gYy52YWx1ZSA9PT0gJydcblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmNvbnN0IGlzU2F0aXNmaWFibGUgPSAoY29tcGFyYXRvcnMsIG9wdGlvbnMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgY29uc3QgcmVtYWluaW5nQ29tcGFyYXRvcnMgPSBjb21wYXJhdG9ycy5zbGljZSgpXG4gIGxldCB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeSgob3RoZXJDb21wYXJhdG9yKSA9PiB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgfSlcblxuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuY29uc3QgcGFyc2VDb21wYXJhdG9yID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmNvbnN0IGlzWCA9IGlkID0+ICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMC0wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4wLjAuMSAtLT4gPj0wLjAuMSA8MC4xLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBjb21wXG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgLm1hcCgoYykgPT4gcmVwbGFjZVRpbGRlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMC4wLjEgLS0+ID49MC4wLjEgPDAuMC4yLTBcbi8vIF4wLjEuMCAtLT4gPj0wLjEuMCA8MC4yLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBjb21wXG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgLm1hcCgoYykgPT4gcmVwbGFjZUNhcmV0KGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXBcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VYUmFuZ2UoYywgb3B0aW9ucykpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29tcCA9IGNvbXAudHJpbSgpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5YUkFOR0VMT09TRV0gOiByZVt0LlhSQU5HRV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikgPT4ge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKVxuICAgIGNvbnN0IHhNID0gaXNYKE0pXG4gICAgY29uc3QgeG0gPSB4TSB8fCBpc1gobSlcbiAgICBjb25zdCB4cCA9IHhtIHx8IGlzWChwKVxuICAgIGNvbnN0IGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIGd0bHQgPSAnPj0nXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgICBtID0gMFxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICAgIHAgPSAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndGx0ID09PSAnPCcpIHtcbiAgICAgICAgcHIgPSAnLTAnXG4gICAgICB9XG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wXG4gICAgLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbi8vIFRPRE8gYnVpbGQ/XG5jb25zdCBoeXBoZW5SZXBsYWNlID0gaW5jUHIgPT4gKCQwLFxuICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICB0bywgdE0sIHRtLCB0cCwgdHByKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gYCR7ZnJvbX0gJHt0b31gLnRyaW0oKVxufVxuXG5jb25zdCB0ZXN0U2V0ID0gKHNldCwgdmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQ29tcGFyYXRvci5BTlkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyXG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/classes/range.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/classes/semver.js":
/*!*****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/classes/semver.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/conf/node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"./node_modules/conf/node_modules/semver/internal/constants.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/conf/node_modules/semver/internal/re.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/conf/node_modules/semver/internal/parse-options.js\")\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"./node_modules/conf/node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE])\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvc2VtdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDekMsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLDRGQUF1QjtBQUN4RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsOEVBQWdCOztBQUVsRCxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBMkI7QUFDeEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGdHQUF5QjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTiwwRUFBMEUsZUFBZTtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXO0FBQzdEO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanM/NjQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IGNvbXBhcmVJZGVudGlmaWVycyB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY2xhc3MgU2VtVmVyIHtcbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2ZXJzaW9uLiBNdXN0IGJlIGEgc3RyaW5nLiBHb3QgdHlwZSBcIiR7dHlwZW9mIHZlcnNpb259XCIuYClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ2J1aWxkIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraSlcbiAgfVxuXG4gIC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuICBpbmMgKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSB7XG4gICAgaWYgKHJlbGVhc2Uuc3RhcnRzV2l0aCgncHJlJykpIHtcbiAgICAgIGlmICghaWRlbnRpZmllciAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBpcyBlbXB0eScpXG4gICAgICB9XG4gICAgICAvLyBBdm9pZCBhbiBpbnZhbGlkIHNlbXZlciByZXN1bHRzXG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGAtJHtpZGVudGlmaWVyfWAubWF0Y2godGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5QUkVSRUxFQVNFTE9PU0VdIDogcmVbdC5QUkVSRUxFQVNFXSlcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSAhPT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyOiAke2lkZW50aWZpZXJ9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgICAvLyBwcmVwYXRjaC5cbiAgICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmVyc2lvbiAke3RoaXMucmF3fSBpcyBub3QgYSBwcmVyZWxlYXNlYClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm1pbm9yICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wYXRjaCAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5tYWpvcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICAgIGNhc2UgJ3ByZSc6IHtcbiAgICAgICAgY29uc3QgYmFzZSA9IE51bWJlcihpZGVudGlmaWVyQmFzZSkgPyAxIDogMFxuXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2Jhc2VdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgICAgaSA9IC0yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgPT09IHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykgJiYgaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6IGlkZW50aWZpZXIgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goYmFzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgbGV0IHByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgYmFzZV1cbiAgICAgICAgICBpZiAoaWRlbnRpZmllckJhc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcmVyZWxlYXNlID0gW2lkZW50aWZpZXJdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21wYXJlSWRlbnRpZmllcnModGhpcy5wcmVyZWxlYXNlWzBdLCBpZGVudGlmaWVyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke3JlbGVhc2V9YClcbiAgICB9XG4gICAgdGhpcy5yYXcgPSB0aGlzLmZvcm1hdCgpXG4gICAgaWYgKHRoaXMuYnVpbGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhdyArPSBgKyR7dGhpcy5idWlsZC5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtVmVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/classes/semver.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/clean.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/clean.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbGVhbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsMkVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanM/MzY3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGNsZWFuID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucylcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/clean.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/cmp.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/cmp.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst eq = __webpack_require__(/*! ./eq */ \"./node_modules/conf/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"./node_modules/conf/node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"./node_modules/conf/node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"./node_modules/conf/node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"./node_modules/conf/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"./node_modules/conf/node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLHFFQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyx1RUFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMscUVBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHVFQUFPO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxxRUFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsdUVBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jbXAuanM/OGM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgZXEgPSByZXF1aXJlKCcuL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vbmVxJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9ndCcpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2d0ZScpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9sdGUnKVxuXG5jb25zdCBjbXAgPSAoYSwgb3AsIGIsIGxvb3NlKSA9PiB7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhID09PSBiXG5cbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIH1cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/cmp.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/coerce.js":
/*!*******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/coerce.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\nconst { safeRe: re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/conf/node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLG9GQUFtQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsMkVBQVM7QUFDL0IsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDhFQUFnQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFNBQVM7QUFDMUUsNERBQTRELFNBQVM7O0FBRXJFLGtCQUFrQixNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTTtBQUMvRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanM/ODJjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHsgc2FmZVJlOiByZSwgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBjb2VyY2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gcmVbdC5DT0VSQ0VGVUxMXSA6IHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vIFdpdGggaW5jbHVkZVByZXJlbGVhc2Ugb3B0aW9uIHNldCwgJzEuMi4zLjQtcmMnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQtcmMnLCBub3QgJzIuMy40J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgY29uc3QgY29lcmNlUnRsUmVnZXggPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gcmVbdC5DT0VSQ0VSVExGVUxMXSA6IHJlW3QuQ09FUkNFUlRMXVxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gY29lcmNlUnRsUmVnZXguZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGhcbiAgICB9XG4gICAgLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuICAgIGNvZXJjZVJ0bFJlZ2V4Lmxhc3RJbmRleCA9IC0xXG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgbWFqb3IgPSBtYXRjaFsyXVxuICBjb25zdCBtaW5vciA9IG1hdGNoWzNdIHx8ICcwJ1xuICBjb25zdCBwYXRjaCA9IG1hdGNoWzRdIHx8ICcwJ1xuICBjb25zdCBwcmVyZWxlYXNlID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBtYXRjaFs1XSA/IGAtJHttYXRjaFs1XX1gIDogJydcbiAgY29uc3QgYnVpbGQgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzZdID8gYCske21hdGNoWzZdfWAgOiAnJ1xuXG4gIHJldHVybiBwYXJzZShgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0ke3ByZXJlbGVhc2V9JHtidWlsZH1gLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/coerce.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/compare-build.js":
/*!**************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/compare-build.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkLmpzP2RmNzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/compare-build.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/compare-loose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/compare-loose.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLWxvb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFXO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanM/NTI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBjb21wYXJlTG9vc2UgPSAoYSwgYikgPT4gY29tcGFyZShhLCBiLCB0cnVlKVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlTG9vc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/compare-loose.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/compare.js":
/*!********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/compare.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUM7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qcz9hZTkwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PlxuICBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/compare.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/diff.js":
/*!*****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/diff.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst parse = __webpack_require__(/*! ./parse.js */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyw4RUFBWTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanM/OWI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcblxuY29uc3QgZGlmZiA9ICh2ZXJzaW9uMSwgdmVyc2lvbjIpID0+IHtcbiAgY29uc3QgdjEgPSBwYXJzZSh2ZXJzaW9uMSwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgdjIgPSBwYXJzZSh2ZXJzaW9uMiwgbnVsbCwgdHJ1ZSlcbiAgY29uc3QgY29tcGFyaXNvbiA9IHYxLmNvbXBhcmUodjIpXG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdjFIaWdoZXIgPSBjb21wYXJpc29uID4gMFxuICBjb25zdCBoaWdoVmVyc2lvbiA9IHYxSGlnaGVyID8gdjEgOiB2MlxuICBjb25zdCBsb3dWZXJzaW9uID0gdjFIaWdoZXIgPyB2MiA6IHYxXG4gIGNvbnN0IGhpZ2hIYXNQcmUgPSAhIWhpZ2hWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG4gIGNvbnN0IGxvd0hhc1ByZSA9ICEhbG93VmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aFxuXG4gIGlmIChsb3dIYXNQcmUgJiYgIWhpZ2hIYXNQcmUpIHtcbiAgICAvLyBHb2luZyBmcm9tIHByZXJlbGVhc2UgLT4gbm8gcHJlcmVsZWFzZSByZXF1aXJlcyBzb21lIHNwZWNpYWwgY2FzaW5nXG5cbiAgICAvLyBJZiB0aGUgbG93IHZlcnNpb24gaGFzIG9ubHkgYSBtYWpvciwgdGhlbiBpdCB3aWxsIGFsd2F5cyBiZSBhIG1ham9yXG4gICAgLy8gU29tZSBleGFtcGxlczpcbiAgICAvLyAxLjAuMC0xIC0+IDEuMC4wXG4gICAgLy8gMS4wLjAtMSAtPiAxLjEuMVxuICAgIC8vIDEuMC4wLTEgLT4gMi4wLjBcbiAgICBpZiAoIWxvd1ZlcnNpb24ucGF0Y2ggJiYgIWxvd1ZlcnNpb24ubWlub3IpIHtcbiAgICAgIHJldHVybiAnbWFqb3InXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG1haW4gcGFydCBoYXMgbm8gZGlmZmVyZW5jZVxuICAgIGlmIChsb3dWZXJzaW9uLmNvbXBhcmVNYWluKGhpZ2hWZXJzaW9uKSA9PT0gMCkge1xuICAgICAgaWYgKGxvd1ZlcnNpb24ubWlub3IgJiYgIWxvd1ZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuICdtaW5vcidcbiAgICAgIH1cbiAgICAgIHJldHVybiAncGF0Y2gnXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBgcHJlYCBwcmVmaXggaWYgd2UgYXJlIGdvaW5nIHRvIGEgcHJlcmVsZWFzZSB2ZXJzaW9uXG4gIGNvbnN0IHByZWZpeCA9IGhpZ2hIYXNQcmUgPyAncHJlJyA6ICcnXG5cbiAgaWYgKHYxLm1ham9yICE9PSB2Mi5tYWpvcikge1xuICAgIHJldHVybiBwcmVmaXggKyAnbWFqb3InXG4gIH1cblxuICBpZiAodjEubWlub3IgIT09IHYyLm1pbm9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtaW5vcidcbiAgfVxuXG4gIGlmICh2MS5wYXRjaCAhPT0gdjIucGF0Y2gpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ3BhdGNoJ1xuICB9XG5cbiAgLy8gaGlnaCBhbmQgbG93IGFyZSBwcmVsZWFzZXNcbiAgcmV0dXJuICdwcmVyZWxlYXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/diff.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/eq.js":
/*!***************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/eq.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9lcS5qcz84NjkxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/eq.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/gt.js":
/*!***************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/gt.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcz8wNzI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGd0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDBcbm1vZHVsZS5leHBvcnRzID0gZ3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/gt.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/gte.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/gte.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzPzdlMzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/gte.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/inc.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/inc.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLG9GQUFtQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2luYy5qcz9jOTIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IGluYyA9ICh2ZXJzaW9uLCByZWxlYXNlLCBvcHRpb25zLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyQmFzZSA9IGlkZW50aWZpZXJcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIoXG4gICAgICB2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyID8gdmVyc2lvbi52ZXJzaW9uIDogdmVyc2lvbixcbiAgICAgIG9wdGlvbnNcbiAgICApLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyLCBpZGVudGlmaWVyQmFzZSkudmVyc2lvblxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gaW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/inc.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/lt.js":
/*!***************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/lt.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdC5qcz9hZmIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/lt.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/lte.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/lte.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9sdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzPzQzN2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/lte.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/major.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/major.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9tYWpvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21ham9yLmpzP2U5ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/major.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/minor.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/minor.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL21pbm9yLmpzP2I3NWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/minor.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/neq.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/neq.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9uZXEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVc7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzPzMwYjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/neq.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/parse.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/parse.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhcnNlLmpzP2RjNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhcnNlID0gKHZlcnNpb24sIG9wdGlvbnMsIHRocm93RXJyb3JzID0gZmFsc2UpID0+IHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoIXRocm93RXJyb3JzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aHJvdyBlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/parse.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/patch.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/patch.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzP2NmNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/patch.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/prerelease.js":
/*!***********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/prerelease.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQywyRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wcmVyZWxlYXNlLmpzP2MzMGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/prerelease.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/rcompare.js":
/*!*********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/rcompare.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compare = __webpack_require__(/*! ./compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yY29tcGFyZS5qcz81OGNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGIsIGEsIGxvb3NlKVxubW9kdWxlLmV4cG9ydHMgPSByY29tcGFyZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/rcompare.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/rsort.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/rsort.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/conf/node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9yc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQywyRkFBaUI7QUFDOUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanM/ZGZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHJzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChiLCBhLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHJzb3J0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/rsort.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/satisfies.js":
/*!**********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/satisfies.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLGtGQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzP2E5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/satisfies.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/sort.js":
/*!*****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/sort.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/conf/node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFpQjtBQUM5QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzPzZmZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/sort.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/functions/valid.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/functions/valid.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy92YWxpZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsMkVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanM/NzkwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/functions/valid.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/index.js":
/*!********************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"./node_modules/conf/node_modules/semver/internal/re.js\")\nconst constants = __webpack_require__(/*! ./internal/constants */ \"./node_modules/conf/node_modules/semver/internal/constants.js\")\nconst SemVer = __webpack_require__(/*! ./classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst identifiers = __webpack_require__(/*! ./internal/identifiers */ \"./node_modules/conf/node_modules/semver/internal/identifiers.js\")\nconst parse = __webpack_require__(/*! ./functions/parse */ \"./node_modules/conf/node_modules/semver/functions/parse.js\")\nconst valid = __webpack_require__(/*! ./functions/valid */ \"./node_modules/conf/node_modules/semver/functions/valid.js\")\nconst clean = __webpack_require__(/*! ./functions/clean */ \"./node_modules/conf/node_modules/semver/functions/clean.js\")\nconst inc = __webpack_require__(/*! ./functions/inc */ \"./node_modules/conf/node_modules/semver/functions/inc.js\")\nconst diff = __webpack_require__(/*! ./functions/diff */ \"./node_modules/conf/node_modules/semver/functions/diff.js\")\nconst major = __webpack_require__(/*! ./functions/major */ \"./node_modules/conf/node_modules/semver/functions/major.js\")\nconst minor = __webpack_require__(/*! ./functions/minor */ \"./node_modules/conf/node_modules/semver/functions/minor.js\")\nconst patch = __webpack_require__(/*! ./functions/patch */ \"./node_modules/conf/node_modules/semver/functions/patch.js\")\nconst prerelease = __webpack_require__(/*! ./functions/prerelease */ \"./node_modules/conf/node_modules/semver/functions/prerelease.js\")\nconst compare = __webpack_require__(/*! ./functions/compare */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nconst rcompare = __webpack_require__(/*! ./functions/rcompare */ \"./node_modules/conf/node_modules/semver/functions/rcompare.js\")\nconst compareLoose = __webpack_require__(/*! ./functions/compare-loose */ \"./node_modules/conf/node_modules/semver/functions/compare-loose.js\")\nconst compareBuild = __webpack_require__(/*! ./functions/compare-build */ \"./node_modules/conf/node_modules/semver/functions/compare-build.js\")\nconst sort = __webpack_require__(/*! ./functions/sort */ \"./node_modules/conf/node_modules/semver/functions/sort.js\")\nconst rsort = __webpack_require__(/*! ./functions/rsort */ \"./node_modules/conf/node_modules/semver/functions/rsort.js\")\nconst gt = __webpack_require__(/*! ./functions/gt */ \"./node_modules/conf/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ./functions/lt */ \"./node_modules/conf/node_modules/semver/functions/lt.js\")\nconst eq = __webpack_require__(/*! ./functions/eq */ \"./node_modules/conf/node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./functions/neq */ \"./node_modules/conf/node_modules/semver/functions/neq.js\")\nconst gte = __webpack_require__(/*! ./functions/gte */ \"./node_modules/conf/node_modules/semver/functions/gte.js\")\nconst lte = __webpack_require__(/*! ./functions/lte */ \"./node_modules/conf/node_modules/semver/functions/lte.js\")\nconst cmp = __webpack_require__(/*! ./functions/cmp */ \"./node_modules/conf/node_modules/semver/functions/cmp.js\")\nconst coerce = __webpack_require__(/*! ./functions/coerce */ \"./node_modules/conf/node_modules/semver/functions/coerce.js\")\nconst Comparator = __webpack_require__(/*! ./classes/comparator */ \"./node_modules/conf/node_modules/semver/classes/comparator.js\")\nconst Range = __webpack_require__(/*! ./classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ./functions/satisfies */ \"./node_modules/conf/node_modules/semver/functions/satisfies.js\")\nconst toComparators = __webpack_require__(/*! ./ranges/to-comparators */ \"./node_modules/conf/node_modules/semver/ranges/to-comparators.js\")\nconst maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ \"./node_modules/conf/node_modules/semver/ranges/max-satisfying.js\")\nconst minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ \"./node_modules/conf/node_modules/semver/ranges/min-satisfying.js\")\nconst minVersion = __webpack_require__(/*! ./ranges/min-version */ \"./node_modules/conf/node_modules/semver/ranges/min-version.js\")\nconst validRange = __webpack_require__(/*! ./ranges/valid */ \"./node_modules/conf/node_modules/semver/ranges/valid.js\")\nconst outside = __webpack_require__(/*! ./ranges/outside */ \"./node_modules/conf/node_modules/semver/ranges/outside.js\")\nconst gtr = __webpack_require__(/*! ./ranges/gtr */ \"./node_modules/conf/node_modules/semver/ranges/gtr.js\")\nconst ltr = __webpack_require__(/*! ./ranges/ltr */ \"./node_modules/conf/node_modules/semver/ranges/ltr.js\")\nconst intersects = __webpack_require__(/*! ./ranges/intersects */ \"./node_modules/conf/node_modules/semver/ranges/intersects.js\")\nconst simplifyRange = __webpack_require__(/*! ./ranges/simplify */ \"./node_modules/conf/node_modules/semver/ranges/simplify.js\")\nconst subset = __webpack_require__(/*! ./ranges/subset */ \"./node_modules/conf/node_modules/semver/ranges/subset.js\")\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkVBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsMkZBQXNCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXdCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHFGQUFtQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMscUZBQW1CO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxpRkFBaUI7QUFDckMsYUFBYSxtQkFBTyxDQUFDLG1GQUFrQjtBQUN2QyxjQUFjLG1CQUFPLENBQUMscUZBQW1CO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHFGQUFtQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBd0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMseUZBQXFCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLDJGQUFzQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxxR0FBMkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMscUdBQTJCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFGQUFtQjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsK0VBQWdCO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLCtFQUFnQjtBQUNuQyxZQUFZLG1CQUFPLENBQUMsaUZBQWlCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxpRkFBaUI7QUFDckMsWUFBWSxtQkFBTyxDQUFDLGlGQUFpQjtBQUNyQyxZQUFZLG1CQUFPLENBQUMsaUZBQWlCO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMkZBQXNCO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsNkZBQXVCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLGlHQUF5QjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBeUI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsaUdBQXlCO0FBQ3ZELG1CQUFtQixtQkFBTyxDQUFDLDJGQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQywrRUFBZ0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWtCO0FBQzFDLFlBQVksbUJBQU8sQ0FBQywyRUFBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsMkVBQWM7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMseUZBQXFCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLHFGQUFtQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsaUZBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanM/NTAyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgaWRlbnRpZmllcnMgPSByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGFyc2UnKVxuY29uc3QgdmFsaWQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpXG5jb25zdCBjbGVhbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJylcbmNvbnN0IGluYyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2luYycpXG5jb25zdCBkaWZmID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpXG5jb25zdCBtYWpvciA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJylcbmNvbnN0IG1pbm9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWlub3InKVxuY29uc3QgcGF0Y2ggPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpXG5jb25zdCBwcmVyZWxlYXNlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpXG5jb25zdCByc29ydCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBlcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJylcbmNvbnN0IG5lcSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL25lcScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBjb2VyY2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKVxuY29uc3QgbWF4U2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21heC1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpXG5jb25zdCBtaW5WZXJzaW9uID0gcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKVxuY29uc3QgdmFsaWRSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3ZhbGlkJylcbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJylcbmNvbnN0IGd0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpXG5jb25zdCBsdHIgPSByZXF1aXJlKCcuL3Jhbmdlcy9sdHInKVxuY29uc3QgaW50ZXJzZWN0cyA9IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKVxuY29uc3Qgc2ltcGxpZnlSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JylcbmNvbnN0IHN1YnNldCA9IHJlcXVpcmUoJy4vcmFuZ2VzL3N1YnNldCcpXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2UsXG4gIHZhbGlkLFxuICBjbGVhbixcbiAgaW5jLFxuICBkaWZmLFxuICBtYWpvcixcbiAgbWlub3IsXG4gIHBhdGNoLFxuICBwcmVyZWxlYXNlLFxuICBjb21wYXJlLFxuICByY29tcGFyZSxcbiAgY29tcGFyZUxvb3NlLFxuICBjb21wYXJlQnVpbGQsXG4gIHNvcnQsXG4gIHJzb3J0LFxuICBndCxcbiAgbHQsXG4gIGVxLFxuICBuZXEsXG4gIGd0ZSxcbiAgbHRlLFxuICBjbXAsXG4gIGNvZXJjZSxcbiAgQ29tcGFyYXRvcixcbiAgUmFuZ2UsXG4gIHNhdGlzZmllcyxcbiAgdG9Db21wYXJhdG9ycyxcbiAgbWF4U2F0aXNmeWluZyxcbiAgbWluU2F0aXNmeWluZyxcbiAgbWluVmVyc2lvbixcbiAgdmFsaWRSYW5nZSxcbiAgb3V0c2lkZSxcbiAgZ3RyLFxuICBsdHIsXG4gIGludGVyc2VjdHMsXG4gIHNpbXBsaWZ5UmFuZ2UsXG4gIHN1YnNldCxcbiAgU2VtVmVyLFxuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IGNvbnN0YW50cy5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBSRUxFQVNFX1RZUEVTOiBjb25zdGFudHMuUkVMRUFTRV9UWVBFUyxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiBpZGVudGlmaWVycy5jb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLnJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/index.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/constants.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanM/M2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBNYXggc2FmZSBsZW5ndGggZm9yIGEgYnVpbGQgaWRlbnRpZmllci4gVGhlIG1heCBsZW5ndGggbWludXMgNiBjaGFyYWN0ZXJzIGZvclxuLy8gdGhlIHNob3J0ZXN0IHZlcnNpb24gd2l0aCBhIGJ1aWxkIDAuMC4wK0JVSUxELlxuY29uc3QgTUFYX1NBRkVfQlVJTERfTEVOR1RIID0gTUFYX0xFTkdUSCAtIDZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/debug.js":
/*!*****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/debug.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nconst debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2RlYnVnLmpzPzk0N2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/debug.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/identifiers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/identifiers.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nconst numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcz9iOWJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBudW1lcmljID0gL15bMC05XSskL1xuY29uc3QgY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICBjb25zdCBibnVtID0gbnVtZXJpYy50ZXN0KGIpXG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYVxuICAgIGIgPSArYlxuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwXG4gICAgOiAoYW51bSAmJiAhYm51bSkgPyAtMVxuICAgIDogKGJudW0gJiYgIWFudW0pID8gMVxuICAgIDogYSA8IGIgPyAtMVxuICAgIDogMVxufVxuXG5jb25zdCByY29tcGFyZUlkZW50aWZpZXJzID0gKGEsIGIpID0+IGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/identifiers.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/lrucache.js":
/*!********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/lrucache.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nclass LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2xydWNhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9scnVjYWNoZS5qcz8zMjI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1heCA9IDEwMDBcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKVxuICB9XG5cbiAgZ2V0IChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMubWFwLmdldChrZXkpXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBrZXkgZnJvbSB0aGUgbWFwIGFuZCBhZGQgaXQgdG8gdGhlIGVuZFxuICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSlcbiAgICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICB9XG5cbiAgZGVsZXRlIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZGVsZXRlKGtleSlcbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmRlbGV0ZShrZXkpXG5cbiAgICBpZiAoIWRlbGV0ZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgY2FjaGUgaXMgZnVsbCwgZGVsZXRlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW1cbiAgICAgIGlmICh0aGlzLm1hcC5zaXplID49IHRoaXMubWF4KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5tYXAua2V5cygpLm5leHQoKS52YWx1ZVxuICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/lrucache.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/parse-options.js":
/*!*************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/parse-options.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3BhcnNlLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzPzIzYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHBhcnNlIG91dCBqdXN0IHRoZSBvcHRpb25zIHdlIGNhcmUgYWJvdXRcbmNvbnN0IGxvb3NlT3B0aW9uID0gT2JqZWN0LmZyZWV6ZSh7IGxvb3NlOiB0cnVlIH0pXG5jb25zdCBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHsgfSlcbmNvbnN0IHBhcnNlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gZW1wdHlPcHRzXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGxvb3NlT3B0aW9uXG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZU9wdGlvbnNcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/parse-options.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/internal/re.js":
/*!**************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/internal/re.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = __webpack_require__(/*! ./constants */ \"./node_modules/conf/node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"./node_modules/conf/node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n// Non-numberic identifiers include numberic identifiers but can be longer.\n// Therefore non-numberic identifiers must go first.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsa0ZBQWE7QUFDekIsY0FBYyxtQkFBTyxDQUFDLDBFQUFTO0FBQy9COztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGVBQWUsY0FBYztBQUM3QixZQUFZLFdBQVc7QUFDdkIsZ0JBQWdCLGVBQWU7QUFDL0IsVUFBVSxTQUFTO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0sWUFBWSxPQUFPLElBQUksS0FBSztBQUNsRCxnQkFBZ0IsTUFBTSxZQUFZLE9BQU8sSUFBSSxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGlCQUFpQjs7QUFFckU7QUFDQTs7QUFFQSwrQkFBK0IseUJBQXlCO0FBQ3hELHVCQUF1Qix5QkFBeUI7QUFDaEQsdUJBQXVCLHlCQUF5Qjs7QUFFaEQsb0NBQW9DLDhCQUE4QjtBQUNsRSw0QkFBNEIsOEJBQThCO0FBQzFELDRCQUE0Qiw4QkFBOEI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQyxDQUFDLEdBQUcseUJBQXlCOztBQUU3QiwrQ0FBK0M7QUFDL0MsQ0FBQyxHQUFHLDhCQUE4Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQyxDQUFDLFFBQVEsNEJBQTRCOztBQUVyQyx3Q0FBd0M7QUFDeEMsQ0FBQyxRQUFRLGlDQUFpQzs7QUFFMUM7QUFDQTs7QUFFQSxrQ0FBa0MsaUJBQWlCOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLENBQUMsUUFBUSx1QkFBdUI7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsQ0FBQyxFQUFFLGtCQUFrQjtBQUNyQixlQUFlOztBQUVmLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxDQUFDLEVBQUUsdUJBQXVCO0FBQzFCLGVBQWU7O0FBRWYseUJBQXlCLGtCQUFrQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDhCQUE4QjtBQUN0RSxtQ0FBbUMseUJBQXlCOztBQUU1RCx1Q0FBdUMsd0JBQXdCO0FBQy9ELDZCQUE2Qix3QkFBd0I7QUFDckQsNkJBQTZCLHdCQUF3QjtBQUNyRCx5QkFBeUIsa0JBQWtCO0FBQzNDLGtDQUFrQztBQUNsQzs7QUFFQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLGtDQUFrQyw2QkFBNkI7QUFDL0Qsa0NBQWtDLDZCQUE2QjtBQUMvRCw4QkFBOEIsdUJBQXVCO0FBQ3JELHVDQUF1QztBQUN2Qzs7QUFFQSwwQkFBMEIsWUFBWSxNQUFNLG1CQUFtQjtBQUMvRCwrQkFBK0IsWUFBWSxNQUFNLHdCQUF3Qjs7QUFFekU7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQkFBb0IsSUFBSSxFQUFFLDJCQUEyQjtBQUNyRCwwQkFBMEIsSUFBSSwyQkFBMkI7QUFDekQsMEJBQTBCLElBQUksMkJBQTJCO0FBQ3pELHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGlCQUFpQjtBQUNuRCx3QkFBd0I7O0FBRXhCLHlCQUF5QixpQkFBaUIsRUFBRSxtQkFBbUI7QUFDL0QsOEJBQThCLGlCQUFpQixFQUFFLHdCQUF3Qjs7QUFFekU7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxpQkFBaUI7QUFDbkQsd0JBQXdCOztBQUV4Qix5QkFBeUIsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQy9ELDhCQUE4QixpQkFBaUIsRUFBRSx3QkFBd0I7O0FBRXpFO0FBQ0EsbUNBQW1DLFlBQVksT0FBTyxrQkFBa0I7QUFDeEUsOEJBQThCLFlBQVksT0FBTyxpQkFBaUI7O0FBRWxFO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsQ0FBQyxPQUFPLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNoRCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUEseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9yZS5qcz85YTE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgTUFYX0xFTkdUSCxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCBzYWZlU3JjID0gZXhwb3J0cy5zYWZlU3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IExFVFRFUkRBU0hOVU1CRVIgPSAnW2EtekEtWjAtOS1dJ1xuXG4vLyBSZXBsYWNlIHNvbWUgZ3JlZWR5IHJlZ2V4IHRva2VucyB0byBwcmV2ZW50IHJlZ2V4IGRvcyBpc3N1ZXMuIFRoZXNlIHJlZ2V4IGFyZVxuLy8gdXNlZCBpbnRlcm5hbGx5IHZpYSB0aGUgc2FmZVJlIG9iamVjdCBzaW5jZSBhbGwgaW5wdXRzIGluIHRoaXMgbGlicmFyeSBnZXRcbi8vIG5vcm1hbGl6ZWQgZmlyc3QgdG8gdHJpbSBhbmQgY29sbGFwc2UgYWxsIGV4dHJhIHdoaXRlc3BhY2UuIFRoZSBvcmlnaW5hbFxuLy8gcmVnZXhlcyBhcmUgZXhwb3J0ZWQgZm9yIHVzZXJsYW5kIGNvbnN1bXB0aW9uIGFuZCBsb3dlciBsZXZlbCB1c2FnZS4gQVxuLy8gZnV0dXJlIGJyZWFraW5nIGNoYW5nZSBjb3VsZCBleHBvcnQgdGhlIHNhZmVyIHJlZ2V4IG9ubHkgd2l0aCBhIG5vdGUgdGhhdFxuLy8gYWxsIGlucHV0IHNob3VsZCBoYXZlIGV4dHJhIHdoaXRlc3BhY2UgcmVtb3ZlZC5cbmNvbnN0IHNhZmVSZWdleFJlcGxhY2VtZW50cyA9IFtcbiAgWydcXFxccycsIDFdLFxuICBbJ1xcXFxkJywgTUFYX0xFTkdUSF0sXG4gIFtMRVRURVJEQVNITlVNQkVSLCBNQVhfU0FGRV9CVUlMRF9MRU5HVEhdLFxuXVxuXG5jb25zdCBtYWtlU2FmZVJlZ2V4ID0gKHZhbHVlKSA9PiB7XG4gIGZvciAoY29uc3QgW3Rva2VuLCBtYXhdIG9mIHNhZmVSZWdleFJlcGxhY2VtZW50cykge1xuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0qYCkuam9pbihgJHt0b2tlbn17MCwke21heH19YClcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0rYCkuam9pbihgJHt0b2tlbn17MSwke21heH19YClcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IHNhZmUgPSBtYWtlU2FmZVJlZ2V4KHZhbHVlKVxuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgc2FmZVNyY1tpbmRleF0gPSBzYWZlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxuICBzYWZlUmVbaW5kZXhdID0gbmV3IFJlZ0V4cChzYWZlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnXFxcXGQrJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYClcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuLy8gTm9uLW51bWJlcmljIGlkZW50aWZpZXJzIGluY2x1ZGUgbnVtYmVyaWMgaWRlbnRpZmllcnMgYnV0IGNhbiBiZSBsb25nZXIuXG4vLyBUaGVyZWZvcmUgbm9uLW51bWJlcmljIGlkZW50aWZpZXJzIG11c3QgZ28gZmlyc3QuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgYCR7TEVUVEVSREFTSE5VTUJFUn0rYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdCVUlMRCcsIGAoPzpcXFxcKygke3NyY1t0LkJVSUxESURFTlRJRklFUl1cbn0oPzpcXFxcLiR7c3JjW3QuQlVJTERJREVOVElGSUVSXX0pKikpYClcblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbmNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBgdj8ke3NyY1t0Lk1BSU5WRVJTSU9OXVxufSR7c3JjW3QuUFJFUkVMRUFTRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0ZVTEwnLCBgXiR7c3JjW3QuRlVMTFBMQUlOXX0kYClcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuY3JlYXRlVG9rZW4oJ0xPT1NFUExBSU4nLCBgW3Y9XFxcXHNdKiR7c3JjW3QuTUFJTlZFUlNJT05MT09TRV1cbn0ke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19PyR7XG4gIHNyY1t0LkJVSUxEXX0/YClcblxuY3JlYXRlVG9rZW4oJ0xPT1NFJywgYF4ke3NyY1t0LkxPT1NFUExBSU5dfSRgKVxuXG5jcmVhdGVUb2tlbignR1RMVCcsICcoKD86PHw+KT89PyknKVxuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUkxPT1NFJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApXG5jcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRVBMQUlOTE9PU0UnLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VMT09TRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF19P2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUxPT1NFJywgYF4ke3NyY1t0LkdUTFRdfVxcXFxzKiR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuY3JlYXRlVG9rZW4oJ0NPRVJDRVBMQUlOJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRScsIGAke3NyY1t0LkNPRVJDRVBMQUlOXX0oPzokfFteXFxcXGRdKWApXG5jcmVhdGVUb2tlbignQ09FUkNFRlVMTCcsIHNyY1t0LkNPRVJDRVBMQUlOXSArXG4gICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/YCArXG4gICAgICAgICAgICAgIGAoPzoke3NyY1t0LkJVSUxEXX0pP2AgK1xuICAgICAgICAgICAgICBgKD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpXG5jcmVhdGVUb2tlbignQ09FUkNFUlRMRlVMTCcsIHNyY1t0LkNPRVJDRUZVTExdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wXFxcXHMqJCcpXG5jcmVhdGVUb2tlbignR1RFMFBSRScsICdeXFxcXHMqPj1cXFxccyowXFxcXC4wXFxcXC4wLTBcXFxccyokJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/internal/re.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/gtr.js":
/*!*************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/gtr.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"./node_modules/conf/node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNuQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanM/ZTUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/gtr.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/intersects.js":
/*!********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/intersects.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzP2NkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/intersects.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/ltr.js":
/*!*************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/ltr.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst outside = __webpack_require__(/*! ./outside */ \"./node_modules/conf/node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNEVBQVc7QUFDbkM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanM/M2JiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmNvbnN0IGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBsdHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/ltr.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/max-satisfying.js":
/*!************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/max-satisfying.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxrRkFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWF4LXNhdGlzZnlpbmcuanM/NTFhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/max-satisfying.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/min-satisfying.js":
/*!************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/min-satisfying.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tc2F0aXNmeWluZy5qcz9jYTY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/min-satisfying.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/min-version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/min-version.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/conf/node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsb0ZBQW1CO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGdGQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQkFBb0I7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanM/NTU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcblxuY29uc3QgbWluVmVyc2lvbiA9IChyYW5nZSwgbG9vc2UpID0+IHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIGxldCBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IHNldE1pbiA9IG51bGxcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAvLyBDbG9uZSB0byBhdm9pZCBtYW5pcHVsYXRpbmcgdGhlIGNvbXBhcmF0b3IncyBzZW12ZXIgb2JqZWN0LlxuICAgICAgY29uc3QgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIXNldE1pbiB8fCBndChjb21wdmVyLCBzZXRNaW4pKSB7XG4gICAgICAgICAgICBzZXRNaW4gPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvcGVyYXRpb246ICR7Y29tcGFyYXRvci5vcGVyYXRvcn1gKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHNldE1pbiAmJiAoIW1pbnZlciB8fCBndChtaW52ZXIsIHNldE1pbikpKSB7XG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgICB9XG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblZlcnNpb25cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/min-version.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/outside.js":
/*!*****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/outside.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/conf/node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"./node_modules/conf/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"./node_modules/conf/node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/conf/node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"./node_modules/conf/node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"./node_modules/conf/node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"./node_modules/conf/node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsNEZBQXVCO0FBQ2xELFFBQVEsTUFBTTtBQUNkLGNBQWMsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXdCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGdGQUFpQjtBQUNwQyxZQUFZLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyxrRkFBa0I7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9vdXRzaWRlLmpzP2NjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IGd0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0JylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2d0ZScpXG5cbmNvbnN0IG91dHNpZGUgPSAodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIG9wdGlvbnMpID0+IHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG5cbiAgbGV0IGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcFxuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndFxuICAgICAgbHRlZm4gPSBsdGVcbiAgICAgIGx0Zm4gPSBsdFxuICAgICAgY29tcCA9ICc+J1xuICAgICAgZWNvbXAgPSAnPj0nXG4gICAgICBicmVha1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0XG4gICAgICBsdGVmbiA9IGd0ZVxuICAgICAgbHRmbiA9IGd0XG4gICAgICBjb21wID0gJzwnXG4gICAgICBlY29tcCA9ICc8PSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJylcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzZmllcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgbGV0IGhpZ2ggPSBudWxsXG4gICAgbGV0IGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRzaWRlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/outside.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/simplify.js":
/*!******************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/simplify.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/conf/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxpR0FBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTix1QkFBdUIsSUFBSTtBQUMzQixNQUFNO0FBQ04sdUJBQXVCLElBQUk7QUFDM0IsTUFBTTtBQUNOLHFCQUFxQixLQUFLLElBQUksSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzPzU1MzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICBsZXQgcHJldiA9IG51bGxcbiAgY29uc3QgdiA9IHZlcnNpb25zLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYSwgYiwgb3B0aW9ucykpXG4gIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2KSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgaWYgKGluY2x1ZGVkKSB7XG4gICAgICBwcmV2ID0gdmVyc2lvblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgc2V0LnB1c2goW2ZpcnN0LCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBmaXJzdCA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0KSB7XG4gICAgc2V0LnB1c2goW2ZpcnN0LCBudWxsXSlcbiAgfVxuXG4gIGNvbnN0IHJhbmdlcyA9IFtdXG4gIGZvciAoY29uc3QgW21pbiwgbWF4XSBvZiBzZXQpIHtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICB9IGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaCgnKicpXG4gICAgfSBlbHNlIGlmICghbWF4KSB7XG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIH0gZWxzZSBpZiAobWluID09PSB2WzBdKSB7XG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMucHVzaChgJHttaW59IC0gJHttYXh9YClcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/simplify.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/subset.js":
/*!****************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/subset.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst Range = __webpack_require__(/*! ../classes/range.js */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"./node_modules/conf/node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/conf/node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/conf/node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLHFGQUFxQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBMEI7QUFDckQsUUFBUSxNQUFNO0FBQ2Qsa0JBQWtCLG1CQUFPLENBQUMsaUdBQTJCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDZGQUF5Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanM/MzRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlLmpzJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3IuanMnKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcblxuLy8gQ29tcGxleCByYW5nZSBgcjEgfHwgcjIgfHwgLi4uYCBpcyBhIHN1YnNldCBvZiBgUjEgfHwgUjIgfHwgLi4uYCBpZmY6XG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIGlzIGEgbnVsbCBzZXQsIE9SXG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIHdoaWNoIGlzIG5vdCBhIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mXG4vLyAgIHNvbWUgYFIxLCBSMiwgLi4uYFxuLy9cbi8vIFNpbXBsZSByYW5nZSBgYzEgYzIgLi4uYCBpcyBhIHN1YnNldCBvZiBzaW1wbGUgcmFuZ2UgYEMxIEMyIC4uLmAgaWZmOlxuLy8gLSBJZiBjIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvciwgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIGZhbHNlXG4vLyAgIC0gZWxzZSByZXBsYWNlIGMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gdHJ1ZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBDIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gTGV0IEVRIGJlIHRoZSBzZXQgb2YgPSBjb21wYXJhdG9ycyBpbiBjXG4vLyAtIElmIEVRIGlzIG1vcmUgdGhhbiBvbmUsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gTGV0IEdUIGJlIHRoZSBoaWdoZXN0ID4gb3IgPj0gY29tcGFyYXRvciBpbiBjXG4vLyAtIExldCBMVCBiZSB0aGUgbG93ZXN0IDwgb3IgPD0gY29tcGFyYXRvciBpbiBjXG4vLyAtIElmIEdUIGFuZCBMVCwgYW5kIEdULnNlbXZlciA+IExULnNlbXZlciwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBJZiBhbnkgQyBpcyBhID0gcmFuZ2UsIGFuZCBHVCBvciBMVCBhcmUgc2V0LCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgRVFcbi8vICAgLSBJZiBHVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgR1QsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBMVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgTFQsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBFUSBzYXRpc2ZpZXMgZXZlcnkgQywgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIHJldHVybiBmYWxzZVxuLy8gLSBJZiBHVFxuLy8gICAtIElmIEdULnNlbXZlciBpcyBsb3dlciB0aGFuIGFueSA+IG9yID49IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1QgaXMgPj0sIGFuZCBHVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIEdULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIExUXG4vLyAgIC0gSWYgTFQuc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBhbnkgPCBvciA8PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIExUIGlzIDw9LCBhbmQgTFQuc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBMVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBFbHNlIHJldHVybiB0cnVlXG5cbmNvbnN0IHN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdWIgPSBuZXcgUmFuZ2Uoc3ViLCBvcHRpb25zKVxuICBkb20gPSBuZXcgUmFuZ2UoZG9tLCBvcHRpb25zKVxuICBsZXQgc2F3Tm9uTnVsbCA9IGZhbHNlXG5cbiAgT1VURVI6IGZvciAoY29uc3Qgc2ltcGxlU3ViIG9mIHN1Yi5zZXQpIHtcbiAgICBmb3IgKGNvbnN0IHNpbXBsZURvbSBvZiBkb20uc2V0KSB7XG4gICAgICBjb25zdCBpc1N1YiA9IHNpbXBsZVN1YnNldChzaW1wbGVTdWIsIHNpbXBsZURvbSwgb3B0aW9ucylcbiAgICAgIHNhd05vbk51bGwgPSBzYXdOb25OdWxsIHx8IGlzU3ViICE9PSBudWxsXG4gICAgICBpZiAoaXNTdWIpIHtcbiAgICAgICAgY29udGludWUgT1VURVJcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhlIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mIGV2ZXJ5dGhpbmcsIGJ1dCBudWxsIHNpbXBsZSByYW5nZXMgaW5cbiAgICAvLyBhIGNvbXBsZXggcmFuZ2Ugc2hvdWxkIGJlIGlnbm9yZWQuICBzbyBpZiB3ZSBzYXcgYSBub24tbnVsbCByYW5nZSxcbiAgICAvLyB0aGVuIHdlIGtub3cgdGhpcyBpc24ndCBhIHN1YnNldCwgYnV0IGlmIEVWRVJZIHNpbXBsZSByYW5nZSB3YXMgbnVsbCxcbiAgICAvLyB0aGVuIGl0IGlzIGEgc3Vic2V0LlxuICAgIGlmIChzYXdOb25OdWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3QgbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZSA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJyldXG5jb25zdCBtaW5pbXVtVmVyc2lvbiA9IFtuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHN1YiA9IG1pbmltdW1WZXJzaW9uV2l0aFByZVJlbGVhc2VcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25cbiAgICB9XG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gbWluaW11bVZlcnNpb25cbiAgICB9XG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBlcVNldC5hZGQoYy5zZW12ZXIpXG4gICAgfVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGd0bHRDb21wID09PSAwICYmIChndC5vcGVyYXRvciAhPT0gJz49JyB8fCBsdC5vcGVyYXRvciAhPT0gJzw9JykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gd2lsbCBpdGVyYXRlIG9uZSBvciB6ZXJvIHRpbWVzXG4gIGZvciAoY29uc3QgZXEgb2YgZXFTZXQpIHtcbiAgICBpZiAoZ3QgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGd0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGx0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhsdCksIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICAgIGlmICghc2F0aXNmaWVzKGVxLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3Qub3BlcmF0b3IgPT09ICc+PScgJiYgIXNhdGlzZmllcyhndC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsdC5vcGVyYXRvciA9PT0gJzw9JyAmJiAhc2F0aXNmaWVzKGx0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobHQgJiYgaGFzRG9tR1QgJiYgIWd0ICYmIGd0bHRDb21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wID4gMCA/IGFcbiAgICA6IGNvbXAgPCAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJz4nICYmIGEub3BlcmF0b3IgPT09ICc+PScgPyBiXG4gICAgOiBhXG59XG5cbi8vIDw9MS4yLjMgaXMgaGlnaGVyIHRoYW4gPDEuMi4zXG5jb25zdCBsb3dlckxUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/subset.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/to-comparators.js":
/*!************************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/to-comparators.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsa0ZBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanM/NTMwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/to-comparators.js\n\n}");

/***/ }),

/***/ "./node_modules/conf/node_modules/semver/ranges/valid.js":
/*!***************************************************************!*\
  !*** ./node_modules/conf/node_modules/semver/ranges/valid.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/conf/node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixjQUFjLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzP2FmNGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCB2YWxpZFJhbmdlID0gKHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRSYW5nZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/conf/node_modules/semver/ranges/valid.js\n\n}");

/***/ }),

/***/ "./node_modules/debounce-fn/index.js":
/*!*******************************************!*\
  !*** ./node_modules/debounce-fn/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var mimic_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mimic-function */ \"./node_modules/mimic-function/index.js\");\n\n\nconst debounceFunction = (inputFunction, options = {}) => {\n\tif (typeof inputFunction !== 'function') {\n\t\tthrow new TypeError(`Expected the first argument to be a function, got \\`${typeof inputFunction}\\``);\n\t}\n\n\tconst {\n\t\twait = 0,\n\t\tmaxWait = Number.POSITIVE_INFINITY,\n\t\tbefore = false,\n\t\tafter = true,\n\t} = options;\n\n\tif (wait < 0 || maxWait < 0) {\n\t\tthrow new RangeError('`wait` and `maxWait` must not be negative.');\n\t}\n\n\tif (!before && !after) {\n\t\tthrow new Error('Both `before` and `after` are false, function wouldn\\'t be called.');\n\t}\n\n\tlet timeout;\n\tlet maxTimeout;\n\tlet result;\n\n\tconst debouncedFunction = function (...arguments_) {\n\t\tconst context = this; // eslint-disable-line unicorn/no-this-assignment\n\n\t\tconst later = () => {\n\t\t\ttimeout = undefined;\n\n\t\t\tif (maxTimeout) {\n\t\t\t\tclearTimeout(maxTimeout);\n\t\t\t\tmaxTimeout = undefined;\n\t\t\t}\n\n\t\t\tif (after) {\n\t\t\t\tresult = inputFunction.apply(context, arguments_);\n\t\t\t}\n\t\t};\n\n\t\tconst maxLater = () => {\n\t\t\tmaxTimeout = undefined;\n\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = undefined;\n\t\t\t}\n\n\t\t\tif (after) {\n\t\t\t\tresult = inputFunction.apply(context, arguments_);\n\t\t\t}\n\t\t};\n\n\t\tconst shouldCallNow = before && !timeout;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\n\t\tif (maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout) {\n\t\t\tmaxTimeout = setTimeout(maxLater, maxWait);\n\t\t}\n\n\t\tif (shouldCallNow) {\n\t\t\tresult = inputFunction.apply(context, arguments_);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t(0,mimic_function__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(debouncedFunction, inputFunction);\n\n\tdebouncedFunction.cancel = () => {\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = undefined;\n\t\t}\n\n\t\tif (maxTimeout) {\n\t\t\tclearTimeout(maxTimeout);\n\t\t\tmaxTimeout = undefined;\n\t\t}\n\t};\n\n\treturn debouncedFunction;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounceFunction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRTNDLHFEQUFxRDtBQUNyRDtBQUNBLDZFQUE2RSxxQkFBcUI7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsMERBQWE7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9pbmRleC5qcz9lNDNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtaW1pY0Z1bmN0aW9uIGZyb20gJ21pbWljLWZ1bmN0aW9uJztcblxuY29uc3QgZGVib3VuY2VGdW5jdGlvbiA9IChpbnB1dEZ1bmN0aW9uLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKHR5cGVvZiBpbnB1dEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24sIGdvdCBcXGAke3R5cGVvZiBpbnB1dEZ1bmN0aW9ufVxcYGApO1xuXHR9XG5cblx0Y29uc3Qge1xuXHRcdHdhaXQgPSAwLFxuXHRcdG1heFdhaXQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG5cdFx0YmVmb3JlID0gZmFsc2UsXG5cdFx0YWZ0ZXIgPSB0cnVlLFxuXHR9ID0gb3B0aW9ucztcblxuXHRpZiAod2FpdCA8IDAgfHwgbWF4V2FpdCA8IDApIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignYHdhaXRgIGFuZCBgbWF4V2FpdGAgbXVzdCBub3QgYmUgbmVnYXRpdmUuJyk7XG5cdH1cblxuXHRpZiAoIWJlZm9yZSAmJiAhYWZ0ZXIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdGggYGJlZm9yZWAgYW5kIGBhZnRlcmAgYXJlIGZhbHNlLCBmdW5jdGlvbiB3b3VsZG5cXCd0IGJlIGNhbGxlZC4nKTtcblx0fVxuXG5cdGxldCB0aW1lb3V0O1xuXHRsZXQgbWF4VGltZW91dDtcblx0bGV0IHJlc3VsdDtcblxuXHRjb25zdCBkZWJvdW5jZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y29uc3QgY29udGV4dCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdW5pY29ybi9uby10aGlzLWFzc2lnbm1lbnRcblxuXHRcdGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuXHRcdFx0dGltZW91dCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKG1heFRpbWVvdXQpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KG1heFRpbWVvdXQpO1xuXHRcdFx0XHRtYXhUaW1lb3V0ID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3QgbWF4TGF0ZXIgPSAoKSA9PiB7XG5cdFx0XHRtYXhUaW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAodGltZW91dCkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRyZXN1bHQgPSBpbnB1dEZ1bmN0aW9uLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50c18pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBzaG91bGRDYWxsTm93ID0gYmVmb3JlICYmICF0aW1lb3V0O1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cblx0XHRpZiAobWF4V2FpdCA+IDAgJiYgbWF4V2FpdCAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmICFtYXhUaW1lb3V0KSB7XG5cdFx0XHRtYXhUaW1lb3V0ID0gc2V0VGltZW91dChtYXhMYXRlciwgbWF4V2FpdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3VsZENhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRtaW1pY0Z1bmN0aW9uKGRlYm91bmNlZEZ1bmN0aW9uLCBpbnB1dEZ1bmN0aW9uKTtcblxuXHRkZWJvdW5jZWRGdW5jdGlvbi5jYW5jZWwgPSAoKSA9PiB7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dChtYXhUaW1lb3V0KTtcblx0XHRcdG1heFRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBkZWJvdW5jZWRGdW5jdGlvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlYm91bmNlRnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/debounce-fn/index.js\n\n}");

/***/ }),

/***/ "./node_modules/dot-prop/index.js":
/*!****************************************!*\
  !*** ./node_modules/dot-prop/index.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepKeys: () => (/* binding */ deepKeys),\n/* harmony export */   deleteProperty: () => (/* binding */ deleteProperty),\n/* harmony export */   escapePath: () => (/* binding */ escapePath),\n/* harmony export */   getProperty: () => (/* binding */ getProperty),\n/* harmony export */   hasProperty: () => (/* binding */ hasProperty),\n/* harmony export */   setProperty: () => (/* binding */ setProperty)\n/* harmony export */ });\nconst isObject = value => {\n\tconst type = typeof value;\n\treturn value !== null && (type === 'object' || type === 'function');\n};\n\nconst isEmptyObject = value => isObject(value) && Object.keys(value).length === 0;\n\nconst disallowedKeys = new Set([\n\t'__proto__',\n\t'prototype',\n\t'constructor',\n]);\n\nconst digits = new Set('0123456789');\n\nfunction getPathSegments(path) {\n\tconst parts = [];\n\tlet currentSegment = '';\n\tlet currentPart = 'start';\n\tlet isIgnoring = false;\n\n\tfor (const character of path) {\n\t\tswitch (character) {\n\t\t\tcase '\\\\': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t}\n\n\t\t\t\tcurrentPart = 'property';\n\t\t\t\tisIgnoring = !isIgnoring;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '.': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tcurrentPart = 'property';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tparts.push(currentSegment);\n\t\t\t\tcurrentSegment = '';\n\t\t\t\tcurrentPart = 'property';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '[': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tcurrentPart = 'index';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += character;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'property') {\n\t\t\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tparts.push(currentSegment);\n\t\t\t\t\tcurrentSegment = '';\n\t\t\t\t}\n\n\t\t\t\tcurrentPart = 'index';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ']': {\n\t\t\t\tif (currentPart === 'index') {\n\t\t\t\t\tparts.push(Number.parseInt(currentSegment, 10));\n\t\t\t\t\tcurrentSegment = '';\n\t\t\t\t\tcurrentPart = 'indexEnd';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\t// Falls through\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif (currentPart === 'index' && !digits.has(character)) {\n\t\t\t\t\tthrow new Error('Invalid character in an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'indexEnd') {\n\t\t\t\t\tthrow new Error('Invalid character after an index');\n\t\t\t\t}\n\n\t\t\t\tif (currentPart === 'start') {\n\t\t\t\t\tcurrentPart = 'property';\n\t\t\t\t}\n\n\t\t\t\tif (isIgnoring) {\n\t\t\t\t\tisIgnoring = false;\n\t\t\t\t\tcurrentSegment += '\\\\';\n\t\t\t\t}\n\n\t\t\t\tcurrentSegment += character;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (isIgnoring) {\n\t\tcurrentSegment += '\\\\';\n\t}\n\n\tswitch (currentPart) {\n\t\tcase 'property': {\n\t\t\tif (disallowedKeys.has(currentSegment)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tparts.push(currentSegment);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'index': {\n\t\t\tthrow new Error('Index was not closed');\n\t\t}\n\n\t\tcase 'start': {\n\t\t\tparts.push('');\n\n\t\t\tbreak;\n\t\t}\n\t\t// No default\n\t}\n\n\treturn parts;\n}\n\nfunction isStringIndex(object, key) {\n\tif (typeof key !== 'number' && Array.isArray(object)) {\n\t\tconst index = Number.parseInt(key, 10);\n\t\treturn Number.isInteger(index) && object[index] === object[key];\n\t}\n\n\treturn false;\n}\n\nfunction assertNotStringIndex(object, key) {\n\tif (isStringIndex(object, key)) {\n\t\tthrow new Error('Cannot use string index');\n\t}\n}\n\nfunction getProperty(object, path, value) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn value === undefined ? object : value;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\tif (pathArray.length === 0) {\n\t\treturn value;\n\t}\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tif (isStringIndex(object, key)) {\n\t\t\tobject = index === pathArray.length - 1 ? undefined : null;\n\t\t} else {\n\t\t\tobject = object[key];\n\t\t}\n\n\t\tif (object === undefined || object === null) {\n\t\t\t// `object` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t// if this is not the last bit of the path, and\n\t\t\t// if it didn't return `undefined`\n\t\t\t// it would return `null` if `object` is `null`\n\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\tif (index !== pathArray.length - 1) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn object === undefined ? value : object;\n}\n\nfunction setProperty(object, path, value) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn object;\n\t}\n\n\tconst root = object;\n\tconst pathArray = getPathSegments(path);\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tassertNotStringIndex(object, key);\n\n\t\tif (index === pathArray.length - 1) {\n\t\t\tobject[key] = value;\n\t\t} else if (!isObject(object[key])) {\n\t\t\tobject[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n\t\t}\n\n\t\tobject = object[key];\n\t}\n\n\treturn root;\n}\n\nfunction deleteProperty(object, path) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\n\tfor (let index = 0; index < pathArray.length; index++) {\n\t\tconst key = pathArray[index];\n\n\t\tassertNotStringIndex(object, key);\n\n\t\tif (index === pathArray.length - 1) {\n\t\t\tdelete object[key];\n\t\t\treturn true;\n\t\t}\n\n\t\tobject = object[key];\n\n\t\tif (!isObject(object)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction hasProperty(object, path) {\n\tif (!isObject(object) || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\tconst pathArray = getPathSegments(path);\n\tif (pathArray.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (const key of pathArray) {\n\t\tif (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tobject = object[key];\n\t}\n\n\treturn true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path) {\n\tif (typeof path !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn path.replaceAll(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n\tconst result = Object.entries(value);\n\tif (Array.isArray(value)) {\n\t\treturn result.map(([key, value]) => [Number(key), value]);\n\t}\n\n\treturn result;\n}\n\nfunction stringifyPath(pathSegments) {\n\tlet result = '';\n\n\tfor (let [index, segment] of entries(pathSegments)) {\n\t\tif (typeof segment === 'number') {\n\t\t\tresult += `[${segment}]`;\n\t\t} else {\n\t\t\tsegment = escapePath(segment);\n\t\t\tresult += index === 0 ? segment : `.${segment}`;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction * deepKeysIterator(object, currentPath = []) {\n\tif (!isObject(object) || isEmptyObject(object)) {\n\t\tif (currentPath.length > 0) {\n\t\t\tyield stringifyPath(currentPath);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (const [key, value] of entries(object)) {\n\t\tyield * deepKeysIterator(value, [...currentPath, key]);\n\t}\n}\n\nfunction deepKeys(object) {\n\treturn [...deepKeysIterator(object)];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG90LXByb3AvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwQkFBMEI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsMEJBQTBCO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDBCQUEwQjtBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsSUFBSTtBQUNKO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9kb3QtcHJvcC9pbmRleC5qcz9lOTRlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4ge1xuXHRjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcblxuY29uc3QgaXNFbXB0eU9iamVjdCA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xuXG5jb25zdCBkaXNhbGxvd2VkS2V5cyA9IG5ldyBTZXQoW1xuXHQnX19wcm90b19fJyxcblx0J3Byb3RvdHlwZScsXG5cdCdjb25zdHJ1Y3RvcicsXG5dKTtcblxuY29uc3QgZGlnaXRzID0gbmV3IFNldCgnMDEyMzQ1Njc4OScpO1xuXG5mdW5jdGlvbiBnZXRQYXRoU2VnbWVudHMocGF0aCkge1xuXHRjb25zdCBwYXJ0cyA9IFtdO1xuXHRsZXQgY3VycmVudFNlZ21lbnQgPSAnJztcblx0bGV0IGN1cnJlbnRQYXJ0ID0gJ3N0YXJ0Jztcblx0bGV0IGlzSWdub3JpbmcgPSBmYWxzZTtcblxuXHRmb3IgKGNvbnN0IGNoYXJhY3RlciBvZiBwYXRoKSB7XG5cdFx0c3dpdGNoIChjaGFyYWN0ZXIpIHtcblx0XHRcdGNhc2UgJ1xcXFwnOiB7XG5cdFx0XHRcdGlmIChjdXJyZW50UGFydCA9PT0gJ2luZGV4Jykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gYW4gaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50UGFydCA9PT0gJ2luZGV4RW5kJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgYWZ0ZXIgYW4gaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc0lnbm9yaW5nKSB7XG5cdFx0XHRcdFx0Y3VycmVudFNlZ21lbnQgKz0gY2hhcmFjdGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudFBhcnQgPSAncHJvcGVydHknO1xuXHRcdFx0XHRpc0lnbm9yaW5nID0gIWlzSWdub3Jpbmc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICcuJzoge1xuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleCcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGFuIGluZGV4Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleEVuZCcpIHtcblx0XHRcdFx0XHRjdXJyZW50UGFydCA9ICdwcm9wZXJ0eSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNJZ25vcmluZykge1xuXHRcdFx0XHRcdGlzSWdub3JpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRjdXJyZW50U2VnbWVudCArPSBjaGFyYWN0ZXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGlzYWxsb3dlZEtleXMuaGFzKGN1cnJlbnRTZWdtZW50KSkge1xuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhcnRzLnB1c2goY3VycmVudFNlZ21lbnQpO1xuXHRcdFx0XHRjdXJyZW50U2VnbWVudCA9ICcnO1xuXHRcdFx0XHRjdXJyZW50UGFydCA9ICdwcm9wZXJ0eSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICdbJzoge1xuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleCcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGFuIGluZGV4Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleEVuZCcpIHtcblx0XHRcdFx0XHRjdXJyZW50UGFydCA9ICdpbmRleCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNJZ25vcmluZykge1xuXHRcdFx0XHRcdGlzSWdub3JpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRjdXJyZW50U2VnbWVudCArPSBjaGFyYWN0ZXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdwcm9wZXJ0eScpIHtcblx0XHRcdFx0XHRpZiAoZGlzYWxsb3dlZEtleXMuaGFzKGN1cnJlbnRTZWdtZW50KSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHBhcnRzLnB1c2goY3VycmVudFNlZ21lbnQpO1xuXHRcdFx0XHRcdGN1cnJlbnRTZWdtZW50ID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50UGFydCA9ICdpbmRleCc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjYXNlICddJzoge1xuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleCcpIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKE51bWJlci5wYXJzZUludChjdXJyZW50U2VnbWVudCwgMTApKTtcblx0XHRcdFx0XHRjdXJyZW50U2VnbWVudCA9ICcnO1xuXHRcdFx0XHRcdGN1cnJlbnRQYXJ0ID0gJ2luZGV4RW5kJztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50UGFydCA9PT0gJ2luZGV4RW5kJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgYWZ0ZXIgYW4gaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZhbGxzIHRocm91Z2hcblx0XHRcdH1cblxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRpZiAoY3VycmVudFBhcnQgPT09ICdpbmRleCcgJiYgIWRpZ2l0cy5oYXMoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gYW4gaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50UGFydCA9PT0gJ2luZGV4RW5kJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgYWZ0ZXIgYW4gaW5kZXgnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50UGFydCA9PT0gJ3N0YXJ0Jykge1xuXHRcdFx0XHRcdGN1cnJlbnRQYXJ0ID0gJ3Byb3BlcnR5Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc0lnbm9yaW5nKSB7XG5cdFx0XHRcdFx0aXNJZ25vcmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdGN1cnJlbnRTZWdtZW50ICs9ICdcXFxcJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRTZWdtZW50ICs9IGNoYXJhY3Rlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaXNJZ25vcmluZykge1xuXHRcdGN1cnJlbnRTZWdtZW50ICs9ICdcXFxcJztcblx0fVxuXG5cdHN3aXRjaCAoY3VycmVudFBhcnQpIHtcblx0XHRjYXNlICdwcm9wZXJ0eSc6IHtcblx0XHRcdGlmIChkaXNhbGxvd2VkS2V5cy5oYXMoY3VycmVudFNlZ21lbnQpKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0cGFydHMucHVzaChjdXJyZW50U2VnbWVudCk7XG5cblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGNhc2UgJ2luZGV4Jzoge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbmRleCB3YXMgbm90IGNsb3NlZCcpO1xuXHRcdH1cblxuXHRcdGNhc2UgJ3N0YXJ0Jzoge1xuXHRcdFx0cGFydHMucHVzaCgnJyk7XG5cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBObyBkZWZhdWx0XG5cdH1cblxuXHRyZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nSW5kZXgob2JqZWN0LCBrZXkpIHtcblx0aWYgKHR5cGVvZiBrZXkgIT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHRcdGNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGtleSwgMTApO1xuXHRcdHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSAmJiBvYmplY3RbaW5kZXhdID09PSBvYmplY3Rba2V5XTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90U3RyaW5nSW5kZXgob2JqZWN0LCBrZXkpIHtcblx0aWYgKGlzU3RyaW5nSW5kZXgob2JqZWN0LCBrZXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIHN0cmluZyBpbmRleCcpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdGlmICghaXNPYmplY3Qob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG9iamVjdCA6IHZhbHVlO1xuXHR9XG5cblx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXHRpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXRoQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gcGF0aEFycmF5W2luZGV4XTtcblxuXHRcdGlmIChpc1N0cmluZ0luZGV4KG9iamVjdCwga2V5KSkge1xuXHRcdFx0b2JqZWN0ID0gaW5kZXggPT09IHBhdGhBcnJheS5sZW5ndGggLSAxID8gdW5kZWZpbmVkIDogbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W2tleV07XG5cdFx0fVxuXG5cdFx0aWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gYG9iamVjdGAgaXMgZWl0aGVyIGB1bmRlZmluZWRgIG9yIGBudWxsYCBzbyB3ZSB3YW50IHRvIHN0b3AgdGhlIGxvb3AsIGFuZFxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBub3QgdGhlIGxhc3QgYml0IG9mIHRoZSBwYXRoLCBhbmRcblx0XHRcdC8vIGlmIGl0IGRpZG4ndCByZXR1cm4gYHVuZGVmaW5lZGBcblx0XHRcdC8vIGl0IHdvdWxkIHJldHVybiBgbnVsbGAgaWYgYG9iamVjdGAgaXMgYG51bGxgXG5cdFx0XHQvLyBidXQgd2Ugd2FudCBgZ2V0KHtmb286IG51bGx9LCAnZm9vLmJhcicpYCB0byBlcXVhbCBgdW5kZWZpbmVkYCwgb3IgdGhlIHN1cHBsaWVkIHZhbHVlLCBub3QgYG51bGxgXG5cdFx0XHRpZiAoaW5kZXggIT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9iamVjdCA9PT0gdW5kZWZpbmVkID8gdmFsdWUgOiBvYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdGlmICghaXNPYmplY3Qob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9XG5cblx0Y29uc3Qgcm9vdCA9IG9iamVjdDtcblx0Y29uc3QgcGF0aEFycmF5ID0gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpO1xuXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXRoQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3Qga2V5ID0gcGF0aEFycmF5W2luZGV4XTtcblxuXHRcdGFzc2VydE5vdFN0cmluZ0luZGV4KG9iamVjdCwga2V5KTtcblxuXHRcdGlmIChpbmRleCA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdG9iamVjdFtrZXldID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICghaXNPYmplY3Qob2JqZWN0W2tleV0pKSB7XG5cdFx0XHRvYmplY3Rba2V5XSA9IHR5cGVvZiBwYXRoQXJyYXlbaW5kZXggKyAxXSA9PT0gJ251bWJlcicgPyBbXSA6IHt9O1xuXHRcdH1cblxuXHRcdG9iamVjdCA9IG9iamVjdFtrZXldO1xuXHR9XG5cblx0cmV0dXJuIHJvb3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eShvYmplY3QsIHBhdGgpIHtcblx0aWYgKCFpc09iamVjdChvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0aEFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdGNvbnN0IGtleSA9IHBhdGhBcnJheVtpbmRleF07XG5cblx0XHRhc3NlcnROb3RTdHJpbmdJbmRleChvYmplY3QsIGtleSk7XG5cblx0XHRpZiAoaW5kZXggPT09IHBhdGhBcnJheS5sZW5ndGggLSAxKSB7XG5cdFx0XHRkZWxldGUgb2JqZWN0W2tleV07XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRvYmplY3QgPSBvYmplY3Rba2V5XTtcblxuXHRcdGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqZWN0LCBwYXRoKSB7XG5cdGlmICghaXNPYmplY3Qob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgb2YgcGF0aEFycmF5KSB7XG5cdFx0aWYgKCFpc09iamVjdChvYmplY3QpIHx8ICEoa2V5IGluIG9iamVjdCkgfHwgaXNTdHJpbmdJbmRleChvYmplY3QsIGtleSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRvYmplY3QgPSBvYmplY3Rba2V5XTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG4vLyBUT0RPOiBCYWNrc2xhc2hlcyB3aXRoIG5vIGVmZmVjdCBzaG91bGQgbm90IGJlIGVzY2FwZWRcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVQYXRoKHBhdGgpIHtcblx0aWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRyZXR1cm4gcGF0aC5yZXBsYWNlQWxsKC9bXFxcXC5bXS9nLCAnXFxcXCQmJyk7XG59XG5cbi8vIFRoZSBrZXlzIHJldHVybmVkIGJ5IE9iamVjdC5lbnRyaWVzKCkgZm9yIGFycmF5cyBhcmUgc3RyaW5nc1xuZnVuY3Rpb24gZW50cmllcyh2YWx1ZSkge1xuXHRjb25zdCByZXN1bHQgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiByZXN1bHQubWFwKChba2V5LCB2YWx1ZV0pID0+IFtOdW1iZXIoa2V5KSwgdmFsdWVdKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhdGgocGF0aFNlZ21lbnRzKSB7XG5cdGxldCByZXN1bHQgPSAnJztcblxuXHRmb3IgKGxldCBbaW5kZXgsIHNlZ21lbnRdIG9mIGVudHJpZXMocGF0aFNlZ21lbnRzKSkge1xuXHRcdGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJlc3VsdCArPSBgWyR7c2VnbWVudH1dYDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudCA9IGVzY2FwZVBhdGgoc2VnbWVudCk7XG5cdFx0XHRyZXN1bHQgKz0gaW5kZXggPT09IDAgPyBzZWdtZW50IDogYC4ke3NlZ21lbnR9YDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiAqIGRlZXBLZXlzSXRlcmF0b3Iob2JqZWN0LCBjdXJyZW50UGF0aCA9IFtdKSB7XG5cdGlmICghaXNPYmplY3Qob2JqZWN0KSB8fCBpc0VtcHR5T2JqZWN0KG9iamVjdCkpIHtcblx0XHRpZiAoY3VycmVudFBhdGgubGVuZ3RoID4gMCkge1xuXHRcdFx0eWllbGQgc3RyaW5naWZ5UGF0aChjdXJyZW50UGF0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhvYmplY3QpKSB7XG5cdFx0eWllbGQgKiBkZWVwS2V5c0l0ZXJhdG9yKHZhbHVlLCBbLi4uY3VycmVudFBhdGgsIGtleV0pO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwS2V5cyhvYmplY3QpIHtcblx0cmV0dXJuIFsuLi5kZWVwS2V5c0l0ZXJhdG9yKG9iamVjdCldO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/dot-prop/index.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var path = __webpack_require__(/*! path */ \"path\");\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js\")('electron-squirrel-startup');\nvar app = (__webpack_require__(/*! electron */ \"electron\").app);\n\nvar run = function(args, done) {\n  var updateExe = path.resolve(path.dirname(process.execPath), '..', 'Update.exe');\n  debug('Spawning `%s` with args `%s`', updateExe, args);\n  spawn(updateExe, args, {\n    detached: true\n  }).on('close', done);\n};\n\nvar check = function() {\n  if (process.platform === 'win32') {\n    var cmd = process.argv[1];\n    debug('processing squirrel command `%s`', cmd);\n    var target = path.basename(process.execPath);\n\n    if (cmd === '--squirrel-install' || cmd === '--squirrel-updated') {\n      run(['--createShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-uninstall') {\n      run(['--removeShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-obsolete') {\n      app.quit();\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = check();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxpRUFBOEI7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLHVGQUFPO0FBQzNCLFVBQVUscURBQXVCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9pbmRleC5qcz8zNzcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cCcpO1xudmFyIGFwcCA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuYXBwO1xuXG52YXIgcnVuID0gZnVuY3Rpb24oYXJncywgZG9uZSkge1xuICB2YXIgdXBkYXRlRXhlID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKSwgJy4uJywgJ1VwZGF0ZS5leGUnKTtcbiAgZGVidWcoJ1NwYXduaW5nIGAlc2Agd2l0aCBhcmdzIGAlc2AnLCB1cGRhdGVFeGUsIGFyZ3MpO1xuICBzcGF3bih1cGRhdGVFeGUsIGFyZ3MsIHtcbiAgICBkZXRhY2hlZDogdHJ1ZVxuICB9KS5vbignY2xvc2UnLCBkb25lKTtcbn07XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIHZhciBjbWQgPSBwcm9jZXNzLmFyZ3ZbMV07XG4gICAgZGVidWcoJ3Byb2Nlc3Npbmcgc3F1aXJyZWwgY29tbWFuZCBgJXNgJywgY21kKTtcbiAgICB2YXIgdGFyZ2V0ID0gcGF0aC5iYXNlbmFtZShwcm9jZXNzLmV4ZWNQYXRoKTtcblxuICAgIGlmIChjbWQgPT09ICctLXNxdWlycmVsLWluc3RhbGwnIHx8IGNtZCA9PT0gJy0tc3F1aXJyZWwtdXBkYXRlZCcpIHtcbiAgICAgIHJ1bihbJy0tY3JlYXRlU2hvcnRjdXQ9JyArIHRhcmdldCArICcnXSwgYXBwLnF1aXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjbWQgPT09ICctLXNxdWlycmVsLXVuaW5zdGFsbCcpIHtcbiAgICAgIHJ1bihbJy0tcmVtb3ZlU2hvcnRjdXQ9JyArIHRhcmdldCArICcnXSwgYXBwLnF1aXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjbWQgPT09ICctLXNxdWlycmVsLW9ic29sZXRlJykge1xuICAgICAgYXBwLnF1aXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/index.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLCtIQUFtQztBQUM3QyxXQUFXO0FBQ1gsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxxQkFBcUI7QUFDM0I7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/ZGFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/electron-squirrel-startup/node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmLGNBQWM7QUFDZCxlQUFlO0FBQ2YscUhBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLGFBQWE7QUFDZixFQUFFLGFBQWE7O0FBRWY7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzPzFmZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxzSUFBd0M7QUFDMUMsRUFBRTtBQUNGLEVBQUUsZ0lBQXFDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzPzY1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwrSEFBbUM7QUFDN0MsWUFBWTtBQUNaLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsY0FBSTtBQUMzQiw0Q0FBNEMsa0JBQWtCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdCQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/NmQzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIC8vIGNhbWVsLWNhc2VcbiAgdmFyIHByb3AgPSBrZXlcbiAgICAuc3Vic3RyaW5nKDYpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGspIHsgcmV0dXJuIGsudG9VcHBlckNhc2UoKSB9KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcbiAgdmFyIHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IHRydWU7XG4gIGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSBmYWxzZTtcbiAgZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHZhbCA9IG51bGw7XG4gIGVsc2UgdmFsID0gTnVtYmVyKHZhbCk7XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFRoZSBmaWxlIGRlc2NyaXB0b3IgdG8gd3JpdGUgdGhlIGBkZWJ1ZygpYCBjYWxscyB0by5cbiAqIFNldCB0aGUgYERFQlVHX0ZEYCBlbnYgdmFyaWFibGUgdG8gb3ZlcnJpZGUgd2l0aCBhbm90aGVyIHZhbHVlLiBpLmUuOlxuICpcbiAqICAgJCBERUJVR19GRD0zIG5vZGUgc2NyaXB0LmpzIDM+ZGVidWcubG9nXG4gKi9cblxudmFyIGZkID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuREVCVUdfRkQsIDEwKSB8fCAyO1xuXG5pZiAoMSAhPT0gZmQgJiYgMiAhPT0gZmQpIHtcbiAgdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24oKXt9LCAnZXhjZXB0IGZvciBzdGRlcnIoMikgYW5kIHN0ZG91dCgxKSwgYW55IG90aGVyIHVzYWdlIG9mIERFQlVHX0ZEIGlzIGRlcHJlY2F0ZWQuIE92ZXJyaWRlIGRlYnVnLmxvZyBpZiB5b3Ugd2FudCB0byB1c2UgYSBkaWZmZXJlbnQgbG9nIGZ1bmN0aW9uIChodHRwczovL2dpdC5pby9kZWJ1Z19mZCknKSgpXG59XG5cbnZhciBzdHJlYW0gPSAxID09PSBmZCA/IHByb2Nlc3Muc3Rkb3V0IDpcbiAgICAgICAgICAgICAyID09PSBmZCA/IHByb2Nlc3Muc3RkZXJyIDpcbiAgICAgICAgICAgICBjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtKGZkKTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0c1xuICAgID8gQm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycylcbiAgICA6IHR0eS5pc2F0dHkoZmQpO1xufVxuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuICAgIC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKClcbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgaWYgKHVzZUNvbG9ycykge1xuICAgIHZhciBjID0gdGhpcy5jb2xvcjtcbiAgICB2YXIgcHJlZml4ID0gJyAgXFx1MDAxYlszJyArIGMgKyAnOzFtJyArIG5hbWUgKyAnICcgKyAnXFx1MDAxYlswbSc7XG5cbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKCdcXHUwMDFiWzMnICsgYyArICdtKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxYlswbScpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbMF0gPSBuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKClcbiAgICAgICsgJyAnICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gYHN0cmVhbWAuXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIENvcGllZCBmcm9tIGBub2RlL3NyYy9ub2RlLmpzYC5cbiAqXG4gKiBYWFg6IEl0J3MgbGFtZSB0aGF0IG5vZGUgZG9lc24ndCBleHBvc2UgdGhpcyBBUEkgb3V0LW9mLXRoZS1ib3guIEl0IGFsc29cbiAqIHJlbGllcyBvbiB0aGUgdW5kb2N1bWVudGVkIGB0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoKWAgd2hpY2ggaXMgYWxzbyBsYW1lLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0gKGZkKSB7XG4gIHZhciBzdHJlYW07XG4gIHZhciB0dHlfd3JhcCA9IHByb2Nlc3MuYmluZGluZygndHR5X3dyYXAnKTtcblxuICAvLyBOb3RlIHN0cmVhbS5fdHlwZSBpcyB1c2VkIGZvciB0ZXN0LW1vZHVsZS1sb2FkLWxpc3QuanNcblxuICBzd2l0Y2ggKHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZShmZCkpIHtcbiAgICBjYXNlICdUVFknOlxuICAgICAgc3RyZWFtID0gbmV3IHR0eS5Xcml0ZVN0cmVhbShmZCk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAndHR5JztcblxuICAgICAgLy8gSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdGSUxFJzpcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICBzdHJlYW0gPSBuZXcgZnMuU3luY1dyaXRlU3RyZWFtKGZkLCB7IGF1dG9DbG9zZTogZmFsc2UgfSk7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAnZnMnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQSVBFJzpcbiAgICBjYXNlICdUQ1AnOlxuICAgICAgdmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuICAgICAgc3RyZWFtID0gbmV3IG5ldC5Tb2NrZXQoe1xuICAgICAgICBmZDogZmQsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGSVhNRSBTaG91bGQgcHJvYmFibHkgaGF2ZSBhbiBvcHRpb24gaW4gbmV0LlNvY2tldCB0byBjcmVhdGUgYVxuICAgICAgLy8gc3RyZWFtIGZyb20gYW4gZXhpc3RpbmcgZmQgd2hpY2ggaXMgd3JpdGFibGUgb25seS4gQnV0IGZvciBub3dcbiAgICAgIC8vIHdlJ2xsIGp1c3QgYWRkIHRoaXMgaGFjayBhbmQgc2V0IHRoZSBgcmVhZGFibGVgIG1lbWJlciB0byBmYWxzZS5cbiAgICAgIC8vIFRlc3Q6IC4vbm9kZSB0ZXN0L2ZpeHR1cmVzL2VjaG8uanMgPCAvZXRjL3Bhc3N3ZFxuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVhZCA9IG51bGw7XG4gICAgICBzdHJlYW0uX3R5cGUgPSAncGlwZSc7XG5cbiAgICAgIC8vIEZJWE1FIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFByb2JhYmx5IGFuIGVycm9yIG9uIGluIHV2X2d1ZXNzX2hhbmRsZSgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcGxlbWVudCBtZS4gVW5rbm93biBzdHJlYW0gZmlsZSB0eXBlIScpO1xuICB9XG5cbiAgLy8gRm9yIHN1cHBvcnRpbmcgbGVnYWN5IEFQSSB3ZSBwdXQgdGhlIEZEIGhlcmUuXG4gIHN0cmVhbS5mZCA9IGZkO1xuXG4gIHN0cmVhbS5faXNTdGRpbyA9IHRydWU7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0IChkZWJ1Zykge1xuICBkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgcHJvY2Vzcy5lbnYuREVCVUdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-squirrel-startup/node_modules/ms/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-squirrel-startup/node_modules/ms/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("{/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/NDIzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/electron-squirrel-startup/node_modules/ms/index.js\n\n}");

/***/ }),

/***/ "./node_modules/electron-store/index.js":
/*!**********************************************!*\
  !*** ./node_modules/electron-store/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ElectronStore)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var conf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! conf */ \"./node_modules/conf/dist/source/index.js\");\n\n\n\n\n\nconst {app, ipcMain, shell} = electron__WEBPACK_IMPORTED_MODULE_2__;\n\nlet isInitialized = false;\n\n// Set up the `ipcMain` handler for communication between renderer and main process.\nconst initDataListener = () => {\n\tif (!ipcMain || !app) {\n\t\tthrow new Error('Electron Store: You need to call `.initRenderer()` from the main process.');\n\t}\n\n\tconst appData = {\n\t\tdefaultCwd: app.getPath('userData'),\n\t\tappVersion: app.getVersion(),\n\t};\n\n\tif (isInitialized) {\n\t\treturn appData;\n\t}\n\n\tipcMain.on('electron-store-get-data', event => {\n\t\tevent.returnValue = appData;\n\t});\n\n\tisInitialized = true;\n\n\treturn appData;\n};\n\nclass ElectronStore extends conf__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n\tconstructor(options) {\n\t\tlet defaultCwd;\n\t\tlet appVersion;\n\n\t\t// If we are in the renderer process, we communicate with the main process\n\t\t// to get the required data for the module otherwise, we pull from the main process.\n\t\tif (node_process__WEBPACK_IMPORTED_MODULE_0__.type === 'renderer') {\n\t\t\tconst appData = electron__WEBPACK_IMPORTED_MODULE_2__.ipcRenderer.sendSync('electron-store-get-data');\n\n\t\t\tif (!appData) {\n\t\t\t\tthrow new Error('Electron Store: You need to call `.initRenderer()` from the main process.');\n\t\t\t}\n\n\t\t\t({defaultCwd, appVersion} = appData);\n\t\t} else if (ipcMain && app) {\n\t\t\t({defaultCwd, appVersion} = initDataListener());\n\t\t}\n\n\t\toptions = {\n\t\t\tname: 'config',\n\t\t\t...options,\n\t\t};\n\n\t\toptions.projectVersion ||= appVersion;\n\n\t\tif (options.cwd) {\n\t\t\toptions.cwd = node_path__WEBPACK_IMPORTED_MODULE_1__.isAbsolute(options.cwd) ? options.cwd : node_path__WEBPACK_IMPORTED_MODULE_1__.join(defaultCwd, options.cwd);\n\t\t} else {\n\t\t\toptions.cwd = defaultCwd;\n\t\t}\n\n\t\toptions.configName = options.name;\n\t\tdelete options.name;\n\n\t\tsuper(options);\n\t}\n\n\tstatic initRenderer() {\n\t\tinitDataListener();\n\t}\n\n\tasync openInEditor() {\n\t\tconst error = await shell.openPath(this.path);\n\n\t\tif (error) {\n\t\t\tthrow new Error(error);\n\t\t}\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tc3RvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFDTjtBQUNHO0FBQ1I7O0FBRXhCLE9BQU8scUJBQXFCLEVBQUUscUNBQVE7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRWUsNEJBQTRCLDRDQUFJO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw4Q0FBWTtBQUNsQixtQkFBbUIsaURBQW9COztBQUV2QztBQUNBO0FBQ0E7O0FBRUEsS0FBSyx3QkFBd0I7QUFDN0IsSUFBSTtBQUNKLEtBQUssd0JBQXdCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLGlEQUFlLDhCQUE4QiwyQ0FBUztBQUN2RSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXN0b3JlL2luZGV4LmpzPzI3NTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgZWxlY3Ryb24gZnJvbSAnZWxlY3Ryb24nO1xuaW1wb3J0IENvbmYgZnJvbSAnY29uZic7XG5cbmNvbnN0IHthcHAsIGlwY01haW4sIHNoZWxsfSA9IGVsZWN0cm9uO1xuXG5sZXQgaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vLyBTZXQgdXAgdGhlIGBpcGNNYWluYCBoYW5kbGVyIGZvciBjb21tdW5pY2F0aW9uIGJldHdlZW4gcmVuZGVyZXIgYW5kIG1haW4gcHJvY2Vzcy5cbmNvbnN0IGluaXREYXRhTGlzdGVuZXIgPSAoKSA9PiB7XG5cdGlmICghaXBjTWFpbiB8fCAhYXBwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdH1cblxuXHRjb25zdCBhcHBEYXRhID0ge1xuXHRcdGRlZmF1bHRDd2Q6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHRcdGFwcFZlcnNpb246IGFwcC5nZXRWZXJzaW9uKCksXG5cdH07XG5cblx0aWYgKGlzSW5pdGlhbGl6ZWQpIHtcblx0XHRyZXR1cm4gYXBwRGF0YTtcblx0fVxuXG5cdGlwY01haW4ub24oJ2VsZWN0cm9uLXN0b3JlLWdldC1kYXRhJywgZXZlbnQgPT4ge1xuXHRcdGV2ZW50LnJldHVyblZhbHVlID0gYXBwRGF0YTtcblx0fSk7XG5cblx0aXNJbml0aWFsaXplZCA9IHRydWU7XG5cblx0cmV0dXJuIGFwcERhdGE7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVjdHJvblN0b3JlIGV4dGVuZHMgQ29uZiB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRsZXQgZGVmYXVsdEN3ZDtcblx0XHRsZXQgYXBwVmVyc2lvbjtcblxuXHRcdC8vIElmIHdlIGFyZSBpbiB0aGUgcmVuZGVyZXIgcHJvY2Vzcywgd2UgY29tbXVuaWNhdGUgd2l0aCB0aGUgbWFpbiBwcm9jZXNzXG5cdFx0Ly8gdG8gZ2V0IHRoZSByZXF1aXJlZCBkYXRhIGZvciB0aGUgbW9kdWxlIG90aGVyd2lzZSwgd2UgcHVsbCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuXG5cdFx0aWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGVsZWN0cm9uLmlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdH07XG5cblx0XHRvcHRpb25zLnByb2plY3RWZXJzaW9uIHx8PSBhcHBWZXJzaW9uO1xuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRhc3luYyBvcGVuSW5FZGl0b3IoKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBhd2FpdCBzaGVsbC5vcGVuUGF0aCh0aGlzLnBhdGgpO1xuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuXHRcdH1cblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/electron-store/index.js\n\n}");

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzP2FiZTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n\n}");

/***/ }),

/***/ "./node_modules/fast-uri/index.js":
/*!****************************************!*\
  !*** ./node_modules/fast-uri/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__(/*! ./lib/utils */ \"./node_modules/fast-uri/lib/utils.js\")\nconst SCHEMES = __webpack_require__(/*! ./lib/schemes */ \"./node_modules/fast-uri/lib/schemes.js\")\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxrR0FBa0csRUFBRSxtQkFBTyxDQUFDLHlEQUFhO0FBQ2pJLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDhCQUE4QjtBQUM3RyxJQUFJO0FBQ0osK0RBQStELDhCQUE4QjtBQUM3Rjs7QUFFQTtBQUNBO0FBQ0EsK0VBQStFLDhCQUE4QjtBQUM3RyxJQUFJO0FBQ0osK0RBQStELDhCQUE4QjtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGFBQWEsOEJBQThCLFFBQVE7O0FBRWxGO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQjtBQUN0QixzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcz82ZmNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIG5vcm1hbGl6ZUlQdjQsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCBTQ0hFTUVTID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHsgLi4uc2NoZW1lbGVzc09wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IGVzY2FwZShjb21wb25lbnRzLnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudHMucGF0aCA9IGNvbXBvbmVudHMucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudHMucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzKVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50cy5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vdSwgJy8lMkYnKSAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnRzLnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50cy5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IGhleExvb2tVcCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEyNyB9LCAoX3YsIGspID0+IC9bXiFcIiQmJygpKissXFwtLjs9X2BhLXp7fX5dL3UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGspKSlcblxuZnVuY3Rpb24gbm9uU2ltcGxlRG9tYWluICh2YWx1ZSkge1xuICBsZXQgY29kZSA9IDBcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoY29kZSA+IDEyNiB8fCBoZXhMb29rVXBbY29kZV0pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBVUklfUEFSU0UgPSAvXig/OihbXiMvOj9dKyk6KT8oPzpcXC9cXC8oKD86KFteIy8/QF0qKUApPyhcXFtbXiMvP1xcXV0rXFxdfFteIy86P10qKSg/OjooXFxkKikpPykpPyhbXiM/XSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFtcXG5cXHJdKSopKT8vdVxuXG5mdW5jdGlvbiBwYXJzZSAodXJpLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgc2NoZW1lOiB1bmRlZmluZWQsXG4gICAgdXNlcmluZm86IHVuZGVmaW5lZCxcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogJycsXG4gICAgcXVlcnk6IHVuZGVmaW5lZCxcbiAgICBmcmFnbWVudDogdW5kZWZpbmVkXG4gIH1cbiAgY29uc3QgZ290RW5jb2RpbmcgPSB1cmkuaW5kZXhPZignJScpICE9PSAtMVxuICBsZXQgaXNJUCA9IGZhbHNlXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gJ3N1ZmZpeCcpIHVyaSA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgJzonIDogJycpICsgJy8vJyArIHVyaVxuXG4gIGNvbnN0IG1hdGNoZXMgPSB1cmkubWF0Y2goVVJJX1BBUlNFKVxuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgLy8gc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICBwYXJzZWQuc2NoZW1lID0gbWF0Y2hlc1sxXVxuICAgIHBhcnNlZC51c2VyaW5mbyA9IG1hdGNoZXNbM11cbiAgICBwYXJzZWQuaG9zdCA9IG1hdGNoZXNbNF1cbiAgICBwYXJzZWQucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKVxuICAgIHBhcnNlZC5wYXRoID0gbWF0Y2hlc1s2XSB8fCAnJ1xuICAgIHBhcnNlZC5xdWVyeSA9IG1hdGNoZXNbN11cbiAgICBwYXJzZWQuZnJhZ21lbnQgPSBtYXRjaGVzWzhdXG5cbiAgICAvLyBmaXggcG9ydCBudW1iZXJcbiAgICBpZiAoaXNOYU4ocGFyc2VkLnBvcnQpKSB7XG4gICAgICBwYXJzZWQucG9ydCA9IG1hdGNoZXNbNV1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5ob3N0KSB7XG4gICAgICBjb25zdCBpcHY0cmVzdWx0ID0gbm9ybWFsaXplSVB2NChwYXJzZWQuaG9zdClcbiAgICAgIGlmIChpcHY0cmVzdWx0LmlzSVBWNCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXB2NnJlc3VsdCA9IG5vcm1hbGl6ZUlQdjYoaXB2NHJlc3VsdC5ob3N0KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY0cmVzdWx0Lmhvc3RcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnF1ZXJ5ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmIChnb3RFbmNvZGluZyAmJiBwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICB9XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQpIHtcbiAgICAgICAgcGFyc2VkLmZyYWdtZW50ID0gZW5jb2RlVVJJKGRlY29kZVVSSUNvbXBvbmVudChwYXJzZWQuZnJhZ21lbnQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKHBhcnNlZCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG4gIHJldHVybiBwYXJzZWRcbn1cblxuY29uc3QgZmFzdFVyaSA9IHtcbiAgU0NIRU1FUyxcbiAgbm9ybWFsaXplLFxuICByZXNvbHZlLFxuICByZXNvbHZlQ29tcG9uZW50cyxcbiAgZXF1YWwsXG4gIHNlcmlhbGl6ZSxcbiAgcGFyc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZmFzdFVyaSA9IGZhc3RVcmlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-uri/index.js\n\n}");

/***/ }),

/***/ "./node_modules/fast-uri/lib/schemes.js":
/*!**********************************************!*\
  !*** ./node_modules/fast-uri/lib/schemes.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nconst UUID_REG = /^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosMkJBQTJCLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxHQUFHO0FBQzFFLG1DQUFtQyxLQUFLLHNCQUFzQixhQUFhLEVBQUU7O0FBRTdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLEdBQUcsaUNBQWlDO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxHQUFHLG1CQUFtQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUIsR0FBRyxJQUFJOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcz9lNmZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBVVUlEX1JFRyA9IC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuZnVuY3Rpb24gaXNTZWN1cmUgKHdzQ29tcG9uZW50cykge1xuICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ3dzcydcbn1cblxuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnRzKSB7XG4gIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudHMpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnRzLnBhdGgpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudHMpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cylcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnRzLnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudHMucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudHMucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnRzKSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnRzLnBvcnQgPT09IChpc1NlY3VyZSh3c0NvbXBvbmVudHMpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50cy5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gKHdzQ29tcG9uZW50cy5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnRzLnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudHMuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50cy5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudHNcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnRzLm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudHMubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnRzLm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudHMubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV1cblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50cy5uc3NcbiAgdXJpQ29tcG9uZW50cy5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzXG4gIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3NcbiAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhVVVJRF9SRUcudGVzdCh1dWlkQ29tcG9uZW50cy51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudHMpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzXG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudHNcbn1cblxuY29uc3QgaHR0cCA9IHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCBodHRwcyA9IHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufVxuXG5jb25zdCB3cyA9IHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufVxuXG5jb25zdCB3c3MgPSB7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn1cblxuY29uc3QgdXJuID0ge1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IHVybnV1aWQgPSB7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59XG5cbmNvbnN0IFNDSEVNRVMgPSB7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTQ0hFTUVTXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fast-uri/lib/schemes.js\n\n}");

/***/ }),

/***/ "./node_modules/fast-uri/lib/scopedChars.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-uri/lib/scopedChars.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3Njb3BlZENoYXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NvcGVkQ2hhcnMuanM/YjM1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgSEVYID0ge1xuICAwOiAwLFxuICAxOiAxLFxuICAyOiAyLFxuICAzOiAzLFxuICA0OiA0LFxuICA1OiA1LFxuICA2OiA2LFxuICA3OiA3LFxuICA4OiA4LFxuICA5OiA5LFxuICBhOiAxMCxcbiAgQTogMTAsXG4gIGI6IDExLFxuICBCOiAxMSxcbiAgYzogMTIsXG4gIEM6IDEyLFxuICBkOiAxMyxcbiAgRDogMTMsXG4gIGU6IDE0LFxuICBFOiAxNCxcbiAgZjogMTUsXG4gIEY6IDE1XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIRVhcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-uri/lib/scopedChars.js\n\n}");

/***/ }),

/***/ "./node_modules/fast-uri/lib/utils.js":
/*!********************************************!*\
  !*** ./node_modules/fast-uri/lib/utils.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\nconst { HEX } = __webpack_require__(/*! ./scopedChars */ \"./node_modules/fast-uri/lib/scopedChars.js\")\n\nconst IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(IPV4_REG) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsaUVBQWU7O0FBRXZDLDhDQUE4QyxFQUFFLGdCQUFnQixFQUFFLHdCQUF3QixFQUFFOztBQUU1RjtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzPzZkNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSEVYIH0gPSByZXF1aXJlKCcuL3Njb3BlZENoYXJzJylcblxuY29uc3QgSVBWNF9SRUcgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZCkkL3VcblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NCAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICcuJykgPCAzKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfSB9XG4gIGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKElQVjRfUkVHKSB8fCBbXVxuICBjb25zdCBbYWRkcmVzc10gPSBtYXRjaGVzXG4gIGlmIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHsgaG9zdDogc3RyaXBMZWFkaW5nWmVyb3MoYWRkcmVzcywgJy4nKSwgaXNJUFY0OiB0cnVlIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjQ6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwWmVybz1mYWxzZV1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0LCBrZWVwWmVybyA9IGZhbHNlKSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgc3RyaXAgPSB0cnVlXG4gIGZvciAoY29uc3QgYyBvZiBpbnB1dCkge1xuICAgIGlmIChIRVhbY10gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmIChjICE9PSAnMCcgJiYgc3RyaXAgPT09IHRydWUpIHN0cmlwID0gZmFsc2VcbiAgICBpZiAoIXN0cmlwKSBhY2MgKz0gY1xuICB9XG4gIGlmIChrZWVwWmVybyAmJiBhY2MubGVuZ3RoID09PSAwKSBhY2MgPSAnMCdcbiAgcmV0dXJuIGFjY1xufVxuXG5mdW5jdGlvbiBnZXRJUFY2IChpbnB1dCkge1xuICBsZXQgdG9rZW5Db3VudCA9IDBcbiAgY29uc3Qgb3V0cHV0ID0geyBlcnJvcjogZmFsc2UsIGFkZHJlc3M6ICcnLCB6b25lOiAnJyB9XG4gIGNvbnN0IGFkZHJlc3MgPSBbXVxuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgaXNab25lID0gZmFsc2VcbiAgbGV0IGVuZGlwdjZFbmNvdW50ZXJlZCA9IGZhbHNlXG4gIGxldCBlbmRJcHY2ID0gZmFsc2VcblxuICBmdW5jdGlvbiBjb25zdW1lICgpIHtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGlzWm9uZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcilcbiAgICAgICAgaWYgKGhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkcmVzcy5wdXNoKGhleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgdG9rZW5Db3VudCsrXG4gICAgICBhZGRyZXNzLnB1c2goJzonKVxuICAgICAgaWYgKHRva2VuQ291bnQgPiA3KSB7XG4gICAgICAgIC8vIG5vdCB2YWxpZFxuICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaSAtIDEgPj0gMCAmJiBpbnB1dFtpIC0gMV0gPT09ICc6Jykge1xuICAgICAgICBlbmRpcHY2RW5jb3VudGVyZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZSgpKSB7IGJyZWFrIH1cbiAgICAgIC8vIHN3aXRjaCB0byB6b25lIGRldGVjdGlvblxuICAgICAgaXNab25lID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChpc1pvbmUpIHtcbiAgICAgIG91dHB1dC56b25lID0gYnVmZmVyLmpvaW4oJycpXG4gICAgfSBlbHNlIGlmIChlbmRJcHY2KSB7XG4gICAgICBhZGRyZXNzLnB1c2goYnVmZmVyLmpvaW4oJycpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRyZXNzLnB1c2goc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcikpXG4gICAgfVxuICB9XG4gIG91dHB1dC5hZGRyZXNzID0gYWRkcmVzcy5qb2luKCcnKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlQdjYgKGhvc3QpIHtcbiAgaWYgKGZpbmRUb2tlbihob3N0LCAnOicpIDwgMikgeyByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH0gfVxuICBjb25zdCBpcHY2ID0gZ2V0SVBWNihob3N0KVxuXG4gIGlmICghaXB2Ni5lcnJvcikge1xuICAgIGxldCBuZXdIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgbGV0IGVzY2FwZWRIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgaWYgKGlwdjYuem9uZSkge1xuICAgICAgbmV3SG9zdCArPSAnJScgKyBpcHY2LnpvbmVcbiAgICAgIGVzY2FwZWRIb3N0ICs9ICclMjUnICsgaXB2Ni56b25lXG4gICAgfVxuICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGVzY2FwZWRIb3N0LCBpc0lQVjY6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwTGVhZGluZ1plcm9zIChzdHIsIHRva2VuKSB7XG4gIGxldCBvdXQgPSAnJ1xuICBsZXQgc2tpcCA9IHRydWVcbiAgY29uc3QgbCA9IHN0ci5sZW5ndGhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjID0gc3RyW2ldXG4gICAgaWYgKGMgPT09ICcwJyAmJiBza2lwKSB7XG4gICAgICBpZiAoKGkgKyAxIDw9IGwgJiYgc3RyW2kgKyAxXSA9PT0gdG9rZW4pIHx8IGkgKyAxID09PSBsKSB7XG4gICAgICAgIG91dCArPSBjXG4gICAgICAgIHNraXAgPSBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYyA9PT0gdG9rZW4pIHtcbiAgICAgICAgc2tpcCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXAgPSBmYWxzZVxuICAgICAgfVxuICAgICAgb3V0ICs9IGNcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBmaW5kVG9rZW4gKHN0ciwgdG9rZW4pIHtcbiAgbGV0IGluZCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSB0b2tlbikgaW5kKytcbiAgfVxuICByZXR1cm4gaW5kXG59XG5cbmNvbnN0IFJEUzEgPSAvXlxcLlxcLj9cXC8vdVxuY29uc3QgUkRTMiA9IC9eXFwvXFwuKD86XFwvfCQpL3VcbmNvbnN0IFJEUzMgPSAvXlxcL1xcLlxcLig/OlxcL3wkKS91XG5jb25zdCBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvdVxuXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyAoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgJycpXG4gICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsICcvJylcbiAgICB9IGVsc2UgaWYgKGlucHV0Lm1hdGNoKFJEUzMpKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgJy8nKVxuICAgICAgb3V0cHV0LnBvcCgpXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy4nIHx8IGlucHV0ID09PSAnLi4nKSB7XG4gICAgICBpbnB1dCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGltID0gaW5wdXQubWF0Y2goUkRTNSlcbiAgICAgIGlmIChpbSkge1xuICAgICAgICBjb25zdCBzID0gaW1bMF1cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShzLmxlbmd0aClcbiAgICAgICAgb3V0cHV0LnB1c2gocylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb24nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnRzLCBlc2MpIHtcbiAgY29uc3QgZnVuYyA9IGVzYyAhPT0gdHJ1ZSA/IGVzY2FwZSA6IHVuZXNjYXBlXG4gIGlmIChjb21wb25lbnRzLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudHMuc2NoZW1lKVxuICB9XG4gIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnRzLnVzZXJpbmZvKVxuICB9XG4gIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuaG9zdCA9IGZ1bmMoY29tcG9uZW50cy5ob3N0KVxuICB9XG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMucGF0aCA9IGZ1bmMoY29tcG9uZW50cy5wYXRoKVxuICB9XG4gIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZnVuYyhjb21wb25lbnRzLnF1ZXJ5KVxuICB9XG4gIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnRzLmZyYWdtZW50KVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHJlY29tcG9zZUF1dGhvcml0eSAoY29tcG9uZW50cykge1xuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKVxuICAgIHVyaVRva2Vucy5wdXNoKCdAJylcbiAgfVxuXG4gIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3N0ID0gdW5lc2NhcGUoY29tcG9uZW50cy5ob3N0KVxuICAgIGNvbnN0IGlwVjRyZXMgPSBub3JtYWxpemVJUHY0KGhvc3QpXG5cbiAgICBpZiAoaXBWNHJlcy5pc0lQVjQpIHtcbiAgICAgIGhvc3QgPSBpcFY0cmVzLmhvc3RcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXBWNnJlcyA9IG5vcm1hbGl6ZUlQdjYoaXBWNHJlcy5ob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudHMuaG9zdFxuICAgICAgfVxuICAgIH1cbiAgICB1cmlUb2tlbnMucHVzaChob3N0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKVxuICB9XG5cbiAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbignJykgOiB1bmRlZmluZWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWNvbXBvc2VBdXRob3JpdHksXG4gIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLFxuICByZW1vdmVEb3RTZWdtZW50cyxcbiAgbm9ybWFsaXplSVB2NCxcbiAgbm9ybWFsaXplSVB2NixcbiAgc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fast-uri/lib/utils.js\n\n}");

/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9qc29uLXNjaGVtYS10cmF2ZXJzZS9pbmRleC5qcz8zYzdiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/json-schema-traverse/index.js\n\n}");

/***/ }),

/***/ "./node_modules/mimic-function/index.js":
/*!**********************************************!*\
  !*** ./node_modules/mimic-function/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mimicFunction)\n/* harmony export */ });\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable\n\t\t&& toDescriptor.enumerable === fromDescriptor.enumerable\n\t\t&& toDescriptor.configurable === fromDescriptor.configurable\n\t\t&& (toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tconst {writable, enumerable, configurable} = toStringDescriptor; // We destructue to avoid a potential `get` descriptor.\n\tObject.defineProperty(to, 'toString', {value: newToString, writable, enumerable, configurable});\n};\n\nfunction mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWltaWMtZnVuY3Rpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhEQUE4RCxTQUFTLE1BQU0sU0FBUzs7QUFFdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQW9DLHNCQUFzQjtBQUNsRSx3Q0FBd0MsdURBQXVEO0FBQy9GOztBQUVlLGtDQUFrQywrQkFBK0IsSUFBSTtBQUNwRixRQUFRLE1BQU07O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL21pbWljLWZ1bmN0aW9uL2luZGV4LmpzPzg2M2EiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29weVByb3BlcnR5ID0gKHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKSA9PiB7XG5cdC8vIGBGdW5jdGlvbiNsZW5ndGhgIHNob3VsZCByZWZsZWN0IHRoZSBwYXJhbWV0ZXJzIG9mIGB0b2Agbm90IGBmcm9tYCBzaW5jZSB3ZSBrZWVwIGl0cyBib2R5LlxuXHQvLyBgRnVuY3Rpb24jcHJvdG90eXBlYCBpcyBub24td3JpdGFibGUgYW5kIG5vbi1jb25maWd1cmFibGUgc28gY2FuIG5ldmVyIGJlIG1vZGlmaWVkLlxuXHRpZiAocHJvcGVydHkgPT09ICdsZW5ndGgnIHx8IHByb3BlcnR5ID09PSAncHJvdG90eXBlJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBGdW5jdGlvbiNhcmd1bWVudHNgIGFuZCBgRnVuY3Rpb24jY2FsbGVyYCBzaG91bGQgbm90IGJlIGNvcGllZC4gVGhleSB3ZXJlIHJlcG9ydGVkIHRvIGJlIHByZXNlbnQgaW4gYFJlZmxlY3Qub3duS2V5c2AgZm9yIHNvbWUgZGV2aWNlcyBpbiBSZWFjdCBOYXRpdmUgKCM0MSksIHNvIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZW0gaGVyZS5cblx0aWYgKHByb3BlcnR5ID09PSAnYXJndW1lbnRzJyB8fCBwcm9wZXJ0eSA9PT0gJ2NhbGxlcicpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvLCBwcm9wZXJ0eSk7XG5cdGNvbnN0IGZyb21EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCFjYW5Db3B5UHJvcGVydHkodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikgJiYgaWdub3JlTm9uQ29uZmlndXJhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwgZnJvbURlc2NyaXB0b3IpO1xufTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCB0aHJvd3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cywgaXMgbm90IGNvbmZpZ3VyYWJsZSBhbmQgZWl0aGVyOlxuLy8gLSBvbmUgaXRzIGRlc2NyaXB0b3JzIGlzIGNoYW5nZWRcbi8vIC0gaXQgaXMgbm9uLXdyaXRhYmxlIGFuZCBpdHMgdmFsdWUgaXMgY2hhbmdlZFxuY29uc3QgY2FuQ29weVByb3BlcnR5ID0gZnVuY3Rpb24gKHRvRGVzY3JpcHRvciwgZnJvbURlc2NyaXB0b3IpIHtcblx0cmV0dXJuIHRvRGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkIHx8IHRvRGVzY3JpcHRvci5jb25maWd1cmFibGUgfHwgKFxuXHRcdHRvRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZnJvbURlc2NyaXB0b3Iud3JpdGFibGVcblx0XHQmJiB0b0Rlc2NyaXB0b3IuZW51bWVyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuZW51bWVyYWJsZVxuXHRcdCYmIHRvRGVzY3JpcHRvci5jb25maWd1cmFibGUgPT09IGZyb21EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZVxuXHRcdCYmICh0b0Rlc2NyaXB0b3Iud3JpdGFibGUgfHwgdG9EZXNjcmlwdG9yLnZhbHVlID09PSBmcm9tRGVzY3JpcHRvci52YWx1ZSlcblx0KTtcbn07XG5cbmNvbnN0IGNoYW5nZVByb3RvdHlwZSA9ICh0bywgZnJvbSkgPT4ge1xuXHRjb25zdCBmcm9tUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyb20pO1xuXHRpZiAoZnJvbVByb3RvdHlwZSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRvKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZih0bywgZnJvbVByb3RvdHlwZSk7XG59O1xuXG5jb25zdCB3cmFwcGVkVG9TdHJpbmcgPSAod2l0aE5hbWUsIGZyb21Cb2R5KSA9PiBgLyogV3JhcHBlZCAke3dpdGhOYW1lfSovXFxuJHtmcm9tQm9keX1gO1xuXG5jb25zdCB0b1N0cmluZ0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJyk7XG5jb25zdCB0b1N0cmluZ05hbWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgJ25hbWUnKTtcblxuLy8gV2UgY2FsbCBgZnJvbS50b1N0cmluZygpYCBlYXJseSAobm90IGxhemlseSkgdG8gZW5zdXJlIGBmcm9tYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZSB1c2UgYGJpbmQoKWAgaW5zdGVhZCBvZiBhIGNsb3N1cmUgZm9yIHRoZSBzYW1lIHJlYXNvbi5cbi8vIENhbGxpbmcgYGZyb20udG9TdHJpbmcoKWAgZWFybHkgYWxzbyBhbGxvd3MgY2FjaGluZyBpdCBpbiBjYXNlIGB0by50b1N0cmluZygpYCBpcyBjYWxsZWQgc2V2ZXJhbCB0aW1lcy5cbmNvbnN0IGNoYW5nZVRvU3RyaW5nID0gKHRvLCBmcm9tLCBuYW1lKSA9PiB7XG5cdGNvbnN0IHdpdGhOYW1lID0gbmFtZSA9PT0gJycgPyAnJyA6IGB3aXRoICR7bmFtZS50cmltKCl9KCkgYDtcblx0Y29uc3QgbmV3VG9TdHJpbmcgPSB3cmFwcGVkVG9TdHJpbmcuYmluZChudWxsLCB3aXRoTmFtZSwgZnJvbS50b1N0cmluZygpKTtcblx0Ly8gRW5zdXJlIGB0by50b1N0cmluZy50b1N0cmluZ2AgaXMgbm9uLWVudW1lcmFibGUgYW5kIGhhcyB0aGUgc2FtZSBgc2FtZWBcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld1RvU3RyaW5nLCAnbmFtZScsIHRvU3RyaW5nTmFtZSk7XG5cdGNvbnN0IHt3cml0YWJsZSwgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlfSA9IHRvU3RyaW5nRGVzY3JpcHRvcjsgLy8gV2UgZGVzdHJ1Y3R1ZSB0byBhdm9pZCBhIHBvdGVudGlhbCBgZ2V0YCBkZXNjcmlwdG9yLlxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sICd0b1N0cmluZycsIHt2YWx1ZTogbmV3VG9TdHJpbmcsIHdyaXRhYmxlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGV9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pbWljRnVuY3Rpb24odG8sIGZyb20sIHtpZ25vcmVOb25Db25maWd1cmFibGUgPSBmYWxzZX0gPSB7fSkge1xuXHRjb25zdCB7bmFtZX0gPSB0bztcblxuXHRmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdGNvcHlQcm9wZXJ0eSh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSk7XG5cdH1cblxuXHRjaGFuZ2VQcm90b3R5cGUodG8sIGZyb20pO1xuXHRjaGFuZ2VUb1N0cmluZyh0bywgZnJvbSwgbmFtZSk7XG5cblx0cmV0dXJuIHRvO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mimic-function/index.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/attemptify.js":
/*!*****************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/attemptify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attemptifyAsync: () => (/* binding */ attemptifyAsync),\n/* harmony export */   attemptifySync: () => (/* binding */ attemptifySync)\n/* harmony export */ });\n/* MAIN */\n//FIXME: The return type of these functions is wrong, it doesn't account for returning \"undefined\", but a correct type cannot be written because generics cannot be extended properly, it seems\nconst attemptifyAsync = (fn, onError) => {\n    return function attemptified(...args) {\n        return fn.apply(undefined, args).catch(onError);\n    };\n};\nconst attemptifySync = (fn, onError) => {\n    return function attemptified(...args) {\n        try {\n            return fn.apply(undefined, args);\n        }\n        catch (error) {\n            return onError(error);\n        }\n    };\n};\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9hdHRlbXB0aWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9hdHRlbXB0aWZ5LmpzPzk2ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTUFJTiAqL1xuLy9GSVhNRTogVGhlIHJldHVybiB0eXBlIG9mIHRoZXNlIGZ1bmN0aW9ucyBpcyB3cm9uZywgaXQgZG9lc24ndCBhY2NvdW50IGZvciByZXR1cm5pbmcgXCJ1bmRlZmluZWRcIiwgYnV0IGEgY29ycmVjdCB0eXBlIGNhbm5vdCBiZSB3cml0dGVuIGJlY2F1c2UgZ2VuZXJpY3MgY2Fubm90IGJlIGV4dGVuZGVkIHByb3Blcmx5LCBpdCBzZWVtc1xuY29uc3QgYXR0ZW1wdGlmeUFzeW5jID0gKGZuLCBvbkVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHRpZmllZCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpLmNhdGNoKG9uRXJyb3IpO1xuICAgIH07XG59O1xuY29uc3QgYXR0ZW1wdGlmeVN5bmMgPSAoZm4sIG9uRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdGlmaWVkKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKiBFWFBPUlQgKi9cbmV4cG9ydCB7IGF0dGVtcHRpZnlBc3luYywgYXR0ZW1wdGlmeVN5bmMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/attemptify.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IS_USER_ROOT: () => (/* binding */ IS_USER_ROOT),\n/* harmony export */   LIMIT_FILES_DESCRIPTORS: () => (/* binding */ LIMIT_FILES_DESCRIPTORS),\n/* harmony export */   NOOP: () => (/* binding */ NOOP)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* IMPORT */\n\n/* MAIN */\nconst IS_USER_ROOT = node_process__WEBPACK_IMPORTED_MODULE_0__.getuid ? !node_process__WEBPACK_IMPORTED_MODULE_0__.getuid() : false;\nconst LIMIT_FILES_DESCRIPTORS = 10000; //TODO: Fetch the real limit from the filesystem, somehow\nconst NOOP = () => undefined;\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ21DO0FBQ25DO0FBQ0EscUJBQXFCLGdEQUFjLElBQUksZ0RBQWM7QUFDckQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9zdHViYm9ybi1mcy9kaXN0L2NvbnN0YW50cy5qcz9hMWVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbi8qIE1BSU4gKi9cbmNvbnN0IElTX1VTRVJfUk9PVCA9IHByb2Nlc3MuZ2V0dWlkID8gIXByb2Nlc3MuZ2V0dWlkKCkgOiBmYWxzZTtcbmNvbnN0IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gMTAwMDA7IC8vVE9ETzogRmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbSwgc29tZWhvd1xuY29uc3QgTk9PUCA9ICgpID0+IHVuZGVmaW5lZDtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IHsgSVNfVVNFUl9ST09ULCBMSU1JVF9GSUxFU19ERVNDUklQVE9SUywgTk9PUCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/handlers.js":
/*!***************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/handlers.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/stubborn-fs/dist/constants.js\");\n/* IMPORT */\n\n/* MAIN */\nconst Handlers = {\n    /* API */\n    isChangeErrorOk: (error) => {\n        if (!Handlers.isNodeError(error))\n            return false;\n        const { code } = error;\n        if (code === 'ENOSYS')\n            return true;\n        if (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_USER_ROOT && (code === 'EINVAL' || code === 'EPERM'))\n            return true;\n        return false;\n    },\n    isNodeError: (error) => {\n        return (error instanceof Error);\n    },\n    isRetriableError: (error) => {\n        if (!Handlers.isNodeError(error))\n            return false;\n        const { code } = error;\n        if (code === 'EMFILE' || code === 'ENFILE' || code === 'EAGAIN' || code === 'EBUSY' || code === 'EACCESS' || code === 'EACCES' || code === 'EACCS' || code === 'EPERM')\n            return true;\n        return false;\n    },\n    onChangeError: (error) => {\n        if (!Handlers.isNodeError(error))\n            throw error;\n        if (Handlers.isChangeErrorOk(error))\n            return;\n        throw error;\n    }\n};\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Handlers);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9oYW5kbGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhLHVEQUFZO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9oYW5kbGVycy5qcz9lMzZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IHsgSVNfVVNFUl9ST09UIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuLyogTUFJTiAqL1xuY29uc3QgSGFuZGxlcnMgPSB7XG4gICAgLyogQVBJICovXG4gICAgaXNDaGFuZ2VFcnJvck9rOiAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKCFIYW5kbGVycy5pc05vZGVFcnJvcihlcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PU1lTJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIUlTX1VTRVJfUk9PVCAmJiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ0VQRVJNJykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNOb2RlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpO1xuICAgIH0sXG4gICAgaXNSZXRyaWFibGVFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmICghSGFuZGxlcnMuaXNOb2RlRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycm9yO1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VNRklMRScgfHwgY29kZSA9PT0gJ0VORklMRScgfHwgY29kZSA9PT0gJ0VBR0FJTicgfHwgY29kZSA9PT0gJ0VCVVNZJyB8fCBjb2RlID09PSAnRUFDQ0VTUycgfHwgY29kZSA9PT0gJ0VBQ0NFUycgfHwgY29kZSA9PT0gJ0VBQ0NTJyB8fCBjb2RlID09PSAnRVBFUk0nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoIUhhbmRsZXJzLmlzTm9kZUVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICBpZiAoSGFuZGxlcnMuaXNDaGFuZ2VFcnJvck9rKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IGRlZmF1bHQgSGFuZGxlcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/handlers.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var _attemptify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attemptify.js */ \"./node_modules/stubborn-fs/dist/attemptify.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/stubborn-fs/dist/constants.js\");\n/* harmony import */ var _handlers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handlers.js */ \"./node_modules/stubborn-fs/dist/handlers.js\");\n/* harmony import */ var _retryify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./retryify.js */ \"./node_modules/stubborn-fs/dist/retryify.js\");\n/* IMPORT */\n\n\n\n\n\n\n/* MAIN */\nconst FS = {\n    attempt: {\n        /* ASYNC */\n        chmod: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.chmod), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].onChangeError),\n        chown: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.chown), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].onChangeError),\n        close: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.close), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        fsync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.fsync), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        mkdir: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.mkdir), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        realpath: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.realpath), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        stat: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.stat), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        unlink: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.unlink), _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        /* SYNC */\n        chmodSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.chmodSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].onChangeError),\n        chownSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.chownSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].onChangeError),\n        closeSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.closeSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        existsSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        fsyncSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.fsync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        mkdirSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.mkdirSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        realpathSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.realpathSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        statSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP),\n        unlinkSync: (0,_attemptify_js__WEBPACK_IMPORTED_MODULE_2__.attemptifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.unlinkSync, _constants_js__WEBPACK_IMPORTED_MODULE_3__.NOOP)\n    },\n    retry: {\n        /* ASYNC */\n        close: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.close), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        fsync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.fsync), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        open: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.open), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        readFile: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.readFile), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        rename: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.rename), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        stat: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.stat), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        write: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.write), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        writeFile: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifyAsync)((0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_fs__WEBPACK_IMPORTED_MODULE_0__.writeFile), _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        /* SYNC */\n        closeSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.closeSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        fsyncSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.fsyncSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        openSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.openSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        readFileSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        renameSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.renameSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        statSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        writeSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.writeSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError),\n        writeFileSync: (0,_retryify_js__WEBPACK_IMPORTED_MODULE_5__.retryifySync)(node_fs__WEBPACK_IMPORTED_MODULE_0__.writeFileSync, _handlers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isRetriableError)\n    }\n};\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDeUI7QUFDYTtBQUM0QjtBQUM1QjtBQUNEO0FBQ3VCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBZSxDQUFDLG9EQUFTLENBQUMsMENBQVEsR0FBRyxvREFBUTtBQUM1RCxlQUFlLCtEQUFlLENBQUMsb0RBQVMsQ0FBQywwQ0FBUSxHQUFHLG9EQUFRO0FBQzVELGVBQWUsK0RBQWUsQ0FBQyxvREFBUyxDQUFDLDBDQUFRLEdBQUcsK0NBQUk7QUFDeEQsZUFBZSwrREFBZSxDQUFDLG9EQUFTLENBQUMsMENBQVEsR0FBRywrQ0FBSTtBQUN4RCxlQUFlLCtEQUFlLENBQUMsb0RBQVMsQ0FBQywwQ0FBUSxHQUFHLCtDQUFJO0FBQ3hELGtCQUFrQiwrREFBZSxDQUFDLG9EQUFTLENBQUMsNkNBQVcsR0FBRywrQ0FBSTtBQUM5RCxjQUFjLCtEQUFlLENBQUMsb0RBQVMsQ0FBQyx5Q0FBTyxHQUFHLCtDQUFJO0FBQ3RELGdCQUFnQiwrREFBZSxDQUFDLG9EQUFTLENBQUMsMkNBQVMsR0FBRywrQ0FBSTtBQUMxRDtBQUNBLG1CQUFtQiw4REFBYyxDQUFDLDhDQUFZLEVBQUUsb0RBQVE7QUFDeEQsbUJBQW1CLDhEQUFjLENBQUMsOENBQVksRUFBRSxvREFBUTtBQUN4RCxtQkFBbUIsOERBQWMsQ0FBQyw4Q0FBWSxFQUFFLCtDQUFJO0FBQ3BELG9CQUFvQiw4REFBYyxDQUFDLCtDQUFhLEVBQUUsK0NBQUk7QUFDdEQsbUJBQW1CLDhEQUFjLENBQUMsMENBQVEsRUFBRSwrQ0FBSTtBQUNoRCxtQkFBbUIsOERBQWMsQ0FBQyw4Q0FBWSxFQUFFLCtDQUFJO0FBQ3BELHNCQUFzQiw4REFBYyxDQUFDLGlEQUFlLEVBQUUsK0NBQUk7QUFDMUQsa0JBQWtCLDhEQUFjLENBQUMsNkNBQVcsRUFBRSwrQ0FBSTtBQUNsRCxvQkFBb0IsOERBQWMsQ0FBQywrQ0FBYSxFQUFFLCtDQUFJO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSwyREFBYSxDQUFDLG9EQUFTLENBQUMsMENBQVEsR0FBRyxvREFBUTtBQUMxRCxlQUFlLDJEQUFhLENBQUMsb0RBQVMsQ0FBQywwQ0FBUSxHQUFHLG9EQUFRO0FBQzFELGNBQWMsMkRBQWEsQ0FBQyxvREFBUyxDQUFDLHlDQUFPLEdBQUcsb0RBQVE7QUFDeEQsa0JBQWtCLDJEQUFhLENBQUMsb0RBQVMsQ0FBQyw2Q0FBVyxHQUFHLG9EQUFRO0FBQ2hFLGdCQUFnQiwyREFBYSxDQUFDLG9EQUFTLENBQUMsMkNBQVMsR0FBRyxvREFBUTtBQUM1RCxjQUFjLDJEQUFhLENBQUMsb0RBQVMsQ0FBQyx5Q0FBTyxHQUFHLG9EQUFRO0FBQ3hELGVBQWUsMkRBQWEsQ0FBQyxvREFBUyxDQUFDLDBDQUFRLEdBQUcsb0RBQVE7QUFDMUQsbUJBQW1CLDJEQUFhLENBQUMsb0RBQVMsQ0FBQyw4Q0FBWSxHQUFHLG9EQUFRO0FBQ2xFO0FBQ0EsbUJBQW1CLDBEQUFZLENBQUMsOENBQVksRUFBRSxvREFBUTtBQUN0RCxtQkFBbUIsMERBQVksQ0FBQyw4Q0FBWSxFQUFFLG9EQUFRO0FBQ3RELGtCQUFrQiwwREFBWSxDQUFDLDZDQUFXLEVBQUUsb0RBQVE7QUFDcEQsc0JBQXNCLDBEQUFZLENBQUMsaURBQWUsRUFBRSxvREFBUTtBQUM1RCxvQkFBb0IsMERBQVksQ0FBQywrQ0FBYSxFQUFFLG9EQUFRO0FBQ3hELGtCQUFrQiwwREFBWSxDQUFDLDZDQUFXLEVBQUUsb0RBQVE7QUFDcEQsbUJBQW1CLDBEQUFZLENBQUMsOENBQVksRUFBRSxvREFBUTtBQUN0RCx1QkFBdUIsMERBQVksQ0FBQyxrREFBZ0IsRUFBRSxvREFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxFQUFFLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9zdHViYm9ybi1mcy9kaXN0L2luZGV4LmpzP2ZkMjciXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IHsgYXR0ZW1wdGlmeUFzeW5jLCBhdHRlbXB0aWZ5U3luYyB9IGZyb20gJy4vYXR0ZW1wdGlmeS5qcyc7XG5pbXBvcnQgeyBOT09QIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IEhhbmRsZXJzIGZyb20gJy4vaGFuZGxlcnMuanMnO1xuaW1wb3J0IHsgcmV0cnlpZnlBc3luYywgcmV0cnlpZnlTeW5jIH0gZnJvbSAnLi9yZXRyeWlmeS5qcyc7XG4vKiBNQUlOICovXG5jb25zdCBGUyA9IHtcbiAgICBhdHRlbXB0OiB7XG4gICAgICAgIC8qIEFTWU5DICovXG4gICAgICAgIGNobW9kOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLmNobW9kKSwgSGFuZGxlcnMub25DaGFuZ2VFcnJvciksXG4gICAgICAgIGNob3duOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLmNob3duKSwgSGFuZGxlcnMub25DaGFuZ2VFcnJvciksXG4gICAgICAgIGNsb3NlOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLmNsb3NlKSwgTk9PUCksXG4gICAgICAgIGZzeW5jOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLmZzeW5jKSwgTk9PUCksXG4gICAgICAgIG1rZGlyOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLm1rZGlyKSwgTk9PUCksXG4gICAgICAgIHJlYWxwYXRoOiBhdHRlbXB0aWZ5QXN5bmMocHJvbWlzaWZ5KGZzLnJlYWxwYXRoKSwgTk9PUCksXG4gICAgICAgIHN0YXQ6IGF0dGVtcHRpZnlBc3luYyhwcm9taXNpZnkoZnMuc3RhdCksIE5PT1ApLFxuICAgICAgICB1bmxpbms6IGF0dGVtcHRpZnlBc3luYyhwcm9taXNpZnkoZnMudW5saW5rKSwgTk9PUCksXG4gICAgICAgIC8qIFNZTkMgKi9cbiAgICAgICAgY2htb2RTeW5jOiBhdHRlbXB0aWZ5U3luYyhmcy5jaG1vZFN5bmMsIEhhbmRsZXJzLm9uQ2hhbmdlRXJyb3IpLFxuICAgICAgICBjaG93blN5bmM6IGF0dGVtcHRpZnlTeW5jKGZzLmNob3duU3luYywgSGFuZGxlcnMub25DaGFuZ2VFcnJvciksXG4gICAgICAgIGNsb3NlU3luYzogYXR0ZW1wdGlmeVN5bmMoZnMuY2xvc2VTeW5jLCBOT09QKSxcbiAgICAgICAgZXhpc3RzU3luYzogYXR0ZW1wdGlmeVN5bmMoZnMuZXhpc3RzU3luYywgTk9PUCksXG4gICAgICAgIGZzeW5jU3luYzogYXR0ZW1wdGlmeVN5bmMoZnMuZnN5bmMsIE5PT1ApLFxuICAgICAgICBta2RpclN5bmM6IGF0dGVtcHRpZnlTeW5jKGZzLm1rZGlyU3luYywgTk9PUCksXG4gICAgICAgIHJlYWxwYXRoU3luYzogYXR0ZW1wdGlmeVN5bmMoZnMucmVhbHBhdGhTeW5jLCBOT09QKSxcbiAgICAgICAgc3RhdFN5bmM6IGF0dGVtcHRpZnlTeW5jKGZzLnN0YXRTeW5jLCBOT09QKSxcbiAgICAgICAgdW5saW5rU3luYzogYXR0ZW1wdGlmeVN5bmMoZnMudW5saW5rU3luYywgTk9PUClcbiAgICB9LFxuICAgIHJldHJ5OiB7XG4gICAgICAgIC8qIEFTWU5DICovXG4gICAgICAgIGNsb3NlOiByZXRyeWlmeUFzeW5jKHByb21pc2lmeShmcy5jbG9zZSksIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICBmc3luYzogcmV0cnlpZnlBc3luYyhwcm9taXNpZnkoZnMuZnN5bmMpLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgb3BlbjogcmV0cnlpZnlBc3luYyhwcm9taXNpZnkoZnMub3BlbiksIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICByZWFkRmlsZTogcmV0cnlpZnlBc3luYyhwcm9taXNpZnkoZnMucmVhZEZpbGUpLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgcmVuYW1lOiByZXRyeWlmeUFzeW5jKHByb21pc2lmeShmcy5yZW5hbWUpLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgc3RhdDogcmV0cnlpZnlBc3luYyhwcm9taXNpZnkoZnMuc3RhdCksIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICB3cml0ZTogcmV0cnlpZnlBc3luYyhwcm9taXNpZnkoZnMud3JpdGUpLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgd3JpdGVGaWxlOiByZXRyeWlmeUFzeW5jKHByb21pc2lmeShmcy53cml0ZUZpbGUpLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgLyogU1lOQyAqL1xuICAgICAgICBjbG9zZVN5bmM6IHJldHJ5aWZ5U3luYyhmcy5jbG9zZVN5bmMsIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICBmc3luY1N5bmM6IHJldHJ5aWZ5U3luYyhmcy5mc3luY1N5bmMsIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICBvcGVuU3luYzogcmV0cnlpZnlTeW5jKGZzLm9wZW5TeW5jLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgcmVhZEZpbGVTeW5jOiByZXRyeWlmeVN5bmMoZnMucmVhZEZpbGVTeW5jLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgcmVuYW1lU3luYzogcmV0cnlpZnlTeW5jKGZzLnJlbmFtZVN5bmMsIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgICAgICBzdGF0U3luYzogcmV0cnlpZnlTeW5jKGZzLnN0YXRTeW5jLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgd3JpdGVTeW5jOiByZXRyeWlmeVN5bmMoZnMud3JpdGVTeW5jLCBIYW5kbGVycy5pc1JldHJpYWJsZUVycm9yKSxcbiAgICAgICAgd3JpdGVGaWxlU3luYzogcmV0cnlpZnlTeW5jKGZzLndyaXRlRmlsZVN5bmMsIEhhbmRsZXJzLmlzUmV0cmlhYmxlRXJyb3IpXG4gICAgfVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IGRlZmF1bHQgRlM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/index.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/retryify.js":
/*!***************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/retryify.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   retryifyAsync: () => (/* binding */ retryifyAsync),\n/* harmony export */   retryifySync: () => (/* binding */ retryifySync)\n/* harmony export */ });\n/* harmony import */ var _retryify_queue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./retryify_queue.js */ \"./node_modules/stubborn-fs/dist/retryify_queue.js\");\n/* IMPORT */\n\n/* MAIN */\n//FIXME: There are a boatload of anys here, but apparently generics cannot be extended properly, so...\nconst retryifyAsync = (fn, isRetriableError) => {\n    return function retrified(timestamp) {\n        return function attempt(...args) {\n            return _retryify_queue_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].schedule().then(cleanup => {\n                const onResolve = (result) => {\n                    cleanup();\n                    return result;\n                };\n                const onReject = (error) => {\n                    cleanup();\n                    if (Date.now() >= timestamp)\n                        throw error;\n                    if (isRetriableError(error)) {\n                        const delay = Math.round(100 * Math.random());\n                        const delayPromise = new Promise(resolve => setTimeout(resolve, delay));\n                        return delayPromise.then(() => attempt.apply(undefined, args));\n                    }\n                    throw error;\n                };\n                return fn.apply(undefined, args).then(onResolve, onReject);\n            });\n        };\n    };\n};\nconst retryifySync = (fn, isRetriableError) => {\n    return function retrified(timestamp) {\n        return function attempt(...args) {\n            try {\n                return fn.apply(undefined, args);\n            }\n            catch (error) {\n                if (Date.now() > timestamp)\n                    throw error;\n                if (isRetriableError(error))\n                    return attempt.apply(undefined, args);\n                throw error;\n            }\n        };\n    };\n};\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9yZXRyeWlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUMrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9zdHViYm9ybi1mcy9kaXN0L3JldHJ5aWZ5LmpzPzY3MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG5pbXBvcnQgUmV0cnlmeVF1ZXVlIGZyb20gJy4vcmV0cnlpZnlfcXVldWUuanMnO1xuLyogTUFJTiAqL1xuLy9GSVhNRTogVGhlcmUgYXJlIGEgYm9hdGxvYWQgb2YgYW55cyBoZXJlLCBidXQgYXBwYXJlbnRseSBnZW5lcmljcyBjYW5ub3QgYmUgZXh0ZW5kZWQgcHJvcGVybHksIHNvLi4uXG5jb25zdCByZXRyeWlmeUFzeW5jID0gKGZuLCBpc1JldHJpYWJsZUVycm9yKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJldHJpZmllZCh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGVtcHQoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIFJldHJ5ZnlRdWV1ZS5zY2hlZHVsZSgpLnRoZW4oY2xlYW51cCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZXNvbHZlID0gKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBvblJlamVjdCA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID49IHRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXRyaWFibGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5yb3VuZCgxMDAgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5UHJvbWlzZS50aGVuKCgpID0+IGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKS50aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5jb25zdCByZXRyeWlmeVN5bmMgPSAoZm4sIGlzUmV0cmlhYmxlRXJyb3IpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmV0cmlmaWVkKHRpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXR0ZW1wdCguLi5hcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IHsgcmV0cnlpZnlBc3luYywgcmV0cnlpZnlTeW5jIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/retryify.js\n\n}");

/***/ }),

/***/ "./node_modules/stubborn-fs/dist/retryify_queue.js":
/*!*********************************************************!*\
  !*** ./node_modules/stubborn-fs/dist/retryify_queue.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/stubborn-fs/dist/constants.js\");\n/* IMPORT */\n\n/* MAIN */\nclass RetryfyQueue {\n    constructor() {\n        /* VARIABLES */\n        this.interval = 25;\n        this.intervalId = undefined;\n        this.limit = _constants_js__WEBPACK_IMPORTED_MODULE_0__.LIMIT_FILES_DESCRIPTORS;\n        this.queueActive = new Set();\n        this.queueWaiting = new Set();\n        /* LIFECYCLE API */\n        this.init = () => {\n            if (this.intervalId)\n                return;\n            this.intervalId = setInterval(this.tick, this.interval);\n        };\n        this.reset = () => {\n            if (!this.intervalId)\n                return;\n            clearInterval(this.intervalId);\n            delete this.intervalId;\n        };\n        /* API */\n        this.add = (fn) => {\n            this.queueWaiting.add(fn);\n            if (this.queueActive.size < (this.limit / 2)) { // Active queue not under preassure, executing immediately\n                this.tick();\n            }\n            else {\n                this.init();\n            }\n        };\n        this.remove = (fn) => {\n            this.queueWaiting.delete(fn);\n            this.queueActive.delete(fn);\n        };\n        this.schedule = () => {\n            return new Promise(resolve => {\n                const cleanup = () => this.remove(resolver);\n                const resolver = () => resolve(cleanup);\n                this.add(resolver);\n            });\n        };\n        this.tick = () => {\n            if (this.queueActive.size >= this.limit)\n                return;\n            if (!this.queueWaiting.size)\n                return this.reset();\n            for (const fn of this.queueWaiting) {\n                if (this.queueActive.size >= this.limit)\n                    break;\n                this.queueWaiting.delete(fn);\n                this.queueActive.add(fn);\n                fn();\n            }\n        };\n    }\n}\n;\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new RetryfyQueue());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1YmJvcm4tZnMvZGlzdC9yZXRyeWlmeV9xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3lEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy9zdHViYm9ybi1mcy9kaXN0L3JldHJ5aWZ5X3F1ZXVlLmpzPzdmMjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG5pbXBvcnQgeyBMSU1JVF9GSUxFU19ERVNDUklQVE9SUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbi8qIE1BSU4gKi9cbmNsYXNzIFJldHJ5ZnlRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIFZBUklBQkxFUyAqL1xuICAgICAgICB0aGlzLmludGVydmFsID0gMjU7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5saW1pdCA9IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTO1xuICAgICAgICB0aGlzLnF1ZXVlQWN0aXZlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnF1ZXVlV2FpdGluZyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyogTElGRUNZQ0xFIEFQSSAqL1xuICAgICAgICB0aGlzLmluaXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMudGljaywgdGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW50ZXJ2YWxJZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcnZhbElkO1xuICAgICAgICB9O1xuICAgICAgICAvKiBBUEkgKi9cbiAgICAgICAgdGhpcy5hZGQgPSAoZm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWVXYWl0aW5nLmFkZChmbik7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWV1ZUFjdGl2ZS5zaXplIDwgKHRoaXMubGltaXQgLyAyKSkgeyAvLyBBY3RpdmUgcXVldWUgbm90IHVuZGVyIHByZWFzc3VyZSwgZXhlY3V0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSAoZm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlQWN0aXZlLmRlbGV0ZShmbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHRoaXMucmVtb3ZlKHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgpID0+IHJlc29sdmUoY2xlYW51cCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQocmVzb2x2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlQWN0aXZlLnNpemUgPj0gdGhpcy5saW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMucXVldWVXYWl0aW5nLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5xdWV1ZVdhaXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWV1ZUFjdGl2ZS5zaXplID49IHRoaXMubGltaXQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZUFjdGl2ZS5hZGQoZm4pO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuO1xuLyogRVhQT1JUICovXG5leHBvcnQgZGVmYXVsdCBuZXcgUmV0cnlmeVF1ZXVlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/stubborn-fs/dist/retryify_queue.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/create.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/create.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.create = void 0;\nconst fs_minipass_1 = __webpack_require__(/*! @isaacs/fs-minipass */ \"./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\");\nconst node_path_1 = __importDefault(__webpack_require__(/*! node:path */ \"node:path\"));\nconst list_js_1 = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/dist/commonjs/list.js\");\nconst make_command_js_1 = __webpack_require__(/*! ./make-command.js */ \"./node_modules/tar/dist/commonjs/make-command.js\");\nconst pack_js_1 = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/dist/commonjs/pack.js\");\nconst createFileSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    const stream = new fs_minipass_1.WriteStreamSync(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst createFile = (opt, files) => {\n    const p = new pack_js_1.Pack(opt);\n    const stream = new fs_minipass_1.WriteStream(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    const promise = new Promise((res, rej) => {\n        stream.on('error', rej);\n        stream.on('close', res);\n        p.on('error', rej);\n    });\n    addFilesAsync(p, files);\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0, list_js_1.list)({\n                file: node_path_1.default.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0, list_js_1.list)({\n                file: node_path_1.default.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => {\n                    p.add(entry);\n                },\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nconst createSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    addFilesSync(p, files);\n    return p;\n};\nconst createAsync = (opt, files) => {\n    const p = new pack_js_1.Pack(opt);\n    addFilesAsync(p, files);\n    return p;\n};\nexports.create = (0, make_command_js_1.makeCommand)(createFileSync, createFile, createSync, createAsync, (_opt, files) => {\n    if (!files?.length) {\n        throw new TypeError('no paths specified to add to archive');\n    }\n});\n//# sourceMappingURL=create.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvY3JlYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLHNCQUFzQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNuRCxvQ0FBb0MsbUJBQU8sQ0FBQyw0QkFBVztBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQywyREFBVztBQUNyQywwQkFBMEIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsMkRBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvY3JlYXRlLmpzP2Y4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZSA9IHZvaWQgMDtcbmNvbnN0IGZzX21pbmlwYXNzXzEgPSByZXF1aXJlKFwiQGlzYWFjcy9mcy1taW5pcGFzc1wiKTtcbmNvbnN0IG5vZGVfcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnBhdGhcIikpO1xuY29uc3QgbGlzdF9qc18xID0gcmVxdWlyZShcIi4vbGlzdC5qc1wiKTtcbmNvbnN0IG1ha2VfY29tbWFuZF9qc18xID0gcmVxdWlyZShcIi4vbWFrZS1jb21tYW5kLmpzXCIpO1xuY29uc3QgcGFja19qc18xID0gcmVxdWlyZShcIi4vcGFjay5qc1wiKTtcbmNvbnN0IGNyZWF0ZUZpbGVTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IHBhY2tfanNfMS5QYWNrU3luYyhvcHQpO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBmc19taW5pcGFzc18xLldyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgICAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NixcbiAgICB9KTtcbiAgICBwLnBpcGUoc3RyZWFtKTtcbiAgICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpO1xufTtcbmNvbnN0IGNyZWF0ZUZpbGUgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFja19qc18xLlBhY2sob3B0KTtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNfbWluaXBhc3NfMS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NixcbiAgICB9KTtcbiAgICBwLnBpcGUoc3RyZWFtKTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWopO1xuICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgcmVzKTtcbiAgICAgICAgcC5vbignZXJyb3InLCByZWopO1xuICAgIH0pO1xuICAgIGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IGFkZEZpbGVzU3luYyA9IChwLCBmaWxlcykgPT4ge1xuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAoMCwgbGlzdF9qc18xLmxpc3QpKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgICAgICAgICAgb25SZWFkRW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5hZGQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBwLmVuZCgpO1xufTtcbmNvbnN0IGFkZEZpbGVzQXN5bmMgPSBhc3luYyAocCwgZmlsZXMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBTdHJpbmcoZmlsZXNbaV0pO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGxpc3RfanNfMS5saXN0KSh7XG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZV9wYXRoXzEuZGVmYXVsdC5yZXNvbHZlKFN0cmluZyhwLmN3ZCksIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uUmVhZEVudHJ5OiBlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHAuYWRkKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLmFkZChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwLmVuZCgpO1xufTtcbmNvbnN0IGNyZWF0ZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFja19qc18xLlBhY2tTeW5jKG9wdCk7XG4gICAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKTtcbiAgICByZXR1cm4gcDtcbn07XG5jb25zdCBjcmVhdGVBc3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gICAgY29uc3QgcCA9IG5ldyBwYWNrX2pzXzEuUGFjayhvcHQpO1xuICAgIGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpO1xuICAgIHJldHVybiBwO1xufTtcbmV4cG9ydHMuY3JlYXRlID0gKDAsIG1ha2VfY29tbWFuZF9qc18xLm1ha2VDb21tYW5kKShjcmVhdGVGaWxlU3luYywgY3JlYXRlRmlsZSwgY3JlYXRlU3luYywgY3JlYXRlQXN5bmMsIChfb3B0LCBmaWxlcykgPT4ge1xuICAgIGlmICghZmlsZXM/Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBwYXRocyBzcGVjaWZpZWQgdG8gYWRkIHRvIGFyY2hpdmUnKTtcbiAgICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/create.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/cwd-error.js":
/*!*****************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/cwd-error.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CwdError = void 0;\nclass CwdError extends Error {\n    path;\n    code;\n    syscall = 'chdir';\n    constructor(path, code) {\n        super(`${code}: Cannot cd into '${path}'`);\n        this.path = path;\n        this.code = code;\n    }\n    get name() {\n        return 'CwdError';\n    }\n}\nexports.CwdError = CwdError;\n//# sourceMappingURL=cwd-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvY3dkLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUssb0JBQW9CLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9jd2QtZXJyb3IuanM/MDgyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3dkRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBDd2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBwYXRoO1xuICAgIGNvZGU7XG4gICAgc3lzY2FsbCA9ICdjaGRpcic7XG4gICAgY29uc3RydWN0b3IocGF0aCwgY29kZSkge1xuICAgICAgICBzdXBlcihgJHtjb2RlfTogQ2Fubm90IGNkIGludG8gJyR7cGF0aH0nYCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0N3ZEVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLkN3ZEVycm9yID0gQ3dkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jd2QtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/cwd-error.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/extract.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/extract.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extract = void 0;\n// tar -x\nconst fsm = __importStar(__webpack_require__(/*! @isaacs/fs-minipass */ \"./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\"));\nconst node_fs_1 = __importDefault(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst list_js_1 = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/dist/commonjs/list.js\");\nconst make_command_js_1 = __webpack_require__(/*! ./make-command.js */ \"./node_modules/tar/dist/commonjs/make-command.js\");\nconst unpack_js_1 = __webpack_require__(/*! ./unpack.js */ \"./node_modules/tar/dist/commonjs/unpack.js\");\nconst extractFileSync = (opt) => {\n    const u = new unpack_js_1.UnpackSync(opt);\n    const file = opt.file;\n    const stat = node_fs_1.default.statSync(file);\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const stream = new fsm.ReadStreamSync(file, {\n        readSize: readSize,\n        size: stat.size,\n    });\n    stream.pipe(u);\n};\nconst extractFile = (opt, _) => {\n    const u = new unpack_js_1.Unpack(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        u.on('error', reject);\n        u.on('close', resolve);\n        // This trades a zero-byte read() syscall for a stat\n        // However, it will usually result in less memory allocation\n        node_fs_1.default.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(u);\n            }\n        });\n    });\n    return p;\n};\nexports.extract = (0, make_command_js_1.makeCommand)(extractFileSync, extractFile, opt => new unpack_js_1.UnpackSync(opt), opt => new unpack_js_1.Unpack(opt), (opt, files) => {\n    if (files?.length)\n        (0, list_js_1.filesFilter)(opt, files);\n});\n//# sourceMappingURL=extract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvZXh0cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQsa0NBQWtDLG1CQUFPLENBQUMsd0JBQVM7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsMkRBQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvZXh0cmFjdC5qcz83MDlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3QgPSB2b2lkIDA7XG4vLyB0YXIgLXhcbmNvbnN0IGZzbSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQGlzYWFjcy9mcy1taW5pcGFzc1wiKSk7XG5jb25zdCBub2RlX2ZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6ZnNcIikpO1xuY29uc3QgbGlzdF9qc18xID0gcmVxdWlyZShcIi4vbGlzdC5qc1wiKTtcbmNvbnN0IG1ha2VfY29tbWFuZF9qc18xID0gcmVxdWlyZShcIi4vbWFrZS1jb21tYW5kLmpzXCIpO1xuY29uc3QgdW5wYWNrX2pzXzEgPSByZXF1aXJlKFwiLi91bnBhY2suanNcIik7XG5jb25zdCBleHRyYWN0RmlsZVN5bmMgPSAob3B0KSA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyB1bnBhY2tfanNfMS5VbnBhY2tTeW5jKG9wdCk7XG4gICAgY29uc3QgZmlsZSA9IG9wdC5maWxlO1xuICAgIGNvbnN0IHN0YXQgPSBub2RlX2ZzXzEuZGVmYXVsdC5zdGF0U3luYyhmaWxlKTtcbiAgICAvLyBUaGlzIHRyYWRlcyBhIHplcm8tYnl0ZSByZWFkKCkgc3lzY2FsbCBmb3IgYSBzdGF0XG4gICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYgKiAxMDI0ICogMTAyNDtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW1TeW5jKGZpbGUsIHtcbiAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgfSk7XG4gICAgc3RyZWFtLnBpcGUodSk7XG59O1xuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBfKSA9PiB7XG4gICAgY29uc3QgdSA9IG5ldyB1bnBhY2tfanNfMS5VbnBhY2sob3B0KTtcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IGZpbGUgPSBvcHQuZmlsZTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB1Lm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHUub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICAgIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgICAgICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBpcGUodSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcbmV4cG9ydHMuZXh0cmFjdCA9ICgwLCBtYWtlX2NvbW1hbmRfanNfMS5tYWtlQ29tbWFuZCkoZXh0cmFjdEZpbGVTeW5jLCBleHRyYWN0RmlsZSwgb3B0ID0+IG5ldyB1bnBhY2tfanNfMS5VbnBhY2tTeW5jKG9wdCksIG9wdCA9PiBuZXcgdW5wYWNrX2pzXzEuVW5wYWNrKG9wdCksIChvcHQsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGZpbGVzPy5sZW5ndGgpXG4gICAgICAgICgwLCBsaXN0X2pzXzEuZmlsZXNGaWx0ZXIpKG9wdCwgZmlsZXMpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/extract.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/get-write-flag.js":
/*!**********************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/get-write-flag.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWriteFlag = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform;\nconst isWindows = platform === 'win32';\n/* c8 ignore start */\nconst { O_CREAT, O_TRUNC, O_WRONLY } = fs_1.default.constants;\nconst UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) ||\n    fs_1.default.constants.UV_FS_O_FILEMAP ||\n    0;\n/* c8 ignore stop */\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;\nconst fMapLimit = 512 * 1024;\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;\nexports.getWriteFlag = !fMapEnabled ?\n    () => 'w'\n    : (size) => (size < fMapLimit ? fMapFlag : 'w');\n//# sourceMappingURL=get-write-flag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvZ2V0LXdyaXRlLWZsYWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiw2QkFBNkIsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL2dldC13cml0ZS1mbGFnLmpzP2YxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBHZXQgdGhlIGFwcHJvcHJpYXRlIGZsYWcgdG8gdXNlIGZvciBjcmVhdGluZyBmaWxlc1xuLy8gV2UgdXNlIGZtYXAgb24gV2luZG93cyBwbGF0Zm9ybXMgZm9yIGZpbGVzIGxlc3MgdGhhblxuLy8gNTEya2IuICBUaGlzIGlzIGEgZmFpcmx5IGxvdyBsaW1pdCwgYnV0IGF2b2lkcyBtYWtpbmdcbi8vIHRoaW5ncyBzbG93ZXIgaW4gc29tZSBjYXNlcy4gIFNpbmNlIG1vc3Qgb2Ygd2hhdCB0aGlzXG4vLyBsaWJyYXJ5IGlzIHVzZWQgZm9yIGlzIGV4dHJhY3RpbmcgdGFyYmFsbHMgb2YgbWFueVxuLy8gcmVsYXRpdmVseSBzbWFsbCBmaWxlcyBpbiBucG0gcGFja2FnZXMgYW5kIHRoZSBsaWtlLFxuLy8gaXQgY2FuIGJlIGEgYmlnIGJvb3N0IG9uIFdpbmRvd3MgcGxhdGZvcm1zLlxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRXcml0ZUZsYWcgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fRkFLRV9QTEFURk9STV9fIHx8IHByb2Nlc3MucGxhdGZvcm07XG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgeyBPX0NSRUFULCBPX1RSVU5DLCBPX1dST05MWSB9ID0gZnNfMS5kZWZhdWx0LmNvbnN0YW50cztcbmNvbnN0IFVWX0ZTX09fRklMRU1BUCA9IE51bWJlcihwcm9jZXNzLmVudi5fX0ZBS0VfRlNfT19GSUxFTkFNRV9fKSB8fFxuICAgIGZzXzEuZGVmYXVsdC5jb25zdGFudHMuVVZfRlNfT19GSUxFTUFQIHx8XG4gICAgMDtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jb25zdCBmTWFwRW5hYmxlZCA9IGlzV2luZG93cyAmJiAhIVVWX0ZTX09fRklMRU1BUDtcbmNvbnN0IGZNYXBMaW1pdCA9IDUxMiAqIDEwMjQ7XG5jb25zdCBmTWFwRmxhZyA9IFVWX0ZTX09fRklMRU1BUCB8IE9fVFJVTkMgfCBPX0NSRUFUIHwgT19XUk9OTFk7XG5leHBvcnRzLmdldFdyaXRlRmxhZyA9ICFmTWFwRW5hYmxlZCA/XG4gICAgKCkgPT4gJ3cnXG4gICAgOiAoc2l6ZSkgPT4gKHNpemUgPCBmTWFwTGltaXQgPyBmTWFwRmxhZyA6ICd3Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd3JpdGUtZmxhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/get-write-flag.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/header.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/header.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Header = void 0;\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst large = __importStar(__webpack_require__(/*! ./large-numbers.js */ \"./node_modules/tar/dist/commonjs/large-numbers.js\"));\nconst types = __importStar(__webpack_require__(/*! ./types.js */ \"./node_modules/tar/dist/commonjs/types.js\"));\nclass Header {\n    cksumValid = false;\n    needPax = false;\n    nullBlock = false;\n    block;\n    path;\n    mode;\n    uid;\n    gid;\n    size;\n    cksum;\n    #type = 'Unsupported';\n    linkpath;\n    uname;\n    gname;\n    devmaj = 0;\n    devmin = 0;\n    atime;\n    ctime;\n    mtime;\n    charset;\n    comment;\n    constructor(data, off = 0, ex, gex) {\n        if (Buffer.isBuffer(data)) {\n            this.decode(data, off || 0, ex, gex);\n        }\n        else if (data) {\n            this.#slurp(data);\n        }\n    }\n    decode(buf, off, ex, gex) {\n        if (!off) {\n            off = 0;\n        }\n        if (!buf || !(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        this.path = decString(buf, off, 100);\n        this.mode = decNumber(buf, off + 100, 8);\n        this.uid = decNumber(buf, off + 108, 8);\n        this.gid = decNumber(buf, off + 116, 8);\n        this.size = decNumber(buf, off + 124, 12);\n        this.mtime = decDate(buf, off + 136, 12);\n        this.cksum = decNumber(buf, off + 148, 12);\n        // if we have extended or global extended headers, apply them now\n        // See https://github.com/npm/node-tar/pull/187\n        // Apply global before local, so it overrides\n        if (gex)\n            this.#slurp(gex, true);\n        if (ex)\n            this.#slurp(ex);\n        // old tar versions marked dirs as a file with a trailing /\n        const t = decString(buf, off + 156, 1);\n        if (types.isCode(t)) {\n            this.#type = t || '0';\n        }\n        if (this.#type === '0' && this.path.slice(-1) === '/') {\n            this.#type = '5';\n        }\n        // tar implementations sometimes incorrectly put the stat(dir).size\n        // as the size in the tarball, even though Directory entries are\n        // not able to have any body at all.  In the very rare chance that\n        // it actually DOES have a body, we weren't going to do anything with\n        // it anyway, and it'll just be a warning about an invalid header.\n        if (this.#type === '5') {\n            this.size = 0;\n        }\n        this.linkpath = decString(buf, off + 157, 100);\n        if (buf.subarray(off + 257, off + 265).toString() ===\n            'ustar\\u000000') {\n            this.uname = decString(buf, off + 265, 32);\n            this.gname = decString(buf, off + 297, 32);\n            /* c8 ignore start */\n            this.devmaj = decNumber(buf, off + 329, 8) ?? 0;\n            this.devmin = decNumber(buf, off + 337, 8) ?? 0;\n            /* c8 ignore stop */\n            if (buf[off + 475] !== 0) {\n                // definitely a prefix, definitely >130 chars.\n                const prefix = decString(buf, off + 345, 155);\n                this.path = prefix + '/' + this.path;\n            }\n            else {\n                const prefix = decString(buf, off + 345, 130);\n                if (prefix) {\n                    this.path = prefix + '/' + this.path;\n                }\n                this.atime = decDate(buf, off + 476, 12);\n                this.ctime = decDate(buf, off + 488, 12);\n            }\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksumValid = sum === this.cksum;\n        if (this.cksum === undefined && sum === 8 * 0x20) {\n            this.nullBlock = true;\n        }\n    }\n    #slurp(ex, gex = false) {\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex) ||\n                (k === 'linkpath' && gex) ||\n                k === 'global');\n        })));\n    }\n    encode(buf, off = 0) {\n        if (!buf) {\n            buf = this.block = Buffer.alloc(512);\n        }\n        if (this.#type === 'Unsupported') {\n            this.#type = '0';\n        }\n        if (!(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        const prefixSize = this.ctime || this.atime ? 130 : 155;\n        const split = splitPrefix(this.path || '', prefixSize);\n        const path = split[0];\n        const prefix = split[1];\n        this.needPax = !!split[2];\n        this.needPax = encString(buf, off, 100, path) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 124, 12, this.size) || this.needPax;\n        this.needPax =\n            encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n        buf[off + 156] = this.#type.charCodeAt(0);\n        this.needPax =\n            encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n        buf.write('ustar\\u000000', off + 257, 8);\n        this.needPax =\n            encString(buf, off + 265, 32, this.uname) || this.needPax;\n        this.needPax =\n            encString(buf, off + 297, 32, this.gname) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n        this.needPax =\n            encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n        if (buf[off + 475] !== 0) {\n            this.needPax =\n                encString(buf, off + 345, 155, prefix) || this.needPax;\n        }\n        else {\n            this.needPax =\n                encString(buf, off + 345, 130, prefix) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 476, 12, this.atime) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksum = sum;\n        encNumber(buf, off + 148, 8, this.cksum);\n        this.cksumValid = true;\n        return this.needPax;\n    }\n    get type() {\n        return (this.#type === 'Unsupported' ?\n            this.#type\n            : types.name.get(this.#type));\n    }\n    get typeKey() {\n        return this.#type;\n    }\n    set type(type) {\n        const c = String(types.code.get(type));\n        if (types.isCode(c) || c === 'Unsupported') {\n            this.#type = c;\n        }\n        else if (types.isCode(type)) {\n            this.#type = type;\n        }\n        else {\n            throw new TypeError('invalid entry type: ' + type);\n        }\n    }\n}\nexports.Header = Header;\nconst splitPrefix = (p, prefixSize) => {\n    const pathSize = 100;\n    let pp = p;\n    let prefix = '';\n    let ret = undefined;\n    const root = node_path_1.posix.parse(p).root || '.';\n    if (Buffer.byteLength(pp) < pathSize) {\n        ret = [pp, prefix, false];\n    }\n    else {\n        // first set prefix to the dir, and path to the base\n        prefix = node_path_1.posix.dirname(pp);\n        pp = node_path_1.posix.basename(pp);\n        do {\n            if (Buffer.byteLength(pp) <= pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // both fit!\n                ret = [pp, prefix, false];\n            }\n            else if (Buffer.byteLength(pp) > pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // prefix fits in prefix, but path doesn't fit in path\n                ret = [pp.slice(0, pathSize - 1), prefix, true];\n            }\n            else {\n                // make path take a bit from prefix\n                pp = node_path_1.posix.join(node_path_1.posix.basename(prefix), pp);\n                prefix = node_path_1.posix.dirname(prefix);\n            }\n        } while (prefix !== root && ret === undefined);\n        // at this point, found no resolution, just truncate\n        if (!ret) {\n            ret = [p.slice(0, pathSize - 1), '', true];\n        }\n    }\n    return ret;\n};\nconst decString = (buf, off, size) => buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*/, '');\nconst decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));\nconst numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);\nconst decNumber = (buf, off, size) => Number(buf[off]) & 0x80 ?\n    large.parse(buf.subarray(off, off + size))\n    : decSmallNumber(buf, off, size);\nconst nanUndef = (value) => (isNaN(value) ? undefined : value);\nconst decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*$/, '')\n    .trim(), 8));\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n    12: 0o77777777777,\n    8: 0o7777777,\n};\nconst encNumber = (buf, off, size, num) => num === undefined ? false\n    : num > MAXNUM[size] || num < 0 ?\n        (large.encode(num, buf.subarray(off, off + size)), true)\n        : (encSmallNumber(buf, off, size, num), false);\nconst encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, 'ascii');\nconst octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);\nconst padOctal = (str, size) => (str.length === size - 1 ?\n    str\n    : new Array(size - str.length - 1).join('0') + str + ' ') + '\\0';\nconst encDate = (buf, off, size, date) => date === undefined ? false : (encNumber(buf, off, size, date.getTime() / 1000));\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0');\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, str) => str === undefined ? false : ((buf.write(str + NULLS, off, size, 'utf8'),\n    str.length !== Buffer.byteLength(str) || str.length > size));\n//# sourceMappingURL=header.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvaGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxvQkFBb0IsbUJBQU8sQ0FBQyw0QkFBVztBQUN2QywyQkFBMkIsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDdkQsMkJBQTJCLG1CQUFPLENBQUMsNkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL2hlYWRlci5qcz80ZjMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gcGFyc2UgYSA1MTItYnl0ZSBoZWFkZXIgYmxvY2sgdG8gYSBkYXRhIG9iamVjdCwgb3IgdmljZS12ZXJzYVxuLy8gZW5jb2RlIHJldHVybnMgYHRydWVgIGlmIGEgcGF4IGV4dGVuZGVkIGhlYWRlciBpcyBuZWVkZWQsIGJlY2F1c2Vcbi8vIHRoZSBkYXRhIGNvdWxkIG5vdCBiZSBmYWl0aGZ1bGx5IGVuY29kZWQgaW4gYSBzaW1wbGUgaGVhZGVyLlxuLy8gKEFsc28sIGNoZWNrIGhlYWRlci5uZWVkUGF4IHRvIHNlZSBpZiBpdCBuZWVkcyBhIHBheCBoZWFkZXIuKVxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlYWRlciA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfcGF0aF8xID0gcmVxdWlyZShcIm5vZGU6cGF0aFwiKTtcbmNvbnN0IGxhcmdlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xhcmdlLW51bWJlcnMuanNcIikpO1xuY29uc3QgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMuanNcIikpO1xuY2xhc3MgSGVhZGVyIHtcbiAgICBja3N1bVZhbGlkID0gZmFsc2U7XG4gICAgbmVlZFBheCA9IGZhbHNlO1xuICAgIG51bGxCbG9jayA9IGZhbHNlO1xuICAgIGJsb2NrO1xuICAgIHBhdGg7XG4gICAgbW9kZTtcbiAgICB1aWQ7XG4gICAgZ2lkO1xuICAgIHNpemU7XG4gICAgY2tzdW07XG4gICAgI3R5cGUgPSAnVW5zdXBwb3J0ZWQnO1xuICAgIGxpbmtwYXRoO1xuICAgIHVuYW1lO1xuICAgIGduYW1lO1xuICAgIGRldm1haiA9IDA7XG4gICAgZGV2bWluID0gMDtcbiAgICBhdGltZTtcbiAgICBjdGltZTtcbiAgICBtdGltZTtcbiAgICBjaGFyc2V0O1xuICAgIGNvbW1lbnQ7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgb2ZmID0gMCwgZXgsIGdleCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZShkYXRhLCBvZmYgfHwgMCwgZXgsIGdleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy4jc2x1cnAoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb2RlKGJ1Ziwgb2ZmLCBleCwgZ2V4KSB7XG4gICAgICAgIGlmICghb2ZmKSB7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmIHx8ICEoYnVmLmxlbmd0aCA+PSBvZmYgKyA1MTIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGggPSBkZWNTdHJpbmcoYnVmLCBvZmYsIDEwMCk7XG4gICAgICAgIHRoaXMubW9kZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEwMCwgOCk7XG4gICAgICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KTtcbiAgICAgICAgdGhpcy5naWQgPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgpO1xuICAgICAgICB0aGlzLnNpemUgPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyKTtcbiAgICAgICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKTtcbiAgICAgICAgdGhpcy5ja3N1bSA9IGRlY051bWJlcihidWYsIG9mZiArIDE0OCwgMTIpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGV4dGVuZGVkIG9yIGdsb2JhbCBleHRlbmRlZCBoZWFkZXJzLCBhcHBseSB0aGVtIG5vd1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgICAgICAvLyBBcHBseSBnbG9iYWwgYmVmb3JlIGxvY2FsLCBzbyBpdCBvdmVycmlkZXNcbiAgICAgICAgaWYgKGdleClcbiAgICAgICAgICAgIHRoaXMuI3NsdXJwKGdleCwgdHJ1ZSk7XG4gICAgICAgIGlmIChleClcbiAgICAgICAgICAgIHRoaXMuI3NsdXJwKGV4KTtcbiAgICAgICAgLy8gb2xkIHRhciB2ZXJzaW9ucyBtYXJrZWQgZGlycyBhcyBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIC9cbiAgICAgICAgY29uc3QgdCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSk7XG4gICAgICAgIGlmICh0eXBlcy5pc0NvZGUodCkpIHtcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgPSB0IHx8ICcwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jdHlwZSA9PT0gJzAnICYmIHRoaXMucGF0aC5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy4jdHlwZSA9ICc1JztcbiAgICAgICAgfVxuICAgICAgICAvLyB0YXIgaW1wbGVtZW50YXRpb25zIHNvbWV0aW1lcyBpbmNvcnJlY3RseSBwdXQgdGhlIHN0YXQoZGlyKS5zaXplXG4gICAgICAgIC8vIGFzIHRoZSBzaXplIGluIHRoZSB0YXJiYWxsLCBldmVuIHRob3VnaCBEaXJlY3RvcnkgZW50cmllcyBhcmVcbiAgICAgICAgLy8gbm90IGFibGUgdG8gaGF2ZSBhbnkgYm9keSBhdCBhbGwuICBJbiB0aGUgdmVyeSByYXJlIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIGl0IGFjdHVhbGx5IERPRVMgaGF2ZSBhIGJvZHksIHdlIHdlcmVuJ3QgZ29pbmcgdG8gZG8gYW55dGhpbmcgd2l0aFxuICAgICAgICAvLyBpdCBhbnl3YXksIGFuZCBpdCdsbCBqdXN0IGJlIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIGhlYWRlci5cbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgPT09ICc1Jykge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtwYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDApO1xuICAgICAgICBpZiAoYnVmLnN1YmFycmF5KG9mZiArIDI1Nywgb2ZmICsgMjY1KS50b1N0cmluZygpID09PVxuICAgICAgICAgICAgJ3VzdGFyXFx1MDAwMDAwJykge1xuICAgICAgICAgICAgdGhpcy51bmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIpO1xuICAgICAgICAgICAgdGhpcy5nbmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICB0aGlzLmRldm1haiA9IGRlY051bWJlcihidWYsIG9mZiArIDMyOSwgOCkgPz8gMDtcbiAgICAgICAgICAgIHRoaXMuZGV2bWluID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzM3LCA4KSA/PyAwO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChidWZbb2ZmICsgNDc1XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaXRlbHkgYSBwcmVmaXgsIGRlZmluaXRlbHkgPjEzMCBjaGFycy5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDE1NSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxMzApO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmF0aW1lID0gZGVjRGF0ZShidWYsIG9mZiArIDQ3NiwgMTIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3RpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDg4LCAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IDggKiAweDIwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBidWZbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gYnVmW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2tzdW1WYWxpZCA9IHN1bSA9PT0gdGhpcy5ja3N1bTtcbiAgICAgICAgaWYgKHRoaXMuY2tzdW0gPT09IHVuZGVmaW5lZCAmJiBzdW0gPT09IDggKiAweDIwKSB7XG4gICAgICAgICAgICB0aGlzLm51bGxCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3NsdXJwKGV4LCBnZXggPSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhleCkuZmlsdGVyKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgICAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuIEFsc28sIGFueVxuICAgICAgICAgICAgLy8gbnVsbC91bmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgICAgICAgICAgcmV0dXJuICEodiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHYgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChrID09PSAncGF0aCcgJiYgZ2V4KSB8fFxuICAgICAgICAgICAgICAgIChrID09PSAnbGlua3BhdGgnICYmIGdleCkgfHxcbiAgICAgICAgICAgICAgICBrID09PSAnZ2xvYmFsJyk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGVuY29kZShidWYsIG9mZiA9IDApIHtcbiAgICAgICAgaWYgKCFidWYpIHtcbiAgICAgICAgICAgIGJ1ZiA9IHRoaXMuYmxvY2sgPSBCdWZmZXIuYWxsb2MoNTEyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jdHlwZSA9PT0gJ1Vuc3VwcG9ydGVkJykge1xuICAgICAgICAgICAgdGhpcy4jdHlwZSA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZCA1MTIgYnl0ZXMgZm9yIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeFNpemUgPSB0aGlzLmN0aW1lIHx8IHRoaXMuYXRpbWUgPyAxMzAgOiAxNTU7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRQcmVmaXgodGhpcy5wYXRoIHx8ICcnLCBwcmVmaXhTaXplKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHNwbGl0WzBdO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzcGxpdFsxXTtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID0gISFzcGxpdFsyXTtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmLCAxMDAsIHBhdGgpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgIGVuY051bWJlcihidWYsIG9mZiArIDEwMCwgOCwgdGhpcy5tb2RlKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDgsIDgsIHRoaXMudWlkKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgsIHRoaXMuZ2lkKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyLCB0aGlzLnNpemUpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyLCB0aGlzLm10aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIGJ1ZltvZmYgKyAxNTZdID0gdGhpcy4jdHlwZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDAsIHRoaXMubGlua3BhdGgpIHx8IHRoaXMubmVlZFBheDtcbiAgICAgICAgYnVmLndyaXRlKCd1c3RhclxcdTAwMDAwMCcsIG9mZiArIDI1NywgOCk7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyLCB0aGlzLnVuYW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyOTcsIDMyLCB0aGlzLmduYW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMjksIDgsIHRoaXMuZGV2bWFqKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgsIHRoaXMuZGV2bWluKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIHByZWZpeFNpemUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4O1xuICAgICAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmVlZFBheCA9XG4gICAgICAgICAgICAgICAgZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZWVkUGF4ID1cbiAgICAgICAgICAgICAgICBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgICAgICB0aGlzLm5lZWRQYXggPVxuICAgICAgICAgICAgICAgIGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1bSA9IDggKiAweDIwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBidWZbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gYnVmW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2tzdW0gPSBzdW07XG4gICAgICAgIGVuY051bWJlcihidWYsIG9mZiArIDE0OCwgOCwgdGhpcy5ja3N1bSk7XG4gICAgICAgIHRoaXMuY2tzdW1WYWxpZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZWRQYXg7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgPT09ICdVbnN1cHBvcnRlZCcgP1xuICAgICAgICAgICAgdGhpcy4jdHlwZVxuICAgICAgICAgICAgOiB0eXBlcy5uYW1lLmdldCh0aGlzLiN0eXBlKSk7XG4gICAgfVxuICAgIGdldCB0eXBlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHlwZTtcbiAgICB9XG4gICAgc2V0IHR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCBjID0gU3RyaW5nKHR5cGVzLmNvZGUuZ2V0KHR5cGUpKTtcbiAgICAgICAgaWYgKHR5cGVzLmlzQ29kZShjKSB8fCBjID09PSAnVW5zdXBwb3J0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLiN0eXBlID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlcy5pc0NvZGUodHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbnRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkhlYWRlciA9IEhlYWRlcjtcbmNvbnN0IHNwbGl0UHJlZml4ID0gKHAsIHByZWZpeFNpemUpID0+IHtcbiAgICBjb25zdCBwYXRoU2l6ZSA9IDEwMDtcbiAgICBsZXQgcHAgPSBwO1xuICAgIGxldCBwcmVmaXggPSAnJztcbiAgICBsZXQgcmV0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJvb3QgPSBub2RlX3BhdGhfMS5wb3NpeC5wYXJzZShwKS5yb290IHx8ICcuJztcbiAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpIHtcbiAgICAgICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHNldCBwcmVmaXggdG8gdGhlIGRpciwgYW5kIHBhdGggdG8gdGhlIGJhc2VcbiAgICAgICAgcHJlZml4ID0gbm9kZV9wYXRoXzEucG9zaXguZGlybmFtZShwcCk7XG4gICAgICAgIHBwID0gbm9kZV9wYXRoXzEucG9zaXguYmFzZW5hbWUocHApO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDw9IHBhdGhTaXplICYmXG4gICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCBmaXQhXG4gICAgICAgICAgICAgICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA+IHBhdGhTaXplICYmXG4gICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlZml4IGZpdHMgaW4gcHJlZml4LCBidXQgcGF0aCBkb2Vzbid0IGZpdCBpbiBwYXRoXG4gICAgICAgICAgICAgICAgcmV0ID0gW3BwLnNsaWNlKDAsIHBhdGhTaXplIC0gMSksIHByZWZpeCwgdHJ1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHBhdGggdGFrZSBhIGJpdCBmcm9tIHByZWZpeFxuICAgICAgICAgICAgICAgIHBwID0gbm9kZV9wYXRoXzEucG9zaXguam9pbihub2RlX3BhdGhfMS5wb3NpeC5iYXNlbmFtZShwcmVmaXgpLCBwcCk7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gbm9kZV9wYXRoXzEucG9zaXguZGlybmFtZShwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChwcmVmaXggIT09IHJvb3QgJiYgcmV0ID09PSB1bmRlZmluZWQpO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBmb3VuZCBubyByZXNvbHV0aW9uLCBqdXN0IHRydW5jYXRlXG4gICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICByZXQgPSBbcC5zbGljZSgwLCBwYXRoU2l6ZSAtIDEpLCAnJywgdHJ1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5jb25zdCBkZWNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUpID0+IGJ1ZlxuICAgIC5zdWJhcnJheShvZmYsIG9mZiArIHNpemUpXG4gICAgLnRvU3RyaW5nKCd1dGY4JylcbiAgICAucmVwbGFjZSgvXFwwLiovLCAnJyk7XG5jb25zdCBkZWNEYXRlID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PiBudW1Ub0RhdGUoZGVjTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplKSk7XG5jb25zdCBudW1Ub0RhdGUgPSAobnVtKSA9PiBudW0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG5ldyBEYXRlKG51bSAqIDEwMDApO1xuY29uc3QgZGVjTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PiBOdW1iZXIoYnVmW29mZl0pICYgMHg4MCA/XG4gICAgbGFyZ2UucGFyc2UoYnVmLnN1YmFycmF5KG9mZiwgb2ZmICsgc2l6ZSkpXG4gICAgOiBkZWNTbWFsbE51bWJlcihidWYsIG9mZiwgc2l6ZSk7XG5jb25zdCBuYW5VbmRlZiA9ICh2YWx1ZSkgPT4gKGlzTmFOKHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbmNvbnN0IGRlY1NtYWxsTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PiBuYW5VbmRlZihwYXJzZUludChidWZcbiAgICAuc3ViYXJyYXkob2ZmLCBvZmYgKyBzaXplKVxuICAgIC50b1N0cmluZygndXRmOCcpXG4gICAgLnJlcGxhY2UoL1xcMC4qJC8sICcnKVxuICAgIC50cmltKCksIDgpKTtcbi8vIHRoZSBtYXhpbXVtIGVuY29kYWJsZSBhcyBhIG51bGwtdGVybWluYXRlZCBvY3RhbCwgYnkgZmllbGQgc2l6ZVxuY29uc3QgTUFYTlVNID0ge1xuICAgIDEyOiAwbzc3Nzc3Nzc3Nzc3LFxuICAgIDg6IDBvNzc3Nzc3Nyxcbn07XG5jb25zdCBlbmNOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUsIG51bSkgPT4gbnVtID09PSB1bmRlZmluZWQgPyBmYWxzZVxuICAgIDogbnVtID4gTUFYTlVNW3NpemVdIHx8IG51bSA8IDAgP1xuICAgICAgICAobGFyZ2UuZW5jb2RlKG51bSwgYnVmLnN1YmFycmF5KG9mZiwgb2ZmICsgc2l6ZSkpLCB0cnVlKVxuICAgICAgICA6IChlbmNTbWFsbE51bWJlcihidWYsIG9mZiwgc2l6ZSwgbnVtKSwgZmFsc2UpO1xuY29uc3QgZW5jU21hbGxOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUsIG51bSkgPT4gYnVmLndyaXRlKG9jdGFsU3RyaW5nKG51bSwgc2l6ZSksIG9mZiwgc2l6ZSwgJ2FzY2lpJyk7XG5jb25zdCBvY3RhbFN0cmluZyA9IChudW0sIHNpemUpID0+IHBhZE9jdGFsKE1hdGguZmxvb3IobnVtKS50b1N0cmluZyg4KSwgc2l6ZSk7XG5jb25zdCBwYWRPY3RhbCA9IChzdHIsIHNpemUpID0+IChzdHIubGVuZ3RoID09PSBzaXplIC0gMSA/XG4gICAgc3RyXG4gICAgOiBuZXcgQXJyYXkoc2l6ZSAtIHN0ci5sZW5ndGggLSAxKS5qb2luKCcwJykgKyBzdHIgKyAnICcpICsgJ1xcMCc7XG5jb25zdCBlbmNEYXRlID0gKGJ1Ziwgb2ZmLCBzaXplLCBkYXRlKSA9PiBkYXRlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChlbmNOdW1iZXIoYnVmLCBvZmYsIHNpemUsIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCkpO1xuLy8gZW5vdWdoIHRvIGZpbGwgdGhlIGxvbmdlc3Qgc3RyaW5nIHdlJ3ZlIGdvdFxuY29uc3QgTlVMTFMgPSBuZXcgQXJyYXkoMTU2KS5qb2luKCdcXDAnKTtcbi8vIHBhZCB3aXRoIG51bGxzLCByZXR1cm4gdHJ1ZSBpZiBpdCdzIGxvbmdlciBvciBub24tYXNjaWlcbmNvbnN0IGVuY1N0cmluZyA9IChidWYsIG9mZiwgc2l6ZSwgc3RyKSA9PiBzdHIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKChidWYud3JpdGUoc3RyICsgTlVMTFMsIG9mZiwgc2l6ZSwgJ3V0ZjgnKSxcbiAgICBzdHIubGVuZ3RoICE9PSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpIHx8IHN0ci5sZW5ndGggPiBzaXplKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/header.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/index.js":
/*!*************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.u = exports.types = exports.r = exports.t = exports.x = exports.c = void 0;\n__exportStar(__webpack_require__(/*! ./create.js */ \"./node_modules/tar/dist/commonjs/create.js\"), exports);\nvar create_js_1 = __webpack_require__(/*! ./create.js */ \"./node_modules/tar/dist/commonjs/create.js\");\nObject.defineProperty(exports, \"c\", ({ enumerable: true, get: function () { return create_js_1.create; } }));\n__exportStar(__webpack_require__(/*! ./extract.js */ \"./node_modules/tar/dist/commonjs/extract.js\"), exports);\nvar extract_js_1 = __webpack_require__(/*! ./extract.js */ \"./node_modules/tar/dist/commonjs/extract.js\");\nObject.defineProperty(exports, \"x\", ({ enumerable: true, get: function () { return extract_js_1.extract; } }));\n__exportStar(__webpack_require__(/*! ./header.js */ \"./node_modules/tar/dist/commonjs/header.js\"), exports);\n__exportStar(__webpack_require__(/*! ./list.js */ \"./node_modules/tar/dist/commonjs/list.js\"), exports);\nvar list_js_1 = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/dist/commonjs/list.js\");\nObject.defineProperty(exports, \"t\", ({ enumerable: true, get: function () { return list_js_1.list; } }));\n// classes\n__exportStar(__webpack_require__(/*! ./pack.js */ \"./node_modules/tar/dist/commonjs/pack.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parse.js */ \"./node_modules/tar/dist/commonjs/parse.js\"), exports);\n__exportStar(__webpack_require__(/*! ./pax.js */ \"./node_modules/tar/dist/commonjs/pax.js\"), exports);\n__exportStar(__webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/dist/commonjs/read-entry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./replace.js */ \"./node_modules/tar/dist/commonjs/replace.js\"), exports);\nvar replace_js_1 = __webpack_require__(/*! ./replace.js */ \"./node_modules/tar/dist/commonjs/replace.js\");\nObject.defineProperty(exports, \"r\", ({ enumerable: true, get: function () { return replace_js_1.replace; } }));\nexports.types = __importStar(__webpack_require__(/*! ./types.js */ \"./node_modules/tar/dist/commonjs/types.js\"));\n__exportStar(__webpack_require__(/*! ./unpack.js */ \"./node_modules/tar/dist/commonjs/unpack.js\"), exports);\n__exportStar(__webpack_require__(/*! ./update.js */ \"./node_modules/tar/dist/commonjs/update.js\"), exports);\nvar update_js_1 = __webpack_require__(/*! ./update.js */ \"./node_modules/tar/dist/commonjs/update.js\");\nObject.defineProperty(exports, \"u\", ({ enumerable: true, get: function () { return update_js_1.update; } }));\n__exportStar(__webpack_require__(/*! ./write-entry.js */ \"./node_modules/tar/dist/commonjs/write-entry.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsR0FBRyxhQUFhLEdBQUcsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUztBQUN6RSxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsK0RBQWE7QUFDdkMscUNBQW9DLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQzFHLGFBQWEsbUJBQU8sQ0FBQyxpRUFBYztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN6QyxxQ0FBb0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDNUcsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVztBQUNuQyxxQ0FBb0MsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDdEc7QUFDQSxhQUFhLG1CQUFPLENBQUMsMkRBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDZEQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyx5REFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsdUVBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxpRUFBYztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN6QyxxQ0FBb0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDNUcsYUFBYSxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBWTtBQUNqRCxhQUFhLG1CQUFPLENBQUMsK0RBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3ZDLHFDQUFvQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMxRyxhQUFhLG1CQUFPLENBQUMseUVBQWtCO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvaW5kZXguanM/MjA5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudSA9IGV4cG9ydHMudHlwZXMgPSBleHBvcnRzLnIgPSBleHBvcnRzLnQgPSBleHBvcnRzLnggPSBleHBvcnRzLmMgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlLmpzXCIpLCBleHBvcnRzKTtcbnZhciBjcmVhdGVfanNfMSA9IHJlcXVpcmUoXCIuL2NyZWF0ZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZV9qc18xLmNyZWF0ZTsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHRyYWN0LmpzXCIpLCBleHBvcnRzKTtcbnZhciBleHRyYWN0X2pzXzEgPSByZXF1aXJlKFwiLi9leHRyYWN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwieFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXh0cmFjdF9qc18xLmV4dHJhY3Q7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGVhZGVyLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saXN0LmpzXCIpLCBleHBvcnRzKTtcbnZhciBsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi9saXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdF9qc18xLmxpc3Q7IH0gfSk7XG4vLyBjbGFzc2VzXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFjay5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2UuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BheC5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVhZC1lbnRyeS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVwbGFjZS5qc1wiKSwgZXhwb3J0cyk7XG52YXIgcmVwbGFjZV9qc18xID0gcmVxdWlyZShcIi4vcmVwbGFjZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcGxhY2VfanNfMS5yZXBsYWNlOyB9IH0pO1xuZXhwb3J0cy50eXBlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy5qc1wiKSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdW5wYWNrLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91cGRhdGUuanNcIiksIGV4cG9ydHMpO1xudmFyIHVwZGF0ZV9qc18xID0gcmVxdWlyZShcIi4vdXBkYXRlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlX2pzXzEudXBkYXRlOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dyaXRlLWVudHJ5LmpzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/large-numbers.js":
/*!*********************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/large-numbers.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = exports.encode = void 0;\nconst encode = (num, buf) => {\n    if (!Number.isSafeInteger(num)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('cannot encode number outside of javascript safe integer range');\n    }\n    else if (num < 0) {\n        encodeNegative(num, buf);\n    }\n    else {\n        encodePositive(num, buf);\n    }\n    return buf;\n};\nexports.encode = encode;\nconst encodePositive = (num, buf) => {\n    buf[0] = 0x80;\n    for (var i = buf.length; i > 1; i--) {\n        buf[i - 1] = num & 0xff;\n        num = Math.floor(num / 0x100);\n    }\n};\nconst encodeNegative = (num, buf) => {\n    buf[0] = 0xff;\n    var flipped = false;\n    num = num * -1;\n    for (var i = buf.length; i > 1; i--) {\n        var byte = num & 0xff;\n        num = Math.floor(num / 0x100);\n        if (flipped) {\n            buf[i - 1] = onesComp(byte);\n        }\n        else if (byte === 0) {\n            buf[i - 1] = 0;\n        }\n        else {\n            flipped = true;\n            buf[i - 1] = twosComp(byte);\n        }\n    }\n};\nconst parse = (buf) => {\n    const pre = buf[0];\n    const value = pre === 0x80 ? pos(buf.subarray(1, buf.length))\n        : pre === 0xff ? twos(buf)\n            : null;\n    if (value === null) {\n        throw Error('invalid base256 encoding');\n    }\n    if (!Number.isSafeInteger(value)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('parsed number outside of javascript safe integer range');\n    }\n    return value;\n};\nexports.parse = parse;\nconst twos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    var flipped = false;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        var f;\n        if (flipped) {\n            f = onesComp(byte);\n        }\n        else if (byte === 0) {\n            f = byte;\n        }\n        else {\n            flipped = true;\n            f = twosComp(byte);\n        }\n        if (f !== 0) {\n            sum -= f * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst pos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        if (byte !== 0) {\n            sum += byte * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst onesComp = (byte) => (0xff ^ byte) & 0xff;\nconst twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;\n//# sourceMappingURL=large-numbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbGFyZ2UtbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL2xhcmdlLW51bWJlcnMuanM/ZDZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRhciBjYW4gZW5jb2RlIGxhcmdlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIHVzaW5nIGEgbGVhZGluZyBieXRlIG9mXG4vLyAweGZmIGZvciBuZWdhdGl2ZSwgYW5kIDB4ODAgZm9yIHBvc2l0aXZlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgZW5jb2RlID0gKG51bSwgYnVmKSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIC8vIFRoZSBudW1iZXIgaXMgc28gbGFyZ2UgdGhhdCBqYXZhc2NyaXB0IGNhbm5vdCByZXByZXNlbnQgaXQgd2l0aCBpbnRlZ2VyXG4gICAgICAgIC8vIHByZWNpc2lvbi5cbiAgICAgICAgdGhyb3cgRXJyb3IoJ2Nhbm5vdCBlbmNvZGUgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobnVtIDwgMCkge1xuICAgICAgICBlbmNvZGVOZWdhdGl2ZShudW0sIGJ1Zik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmNvZGVQb3NpdGl2ZShudW0sIGJ1Zik7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5jb25zdCBlbmNvZGVQb3NpdGl2ZSA9IChudW0sIGJ1ZikgPT4ge1xuICAgIGJ1ZlswXSA9IDB4ODA7XG4gICAgZm9yICh2YXIgaSA9IGJ1Zi5sZW5ndGg7IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgYnVmW2kgLSAxXSA9IG51bSAmIDB4ZmY7XG4gICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApO1xuICAgIH1cbn07XG5jb25zdCBlbmNvZGVOZWdhdGl2ZSA9IChudW0sIGJ1ZikgPT4ge1xuICAgIGJ1ZlswXSA9IDB4ZmY7XG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcbiAgICBudW0gPSBudW0gKiAtMTtcbiAgICBmb3IgKHZhciBpID0gYnVmLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgICAgICB2YXIgYnl0ZSA9IG51bSAmIDB4ZmY7XG4gICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApO1xuICAgICAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgICAgICAgYnVmW2kgLSAxXSA9IG9uZXNDb21wKGJ5dGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGUgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZltpIC0gMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBidWZbaSAtIDFdID0gdHdvc0NvbXAoYnl0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcGFyc2UgPSAoYnVmKSA9PiB7XG4gICAgY29uc3QgcHJlID0gYnVmWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gcHJlID09PSAweDgwID8gcG9zKGJ1Zi5zdWJhcnJheSgxLCBidWYubGVuZ3RoKSlcbiAgICAgICAgOiBwcmUgPT09IDB4ZmYgPyB0d29zKGJ1ZilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2ludmFsaWQgYmFzZTI1NiBlbmNvZGluZycpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAvLyBUaGUgbnVtYmVyIGlzIHNvIGxhcmdlIHRoYXQgamF2YXNjcmlwdCBjYW5ub3QgcmVwcmVzZW50IGl0IHdpdGggaW50ZWdlclxuICAgICAgICAvLyBwcmVjaXNpb24uXG4gICAgICAgIHRocm93IEVycm9yKCdwYXJzZWQgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmNvbnN0IHR3b3MgPSAoYnVmKSA9PiB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBOdW1iZXIoYnVmW2ldKTtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICAgICAgICBmID0gb25lc0NvbXAoYnl0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZiA9IGJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGYgPSB0d29zQ29tcChieXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAhPT0gMCkge1xuICAgICAgICAgICAgc3VtIC09IGYgKiBNYXRoLnBvdygyNTYsIGxlbiAtIGkgLSAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufTtcbmNvbnN0IHBvcyA9IChidWYpID0+IHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgdmFyIGJ5dGUgPSBOdW1iZXIoYnVmW2ldKTtcbiAgICAgICAgaWYgKGJ5dGUgIT09IDApIHtcbiAgICAgICAgICAgIHN1bSArPSBieXRlICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn07XG5jb25zdCBvbmVzQ29tcCA9IChieXRlKSA9PiAoMHhmZiBeIGJ5dGUpICYgMHhmZjtcbmNvbnN0IHR3b3NDb21wID0gKGJ5dGUpID0+ICgoMHhmZiBeIGJ5dGUpICsgMSkgJiAweGZmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFyZ2UtbnVtYmVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/large-numbers.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/list.js":
/*!************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/list.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.list = exports.filesFilter = void 0;\n// tar -t\nconst fsm = __importStar(__webpack_require__(/*! @isaacs/fs-minipass */ \"./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\"));\nconst node_fs_1 = __importDefault(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst make_command_js_1 = __webpack_require__(/*! ./make-command.js */ \"./node_modules/tar/dist/commonjs/make-command.js\");\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/dist/commonjs/parse.js\");\nconst strip_trailing_slashes_js_1 = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/dist/commonjs/strip-trailing-slashes.js\");\nconst onReadEntryFunction = (opt) => {\n    const onReadEntry = opt.onReadEntry;\n    opt.onReadEntry =\n        onReadEntry ?\n            e => {\n                onReadEntry(e);\n                e.resume();\n            }\n            : e => e.resume();\n};\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n    const map = new Map(files.map(f => [(0, strip_trailing_slashes_js_1.stripTrailingSlashes)(f), true]));\n    const filter = opt.filter;\n    const mapHas = (file, r = '') => {\n        const root = r || (0, path_1.parse)(file).root || '.';\n        let ret;\n        if (file === root)\n            ret = false;\n        else {\n            const m = map.get(file);\n            if (m !== undefined) {\n                ret = m;\n            }\n            else {\n                ret = mapHas((0, path_1.dirname)(file), root);\n            }\n        }\n        map.set(file, ret);\n        return ret;\n    };\n    opt.filter =\n        filter ?\n            (file, entry) => filter(file, entry) && mapHas((0, strip_trailing_slashes_js_1.stripTrailingSlashes)(file))\n            : file => mapHas((0, strip_trailing_slashes_js_1.stripTrailingSlashes)(file));\n};\nexports.filesFilter = filesFilter;\nconst listFileSync = (opt) => {\n    const p = new parse_js_1.Parser(opt);\n    const file = opt.file;\n    let fd;\n    try {\n        const stat = node_fs_1.default.statSync(file);\n        const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n        if (stat.size < readSize) {\n            p.end(node_fs_1.default.readFileSync(file));\n        }\n        else {\n            let pos = 0;\n            const buf = Buffer.allocUnsafe(readSize);\n            fd = node_fs_1.default.openSync(file, 'r');\n            while (pos < stat.size) {\n                const bytesRead = node_fs_1.default.readSync(fd, buf, 0, readSize, pos);\n                pos += bytesRead;\n                p.write(buf.subarray(0, bytesRead));\n            }\n            p.end();\n        }\n    }\n    finally {\n        if (typeof fd === 'number') {\n            try {\n                node_fs_1.default.closeSync(fd);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n    }\n};\nconst listFile = (opt, _files) => {\n    const parse = new parse_js_1.Parser(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        parse.on('error', reject);\n        parse.on('end', resolve);\n        node_fs_1.default.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(parse);\n            }\n        });\n    });\n    return p;\n};\nexports.list = (0, make_command_js_1.makeCommand)(listFileSync, listFile, opt => new parse_js_1.Parser(opt), opt => new parse_js_1.Parser(opt), (opt, files) => {\n    if (files?.length)\n        (0, exports.filesFilter)(opt, files);\n    if (!opt.noResume)\n        onReadEntryFunction(opt);\n});\n//# sourceMappingURL=list.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsbUJBQW1CO0FBQ2xDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3RELGtDQUFrQyxtQkFBTyxDQUFDLHdCQUFTO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVk7QUFDdkMsb0NBQW9DLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbGlzdC5qcz84YTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxpc3QgPSBleHBvcnRzLmZpbGVzRmlsdGVyID0gdm9pZCAwO1xuLy8gdGFyIC10XG5jb25zdCBmc20gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBpc2FhY3MvZnMtbWluaXBhc3NcIikpO1xuY29uc3Qgbm9kZV9mc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOmZzXCIpKTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgbWFrZV9jb21tYW5kX2pzXzEgPSByZXF1aXJlKFwiLi9tYWtlLWNvbW1hbmQuanNcIik7XG5jb25zdCBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5jb25zdCBzdHJpcF90cmFpbGluZ19zbGFzaGVzX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzXCIpO1xuY29uc3Qgb25SZWFkRW50cnlGdW5jdGlvbiA9IChvcHQpID0+IHtcbiAgICBjb25zdCBvblJlYWRFbnRyeSA9IG9wdC5vblJlYWRFbnRyeTtcbiAgICBvcHQub25SZWFkRW50cnkgPVxuICAgICAgICBvblJlYWRFbnRyeSA/XG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICBvblJlYWRFbnRyeShlKTtcbiAgICAgICAgICAgICAgICBlLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBlID0+IGUucmVzdW1lKCk7XG59O1xuLy8gY29uc3RydWN0IGEgZmlsdGVyIHRoYXQgbGltaXRzIHRoZSBmaWxlIGVudHJpZXMgbGlzdGVkXG4vLyBpbmNsdWRlIGNoaWxkIGVudHJpZXMgaWYgYSBkaXIgaXMgaW5jbHVkZWRcbmNvbnN0IGZpbGVzRmlsdGVyID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKGZpbGVzLm1hcChmID0+IFsoMCwgc3RyaXBfdHJhaWxpbmdfc2xhc2hlc19qc18xLnN0cmlwVHJhaWxpbmdTbGFzaGVzKShmKSwgdHJ1ZV0pKTtcbiAgICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyO1xuICAgIGNvbnN0IG1hcEhhcyA9IChmaWxlLCByID0gJycpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHIgfHwgKDAsIHBhdGhfMS5wYXJzZSkoZmlsZSkucm9vdCB8fCAnLic7XG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGlmIChmaWxlID09PSByb290KVxuICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbSA9IG1hcC5nZXQoZmlsZSk7XG4gICAgICAgICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IG1hcEhhcygoMCwgcGF0aF8xLmRpcm5hbWUpKGZpbGUpLCByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGZpbGUsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICBvcHQuZmlsdGVyID1cbiAgICAgICAgZmlsdGVyID9cbiAgICAgICAgICAgIChmaWxlLCBlbnRyeSkgPT4gZmlsdGVyKGZpbGUsIGVudHJ5KSAmJiBtYXBIYXMoKDAsIHN0cmlwX3RyYWlsaW5nX3NsYXNoZXNfanNfMS5zdHJpcFRyYWlsaW5nU2xhc2hlcykoZmlsZSkpXG4gICAgICAgICAgICA6IGZpbGUgPT4gbWFwSGFzKCgwLCBzdHJpcF90cmFpbGluZ19zbGFzaGVzX2pzXzEuc3RyaXBUcmFpbGluZ1NsYXNoZXMpKGZpbGUpKTtcbn07XG5leHBvcnRzLmZpbGVzRmlsdGVyID0gZmlsZXNGaWx0ZXI7XG5jb25zdCBsaXN0RmlsZVN5bmMgPSAob3B0KSA9PiB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZV9qc18xLlBhcnNlcihvcHQpO1xuICAgIGNvbnN0IGZpbGUgPSBvcHQuZmlsZTtcbiAgICBsZXQgZmQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IG5vZGVfZnNfMS5kZWZhdWx0LnN0YXRTeW5jKGZpbGUpO1xuICAgICAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0O1xuICAgICAgICBpZiAoc3RhdC5zaXplIDwgcmVhZFNpemUpIHtcbiAgICAgICAgICAgIHAuZW5kKG5vZGVfZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luYyhmaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShyZWFkU2l6ZSk7XG4gICAgICAgICAgICBmZCA9IG5vZGVfZnNfMS5kZWZhdWx0Lm9wZW5TeW5jKGZpbGUsICdyJyk7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RhdC5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gbm9kZV9mc18xLmRlZmF1bHQucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgcmVhZFNpemUsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICBwLndyaXRlKGJ1Zi5zdWJhcnJheSgwLCBieXRlc1JlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbGlzdEZpbGUgPSAob3B0LCBfZmlsZXMpID0+IHtcbiAgICBjb25zdCBwYXJzZSA9IG5ldyBwYXJzZV9qc18xLlBhcnNlcihvcHQpO1xuICAgIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjQ7XG4gICAgY29uc3QgZmlsZSA9IG9wdC5maWxlO1xuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHBhcnNlLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIHBhcnNlLm9uKCdlbmQnLCByZXNvbHZlKTtcbiAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQuc3RhdChmaWxlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgICAgICAgICAgICByZWFkU2l6ZTogcmVhZFNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHN0YXQuc2l6ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucGlwZShwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcbmV4cG9ydHMubGlzdCA9ICgwLCBtYWtlX2NvbW1hbmRfanNfMS5tYWtlQ29tbWFuZCkobGlzdEZpbGVTeW5jLCBsaXN0RmlsZSwgb3B0ID0+IG5ldyBwYXJzZV9qc18xLlBhcnNlcihvcHQpLCBvcHQgPT4gbmV3IHBhcnNlX2pzXzEuUGFyc2VyKG9wdCksIChvcHQsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGZpbGVzPy5sZW5ndGgpXG4gICAgICAgICgwLCBleHBvcnRzLmZpbGVzRmlsdGVyKShvcHQsIGZpbGVzKTtcbiAgICBpZiAoIW9wdC5ub1Jlc3VtZSlcbiAgICAgICAgb25SZWFkRW50cnlGdW5jdGlvbihvcHQpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/list.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/make-command.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/make-command.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeCommand = void 0;\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"./node_modules/tar/dist/commonjs/options.js\");\nconst makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {\n    return Object.assign((opt_ = [], entries, cb) => {\n        if (Array.isArray(opt_)) {\n            entries = opt_;\n            opt_ = {};\n        }\n        if (typeof entries === 'function') {\n            cb = entries;\n            entries = undefined;\n        }\n        if (!entries) {\n            entries = [];\n        }\n        else {\n            entries = Array.from(entries);\n        }\n        const opt = (0, options_js_1.dealias)(opt_);\n        validate?.(opt, entries);\n        if ((0, options_js_1.isSyncFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncFile(opt, entries);\n        }\n        else if ((0, options_js_1.isAsyncFile)(opt)) {\n            const p = asyncFile(opt, entries);\n            // weirdness to make TS happy\n            const c = cb ? cb : undefined;\n            return c ? p.then(() => c(), c) : p;\n        }\n        else if ((0, options_js_1.isSyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncNoFile(opt, entries);\n        }\n        else if ((0, options_js_1.isAsyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback only supported with file option');\n            }\n            return asyncNoFile(opt, entries);\n            /* c8 ignore start */\n        }\n        else {\n            throw new Error('impossible options??');\n        }\n        /* c8 ignore stop */\n    }, {\n        syncFile,\n        asyncFile,\n        syncNoFile,\n        asyncNoFile,\n        validate,\n    });\n};\nexports.makeCommand = makeCommand;\n//# sourceMappingURL=make-command.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbWFrZS1jb21tYW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9tYWtlLWNvbW1hbmQuanM/NzkzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZUNvbW1hbmQgPSB2b2lkIDA7XG5jb25zdCBvcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xuY29uc3QgbWFrZUNvbW1hbmQgPSAoc3luY0ZpbGUsIGFzeW5jRmlsZSwgc3luY05vRmlsZSwgYXN5bmNOb0ZpbGUsIHZhbGlkYXRlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKG9wdF8gPSBbXSwgZW50cmllcywgY2IpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSBvcHRfO1xuICAgICAgICAgICAgb3B0XyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbnRyaWVzO1xuICAgICAgICAgICAgZW50cmllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudHJpZXMpIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSBBcnJheS5mcm9tKGVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9ICgwLCBvcHRpb25zX2pzXzEuZGVhbGlhcykob3B0Xyk7XG4gICAgICAgIHZhbGlkYXRlPy4ob3B0LCBlbnRyaWVzKTtcbiAgICAgICAgaWYgKCgwLCBvcHRpb25zX2pzXzEuaXNTeW5jRmlsZSkob3B0KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bmNGaWxlKG9wdCwgZW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIG9wdGlvbnNfanNfMS5pc0FzeW5jRmlsZSkob3B0KSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IGFzeW5jRmlsZShvcHQsIGVudHJpZXMpO1xuICAgICAgICAgICAgLy8gd2VpcmRuZXNzIHRvIG1ha2UgVFMgaGFwcHlcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjYiA/IGNiIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGMgPyBwLnRoZW4oKCkgPT4gYygpLCBjKSA6IHA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIG9wdGlvbnNfanNfMS5pc1N5bmNOb0ZpbGUpKG9wdCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBub3Qgc3VwcG9ydGVkIGZvciBzeW5jIHRhciBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzeW5jTm9GaWxlKG9wdCwgZW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIG9wdGlvbnNfanNfMS5pc0FzeW5jTm9GaWxlKShvcHQpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgb25seSBzdXBwb3J0ZWQgd2l0aCBmaWxlIG9wdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzeW5jTm9GaWxlKG9wdCwgZW50cmllcyk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3NzaWJsZSBvcHRpb25zPz8nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH0sIHtcbiAgICAgICAgc3luY0ZpbGUsXG4gICAgICAgIGFzeW5jRmlsZSxcbiAgICAgICAgc3luY05vRmlsZSxcbiAgICAgICAgYXN5bmNOb0ZpbGUsXG4gICAgICAgIHZhbGlkYXRlLFxuICAgIH0pO1xufTtcbmV4cG9ydHMubWFrZUNvbW1hbmQgPSBtYWtlQ29tbWFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtY29tbWFuZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/make-command.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/mkdir.js":
/*!*************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/mkdir.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mkdirSync = exports.mkdir = void 0;\nconst chownr_1 = __webpack_require__(/*! chownr */ \"./node_modules/tar/node_modules/chownr/dist/commonjs/index.js\");\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst mkdirp_1 = __webpack_require__(/*! mkdirp */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/index.js\");\nconst node_path_1 = __importDefault(__webpack_require__(/*! node:path */ \"node:path\"));\nconst cwd_error_js_1 = __webpack_require__(/*! ./cwd-error.js */ \"./node_modules/tar/dist/commonjs/cwd-error.js\");\nconst normalize_windows_path_js_1 = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/dist/commonjs/normalize-windows-path.js\");\nconst symlink_error_js_1 = __webpack_require__(/*! ./symlink-error.js */ \"./node_modules/tar/dist/commonjs/symlink-error.js\");\nconst cGet = (cache, key) => cache.get((0, normalize_windows_path_js_1.normalizeWindowsPath)(key));\nconst cSet = (cache, key, val) => cache.set((0, normalize_windows_path_js_1.normalizeWindowsPath)(key), val);\nconst checkCwd = (dir, cb) => {\n    fs_1.default.stat(dir, (er, st) => {\n        if (er || !st.isDirectory()) {\n            er = new cwd_error_js_1.CwdError(dir, er?.code || 'ENOTDIR');\n        }\n        cb(er);\n    });\n};\n/**\n * Wrapper around mkdirp for tar's needs.\n *\n * The main purpose is to avoid creating directories if we know that\n * they already exist (and track which ones exist for this purpose),\n * and prevent entries from being extracted into symlinked folders,\n * if `preservePaths` is not set.\n */\nconst mkdir = (dir, opt, cb) => {\n    dir = (0, normalize_windows_path_js_1.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o0700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd);\n    const done = (er, created) => {\n        if (er) {\n            cb(er);\n        }\n        else {\n            cSet(cache, dir, true);\n            if (created && doChown) {\n                (0, chownr_1.chownr)(created, uid, gid, er => done(er));\n            }\n            else if (needChmod) {\n                fs_1.default.chmod(dir, mode, cb);\n            }\n            else {\n                cb();\n            }\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        return checkCwd(dir, done);\n    }\n    if (preserve) {\n        return (0, mkdirp_1.mkdirp)(dir, { mode }).then(made => done(null, made ?? undefined), // oh, ts\n        done);\n    }\n    const sub = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.relative(cwd, dir));\n    const parts = sub.split('/');\n    mkdir_(cwd, parts, mode, cache, unlink, cwd, undefined, done);\n};\nexports.mkdir = mkdir;\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n    if (!parts.length) {\n        return cb(null, created);\n    }\n    const p = parts.shift();\n    const part = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(base + '/' + p));\n    if (cGet(cache, part)) {\n        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n    fs_1.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {\n    if (er) {\n        fs_1.default.lstat(part, (statEr, st) => {\n            if (statEr) {\n                statEr.path =\n                    statEr.path && (0, normalize_windows_path_js_1.normalizeWindowsPath)(statEr.path);\n                cb(statEr);\n            }\n            else if (st.isDirectory()) {\n                mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n            }\n            else if (unlink) {\n                fs_1.default.unlink(part, er => {\n                    if (er) {\n                        return cb(er);\n                    }\n                    fs_1.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n                });\n            }\n            else if (st.isSymbolicLink()) {\n                return cb(new symlink_error_js_1.SymlinkError(part, part + '/' + parts.join('/')));\n            }\n            else {\n                cb(er);\n            }\n        });\n    }\n    else {\n        created = created || part;\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n};\nconst checkCwdSync = (dir) => {\n    let ok = false;\n    let code = undefined;\n    try {\n        ok = fs_1.default.statSync(dir).isDirectory();\n    }\n    catch (er) {\n        code = er?.code;\n    }\n    finally {\n        if (!ok) {\n            throw new cwd_error_js_1.CwdError(dir, code ?? 'ENOTDIR');\n        }\n    }\n};\nconst mkdirSync = (dir, opt) => {\n    dir = (0, normalize_windows_path_js_1.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd);\n    const done = (created) => {\n        cSet(cache, dir, true);\n        if (created && doChown) {\n            (0, chownr_1.chownrSync)(created, uid, gid);\n        }\n        if (needChmod) {\n            fs_1.default.chmodSync(dir, mode);\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        checkCwdSync(cwd);\n        return done();\n    }\n    if (preserve) {\n        return done((0, mkdirp_1.mkdirpSync)(dir, mode) ?? undefined);\n    }\n    const sub = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.relative(cwd, dir));\n    const parts = sub.split('/');\n    let created = undefined;\n    for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n        part = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(part));\n        if (cGet(cache, part)) {\n            continue;\n        }\n        try {\n            fs_1.default.mkdirSync(part, mode);\n            created = created || part;\n            cSet(cache, part, true);\n        }\n        catch (er) {\n            const st = fs_1.default.lstatSync(part);\n            if (st.isDirectory()) {\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (unlink) {\n                fs_1.default.unlinkSync(part);\n                fs_1.default.mkdirSync(part, mode);\n                created = created || part;\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (st.isSymbolicLink()) {\n                return new symlink_error_js_1.SymlinkError(part, part + '/' + parts.join('/'));\n            }\n        }\n    }\n    return done(created);\n};\nexports.mkdirSync = mkdirSync;\n//# sourceMappingURL=mkdir.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbWtkaXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxhQUFhO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFRO0FBQ2pDLDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVE7QUFDakMsb0NBQW9DLG1CQUFPLENBQUMsNEJBQVc7QUFDdkQsdUJBQXVCLG1CQUFPLENBQUMscUVBQWdCO0FBQy9DLG9DQUFvQyxtQkFBTyxDQUFDLCtGQUE2QjtBQUN6RSwyQkFBMkIsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL21rZGlyLmpzPzY1ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1rZGlyU3luYyA9IGV4cG9ydHMubWtkaXIgPSB2b2lkIDA7XG5jb25zdCBjaG93bnJfMSA9IHJlcXVpcmUoXCJjaG93bnJcIik7XG5jb25zdCBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBta2RpcnBfMSA9IHJlcXVpcmUoXCJta2RpcnBcIik7XG5jb25zdCBub2RlX3BhdGhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpwYXRoXCIpKTtcbmNvbnN0IGN3ZF9lcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY3dkLWVycm9yLmpzXCIpO1xuY29uc3Qgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qc1wiKTtcbmNvbnN0IHN5bWxpbmtfZXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuL3N5bWxpbmstZXJyb3IuanNcIik7XG5jb25zdCBjR2V0ID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmdldCgoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShrZXkpKTtcbmNvbnN0IGNTZXQgPSAoY2FjaGUsIGtleSwgdmFsKSA9PiBjYWNoZS5zZXQoKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkoa2V5KSwgdmFsKTtcbmNvbnN0IGNoZWNrQ3dkID0gKGRpciwgY2IpID0+IHtcbiAgICBmc18xLmRlZmF1bHQuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICAgICAgaWYgKGVyIHx8ICFzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBlciA9IG5ldyBjd2RfZXJyb3JfanNfMS5Dd2RFcnJvcihkaXIsIGVyPy5jb2RlIHx8ICdFTk9URElSJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoZXIpO1xuICAgIH0pO1xufTtcbi8qKlxuICogV3JhcHBlciBhcm91bmQgbWtkaXJwIGZvciB0YXIncyBuZWVkcy5cbiAqXG4gKiBUaGUgbWFpbiBwdXJwb3NlIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGRpcmVjdG9yaWVzIGlmIHdlIGtub3cgdGhhdFxuICogdGhleSBhbHJlYWR5IGV4aXN0IChhbmQgdHJhY2sgd2hpY2ggb25lcyBleGlzdCBmb3IgdGhpcyBwdXJwb3NlKSxcbiAqIGFuZCBwcmV2ZW50IGVudHJpZXMgZnJvbSBiZWluZyBleHRyYWN0ZWQgaW50byBzeW1saW5rZWQgZm9sZGVycyxcbiAqIGlmIGBwcmVzZXJ2ZVBhdGhzYCBpcyBub3Qgc2V0LlxuICovXG5jb25zdCBta2RpciA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgICBkaXIgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShkaXIpO1xuICAgIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAgIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2sgPz8gMG8yMjtcbiAgICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDA7XG4gICAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDA7XG4gICAgY29uc3QgdWlkID0gb3B0LnVpZDtcbiAgICBjb25zdCBnaWQgPSBvcHQuZ2lkO1xuICAgIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZ2lkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAodWlkICE9PSBvcHQucHJvY2Vzc1VpZCB8fCBnaWQgIT09IG9wdC5wcm9jZXNzR2lkKTtcbiAgICBjb25zdCBwcmVzZXJ2ZSA9IG9wdC5wcmVzZXJ2ZTtcbiAgICBjb25zdCB1bmxpbmsgPSBvcHQudW5saW5rO1xuICAgIGNvbnN0IGNhY2hlID0gb3B0LmNhY2hlO1xuICAgIGNvbnN0IGN3ZCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG9wdC5jd2QpO1xuICAgIGNvbnN0IGRvbmUgPSAoZXIsIGNyZWF0ZWQpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBjYihlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjU2V0KGNhY2hlLCBkaXIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bikge1xuICAgICAgICAgICAgICAgICgwLCBjaG93bnJfMS5jaG93bnIpKGNyZWF0ZWQsIHVpZCwgZ2lkLCBlciA9PiBkb25lKGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkQ2htb2QpIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuY2htb2QoZGlyLCBtb2RlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoY2FjaGUgJiYgY0dldChjYWNoZSwgZGlyKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ3dkKGRpciwgZG9uZSk7XG4gICAgfVxuICAgIGlmIChwcmVzZXJ2ZSkge1xuICAgICAgICByZXR1cm4gKDAsIG1rZGlycF8xLm1rZGlycCkoZGlyLCB7IG1vZGUgfSkudGhlbihtYWRlID0+IGRvbmUobnVsbCwgbWFkZSA/PyB1bmRlZmluZWQpLCAvLyBvaCwgdHNcbiAgICAgICAgZG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YiA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG5vZGVfcGF0aF8xLmRlZmF1bHQucmVsYXRpdmUoY3dkLCBkaXIpKTtcbiAgICBjb25zdCBwYXJ0cyA9IHN1Yi5zcGxpdCgnLycpO1xuICAgIG1rZGlyXyhjd2QsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIHVuZGVmaW5lZCwgZG9uZSk7XG59O1xuZXhwb3J0cy5ta2RpciA9IG1rZGlyO1xuY29uc3QgbWtkaXJfID0gKGJhc2UsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSA9PiB7XG4gICAgaWYgKCFwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGNyZWF0ZWQpO1xuICAgIH1cbiAgICBjb25zdCBwID0gcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCBwYXJ0ID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkobm9kZV9wYXRoXzEuZGVmYXVsdC5yZXNvbHZlKGJhc2UgKyAnLycgKyBwKSk7XG4gICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKSB7XG4gICAgICAgIHJldHVybiBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpO1xuICAgIH1cbiAgICBmc18xLmRlZmF1bHQubWtkaXIocGFydCwgbW9kZSwgb25ta2RpcihwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikpO1xufTtcbmNvbnN0IG9ubWtkaXIgPSAocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IChlcikgPT4ge1xuICAgIGlmIChlcikge1xuICAgICAgICBmc18xLmRlZmF1bHQubHN0YXQocGFydCwgKHN0YXRFciwgc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0RXIpIHtcbiAgICAgICAgICAgICAgICBzdGF0RXIucGF0aCA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRFci5wYXRoICYmICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKHN0YXRFci5wYXRoKTtcbiAgICAgICAgICAgICAgICBjYihzdGF0RXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rKHBhcnQsIGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5ta2RpcihwYXJ0LCBtb2RlLCBvbm1rZGlyKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBzeW1saW5rX2Vycm9yX2pzXzEuU3ltbGlua0Vycm9yKHBhcnQsIHBhcnQgKyAnLycgKyBwYXJ0cy5qb2luKCcvJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjcmVhdGVkID0gY3JlYXRlZCB8fCBwYXJ0O1xuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpO1xuICAgIH1cbn07XG5jb25zdCBjaGVja0N3ZFN5bmMgPSAoZGlyKSA9PiB7XG4gICAgbGV0IG9rID0gZmFsc2U7XG4gICAgbGV0IGNvZGUgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgb2sgPSBmc18xLmRlZmF1bHQuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgY29kZSA9IGVyPy5jb2RlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGN3ZF9lcnJvcl9qc18xLkN3ZEVycm9yKGRpciwgY29kZSA/PyAnRU5PVERJUicpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG1rZGlyU3luYyA9IChkaXIsIG9wdCkgPT4ge1xuICAgIGRpciA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKGRpcik7XG4gICAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gICAgLy8gdGhlbiB3ZSdsbCBuZWVkIGFuIGV4cGxpY2l0IGNobW9kXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB1bWFzayA9IG9wdC51bWFzayA/PyAwbzIyO1xuICAgIGNvbnN0IG1vZGUgPSBvcHQubW9kZSB8IDBvNzAwO1xuICAgIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwO1xuICAgIGNvbnN0IHVpZCA9IG9wdC51aWQ7XG4gICAgY29uc3QgZ2lkID0gb3B0LmdpZDtcbiAgICBjb25zdCBkb0Nob3duID0gdHlwZW9mIHVpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCk7XG4gICAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmU7XG4gICAgY29uc3QgdW5saW5rID0gb3B0LnVubGluaztcbiAgICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZTtcbiAgICBjb25zdCBjd2QgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShvcHQuY3dkKTtcbiAgICBjb25zdCBkb25lID0gKGNyZWF0ZWQpID0+IHtcbiAgICAgICAgY1NldChjYWNoZSwgZGlyLCB0cnVlKTtcbiAgICAgICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bikge1xuICAgICAgICAgICAgKDAsIGNob3ducl8xLmNob3duclN5bmMpKGNyZWF0ZWQsIHVpZCwgZ2lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZENobW9kKSB7XG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2htb2RTeW5jKGRpciwgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChjYWNoZSAmJiBjR2V0KGNhY2hlLCBkaXIpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIGlmIChkaXIgPT09IGN3ZCkge1xuICAgICAgICBjaGVja0N3ZFN5bmMoY3dkKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlKSB7XG4gICAgICAgIHJldHVybiBkb25lKCgwLCBta2RpcnBfMS5ta2RpcnBTeW5jKShkaXIsIG1vZGUpID8/IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNvbnN0IHN1YiA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG5vZGVfcGF0aF8xLmRlZmF1bHQucmVsYXRpdmUoY3dkLCBkaXIpKTtcbiAgICBjb25zdCBwYXJ0cyA9IHN1Yi5zcGxpdCgnLycpO1xuICAgIGxldCBjcmVhdGVkID0gdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IHAgPSBwYXJ0cy5zaGlmdCgpLCBwYXJ0ID0gY3dkOyBwICYmIChwYXJ0ICs9ICcvJyArIHApOyBwID0gcGFydHMuc2hpZnQoKSkge1xuICAgICAgICBwYXJ0ID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkobm9kZV9wYXRoXzEuZGVmYXVsdC5yZXNvbHZlKHBhcnQpKTtcbiAgICAgICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnNfMS5kZWZhdWx0Lm1rZGlyU3luYyhwYXJ0LCBtb2RlKTtcbiAgICAgICAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnQ7XG4gICAgICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gZnNfMS5kZWZhdWx0LmxzdGF0U3luYyhwYXJ0KTtcbiAgICAgICAgICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgY1NldChjYWNoZSwgcGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQudW5saW5rU3luYyhwYXJ0KTtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQubWtkaXJTeW5jKHBhcnQsIG1vZGUpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnQ7XG4gICAgICAgICAgICAgICAgY1NldChjYWNoZSwgcGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW1saW5rX2Vycm9yX2pzXzEuU3ltbGlua0Vycm9yKHBhcnQsIHBhcnQgKyAnLycgKyBwYXJ0cy5qb2luKCcvJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb25lKGNyZWF0ZWQpO1xufTtcbmV4cG9ydHMubWtkaXJTeW5jID0gbWtkaXJTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWtkaXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/mkdir.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/mode-fix.js":
/*!****************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/mode-fix.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.modeFix = void 0;\nconst modeFix = (mode, isDir, portable) => {\n    mode &= 0o7777;\n    // in portable mode, use the minimum reasonable umask\n    // if this system creates files with 0o664 by default\n    // (as some linux distros do), then we'll write the\n    // archive with 0o644 instead.  Also, don't ever create\n    // a file that is not readable/writable by the owner.\n    if (portable) {\n        mode = (mode | 0o600) & ~0o22;\n    }\n    // if dirs are readable, then they should be listable\n    if (isDir) {\n        if (mode & 0o400) {\n            mode |= 0o100;\n        }\n        if (mode & 0o40) {\n            mode |= 0o10;\n        }\n        if (mode & 0o4) {\n            mode |= 0o1;\n        }\n    }\n    return mode;\n};\nexports.modeFix = modeFix;\n//# sourceMappingURL=mode-fix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbW9kZS1maXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL21vZGUtZml4LmpzPzFjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1vZGVGaXggPSB2b2lkIDA7XG5jb25zdCBtb2RlRml4ID0gKG1vZGUsIGlzRGlyLCBwb3J0YWJsZSkgPT4ge1xuICAgIG1vZGUgJj0gMG83Nzc3O1xuICAgIC8vIGluIHBvcnRhYmxlIG1vZGUsIHVzZSB0aGUgbWluaW11bSByZWFzb25hYmxlIHVtYXNrXG4gICAgLy8gaWYgdGhpcyBzeXN0ZW0gY3JlYXRlcyBmaWxlcyB3aXRoIDBvNjY0IGJ5IGRlZmF1bHRcbiAgICAvLyAoYXMgc29tZSBsaW51eCBkaXN0cm9zIGRvKSwgdGhlbiB3ZSdsbCB3cml0ZSB0aGVcbiAgICAvLyBhcmNoaXZlIHdpdGggMG82NDQgaW5zdGVhZC4gIEFsc28sIGRvbid0IGV2ZXIgY3JlYXRlXG4gICAgLy8gYSBmaWxlIHRoYXQgaXMgbm90IHJlYWRhYmxlL3dyaXRhYmxlIGJ5IHRoZSBvd25lci5cbiAgICBpZiAocG9ydGFibGUpIHtcbiAgICAgICAgbW9kZSA9IChtb2RlIHwgMG82MDApICYgfjBvMjI7XG4gICAgfVxuICAgIC8vIGlmIGRpcnMgYXJlIHJlYWRhYmxlLCB0aGVuIHRoZXkgc2hvdWxkIGJlIGxpc3RhYmxlXG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICAgIGlmIChtb2RlICYgMG80MDApIHtcbiAgICAgICAgICAgIG1vZGUgfD0gMG8xMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgJiAwbzQwKSB7XG4gICAgICAgICAgICBtb2RlIHw9IDBvMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgJiAwbzQpIHtcbiAgICAgICAgICAgIG1vZGUgfD0gMG8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RlO1xufTtcbmV4cG9ydHMubW9kZUZpeCA9IG1vZGVGaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWZpeC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/mode-fix.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/normalize-unicode.js":
/*!*************************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/normalize-unicode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeUnicode = void 0;\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null);\nconst { hasOwnProperty } = Object.prototype;\nconst normalizeUnicode = (s) => {\n    if (!hasOwnProperty.call(normalizeCache, s)) {\n        normalizeCache[s] = s.normalize('NFD');\n    }\n    return normalizeCache[s];\n};\nexports.normalizeUnicode = normalizeUnicode;\n//# sourceMappingURL=normalize-unicode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbm9ybWFsaXplLXVuaWNvZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9ub3JtYWxpemUtdW5pY29kZS5qcz82ZDRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemVVbmljb2RlID0gdm9pZCAwO1xuLy8gd2FybmluZzogZXh0cmVtZWx5IGhvdCBjb2RlIHBhdGguXG4vLyBUaGlzIGhhcyBiZWVuIG1ldGljdWxvdXNseSBvcHRpbWl6ZWQgZm9yIHVzZVxuLy8gd2l0aGluIG5wbSBpbnN0YWxsIG9uIGxhcmdlIHBhY2thZ2UgdHJlZXMuXG4vLyBEbyBub3QgZWRpdCB3aXRob3V0IGNhcmVmdWwgYmVuY2htYXJraW5nLlxuY29uc3Qgbm9ybWFsaXplQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IG5vcm1hbGl6ZVVuaWNvZGUgPSAocykgPT4ge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub3JtYWxpemVDYWNoZSwgcykpIHtcbiAgICAgICAgbm9ybWFsaXplQ2FjaGVbc10gPSBzLm5vcm1hbGl6ZSgnTkZEJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVDYWNoZVtzXTtcbn07XG5leHBvcnRzLm5vcm1hbGl6ZVVuaWNvZGUgPSBub3JtYWxpemVVbmljb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLXVuaWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/normalize-unicode.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/normalize-windows-path.js":
/*!******************************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/normalize-windows-path.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeWindowsPath = void 0;\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nexports.normalizeWindowsPath = platform !== 'win32' ?\n    (p) => p\n    : (p) => p && p.replace(/\\\\/g, '/');\n//# sourceMappingURL=normalize-windows-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzP2Q4NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBvbiB3aW5kb3dzLCBlaXRoZXIgXFwgb3IgLyBhcmUgdmFsaWQgZGlyZWN0b3J5IHNlcGFyYXRvcnMuXG4vLyBvbiB1bml4LCBcXCBpcyBhIHZhbGlkIGNoYXJhY3RlciBpbiBmaWxlbmFtZXMuXG4vLyBzbywgb24gd2luZG93cywgYW5kIG9ubHkgb24gd2luZG93cywgd2UgcmVwbGFjZSBhbGwgXFwgY2hhcnMgd2l0aCAvLFxuLy8gc28gdGhhdCB3ZSBjYW4gdXNlIC8gYXMgb3VyIG9uZSBhbmQgb25seSBkaXJlY3Rvcnkgc2VwYXJhdG9yIGNoYXIuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZVdpbmRvd3NQYXRoID0gdm9pZCAwO1xuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm07XG5leHBvcnRzLm5vcm1hbGl6ZVdpbmRvd3NQYXRoID0gcGxhdGZvcm0gIT09ICd3aW4zMicgP1xuICAgIChwKSA9PiBwXG4gICAgOiAocCkgPT4gcCAmJiBwLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/normalize-windows-path.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/options.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dealias = exports.isNoFile = exports.isFile = exports.isAsync = exports.isSync = exports.isAsyncNoFile = exports.isSyncNoFile = exports.isAsyncFile = exports.isSyncFile = void 0;\nconst argmap = new Map([\n    ['C', 'cwd'],\n    ['f', 'file'],\n    ['z', 'gzip'],\n    ['P', 'preservePaths'],\n    ['U', 'unlink'],\n    ['strip-components', 'strip'],\n    ['stripComponents', 'strip'],\n    ['keep-newer', 'newer'],\n    ['keepNewer', 'newer'],\n    ['keep-newer-files', 'newer'],\n    ['keepNewerFiles', 'newer'],\n    ['k', 'keep'],\n    ['keep-existing', 'keep'],\n    ['keepExisting', 'keep'],\n    ['m', 'noMtime'],\n    ['no-mtime', 'noMtime'],\n    ['p', 'preserveOwner'],\n    ['L', 'follow'],\n    ['h', 'follow'],\n    ['onentry', 'onReadEntry'],\n]);\nconst isSyncFile = (o) => !!o.sync && !!o.file;\nexports.isSyncFile = isSyncFile;\nconst isAsyncFile = (o) => !o.sync && !!o.file;\nexports.isAsyncFile = isAsyncFile;\nconst isSyncNoFile = (o) => !!o.sync && !o.file;\nexports.isSyncNoFile = isSyncNoFile;\nconst isAsyncNoFile = (o) => !o.sync && !o.file;\nexports.isAsyncNoFile = isAsyncNoFile;\nconst isSync = (o) => !!o.sync;\nexports.isSync = isSync;\nconst isAsync = (o) => !o.sync;\nexports.isAsync = isAsync;\nconst isFile = (o) => !!o.file;\nexports.isFile = isFile;\nconst isNoFile = (o) => !o.file;\nexports.isNoFile = isNoFile;\nconst dealiasKey = (k) => {\n    const d = argmap.get(k);\n    if (d)\n        return d;\n    return k;\n};\nconst dealias = (opt = {}) => {\n    if (!opt)\n        return {};\n    const result = {};\n    for (const [key, v] of Object.entries(opt)) {\n        // TS doesn't know that aliases are going to always be the same type\n        const k = dealiasKey(key);\n        result[k] = v;\n    }\n    // affordance for deprecated noChmod -> chmod\n    if (result.chmod === undefined && result.noChmod === false) {\n        result.chmod = true;\n    }\n    delete result.noChmod;\n    return result;\n};\nexports.dealias = dealias;\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvb3B0aW9ucy5qcz9iODdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHVybiB0YXIoMSkgc3R5bGUgYXJncyBsaWtlIGBDYCBpbnRvIHRoZSBtb3JlIHZlcmJvc2UgdGhpbmdzIGxpa2UgYGN3ZGBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVhbGlhcyA9IGV4cG9ydHMuaXNOb0ZpbGUgPSBleHBvcnRzLmlzRmlsZSA9IGV4cG9ydHMuaXNBc3luYyA9IGV4cG9ydHMuaXNTeW5jID0gZXhwb3J0cy5pc0FzeW5jTm9GaWxlID0gZXhwb3J0cy5pc1N5bmNOb0ZpbGUgPSBleHBvcnRzLmlzQXN5bmNGaWxlID0gZXhwb3J0cy5pc1N5bmNGaWxlID0gdm9pZCAwO1xuY29uc3QgYXJnbWFwID0gbmV3IE1hcChbXG4gICAgWydDJywgJ2N3ZCddLFxuICAgIFsnZicsICdmaWxlJ10sXG4gICAgWyd6JywgJ2d6aXAnXSxcbiAgICBbJ1AnLCAncHJlc2VydmVQYXRocyddLFxuICAgIFsnVScsICd1bmxpbmsnXSxcbiAgICBbJ3N0cmlwLWNvbXBvbmVudHMnLCAnc3RyaXAnXSxcbiAgICBbJ3N0cmlwQ29tcG9uZW50cycsICdzdHJpcCddLFxuICAgIFsna2VlcC1uZXdlcicsICduZXdlciddLFxuICAgIFsna2VlcE5ld2VyJywgJ25ld2VyJ10sXG4gICAgWydrZWVwLW5ld2VyLWZpbGVzJywgJ25ld2VyJ10sXG4gICAgWydrZWVwTmV3ZXJGaWxlcycsICduZXdlciddLFxuICAgIFsnaycsICdrZWVwJ10sXG4gICAgWydrZWVwLWV4aXN0aW5nJywgJ2tlZXAnXSxcbiAgICBbJ2tlZXBFeGlzdGluZycsICdrZWVwJ10sXG4gICAgWydtJywgJ25vTXRpbWUnXSxcbiAgICBbJ25vLW10aW1lJywgJ25vTXRpbWUnXSxcbiAgICBbJ3AnLCAncHJlc2VydmVPd25lciddLFxuICAgIFsnTCcsICdmb2xsb3cnXSxcbiAgICBbJ2gnLCAnZm9sbG93J10sXG4gICAgWydvbmVudHJ5JywgJ29uUmVhZEVudHJ5J10sXG5dKTtcbmNvbnN0IGlzU3luY0ZpbGUgPSAobykgPT4gISFvLnN5bmMgJiYgISFvLmZpbGU7XG5leHBvcnRzLmlzU3luY0ZpbGUgPSBpc1N5bmNGaWxlO1xuY29uc3QgaXNBc3luY0ZpbGUgPSAobykgPT4gIW8uc3luYyAmJiAhIW8uZmlsZTtcbmV4cG9ydHMuaXNBc3luY0ZpbGUgPSBpc0FzeW5jRmlsZTtcbmNvbnN0IGlzU3luY05vRmlsZSA9IChvKSA9PiAhIW8uc3luYyAmJiAhby5maWxlO1xuZXhwb3J0cy5pc1N5bmNOb0ZpbGUgPSBpc1N5bmNOb0ZpbGU7XG5jb25zdCBpc0FzeW5jTm9GaWxlID0gKG8pID0+ICFvLnN5bmMgJiYgIW8uZmlsZTtcbmV4cG9ydHMuaXNBc3luY05vRmlsZSA9IGlzQXN5bmNOb0ZpbGU7XG5jb25zdCBpc1N5bmMgPSAobykgPT4gISFvLnN5bmM7XG5leHBvcnRzLmlzU3luYyA9IGlzU3luYztcbmNvbnN0IGlzQXN5bmMgPSAobykgPT4gIW8uc3luYztcbmV4cG9ydHMuaXNBc3luYyA9IGlzQXN5bmM7XG5jb25zdCBpc0ZpbGUgPSAobykgPT4gISFvLmZpbGU7XG5leHBvcnRzLmlzRmlsZSA9IGlzRmlsZTtcbmNvbnN0IGlzTm9GaWxlID0gKG8pID0+ICFvLmZpbGU7XG5leHBvcnRzLmlzTm9GaWxlID0gaXNOb0ZpbGU7XG5jb25zdCBkZWFsaWFzS2V5ID0gKGspID0+IHtcbiAgICBjb25zdCBkID0gYXJnbWFwLmdldChrKTtcbiAgICBpZiAoZClcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgcmV0dXJuIGs7XG59O1xuY29uc3QgZGVhbGlhcyA9IChvcHQgPSB7fSkgPT4ge1xuICAgIGlmICghb3B0KVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhvcHQpKSB7XG4gICAgICAgIC8vIFRTIGRvZXNuJ3Qga25vdyB0aGF0IGFsaWFzZXMgYXJlIGdvaW5nIHRvIGFsd2F5cyBiZSB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGNvbnN0IGsgPSBkZWFsaWFzS2V5KGtleSk7XG4gICAgICAgIHJlc3VsdFtrXSA9IHY7XG4gICAgfVxuICAgIC8vIGFmZm9yZGFuY2UgZm9yIGRlcHJlY2F0ZWQgbm9DaG1vZCAtPiBjaG1vZFxuICAgIGlmIChyZXN1bHQuY2htb2QgPT09IHVuZGVmaW5lZCAmJiByZXN1bHQubm9DaG1vZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVzdWx0LmNobW9kID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVsZXRlIHJlc3VsdC5ub0NobW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5kZWFsaWFzID0gZGVhbGlhcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/options.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/pack.js":
/*!************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/pack.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PackSync = exports.Pack = exports.PackJob = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst write_entry_js_1 = __webpack_require__(/*! ./write-entry.js */ \"./node_modules/tar/dist/commonjs/write-entry.js\");\nclass PackJob {\n    path;\n    absolute;\n    entry;\n    stat;\n    readdir;\n    pending = false;\n    ignore = false;\n    piped = false;\n    constructor(path, absolute) {\n        this.path = path || './';\n        this.absolute = absolute;\n    }\n}\nexports.PackJob = PackJob;\nconst minipass_1 = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/dist/commonjs/index.js\");\nconst zlib = __importStar(__webpack_require__(/*! minizlib */ \"./node_modules/tar/node_modules/minizlib/dist/commonjs/index.js\"));\nconst yallist_1 = __webpack_require__(/*! yallist */ \"./node_modules/tar/node_modules/yallist/dist/commonjs/index.js\");\nconst read_entry_js_1 = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/dist/commonjs/read-entry.js\");\nconst warn_method_js_1 = __webpack_require__(/*! ./warn-method.js */ \"./node_modules/tar/dist/commonjs/warn-method.js\");\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst normalize_windows_path_js_1 = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/dist/commonjs/normalize-windows-path.js\");\nclass Pack extends minipass_1.Minipass {\n    opt;\n    cwd;\n    maxReadSize;\n    preservePaths;\n    strict;\n    noPax;\n    prefix;\n    linkCache;\n    statCache;\n    file;\n    portable;\n    zip;\n    readdirCache;\n    noDirRecurse;\n    follow;\n    noMtime;\n    mtime;\n    filter;\n    jobs;\n    [WRITEENTRYCLASS];\n    onWriteEntry;\n    [QUEUE];\n    [JOBS] = 0;\n    [PROCESSING] = false;\n    [ENDED] = false;\n    constructor(opt = {}) {\n        //@ts-ignore\n        super();\n        this.opt = opt;\n        this.file = opt.file || '';\n        this.cwd = opt.cwd || process.cwd();\n        this.maxReadSize = opt.maxReadSize;\n        this.preservePaths = !!opt.preservePaths;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.prefix = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix || '');\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.readdirCache = opt.readdirCache || new Map();\n        this.onWriteEntry = opt.onWriteEntry;\n        this[WRITEENTRYCLASS] = write_entry_js_1.WriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        this.portable = !!opt.portable;\n        if (opt.gzip || opt.brotli) {\n            if (opt.gzip && opt.brotli) {\n                throw new TypeError('gzip and brotli are mutually exclusive');\n            }\n            if (opt.gzip) {\n                if (typeof opt.gzip !== 'object') {\n                    opt.gzip = {};\n                }\n                if (this.portable) {\n                    opt.gzip.portable = true;\n                }\n                this.zip = new zlib.Gzip(opt.gzip);\n            }\n            if (opt.brotli) {\n                if (typeof opt.brotli !== 'object') {\n                    opt.brotli = {};\n                }\n                this.zip = new zlib.BrotliCompress(opt.brotli);\n            }\n            /* c8 ignore next */\n            if (!this.zip)\n                throw new Error('impossible');\n            const zip = this.zip;\n            zip.on('data', chunk => super.write(chunk));\n            zip.on('end', () => super.end());\n            zip.on('drain', () => this[ONDRAIN]());\n            this.on('resume', () => zip.resume());\n        }\n        else {\n            this.on('drain', this[ONDRAIN]);\n        }\n        this.noDirRecurse = !!opt.noDirRecurse;\n        this.follow = !!opt.follow;\n        this.noMtime = !!opt.noMtime;\n        if (opt.mtime)\n            this.mtime = opt.mtime;\n        this.filter =\n            typeof opt.filter === 'function' ? opt.filter : () => true;\n        this[QUEUE] = new yallist_1.Yallist();\n        this[JOBS] = 0;\n        this.jobs = Number(opt.jobs) || 4;\n        this[PROCESSING] = false;\n        this[ENDED] = false;\n    }\n    [WRITE](chunk) {\n        return super.write(chunk);\n    }\n    add(path) {\n        this.write(path);\n        return this;\n    }\n    end(path, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof path === 'function') {\n            cb = path;\n            path = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (path) {\n            this.add(path);\n        }\n        this[ENDED] = true;\n        this[PROCESS]();\n        /* c8 ignore next */\n        if (cb)\n            cb();\n        return this;\n    }\n    write(path) {\n        if (this[ENDED]) {\n            throw new Error('write after end');\n        }\n        if (path instanceof read_entry_js_1.ReadEntry) {\n            this[ADDTARENTRY](path);\n        }\n        else {\n            this[ADDFSENTRY](path);\n        }\n        return this.flowing;\n    }\n    [ADDTARENTRY](p) {\n        const absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(this.cwd, p.path));\n        // in this case, we don't have to wait for the stat\n        if (!this.filter(p.path, p)) {\n            p.resume();\n        }\n        else {\n            const job = new PackJob(p.path, absolute);\n            job.entry = new write_entry_js_1.WriteEntryTar(p, this[ENTRYOPT](job));\n            job.entry.on('end', () => this[JOBDONE](job));\n            this[JOBS] += 1;\n            this[QUEUE].push(job);\n        }\n        this[PROCESS]();\n    }\n    [ADDFSENTRY](p) {\n        const absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(this.cwd, p));\n        this[QUEUE].push(new PackJob(p, absolute));\n        this[PROCESS]();\n    }\n    [STAT](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        const stat = this.follow ? 'stat' : 'lstat';\n        fs_1.default[stat](job.absolute, (er, stat) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                this.emit('error', er);\n            }\n            else {\n                this[ONSTAT](job, stat);\n            }\n        });\n    }\n    [ONSTAT](job, stat) {\n        this.statCache.set(job.absolute, stat);\n        job.stat = stat;\n        // now we have the stat, we can filter it.\n        if (!this.filter(job.path, stat)) {\n            job.ignore = true;\n        }\n        this[PROCESS]();\n    }\n    [READDIR](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        fs_1.default.readdir(job.absolute, (er, entries) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADDIR](job, entries);\n        });\n    }\n    [ONREADDIR](job, entries) {\n        this.readdirCache.set(job.absolute, entries);\n        job.readdir = entries;\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        if (this[PROCESSING]) {\n            return;\n        }\n        this[PROCESSING] = true;\n        for (let w = this[QUEUE].head; !!w && this[JOBS] < this.jobs; w = w.next) {\n            this[PROCESSJOB](w.value);\n            if (w.value.ignore) {\n                const p = w.next;\n                this[QUEUE].removeNode(w);\n                w.next = p;\n            }\n        }\n        this[PROCESSING] = false;\n        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n            if (this.zip) {\n                this.zip.end(EOF);\n            }\n            else {\n                super.write(EOF);\n                super.end();\n            }\n        }\n    }\n    get [CURRENT]() {\n        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n    [JOBDONE](_job) {\n        this[QUEUE].shift();\n        this[JOBS] -= 1;\n        this[PROCESS]();\n    }\n    [PROCESSJOB](job) {\n        if (job.pending) {\n            return;\n        }\n        if (job.entry) {\n            if (job === this[CURRENT] && !job.piped) {\n                this[PIPE](job);\n            }\n            return;\n        }\n        if (!job.stat) {\n            const sc = this.statCache.get(job.absolute);\n            if (sc) {\n                this[ONSTAT](job, sc);\n            }\n            else {\n                this[STAT](job);\n            }\n        }\n        if (!job.stat) {\n            return;\n        }\n        // filtered out!\n        if (job.ignore) {\n            return;\n        }\n        if (!this.noDirRecurse &&\n            job.stat.isDirectory() &&\n            !job.readdir) {\n            const rc = this.readdirCache.get(job.absolute);\n            if (rc) {\n                this[ONREADDIR](job, rc);\n            }\n            else {\n                this[READDIR](job);\n            }\n            if (!job.readdir) {\n                return;\n            }\n        }\n        // we know it doesn't have an entry, because that got checked above\n        job.entry = this[ENTRY](job);\n        if (!job.entry) {\n            job.ignore = true;\n            return;\n        }\n        if (job === this[CURRENT] && !job.piped) {\n            this[PIPE](job);\n        }\n    }\n    [ENTRYOPT](job) {\n        return {\n            onwarn: (code, msg, data) => this.warn(code, msg, data),\n            noPax: this.noPax,\n            cwd: this.cwd,\n            absolute: job.absolute,\n            preservePaths: this.preservePaths,\n            maxReadSize: this.maxReadSize,\n            strict: this.strict,\n            portable: this.portable,\n            linkCache: this.linkCache,\n            statCache: this.statCache,\n            noMtime: this.noMtime,\n            mtime: this.mtime,\n            prefix: this.prefix,\n            onWriteEntry: this.onWriteEntry,\n        };\n    }\n    [ENTRY](job) {\n        this[JOBS] += 1;\n        try {\n            const e = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));\n            return e\n                .on('end', () => this[JOBDONE](job))\n                .on('error', er => this.emit('error', er));\n        }\n        catch (er) {\n            this.emit('error', er);\n        }\n    }\n    [ONDRAIN]() {\n        if (this[CURRENT] && this[CURRENT].entry) {\n            this[CURRENT].entry.resume();\n        }\n    }\n    // like .pipe() but using super, because our write() is special\n    [PIPE](job) {\n        job.piped = true;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        const source = job.entry;\n        const zip = this.zip;\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                if (!zip.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                if (!super.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n    }\n    pause() {\n        if (this.zip) {\n            this.zip.pause();\n        }\n        return super.pause();\n    }\n    warn(code, message, data = {}) {\n        (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n}\nexports.Pack = Pack;\nclass PackSync extends Pack {\n    sync = true;\n    constructor(opt) {\n        super(opt);\n        this[WRITEENTRYCLASS] = write_entry_js_1.WriteEntrySync;\n    }\n    // pause/resume are no-ops in sync streams.\n    pause() { }\n    resume() { }\n    [STAT](job) {\n        const stat = this.follow ? 'statSync' : 'lstatSync';\n        this[ONSTAT](job, fs_1.default[stat](job.absolute));\n    }\n    [READDIR](job) {\n        this[ONREADDIR](job, fs_1.default.readdirSync(job.absolute));\n    }\n    // gotta get it all in this tick\n    [PIPE](job) {\n        const source = job.entry;\n        const zip = this.zip;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('Cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                zip.write(chunk);\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                super[WRITE](chunk);\n            });\n        }\n    }\n}\nexports.PackSync = PackSync;\n//# sourceMappingURL=pack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGVBQWU7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsY0FBSTtBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBVTtBQUNyQywwQkFBMEIsbUJBQU8sQ0FBQyxpRkFBVTtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQywrRUFBUztBQUNuQyx3QkFBd0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMseUVBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDLG9DQUFvQyxtQkFBTyxDQUFDLCtGQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGFjay5qcz8xMDg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQSByZWFkYWJsZSB0YXIgc3RyZWFtIGNyZWF0b3Jcbi8vIFRlY2huaWNhbGx5LCB0aGlzIGlzIGEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IHlvdSB3cml0ZSBwYXRocyBpbnRvLFxuLy8gYW5kIHRhciBmb3JtYXQgY29tZXMgb3V0IG9mLlxuLy8gVGhlIGBhZGQoKWAgbWV0aG9kIGlzIGxpa2UgYHdyaXRlKClgIGJ1dCByZXR1cm5zIHRoaXMsXG4vLyBhbmQgZW5kKCkgcmV0dXJuIGB0aGlzYCBhcyB3ZWxsLCBzbyB5b3UgY2FuXG4vLyBkbyBgbmV3IFBhY2sob3B0KS5hZGQoJ2ZpbGVzJykuYWRkKCdkaXInKS5lbmQoKS5waXBlKG91dHB1dClcbi8vIFlvdSBjb3VsZCBhbHNvIGRvIHNvbWV0aGluZyBsaWtlOlxuLy8gc3RyZWFtT2ZQYXRocygpLnBpcGUobmV3IFBhY2soKSkucGlwZShuZXcgZnMuV3JpdGVTdHJlYW0oJ291dC50YXInKSlcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYWNrU3luYyA9IGV4cG9ydHMuUGFjayA9IGV4cG9ydHMuUGFja0pvYiA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IHdyaXRlX2VudHJ5X2pzXzEgPSByZXF1aXJlKFwiLi93cml0ZS1lbnRyeS5qc1wiKTtcbmNsYXNzIFBhY2tKb2Ige1xuICAgIHBhdGg7XG4gICAgYWJzb2x1dGU7XG4gICAgZW50cnk7XG4gICAgc3RhdDtcbiAgICByZWFkZGlyO1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICBpZ25vcmUgPSBmYWxzZTtcbiAgICBwaXBlZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGFic29sdXRlKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGggfHwgJy4vJztcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IGFic29sdXRlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFja0pvYiA9IFBhY2tKb2I7XG5jb25zdCBtaW5pcGFzc18xID0gcmVxdWlyZShcIm1pbmlwYXNzXCIpO1xuY29uc3QgemxpYiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibWluaXpsaWJcIikpO1xuY29uc3QgeWFsbGlzdF8xID0gcmVxdWlyZShcInlhbGxpc3RcIik7XG5jb25zdCByZWFkX2VudHJ5X2pzXzEgPSByZXF1aXJlKFwiLi9yZWFkLWVudHJ5LmpzXCIpO1xuY29uc3Qgd2Fybl9tZXRob2RfanNfMSA9IHJlcXVpcmUoXCIuL3dhcm4tbWV0aG9kLmpzXCIpO1xuY29uc3QgRU9GID0gQnVmZmVyLmFsbG9jKDEwMjQpO1xuY29uc3QgT05TVEFUID0gU3ltYm9sKCdvblN0YXQnKTtcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpO1xuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJyk7XG5jb25zdCBDVVJSRU5UID0gU3ltYm9sKCdjdXJyZW50Jyk7XG5jb25zdCBQUk9DRVNTID0gU3ltYm9sKCdwcm9jZXNzJyk7XG5jb25zdCBQUk9DRVNTSU5HID0gU3ltYm9sKCdwcm9jZXNzaW5nJyk7XG5jb25zdCBQUk9DRVNTSk9CID0gU3ltYm9sKCdwcm9jZXNzSm9iJyk7XG5jb25zdCBKT0JTID0gU3ltYm9sKCdqb2JzJyk7XG5jb25zdCBKT0JET05FID0gU3ltYm9sKCdqb2JEb25lJyk7XG5jb25zdCBBRERGU0VOVFJZID0gU3ltYm9sKCdhZGRGU0VudHJ5Jyk7XG5jb25zdCBBRERUQVJFTlRSWSA9IFN5bWJvbCgnYWRkVGFyRW50cnknKTtcbmNvbnN0IFNUQVQgPSBTeW1ib2woJ3N0YXQnKTtcbmNvbnN0IFJFQURESVIgPSBTeW1ib2woJ3JlYWRkaXInKTtcbmNvbnN0IE9OUkVBRERJUiA9IFN5bWJvbCgnb25yZWFkZGlyJyk7XG5jb25zdCBQSVBFID0gU3ltYm9sKCdwaXBlJyk7XG5jb25zdCBFTlRSWSA9IFN5bWJvbCgnZW50cnknKTtcbmNvbnN0IEVOVFJZT1BUID0gU3ltYm9sKCdlbnRyeU9wdCcpO1xuY29uc3QgV1JJVEVFTlRSWUNMQVNTID0gU3ltYm9sKCd3cml0ZUVudHJ5Q2xhc3MnKTtcbmNvbnN0IFdSSVRFID0gU3ltYm9sKCd3cml0ZScpO1xuY29uc3QgT05EUkFJTiA9IFN5bWJvbCgnb25kcmFpbicpO1xuY29uc3QgcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtcbmNvbnN0IG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMSA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanNcIik7XG5jbGFzcyBQYWNrIGV4dGVuZHMgbWluaXBhc3NfMS5NaW5pcGFzcyB7XG4gICAgb3B0O1xuICAgIGN3ZDtcbiAgICBtYXhSZWFkU2l6ZTtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHN0cmljdDtcbiAgICBub1BheDtcbiAgICBwcmVmaXg7XG4gICAgbGlua0NhY2hlO1xuICAgIHN0YXRDYWNoZTtcbiAgICBmaWxlO1xuICAgIHBvcnRhYmxlO1xuICAgIHppcDtcbiAgICByZWFkZGlyQ2FjaGU7XG4gICAgbm9EaXJSZWN1cnNlO1xuICAgIGZvbGxvdztcbiAgICBub010aW1lO1xuICAgIG10aW1lO1xuICAgIGZpbHRlcjtcbiAgICBqb2JzO1xuICAgIFtXUklURUVOVFJZQ0xBU1NdO1xuICAgIG9uV3JpdGVFbnRyeTtcbiAgICBbUVVFVUVdO1xuICAgIFtKT0JTXSA9IDA7XG4gICAgW1BST0NFU1NJTkddID0gZmFsc2U7XG4gICAgW0VOREVEXSA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKG9wdCA9IHt9KSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcbiAgICAgICAgdGhpcy5maWxlID0gb3B0LmZpbGUgfHwgJyc7XG4gICAgICAgIHRoaXMuY3dkID0gb3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICB0aGlzLm1heFJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplO1xuICAgICAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzO1xuICAgICAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdDtcbiAgICAgICAgdGhpcy5ub1BheCA9ICEhb3B0Lm5vUGF4O1xuICAgICAgICB0aGlzLnByZWZpeCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG9wdC5wcmVmaXggfHwgJycpO1xuICAgICAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXRDYWNoZSA9IG9wdC5zdGF0Q2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlYWRkaXJDYWNoZSA9IG9wdC5yZWFkZGlyQ2FjaGUgfHwgbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uV3JpdGVFbnRyeSA9IG9wdC5vbldyaXRlRW50cnk7XG4gICAgICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IHdyaXRlX2VudHJ5X2pzXzEuV3JpdGVFbnRyeTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2Fybik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlO1xuICAgICAgICBpZiAob3B0Lmd6aXAgfHwgb3B0LmJyb3RsaSkge1xuICAgICAgICAgICAgaWYgKG9wdC5nemlwICYmIG9wdC5icm90bGkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnemlwIGFuZCBicm90bGkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5nemlwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQuZ3ppcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Lmd6aXAgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Lmd6aXAucG9ydGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnppcCA9IG5ldyB6bGliLkd6aXAob3B0Lmd6aXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5icm90bGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdC5icm90bGkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5icm90bGkgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy56aXAgPSBuZXcgemxpYi5Ccm90bGlDb21wcmVzcyhvcHQuYnJvdGxpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuemlwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3NzaWJsZScpO1xuICAgICAgICAgICAgY29uc3QgemlwID0gdGhpcy56aXA7XG4gICAgICAgICAgICB6aXAub24oJ2RhdGEnLCBjaHVuayA9PiBzdXBlci53cml0ZShjaHVuaykpO1xuICAgICAgICAgICAgemlwLm9uKCdlbmQnLCAoKSA9PiBzdXBlci5lbmQoKSk7XG4gICAgICAgICAgICB6aXAub24oJ2RyYWluJywgKCkgPT4gdGhpc1tPTkRSQUlOXSgpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ3Jlc3VtZScsICgpID0+IHppcC5yZXN1bWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uKCdkcmFpbicsIHRoaXNbT05EUkFJTl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9EaXJSZWN1cnNlID0gISFvcHQubm9EaXJSZWN1cnNlO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0LmZvbGxvdztcbiAgICAgICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZTtcbiAgICAgICAgaWYgKG9wdC5tdGltZSlcbiAgICAgICAgICAgIHRoaXMubXRpbWUgPSBvcHQubXRpbWU7XG4gICAgICAgIHRoaXMuZmlsdGVyID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHQuZmlsdGVyID09PSAnZnVuY3Rpb24nID8gb3B0LmZpbHRlciA6ICgpID0+IHRydWU7XG4gICAgICAgIHRoaXNbUVVFVUVdID0gbmV3IHlhbGxpc3RfMS5ZYWxsaXN0KCk7XG4gICAgICAgIHRoaXNbSk9CU10gPSAwO1xuICAgICAgICB0aGlzLmpvYnMgPSBOdW1iZXIob3B0LmpvYnMpIHx8IDQ7XG4gICAgICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tFTkRFRF0gPSBmYWxzZTtcbiAgICB9XG4gICAgW1dSSVRFXShjaHVuaykge1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICBhZGQocGF0aCkge1xuICAgICAgICB0aGlzLndyaXRlKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW5kKHBhdGgsIGVuY29kaW5nLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IHBhdGg7XG4gICAgICAgICAgICBwYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3cml0ZShwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzW0VOREVEXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIHJlYWRfZW50cnlfanNfMS5SZWFkRW50cnkpIHtcbiAgICAgICAgICAgIHRoaXNbQUREVEFSRU5UUlldKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tBRERGU0VOVFJZXShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mbG93aW5nO1xuICAgIH1cbiAgICBbQUREVEFSRU5UUlldKHApIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGUgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShwYXRoXzEuZGVmYXVsdC5yZXNvbHZlKHRoaXMuY3dkLCBwLnBhdGgpKTtcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkb24ndCBoYXZlIHRvIHdhaXQgZm9yIHRoZSBzdGF0XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXIocC5wYXRoLCBwKSkge1xuICAgICAgICAgICAgcC5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IG5ldyBQYWNrSm9iKHAucGF0aCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgam9iLmVudHJ5ID0gbmV3IHdyaXRlX2VudHJ5X2pzXzEuV3JpdGVFbnRyeVRhcihwLCB0aGlzW0VOVFJZT1BUXShqb2IpKTtcbiAgICAgICAgICAgIGpvYi5lbnRyeS5vbignZW5kJywgKCkgPT4gdGhpc1tKT0JET05FXShqb2IpKTtcbiAgICAgICAgICAgIHRoaXNbSk9CU10gKz0gMTtcbiAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1BST0NFU1NdKCk7XG4gICAgfVxuICAgIFtBRERGU0VOVFJZXShwKSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkocGF0aF8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmN3ZCwgcCkpO1xuICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKG5ldyBQYWNrSm9iKHAsIGFic29sdXRlKSk7XG4gICAgICAgIHRoaXNbUFJPQ0VTU10oKTtcbiAgICB9XG4gICAgW1NUQVRdKGpvYikge1xuICAgICAgICBqb2IucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXNbSk9CU10gKz0gMTtcbiAgICAgICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXQnIDogJ2xzdGF0JztcbiAgICAgICAgZnNfMS5kZWZhdWx0W3N0YXRdKGpvYi5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBqb2IucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tKT0JTXSAtPSAxO1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgW09OU1RBVF0oam9iLCBzdGF0KSB7XG4gICAgICAgIHRoaXMuc3RhdENhY2hlLnNldChqb2IuYWJzb2x1dGUsIHN0YXQpO1xuICAgICAgICBqb2Iuc3RhdCA9IHN0YXQ7XG4gICAgICAgIC8vIG5vdyB3ZSBoYXZlIHRoZSBzdGF0LCB3ZSBjYW4gZmlsdGVyIGl0LlxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyKGpvYi5wYXRoLCBzdGF0KSkge1xuICAgICAgICAgICAgam9iLmlnbm9yZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUkVBRERJUl0oam9iKSB7XG4gICAgICAgIGpvYi5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tKT0JTXSArPSAxO1xuICAgICAgICBmc18xLmRlZmF1bHQucmVhZGRpcihqb2IuYWJzb2x1dGUsIChlciwgZW50cmllcykgPT4ge1xuICAgICAgICAgICAgam9iLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbSk9CU10gLT0gMTtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZW50cmllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbT05SRUFERElSXShqb2IsIGVudHJpZXMpIHtcbiAgICAgICAgdGhpcy5yZWFkZGlyQ2FjaGUuc2V0KGpvYi5hYnNvbHV0ZSwgZW50cmllcyk7XG4gICAgICAgIGpvYi5yZWFkZGlyID0gZW50cmllcztcbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUFJPQ0VTU10oKSB7XG4gICAgICAgIGlmICh0aGlzW1BST0NFU1NJTkddKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQUk9DRVNTSU5HXSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHcgPSB0aGlzW1FVRVVFXS5oZWFkOyAhIXcgJiYgdGhpc1tKT0JTXSA8IHRoaXMuam9iczsgdyA9IHcubmV4dCkge1xuICAgICAgICAgICAgdGhpc1tQUk9DRVNTSk9CXSh3LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh3LnZhbHVlLmlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB3Lm5leHQ7XG4gICAgICAgICAgICAgICAgdGhpc1tRVUVVRV0ucmVtb3ZlTm9kZSh3KTtcbiAgICAgICAgICAgICAgICB3Lm5leHQgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbRU5ERURdICYmICF0aGlzW1FVRVVFXS5sZW5ndGggJiYgdGhpc1tKT0JTXSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuemlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56aXAuZW5kKEVPRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlci53cml0ZShFT0YpO1xuICAgICAgICAgICAgICAgIHN1cGVyLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBbQ1VSUkVOVF0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1FVRVVFXSAmJiB0aGlzW1FVRVVFXS5oZWFkICYmIHRoaXNbUVVFVUVdLmhlYWQudmFsdWU7XG4gICAgfVxuICAgIFtKT0JET05FXShfam9iKSB7XG4gICAgICAgIHRoaXNbUVVFVUVdLnNoaWZ0KCk7XG4gICAgICAgIHRoaXNbSk9CU10gLT0gMTtcbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUFJPQ0VTU0pPQl0oam9iKSB7XG4gICAgICAgIGlmIChqb2IucGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2IuZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbUElQRV0oam9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpvYi5zdGF0KSB7XG4gICAgICAgICAgICBjb25zdCBzYyA9IHRoaXMuc3RhdENhY2hlLmdldChqb2IuYWJzb2x1dGUpO1xuICAgICAgICAgICAgaWYgKHNjKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tPTlNUQVRdKGpvYiwgc2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tTVEFUXShqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgham9iLnN0YXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXJlZCBvdXQhXG4gICAgICAgIGlmIChqb2IuaWdub3JlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5vRGlyUmVjdXJzZSAmJlxuICAgICAgICAgICAgam9iLnN0YXQuaXNEaXJlY3RvcnkoKSAmJlxuICAgICAgICAgICAgIWpvYi5yZWFkZGlyKSB7XG4gICAgICAgICAgICBjb25zdCByYyA9IHRoaXMucmVhZGRpckNhY2hlLmdldChqb2IuYWJzb2x1dGUpO1xuICAgICAgICAgICAgaWYgKHJjKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tPTlJFQURESVJdKGpvYiwgcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tSRUFERElSXShqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFqb2IucmVhZGRpcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBrbm93IGl0IGRvZXNuJ3QgaGF2ZSBhbiBlbnRyeSwgYmVjYXVzZSB0aGF0IGdvdCBjaGVja2VkIGFib3ZlXG4gICAgICAgIGpvYi5lbnRyeSA9IHRoaXNbRU5UUlldKGpvYik7XG4gICAgICAgIGlmICgham9iLmVudHJ5KSB7XG4gICAgICAgICAgICBqb2IuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9iID09PSB0aGlzW0NVUlJFTlRdICYmICFqb2IucGlwZWQpIHtcbiAgICAgICAgICAgIHRoaXNbUElQRV0oam9iKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbRU5UUllPUFRdKGpvYikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb253YXJuOiAoY29kZSwgbXNnLCBkYXRhKSA9PiB0aGlzLndhcm4oY29kZSwgbXNnLCBkYXRhKSxcbiAgICAgICAgICAgIG5vUGF4OiB0aGlzLm5vUGF4LFxuICAgICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICAgIGFic29sdXRlOiBqb2IuYWJzb2x1dGUsXG4gICAgICAgICAgICBwcmVzZXJ2ZVBhdGhzOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICAgICAgICBtYXhSZWFkU2l6ZTogdGhpcy5tYXhSZWFkU2l6ZSxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5zdHJpY3QsXG4gICAgICAgICAgICBwb3J0YWJsZTogdGhpcy5wb3J0YWJsZSxcbiAgICAgICAgICAgIGxpbmtDYWNoZTogdGhpcy5saW5rQ2FjaGUsXG4gICAgICAgICAgICBzdGF0Q2FjaGU6IHRoaXMuc3RhdENhY2hlLFxuICAgICAgICAgICAgbm9NdGltZTogdGhpcy5ub010aW1lLFxuICAgICAgICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgb25Xcml0ZUVudHJ5OiB0aGlzLm9uV3JpdGVFbnRyeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW0VOVFJZXShqb2IpIHtcbiAgICAgICAgdGhpc1tKT0JTXSArPSAxO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyB0aGlzW1dSSVRFRU5UUllDTEFTU10oam9iLnBhdGgsIHRoaXNbRU5UUllPUFRdKGpvYikpO1xuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHRoaXNbSk9CRE9ORV0oam9iKSlcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZXIgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtPTkRSQUlOXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbQ1VSUkVOVF0gJiYgdGhpc1tDVVJSRU5UXS5lbnRyeSkge1xuICAgICAgICAgICAgdGhpc1tDVVJSRU5UXS5lbnRyeS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBsaWtlIC5waXBlKCkgYnV0IHVzaW5nIHN1cGVyLCBiZWNhdXNlIG91ciB3cml0ZSgpIGlzIHNwZWNpYWxcbiAgICBbUElQRV0oam9iKSB7XG4gICAgICAgIGpvYi5waXBlZCA9IHRydWU7XG4gICAgICAgIGlmIChqb2IucmVhZGRpcikge1xuICAgICAgICAgICAgam9iLnJlYWRkaXIuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGpvYi5wYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBwID09PSAnLi8nID8gJycgOiBwLnJlcGxhY2UoL1xcLyokLywgJy8nKTtcbiAgICAgICAgICAgICAgICB0aGlzW0FEREZTRU5UUlldKGJhc2UgKyBlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSBqb2IuZW50cnk7XG4gICAgICAgIGNvbnN0IHppcCA9IHRoaXMuemlwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBwaXBlIHdpdGhvdXQgc291cmNlJyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh6aXApIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXppcC53cml0ZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2Uub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBlci53cml0ZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnppcCkge1xuICAgICAgICAgICAgdGhpcy56aXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucGF1c2UoKTtcbiAgICB9XG4gICAgd2Fybihjb2RlLCBtZXNzYWdlLCBkYXRhID0ge30pIHtcbiAgICAgICAgKDAsIHdhcm5fbWV0aG9kX2pzXzEud2Fybk1ldGhvZCkodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5QYWNrID0gUGFjaztcbmNsYXNzIFBhY2tTeW5jIGV4dGVuZHMgUGFjayB7XG4gICAgc3luYyA9IHRydWU7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IHdyaXRlX2VudHJ5X2pzXzEuV3JpdGVFbnRyeVN5bmM7XG4gICAgfVxuICAgIC8vIHBhdXNlL3Jlc3VtZSBhcmUgbm8tb3BzIGluIHN5bmMgc3RyZWFtcy5cbiAgICBwYXVzZSgpIHsgfVxuICAgIHJlc3VtZSgpIHsgfVxuICAgIFtTVEFUXShqb2IpIHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXRTeW5jJyA6ICdsc3RhdFN5bmMnO1xuICAgICAgICB0aGlzW09OU1RBVF0oam9iLCBmc18xLmRlZmF1bHRbc3RhdF0oam9iLmFic29sdXRlKSk7XG4gICAgfVxuICAgIFtSRUFERElSXShqb2IpIHtcbiAgICAgICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZnNfMS5kZWZhdWx0LnJlYWRkaXJTeW5jKGpvYi5hYnNvbHV0ZSkpO1xuICAgIH1cbiAgICAvLyBnb3R0YSBnZXQgaXQgYWxsIGluIHRoaXMgdGlja1xuICAgIFtQSVBFXShqb2IpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5O1xuICAgICAgICBjb25zdCB6aXAgPSB0aGlzLnppcDtcbiAgICAgICAgaWYgKGpvYi5yZWFkZGlyKSB7XG4gICAgICAgICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gam9iLnBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpO1xuICAgICAgICAgICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBpcGUgd2l0aG91dCBzb3VyY2UnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHppcCkge1xuICAgICAgICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIHppcC53cml0ZShjaHVuayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICBzdXBlcltXUklURV0oY2h1bmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhY2tTeW5jID0gUGFja1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/pack.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/parse.js":
/*!*************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/parse.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst minizlib_1 = __webpack_require__(/*! minizlib */ \"./node_modules/tar/node_modules/minizlib/dist/commonjs/index.js\");\nconst yallist_1 = __webpack_require__(/*! yallist */ \"./node_modules/tar/node_modules/yallist/dist/commonjs/index.js\");\nconst header_js_1 = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/dist/commonjs/header.js\");\nconst pax_js_1 = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/dist/commonjs/pax.js\");\nconst read_entry_js_1 = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/dist/commonjs/read-entry.js\");\nconst warn_method_js_1 = __webpack_require__(/*! ./warn-method.js */ \"./node_modules/tar/dist/commonjs/warn-method.js\");\nconst maxMetaEntrySize = 1024 * 1024;\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\nconst CLOSESTREAM = Symbol('closeStream');\nconst noop = () => true;\nclass Parser extends events_1.EventEmitter {\n    file;\n    strict;\n    maxMetaEntrySize;\n    filter;\n    brotli;\n    writable = true;\n    readable = false;\n    [QUEUE] = new yallist_1.Yallist();\n    [BUFFER];\n    [READENTRY];\n    [WRITEENTRY];\n    [STATE] = 'begin';\n    [META] = '';\n    [EX];\n    [GEX];\n    [ENDED] = false;\n    [UNZIP];\n    [ABORTED] = false;\n    [SAW_VALID_ENTRY];\n    [SAW_NULL_BLOCK] = false;\n    [SAW_EOF] = false;\n    [WRITING] = false;\n    [CONSUMING] = false;\n    [EMITTEDEND] = false;\n    constructor(opt = {}) {\n        super();\n        this.file = opt.file || '';\n        // these BADARCHIVE errors can't be detected early. listen on DONE.\n        this.on(DONE, () => {\n            if (this[STATE] === 'begin' ||\n                this[SAW_VALID_ENTRY] === false) {\n                // either less than 1 block of data, or all entries were invalid.\n                // Either way, probably not even a tarball.\n                this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n            }\n        });\n        if (opt.ondone) {\n            this.on(DONE, opt.ondone);\n        }\n        else {\n            this.on(DONE, () => {\n                this.emit('prefinish');\n                this.emit('finish');\n                this.emit('end');\n            });\n        }\n        this.strict = !!opt.strict;\n        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n        this.filter = typeof opt.filter === 'function' ? opt.filter : noop;\n        // Unlike gzip, brotli doesn't have any magic bytes to identify it\n        // Users need to explicitly tell us they're extracting a brotli file\n        // Or we infer from the file extension\n        const isTBR = opt.file &&\n            (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'));\n        // if it's a tbr file it MIGHT be brotli, but we don't know until\n        // we look at it and verify it's not a valid tar file.\n        this.brotli =\n            !opt.gzip && opt.brotli !== undefined ? opt.brotli\n                : isTBR ? undefined\n                    : false;\n        // have to set this so that streams are ok piping into it\n        this.on('end', () => this[CLOSESTREAM]());\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        if (typeof opt.onReadEntry === 'function') {\n            this.on('entry', opt.onReadEntry);\n        }\n    }\n    warn(code, message, data = {}) {\n        (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    [CONSUMEHEADER](chunk, position) {\n        if (this[SAW_VALID_ENTRY] === undefined) {\n            this[SAW_VALID_ENTRY] = false;\n        }\n        let header;\n        try {\n            header = new header_js_1.Header(chunk, position, this[EX], this[GEX]);\n        }\n        catch (er) {\n            return this.warn('TAR_ENTRY_INVALID', er);\n        }\n        if (header.nullBlock) {\n            if (this[SAW_NULL_BLOCK]) {\n                this[SAW_EOF] = true;\n                // ending an archive with no entries.  pointless, but legal.\n                if (this[STATE] === 'begin') {\n                    this[STATE] = 'header';\n                }\n                this[EMIT]('eof');\n            }\n            else {\n                this[SAW_NULL_BLOCK] = true;\n                this[EMIT]('nullBlock');\n            }\n        }\n        else {\n            this[SAW_NULL_BLOCK] = false;\n            if (!header.cksumValid) {\n                this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header });\n            }\n            else if (!header.path) {\n                this.warn('TAR_ENTRY_INVALID', 'path is required', { header });\n            }\n            else {\n                const type = header.type;\n                if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n                        header,\n                    });\n                }\n                else if (!/^(Symbolic)?Link$/.test(type) &&\n                    !/^(Global)?ExtendedHeader$/.test(type) &&\n                    header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n                        header,\n                    });\n                }\n                else {\n                    const entry = (this[WRITEENTRY] = new read_entry_js_1.ReadEntry(header, this[EX], this[GEX]));\n                    // we do this for meta & ignored entries as well, because they\n                    // are still valid tar, or else we wouldn't know to ignore them\n                    if (!this[SAW_VALID_ENTRY]) {\n                        if (entry.remain) {\n                            // this might be the one!\n                            const onend = () => {\n                                if (!entry.invalid) {\n                                    this[SAW_VALID_ENTRY] = true;\n                                }\n                            };\n                            entry.on('end', onend);\n                        }\n                        else {\n                            this[SAW_VALID_ENTRY] = true;\n                        }\n                    }\n                    if (entry.meta) {\n                        if (entry.size > this.maxMetaEntrySize) {\n                            entry.ignore = true;\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = 'ignore';\n                            entry.resume();\n                        }\n                        else if (entry.size > 0) {\n                            this[META] = '';\n                            entry.on('data', c => (this[META] += c));\n                            this[STATE] = 'meta';\n                        }\n                    }\n                    else {\n                        this[EX] = undefined;\n                        entry.ignore =\n                            entry.ignore || !this.filter(entry.path, entry);\n                        if (entry.ignore) {\n                            // probably valid, just not something we care about\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = entry.remain ? 'ignore' : 'header';\n                            entry.resume();\n                        }\n                        else {\n                            if (entry.remain) {\n                                this[STATE] = 'body';\n                            }\n                            else {\n                                this[STATE] = 'header';\n                                entry.end();\n                            }\n                            if (!this[READENTRY]) {\n                                this[QUEUE].push(entry);\n                                this[NEXTENTRY]();\n                            }\n                            else {\n                                this[QUEUE].push(entry);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    [CLOSESTREAM]() {\n        queueMicrotask(() => this.emit('close'));\n    }\n    [PROCESSENTRY](entry) {\n        let go = true;\n        if (!entry) {\n            this[READENTRY] = undefined;\n            go = false;\n        }\n        else if (Array.isArray(entry)) {\n            const [ev, ...args] = entry;\n            this.emit(ev, ...args);\n        }\n        else {\n            this[READENTRY] = entry;\n            this.emit('entry', entry);\n            if (!entry.emittedEnd) {\n                entry.on('end', () => this[NEXTENTRY]());\n                go = false;\n            }\n        }\n        return go;\n    }\n    [NEXTENTRY]() {\n        do { } while (this[PROCESSENTRY](this[QUEUE].shift()));\n        if (!this[QUEUE].length) {\n            // At this point, there's nothing in the queue, but we may have an\n            // entry which is being consumed (readEntry).\n            // If we don't, then we definitely can handle more data.\n            // If we do, and either it's flowing, or it has never had any data\n            // written to it, then it needs more.\n            // The only other possibility is that it has returned false from a\n            // write() call, so we wait for the next drain to continue.\n            const re = this[READENTRY];\n            const drainNow = !re || re.flowing || re.size === re.remain;\n            if (drainNow) {\n                if (!this[WRITING]) {\n                    this.emit('drain');\n                }\n            }\n            else {\n                re.once('drain', () => this.emit('drain'));\n            }\n        }\n    }\n    [CONSUMEBODY](chunk, position) {\n        // write up to but no  more than writeEntry.blockRemain\n        const entry = this[WRITEENTRY];\n        /* c8 ignore start */\n        if (!entry) {\n            throw new Error('attempt to consume body without entry??');\n        }\n        const br = entry.blockRemain ?? 0;\n        /* c8 ignore stop */\n        const c = br >= chunk.length && position === 0 ?\n            chunk\n            : chunk.subarray(position, position + br);\n        entry.write(c);\n        if (!entry.blockRemain) {\n            this[STATE] = 'header';\n            this[WRITEENTRY] = undefined;\n            entry.end();\n        }\n        return c.length;\n    }\n    [CONSUMEMETA](chunk, position) {\n        const entry = this[WRITEENTRY];\n        const ret = this[CONSUMEBODY](chunk, position);\n        // if we finished, then the entry is reset\n        if (!this[WRITEENTRY] && entry) {\n            this[EMITMETA](entry);\n        }\n        return ret;\n    }\n    [EMIT](ev, data, extra) {\n        if (!this[QUEUE].length && !this[READENTRY]) {\n            this.emit(ev, data, extra);\n        }\n        else {\n            this[QUEUE].push([ev, data, extra]);\n        }\n    }\n    [EMITMETA](entry) {\n        this[EMIT]('meta', this[META]);\n        switch (entry.type) {\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this[EX] = pax_js_1.Pax.parse(this[META], this[EX], false);\n                break;\n            case 'GlobalExtendedHeader':\n                this[GEX] = pax_js_1.Pax.parse(this[META], this[GEX], true);\n                break;\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath': {\n                const ex = this[EX] ?? Object.create(null);\n                this[EX] = ex;\n                ex.path = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            case 'NextFileHasLongLinkpath': {\n                const ex = this[EX] || Object.create(null);\n                this[EX] = ex;\n                ex.linkpath = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            /* c8 ignore start */\n            default:\n                throw new Error('unknown meta: ' + entry.type);\n            /* c8 ignore stop */\n        }\n    }\n    abort(error) {\n        this[ABORTED] = true;\n        this.emit('abort', error);\n        // always throws, even in non-strict mode\n        this.warn('TAR_ABORT', error, { recoverable: false });\n    }\n    write(chunk, encoding, cb) {\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, \n            /* c8 ignore next */\n            typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        if (this[ABORTED]) {\n            /* c8 ignore next */\n            cb?.();\n            return false;\n        }\n        // first write, might be gzipped\n        const needSniff = this[UNZIP] === undefined ||\n            (this.brotli === undefined && this[UNZIP] === false);\n        if (needSniff && chunk) {\n            if (this[BUFFER]) {\n                chunk = Buffer.concat([this[BUFFER], chunk]);\n                this[BUFFER] = undefined;\n            }\n            if (chunk.length < gzipHeader.length) {\n                this[BUFFER] = chunk;\n                /* c8 ignore next */\n                cb?.();\n                return true;\n            }\n            // look for gzip header\n            for (let i = 0; this[UNZIP] === undefined && i < gzipHeader.length; i++) {\n                if (chunk[i] !== gzipHeader[i]) {\n                    this[UNZIP] = false;\n                }\n            }\n            const maybeBrotli = this.brotli === undefined;\n            if (this[UNZIP] === false && maybeBrotli) {\n                // read the first header to see if it's a valid tar file. If so,\n                // we can safely assume that it's not actually brotli, despite the\n                // .tbr or .tar.br file extension.\n                // if we ended before getting a full chunk, yes, def brotli\n                if (chunk.length < 512) {\n                    if (this[ENDED]) {\n                        this.brotli = true;\n                    }\n                    else {\n                        this[BUFFER] = chunk;\n                        /* c8 ignore next */\n                        cb?.();\n                        return true;\n                    }\n                }\n                else {\n                    // if it's tar, it's pretty reliably not brotli, chances of\n                    // that happening are astronomical.\n                    try {\n                        new header_js_1.Header(chunk.subarray(0, 512));\n                        this.brotli = false;\n                    }\n                    catch (_) {\n                        this.brotli = true;\n                    }\n                }\n            }\n            if (this[UNZIP] === undefined ||\n                (this[UNZIP] === false && this.brotli)) {\n                const ended = this[ENDED];\n                this[ENDED] = false;\n                this[UNZIP] =\n                    this[UNZIP] === undefined ?\n                        new minizlib_1.Unzip({})\n                        : new minizlib_1.BrotliDecompress({});\n                this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n                this[UNZIP].on('error', er => this.abort(er));\n                this[UNZIP].on('end', () => {\n                    this[ENDED] = true;\n                    this[CONSUMECHUNK]();\n                });\n                this[WRITING] = true;\n                const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk);\n                this[WRITING] = false;\n                cb?.();\n                return ret;\n            }\n        }\n        this[WRITING] = true;\n        if (this[UNZIP]) {\n            this[UNZIP].write(chunk);\n        }\n        else {\n            this[CONSUMECHUNK](chunk);\n        }\n        this[WRITING] = false;\n        // return false if there's a queue, or if the current entry isn't flowing\n        const ret = this[QUEUE].length ? false\n            : this[READENTRY] ? this[READENTRY].flowing\n                : true;\n        // if we have no queue, then that means a clogged READENTRY\n        if (!ret && !this[QUEUE].length) {\n            this[READENTRY]?.once('drain', () => this.emit('drain'));\n        }\n        /* c8 ignore next */\n        cb?.();\n        return ret;\n    }\n    [BUFFERCONCAT](c) {\n        if (c && !this[ABORTED]) {\n            this[BUFFER] =\n                this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n        }\n    }\n    [MAYBEEND]() {\n        if (this[ENDED] &&\n            !this[EMITTEDEND] &&\n            !this[ABORTED] &&\n            !this[CONSUMING]) {\n            this[EMITTEDEND] = true;\n            const entry = this[WRITEENTRY];\n            if (entry && entry.blockRemain) {\n                // truncated, likely a damaged file\n                const have = this[BUFFER] ? this[BUFFER].length : 0;\n                this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });\n                if (this[BUFFER]) {\n                    entry.write(this[BUFFER]);\n                }\n                entry.end();\n            }\n            this[EMIT](DONE);\n        }\n    }\n    [CONSUMECHUNK](chunk) {\n        if (this[CONSUMING] && chunk) {\n            this[BUFFERCONCAT](chunk);\n        }\n        else if (!chunk && !this[BUFFER]) {\n            this[MAYBEEND]();\n        }\n        else if (chunk) {\n            this[CONSUMING] = true;\n            if (this[BUFFER]) {\n                this[BUFFERCONCAT](chunk);\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            else {\n                this[CONSUMECHUNKSUB](chunk);\n            }\n            while (this[BUFFER] &&\n                this[BUFFER]?.length >= 512 &&\n                !this[ABORTED] &&\n                !this[SAW_EOF]) {\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            this[CONSUMING] = false;\n        }\n        if (!this[BUFFER] || this[ENDED]) {\n            this[MAYBEEND]();\n        }\n    }\n    [CONSUMECHUNKSUB](chunk) {\n        // we know that we are in CONSUMING mode, so anything written goes into\n        // the buffer.  Advance the position and put any remainder in the buffer.\n        let position = 0;\n        const length = chunk.length;\n        while (position + 512 <= length &&\n            !this[ABORTED] &&\n            !this[SAW_EOF]) {\n            switch (this[STATE]) {\n                case 'begin':\n                case 'header':\n                    this[CONSUMEHEADER](chunk, position);\n                    position += 512;\n                    break;\n                case 'ignore':\n                case 'body':\n                    position += this[CONSUMEBODY](chunk, position);\n                    break;\n                case 'meta':\n                    position += this[CONSUMEMETA](chunk, position);\n                    break;\n                /* c8 ignore start */\n                default:\n                    throw new Error('invalid state: ' + this[STATE]);\n                /* c8 ignore stop */\n            }\n        }\n        if (position < length) {\n            if (this[BUFFER]) {\n                this[BUFFER] = Buffer.concat([\n                    chunk.subarray(position),\n                    this[BUFFER],\n                ]);\n            }\n            else {\n                this[BUFFER] = chunk.subarray(position);\n            }\n        }\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (cb)\n            this.once('finish', cb);\n        if (!this[ABORTED]) {\n            if (this[UNZIP]) {\n                /* c8 ignore start */\n                if (chunk)\n                    this[UNZIP].write(chunk);\n                /* c8 ignore stop */\n                this[UNZIP].end();\n            }\n            else {\n                this[ENDED] = true;\n                if (this.brotli === undefined)\n                    chunk = chunk || Buffer.alloc(0);\n                if (chunk)\n                    this.write(chunk);\n                this[MAYBEEND]();\n            }\n        }\n        return this;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQVU7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQVM7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsK0RBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMseURBQVU7QUFDbkMsd0JBQXdCLG1CQUFPLENBQUMsdUVBQWlCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLHlFQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvREFBb0Q7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG1CQUFtQixtQkFBbUIsTUFBTSxlQUFlLE9BQU87QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGFyc2UuanM/MzgyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHRoaXNbQlVGRkVSXSBpcyB0aGUgcmVtYWluZGVyIG9mIGEgY2h1bmsgaWYgd2UncmUgd2FpdGluZyBmb3Jcbi8vIHRoZSBmdWxsIDUxMiBieXRlcyBvZiBhIGhlYWRlciB0byBjb21lIGluLiAgV2Ugd2lsbCBCdWZmZXIuY29uY2F0KClcbi8vIGl0IHRvIHRoZSBuZXh0IHdyaXRlKCksIHdoaWNoIGlzIGEgbWVtIGNvcHksIGJ1dCBhIHNtYWxsIG9uZS5cbi8vXG4vLyB0aGlzW1FVRVVFXSBpcyBhIFlhbGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkXG4vLyB5ZXQgdGhpcyBjYW4gb25seSBnZXQgZmlsbGVkIHVwIGlmIHRoZSB1c2VyIGtlZXBzIHdyaXRlKClpbmcgYWZ0ZXJcbi8vIGEgd3JpdGUoKSByZXR1cm5zIGZhbHNlLCBvciBkb2VzIGEgd3JpdGUoKSB3aXRoIG1vcmUgdGhhbiBvbmUgZW50cnlcbi8vXG4vLyBXZSBkb24ndCBidWZmZXIgY2h1bmtzLCB3ZSBhbHdheXMgcGFyc2UgdGhlbSBhbmQgZWl0aGVyIGNyZWF0ZSBhblxuLy8gZW50cnksIG9yIHB1c2ggaXQgaW50byB0aGUgYWN0aXZlIGVudHJ5LiAgVGhlIFJlYWRFbnRyeSBjbGFzcyBrbm93c1xuLy8gdG8gdGhyb3cgZGF0YSBhd2F5IGlmIC5pZ25vcmU9dHJ1ZVxuLy9cbi8vIFNoaWZ0IGVudHJ5IG9mZiB0aGUgYnVmZmVyIHdoZW4gaXQgZW1pdHMgJ2VuZCcsIGFuZCBlbWl0ICdlbnRyeScgZm9yXG4vLyB0aGUgbmV4dCBvbmUgaW4gdGhlIGxpc3QuXG4vL1xuLy8gQXQgYW55IHRpbWUsIHdlJ3JlIHB1c2hpbmcgYm9keSBjaHVua3MgaW50byB0aGUgZW50cnkgYXQgV1JJVEVFTlRSWSxcbi8vIGFuZCB3YWl0aW5nIGZvciAnZW5kJyBvbiB0aGUgZW50cnkgYXQgUkVBREVOVFJZXG4vL1xuLy8gaWdub3JlZCBlbnRyaWVzIGdldCAucmVzdW1lKCkgY2FsbGVkIG9uIHRoZW0gc3RyYWlnaHQgYXdheVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBtaW5pemxpYl8xID0gcmVxdWlyZShcIm1pbml6bGliXCIpO1xuY29uc3QgeWFsbGlzdF8xID0gcmVxdWlyZShcInlhbGxpc3RcIik7XG5jb25zdCBoZWFkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2hlYWRlci5qc1wiKTtcbmNvbnN0IHBheF9qc18xID0gcmVxdWlyZShcIi4vcGF4LmpzXCIpO1xuY29uc3QgcmVhZF9lbnRyeV9qc18xID0gcmVxdWlyZShcIi4vcmVhZC1lbnRyeS5qc1wiKTtcbmNvbnN0IHdhcm5fbWV0aG9kX2pzXzEgPSByZXF1aXJlKFwiLi93YXJuLW1ldGhvZC5qc1wiKTtcbmNvbnN0IG1heE1ldGFFbnRyeVNpemUgPSAxMDI0ICogMTAyNDtcbmNvbnN0IGd6aXBIZWFkZXIgPSBCdWZmZXIuZnJvbShbMHgxZiwgMHg4Yl0pO1xuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJyk7XG5jb25zdCBXUklURUVOVFJZID0gU3ltYm9sKCd3cml0ZUVudHJ5Jyk7XG5jb25zdCBSRUFERU5UUlkgPSBTeW1ib2woJ3JlYWRFbnRyeScpO1xuY29uc3QgTkVYVEVOVFJZID0gU3ltYm9sKCduZXh0RW50cnknKTtcbmNvbnN0IFBST0NFU1NFTlRSWSA9IFN5bWJvbCgncHJvY2Vzc0VudHJ5Jyk7XG5jb25zdCBFWCA9IFN5bWJvbCgnZXh0ZW5kZWRIZWFkZXInKTtcbmNvbnN0IEdFWCA9IFN5bWJvbCgnZ2xvYmFsRXh0ZW5kZWRIZWFkZXInKTtcbmNvbnN0IE1FVEEgPSBTeW1ib2woJ21ldGEnKTtcbmNvbnN0IEVNSVRNRVRBID0gU3ltYm9sKCdlbWl0TWV0YScpO1xuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKTtcbmNvbnN0IFFVRVVFID0gU3ltYm9sKCdxdWV1ZScpO1xuY29uc3QgRU5ERUQgPSBTeW1ib2woJ2VuZGVkJyk7XG5jb25zdCBFTUlUVEVERU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJyk7XG5jb25zdCBFTUlUID0gU3ltYm9sKCdlbWl0Jyk7XG5jb25zdCBVTlpJUCA9IFN5bWJvbCgndW56aXAnKTtcbmNvbnN0IENPTlNVTUVDSFVOSyA9IFN5bWJvbCgnY29uc3VtZUNodW5rJyk7XG5jb25zdCBDT05TVU1FQ0hVTktTVUIgPSBTeW1ib2woJ2NvbnN1bWVDaHVua1N1YicpO1xuY29uc3QgQ09OU1VNRUJPRFkgPSBTeW1ib2woJ2NvbnN1bWVCb2R5Jyk7XG5jb25zdCBDT05TVU1FTUVUQSA9IFN5bWJvbCgnY29uc3VtZU1ldGEnKTtcbmNvbnN0IENPTlNVTUVIRUFERVIgPSBTeW1ib2woJ2NvbnN1bWVIZWFkZXInKTtcbmNvbnN0IENPTlNVTUlORyA9IFN5bWJvbCgnY29uc3VtaW5nJyk7XG5jb25zdCBCVUZGRVJDT05DQVQgPSBTeW1ib2woJ2J1ZmZlckNvbmNhdCcpO1xuY29uc3QgTUFZQkVFTkQgPSBTeW1ib2woJ21heWJlRW5kJyk7XG5jb25zdCBXUklUSU5HID0gU3ltYm9sKCd3cml0aW5nJyk7XG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJyk7XG5jb25zdCBET05FID0gU3ltYm9sKCdvbkRvbmUnKTtcbmNvbnN0IFNBV19WQUxJRF9FTlRSWSA9IFN5bWJvbCgnc2F3VmFsaWRFbnRyeScpO1xuY29uc3QgU0FXX05VTExfQkxPQ0sgPSBTeW1ib2woJ3Nhd051bGxCbG9jaycpO1xuY29uc3QgU0FXX0VPRiA9IFN5bWJvbCgnc2F3RU9GJyk7XG5jb25zdCBDTE9TRVNUUkVBTSA9IFN5bWJvbCgnY2xvc2VTdHJlYW0nKTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB0cnVlO1xuY2xhc3MgUGFyc2VyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBmaWxlO1xuICAgIHN0cmljdDtcbiAgICBtYXhNZXRhRW50cnlTaXplO1xuICAgIGZpbHRlcjtcbiAgICBicm90bGk7XG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgW1FVRVVFXSA9IG5ldyB5YWxsaXN0XzEuWWFsbGlzdCgpO1xuICAgIFtCVUZGRVJdO1xuICAgIFtSRUFERU5UUlldO1xuICAgIFtXUklURUVOVFJZXTtcbiAgICBbU1RBVEVdID0gJ2JlZ2luJztcbiAgICBbTUVUQV0gPSAnJztcbiAgICBbRVhdO1xuICAgIFtHRVhdO1xuICAgIFtFTkRFRF0gPSBmYWxzZTtcbiAgICBbVU5aSVBdO1xuICAgIFtBQk9SVEVEXSA9IGZhbHNlO1xuICAgIFtTQVdfVkFMSURfRU5UUlldO1xuICAgIFtTQVdfTlVMTF9CTE9DS10gPSBmYWxzZTtcbiAgICBbU0FXX0VPRl0gPSBmYWxzZTtcbiAgICBbV1JJVElOR10gPSBmYWxzZTtcbiAgICBbQ09OU1VNSU5HXSA9IGZhbHNlO1xuICAgIFtFTUlUVEVERU5EXSA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKG9wdCA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmlsZSA9IG9wdC5maWxlIHx8ICcnO1xuICAgICAgICAvLyB0aGVzZSBCQURBUkNISVZFIGVycm9ycyBjYW4ndCBiZSBkZXRlY3RlZCBlYXJseS4gbGlzdGVuIG9uIERPTkUuXG4gICAgICAgIHRoaXMub24oRE9ORSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXNbU1RBVEVdID09PSAnYmVnaW4nIHx8XG4gICAgICAgICAgICAgICAgdGhpc1tTQVdfVkFMSURfRU5UUlldID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciBsZXNzIHRoYW4gMSBibG9jayBvZiBkYXRhLCBvciBhbGwgZW50cmllcyB3ZXJlIGludmFsaWQuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHdheSwgcHJvYmFibHkgbm90IGV2ZW4gYSB0YXJiYWxsLlxuICAgICAgICAgICAgICAgIHRoaXMud2FybignVEFSX0JBRF9BUkNISVZFJywgJ1VucmVjb2duaXplZCBhcmNoaXZlIGZvcm1hdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdC5vbmRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMub24oRE9ORSwgb3B0Lm9uZG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uKERPTkUsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gISFvcHQuc3RyaWN0O1xuICAgICAgICB0aGlzLm1heE1ldGFFbnRyeVNpemUgPSBvcHQubWF4TWV0YUVudHJ5U2l6ZSB8fCBtYXhNZXRhRW50cnlTaXplO1xuICAgICAgICB0aGlzLmZpbHRlciA9IHR5cGVvZiBvcHQuZmlsdGVyID09PSAnZnVuY3Rpb24nID8gb3B0LmZpbHRlciA6IG5vb3A7XG4gICAgICAgIC8vIFVubGlrZSBnemlwLCBicm90bGkgZG9lc24ndCBoYXZlIGFueSBtYWdpYyBieXRlcyB0byBpZGVudGlmeSBpdFxuICAgICAgICAvLyBVc2VycyBuZWVkIHRvIGV4cGxpY2l0bHkgdGVsbCB1cyB0aGV5J3JlIGV4dHJhY3RpbmcgYSBicm90bGkgZmlsZVxuICAgICAgICAvLyBPciB3ZSBpbmZlciBmcm9tIHRoZSBmaWxlIGV4dGVuc2lvblxuICAgICAgICBjb25zdCBpc1RCUiA9IG9wdC5maWxlICYmXG4gICAgICAgICAgICAob3B0LmZpbGUuZW5kc1dpdGgoJy50YXIuYnInKSB8fCBvcHQuZmlsZS5lbmRzV2l0aCgnLnRicicpKTtcbiAgICAgICAgLy8gaWYgaXQncyBhIHRiciBmaWxlIGl0IE1JR0hUIGJlIGJyb3RsaSwgYnV0IHdlIGRvbid0IGtub3cgdW50aWxcbiAgICAgICAgLy8gd2UgbG9vayBhdCBpdCBhbmQgdmVyaWZ5IGl0J3Mgbm90IGEgdmFsaWQgdGFyIGZpbGUuXG4gICAgICAgIHRoaXMuYnJvdGxpID1cbiAgICAgICAgICAgICFvcHQuZ3ppcCAmJiBvcHQuYnJvdGxpICE9PSB1bmRlZmluZWQgPyBvcHQuYnJvdGxpXG4gICAgICAgICAgICAgICAgOiBpc1RCUiA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAvLyBoYXZlIHRvIHNldCB0aGlzIHNvIHRoYXQgc3RyZWFtcyBhcmUgb2sgcGlwaW5nIGludG8gaXRcbiAgICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gdGhpc1tDTE9TRVNUUkVBTV0oKSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0Lm9uUmVhZEVudHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCdlbnRyeScsIG9wdC5vblJlYWRFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fybihjb2RlLCBtZXNzYWdlLCBkYXRhID0ge30pIHtcbiAgICAgICAgKDAsIHdhcm5fbWV0aG9kX2pzXzEud2Fybk1ldGhvZCkodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIFtDT05TVU1FSEVBREVSXShjaHVuaywgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGVhZGVyID0gbmV3IGhlYWRlcl9qc18xLkhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FybignVEFSX0VOVFJZX0lOVkFMSUQnLCBlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci5udWxsQmxvY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzW1NBV19OVUxMX0JMT0NLXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbU0FXX0VPRl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbiBhcmNoaXZlIHdpdGggbm8gZW50cmllcy4gIHBvaW50bGVzcywgYnV0IGxlZ2FsLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzW1NUQVRFXSA9PT0gJ2JlZ2luJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdoZWFkZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW0VNSVRdKCdlb2YnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbU0FXX05VTExfQkxPQ0tdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzW0VNSVRdKCdudWxsQmxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbU0FXX05VTExfQkxPQ0tdID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWhlYWRlci5ja3N1bVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdjaGVja3N1bSBmYWlsdXJlJywgeyBoZWFkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaGVhZGVyLnBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ3BhdGggaXMgcmVxdWlyZWQnLCB7IGhlYWRlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmICFoZWFkZXIubGlua3BhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdsaW5rcGF0aCByZXF1aXJlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEvXihTeW1ib2xpYyk/TGluayQvLnRlc3QodHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIS9eKEdsb2JhbCk/RXh0ZW5kZWRIZWFkZXIkLy50ZXN0KHR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlci5saW5rcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2xpbmtwYXRoIGZvcmJpZGRlbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9ICh0aGlzW1dSSVRFRU5UUlldID0gbmV3IHJlYWRfZW50cnlfanNfMS5SZWFkRW50cnkoaGVhZGVyLCB0aGlzW0VYXSwgdGhpc1tHRVhdKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIHRoaXMgZm9yIG1ldGEgJiBpZ25vcmVkIGVudHJpZXMgYXMgd2VsbCwgYmVjYXVzZSB0aGV5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSBzdGlsbCB2YWxpZCB0YXIsIG9yIGVsc2Ugd2Ugd291bGRuJ3Qga25vdyB0byBpZ25vcmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbU0FXX1ZBTElEX0VOVFJZXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgdGhlIG9uZSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnRyeS5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tTQVdfVkFMSURfRU5UUlldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnNpemUgPiB0aGlzLm1heE1ldGFFbnRyeVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbRU1JVF0oJ2lnbm9yZWRFbnRyeScsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdpZ25vcmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW01FVEFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkub24oJ2RhdGEnLCBjID0+ICh0aGlzW01FVEFdICs9IGMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdtZXRhJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbRVhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuaWdub3JlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5pZ25vcmUgfHwgIXRoaXMuZmlsdGVyKGVudHJ5LnBhdGgsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSB2YWxpZCwganVzdCBub3Qgc29tZXRoaW5nIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW0VNSVRdKCdpZ25vcmVkRW50cnknLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSBlbnRyeS5yZW1haW4gPyAnaWdub3JlJyA6ICdoZWFkZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdib2R5JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2hlYWRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0NMT1NFU1RSRUFNXSgpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTtcbiAgICB9XG4gICAgW1BST0NFU1NFTlRSWV0oZW50cnkpIHtcbiAgICAgICAgbGV0IGdvID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgdGhpc1tSRUFERU5UUlldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZ28gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgY29uc3QgW2V2LCAuLi5hcmdzXSA9IGVudHJ5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbUkVBREVOVFJZXSA9IGVudHJ5O1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbnRyeScsIGVudHJ5KTtcbiAgICAgICAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICAgICAgICAgIGVudHJ5Lm9uKCdlbmQnLCAoKSA9PiB0aGlzW05FWFRFTlRSWV0oKSk7XG4gICAgICAgICAgICAgICAgZ28gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ287XG4gICAgfVxuICAgIFtORVhURU5UUlldKCkge1xuICAgICAgICBkbyB7IH0gd2hpbGUgKHRoaXNbUFJPQ0VTU0VOVFJZXSh0aGlzW1FVRVVFXS5zaGlmdCgpKSk7XG4gICAgICAgIGlmICghdGhpc1tRVUVVRV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHF1ZXVlLCBidXQgd2UgbWF5IGhhdmUgYW5cbiAgICAgICAgICAgIC8vIGVudHJ5IHdoaWNoIGlzIGJlaW5nIGNvbnN1bWVkIChyZWFkRW50cnkpLlxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QsIHRoZW4gd2UgZGVmaW5pdGVseSBjYW4gaGFuZGxlIG1vcmUgZGF0YS5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvLCBhbmQgZWl0aGVyIGl0J3MgZmxvd2luZywgb3IgaXQgaGFzIG5ldmVyIGhhZCBhbnkgZGF0YVxuICAgICAgICAgICAgLy8gd3JpdHRlbiB0byBpdCwgdGhlbiBpdCBuZWVkcyBtb3JlLlxuICAgICAgICAgICAgLy8gVGhlIG9ubHkgb3RoZXIgcG9zc2liaWxpdHkgaXMgdGhhdCBpdCBoYXMgcmV0dXJuZWQgZmFsc2UgZnJvbSBhXG4gICAgICAgICAgICAvLyB3cml0ZSgpIGNhbGwsIHNvIHdlIHdhaXQgZm9yIHRoZSBuZXh0IGRyYWluIHRvIGNvbnRpbnVlLlxuICAgICAgICAgICAgY29uc3QgcmUgPSB0aGlzW1JFQURFTlRSWV07XG4gICAgICAgICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpbjtcbiAgICAgICAgICAgIGlmIChkcmFpbk5vdykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc1tXUklUSU5HXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmUub25jZSgnZHJhaW4nLCAoKSA9PiB0aGlzLmVtaXQoJ2RyYWluJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFtDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIHdyaXRlIHVwIHRvIGJ1dCBubyAgbW9yZSB0aGFuIHdyaXRlRW50cnkuYmxvY2tSZW1haW5cbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0IHRvIGNvbnN1bWUgYm9keSB3aXRob3V0IGVudHJ5Pz8nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiciA9IGVudHJ5LmJsb2NrUmVtYWluID8/IDA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGMgPSBiciA+PSBjaHVuay5sZW5ndGggJiYgcG9zaXRpb24gPT09IDAgP1xuICAgICAgICAgICAgY2h1bmtcbiAgICAgICAgICAgIDogY2h1bmsuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYnIpO1xuICAgICAgICBlbnRyeS53cml0ZShjKTtcbiAgICAgICAgaWYgKCFlbnRyeS5ibG9ja1JlbWFpbikge1xuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJztcbiAgICAgICAgICAgIHRoaXNbV1JJVEVFTlRSWV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlbnRyeS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYy5sZW5ndGg7XG4gICAgfVxuICAgIFtDT05TVU1FTUVUQV0oY2h1bmssIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXTtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKTtcbiAgICAgICAgLy8gaWYgd2UgZmluaXNoZWQsIHRoZW4gdGhlIGVudHJ5IGlzIHJlc2V0XG4gICAgICAgIGlmICghdGhpc1tXUklURUVOVFJZXSAmJiBlbnRyeSkge1xuICAgICAgICAgICAgdGhpc1tFTUlUTUVUQV0oZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlUXShldiwgZGF0YSwgZXh0cmEpIHtcbiAgICAgICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCBkYXRhLCBleHRyYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKFtldiwgZGF0YSwgZXh0cmFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbRU1JVE1FVEFdKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbRU1JVF0oJ21ldGEnLCB0aGlzW01FVEFdKTtcbiAgICAgICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgICAgICBjYXNlICdPbGRFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgICAgICAgICAgdGhpc1tFWF0gPSBwYXhfanNfMS5QYXgucGFyc2UodGhpc1tNRVRBXSwgdGhpc1tFWF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzW0dFWF0gPSBwYXhfanNfMS5QYXgucGFyc2UodGhpc1tNRVRBXSwgdGhpc1tHRVhdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ1BhdGgnOlxuICAgICAgICAgICAgY2FzZSAnT2xkR251TG9uZ1BhdGgnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXggPSB0aGlzW0VYXSA/PyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXNbRVhdID0gZXg7XG4gICAgICAgICAgICAgICAgZXgucGF0aCA9IHRoaXNbTUVUQV0ucmVwbGFjZSgvXFwwLiovLCAnJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleCA9IHRoaXNbRVhdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpc1tFWF0gPSBleDtcbiAgICAgICAgICAgICAgICBleC5saW5rcGF0aCA9IHRoaXNbTUVUQV0ucmVwbGFjZSgvXFwwLiovLCAnJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1ldGE6ICcgKyBlbnRyeS50eXBlKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJvcnQoZXJyb3IpIHtcbiAgICAgICAgdGhpc1tBQk9SVEVEXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnYWJvcnQnLCBlcnJvcik7XG4gICAgICAgIC8vIGFsd2F5cyB0aHJvd3MsIGV2ZW4gaW4gbm9uLXN0cmljdCBtb2RlXG4gICAgICAgIHRoaXMud2FybignVEFSX0FCT1JUJywgZXJyb3IsIHsgcmVjb3ZlcmFibGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyA/IGVuY29kaW5nIDogJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1tBQk9SVEVEXSkge1xuICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGNiPy4oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJzdCB3cml0ZSwgbWlnaHQgYmUgZ3ppcHBlZFxuICAgICAgICBjb25zdCBuZWVkU25pZmYgPSB0aGlzW1VOWklQXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAodGhpcy5icm90bGkgPT09IHVuZGVmaW5lZCAmJiB0aGlzW1VOWklQXSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAobmVlZFNuaWZmICYmIGNodW5rKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNodW5rXSk7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA8IGd6aXBIZWFkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gY2h1bms7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBjYj8uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb29rIGZvciBnemlwIGhlYWRlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IHRoaXNbVU5aSVBdID09PSB1bmRlZmluZWQgJiYgaSA8IGd6aXBIZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtbaV0gIT09IGd6aXBIZWFkZXJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXliZUJyb3RsaSA9IHRoaXMuYnJvdGxpID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpc1tVTlpJUF0gPT09IGZhbHNlICYmIG1heWJlQnJvdGxpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVhZCB0aGUgZmlyc3QgaGVhZGVyIHRvIHNlZSBpZiBpdCdzIGEgdmFsaWQgdGFyIGZpbGUuIElmIHNvLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXQgaXQncyBub3QgYWN0dWFsbHkgYnJvdGxpLCBkZXNwaXRlIHRoZVxuICAgICAgICAgICAgICAgIC8vIC50YnIgb3IgLnRhci5iciBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBlbmRlZCBiZWZvcmUgZ2V0dGluZyBhIGZ1bGwgY2h1bmssIHllcywgZGVmIGJyb3RsaVxuICAgICAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPCA1MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbRU5ERURdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyb3RsaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjYj8uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQncyB0YXIsIGl0J3MgcHJldHR5IHJlbGlhYmx5IG5vdCBicm90bGksIGNoYW5jZXMgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBoYXBwZW5pbmcgYXJlIGFzdHJvbm9taWNhbC5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBoZWFkZXJfanNfMS5IZWFkZXIoY2h1bmsuc3ViYXJyYXkoMCwgNTEyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyb3RsaSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyb3RsaSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tVTlpJUF0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICh0aGlzW1VOWklQXSA9PT0gZmFsc2UgJiYgdGhpcy5icm90bGkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXTtcbiAgICAgICAgICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXNbVU5aSVBdID1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0gPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgbWluaXpsaWJfMS5VbnppcCh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IG1pbml6bGliXzEuQnJvdGxpRGVjb21wcmVzcyh7fSk7XG4gICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0ub24oJ2RhdGEnLCBjaHVuayA9PiB0aGlzW0NPTlNVTUVDSFVOS10oY2h1bmspKTtcbiAgICAgICAgICAgICAgICB0aGlzW1VOWklQXS5vbignZXJyb3InLCBlciA9PiB0aGlzLmFib3J0KGVyKSk7XG4gICAgICAgICAgICAgICAgdGhpc1tVTlpJUF0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS10oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzW1dSSVRJTkddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSAhIXRoaXNbVU5aSVBdW2VuZGVkID8gJ2VuZCcgOiAnd3JpdGUnXShjaHVuayk7XG4gICAgICAgICAgICAgICAgdGhpc1tXUklUSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNiPy4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbV1JJVElOR10gPSB0cnVlO1xuICAgICAgICBpZiAodGhpc1tVTlpJUF0pIHtcbiAgICAgICAgICAgIHRoaXNbVU5aSVBdLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tXUklUSU5HXSA9IGZhbHNlO1xuICAgICAgICAvLyByZXR1cm4gZmFsc2UgaWYgdGhlcmUncyBhIHF1ZXVlLCBvciBpZiB0aGUgY3VycmVudCBlbnRyeSBpc24ndCBmbG93aW5nXG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXNbUVVFVUVdLmxlbmd0aCA/IGZhbHNlXG4gICAgICAgICAgICA6IHRoaXNbUkVBREVOVFJZXSA/IHRoaXNbUkVBREVOVFJZXS5mbG93aW5nXG4gICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vIHF1ZXVlLCB0aGVuIHRoYXQgbWVhbnMgYSBjbG9nZ2VkIFJFQURFTlRSWVxuICAgICAgICBpZiAoIXJldCAmJiAhdGhpc1tRVUVVRV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzW1JFQURFTlRSWV0/Lm9uY2UoJ2RyYWluJywgKCkgPT4gdGhpcy5lbWl0KCdkcmFpbicpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjYj8uKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtCVUZGRVJDT05DQVRdKGMpIHtcbiAgICAgICAgaWYgKGMgJiYgIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdID8gQnVmZmVyLmNvbmNhdChbdGhpc1tCVUZGRVJdLCBjXSkgOiBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtNQVlCRUVORF0oKSB7XG4gICAgICAgIGlmICh0aGlzW0VOREVEXSAmJlxuICAgICAgICAgICAgIXRoaXNbRU1JVFRFREVORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0FCT1JURURdICYmXG4gICAgICAgICAgICAhdGhpc1tDT05TVU1JTkddKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRURURFTkRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXTtcbiAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5ibG9ja1JlbWFpbikge1xuICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlZCwgbGlrZWx5IGEgZGFtYWdlZCBmaWxlXG4gICAgICAgICAgICAgICAgY29uc3QgaGF2ZSA9IHRoaXNbQlVGRkVSXSA/IHRoaXNbQlVGRkVSXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIHRoaXMud2FybignVEFSX0JBRF9BUkNISVZFJywgYFRydW5jYXRlZCBpbnB1dCAobmVlZGVkICR7ZW50cnkuYmxvY2tSZW1haW59IG1vcmUgYnl0ZXMsIG9ubHkgJHtoYXZlfSBhdmFpbGFibGUpYCwgeyBlbnRyeSB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJ5LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tFTUlUXShET05FKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbQ09OU1VNRUNIVU5LXShjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tDT05TVU1JTkddICYmIGNodW5rKSB7XG4gICAgICAgICAgICB0aGlzW0JVRkZFUkNPTkNBVF0oY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaHVuayAmJiAhdGhpc1tCVUZGRVJdKSB7XG4gICAgICAgICAgICB0aGlzW01BWUJFRU5EXSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICB0aGlzW0NPTlNVTUlOR10gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuayk7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0aGlzW0JVRkZFUl0gJiZcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0/Lmxlbmd0aCA+PSA1MTIgJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzW1NBV19FT0ZdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tDT05TVU1JTkddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzW0JVRkZFUl0gfHwgdGhpc1tFTkRFRF0pIHtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVFTkRdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0NPTlNVTUVDSFVOS1NVQl0oY2h1bmspIHtcbiAgICAgICAgLy8gd2Uga25vdyB0aGF0IHdlIGFyZSBpbiBDT05TVU1JTkcgbW9kZSwgc28gYW55dGhpbmcgd3JpdHRlbiBnb2VzIGludG9cbiAgICAgICAgLy8gdGhlIGJ1ZmZlci4gIEFkdmFuY2UgdGhlIHBvc2l0aW9uIGFuZCBwdXQgYW55IHJlbWFpbmRlciBpbiB0aGUgYnVmZmVyLlxuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChwb3NpdGlvbiArIDUxMiA8PSBsZW5ndGggJiZcbiAgICAgICAgICAgICF0aGlzW0FCT1JURURdICYmXG4gICAgICAgICAgICAhdGhpc1tTQVdfRU9GXSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzW1NUQVRFXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JlZ2luJzpcbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzW0NPTlNVTUVIRUFERVJdKGNodW5rLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDUxMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRU1FVEFdKGNodW5rLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZTogJyArIHRoaXNbU1RBVEVdKTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5zdWJhcnJheShwb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXSA9IGNodW5rLnN1YmFycmF5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmQoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGNodW5rO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjaHVuayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgICAgICAgaWYgKCF0aGlzW0FCT1JURURdKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tVTlpJUF0pIHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbVU5aSVBdLndyaXRlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXNbVU5aSVBdLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJyb3RsaSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rIHx8IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHRoaXNbTUFZQkVFTkRdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/parse.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/path-reservations.js":
/*!*************************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/path-reservations.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathReservations = void 0;\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst normalize_unicode_js_1 = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/dist/commonjs/normalize-unicode.js\");\nconst strip_trailing_slashes_js_1 = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/dist/commonjs/strip-trailing-slashes.js\");\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\n// return a set of parent dirs for a given path\n// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\nconst getDirs = (path) => {\n    const dirs = path\n        .split('/')\n        .slice(0, -1)\n        .reduce((set, path) => {\n        const s = set[set.length - 1];\n        if (s !== undefined) {\n            path = (0, node_path_1.join)(s, path);\n        }\n        set.push(path || '/');\n        return set;\n    }, []);\n    return dirs;\n};\nclass PathReservations {\n    // path => [function or Set]\n    // A Set object means a directory reservation\n    // A fn is a direct reservation on that path\n    #queues = new Map();\n    // fn => {paths:[path,...], dirs:[path, ...]}\n    #reservations = new Map();\n    // functions currently running\n    #running = new Set();\n    reserve(paths, fn) {\n        paths =\n            isWindows ?\n                ['win32 parallelization disabled']\n                : paths.map(p => {\n                    // don't need normPath, because we skip this entirely for windows\n                    return (0, strip_trailing_slashes_js_1.stripTrailingSlashes)((0, node_path_1.join)((0, normalize_unicode_js_1.normalizeUnicode)(p))).toLowerCase();\n                });\n        const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n        this.#reservations.set(fn, { dirs, paths });\n        for (const p of paths) {\n            const q = this.#queues.get(p);\n            if (!q) {\n                this.#queues.set(p, [fn]);\n            }\n            else {\n                q.push(fn);\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            if (!q) {\n                this.#queues.set(dir, [new Set([fn])]);\n            }\n            else {\n                const l = q[q.length - 1];\n                if (l instanceof Set) {\n                    l.add(fn);\n                }\n                else {\n                    q.push(new Set([fn]));\n                }\n            }\n        }\n        return this.#run(fn);\n    }\n    // return the queues for each path the function cares about\n    // fn => {paths, dirs}\n    #getQueues(fn) {\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('function does not have any path reservations');\n        }\n        /* c8 ignore stop */\n        return {\n            paths: res.paths.map((path) => this.#queues.get(path)),\n            dirs: [...res.dirs].map(path => this.#queues.get(path)),\n        };\n    }\n    // check if fn is first in line for all its paths, and is\n    // included in the first set for all its dir queues\n    check(fn) {\n        const { paths, dirs } = this.#getQueues(fn);\n        return (paths.every(q => q && q[0] === fn) &&\n            dirs.every(q => q && q[0] instanceof Set && q[0].has(fn)));\n    }\n    // run the function if it's first in line and not already running\n    #run(fn) {\n        if (this.#running.has(fn) || !this.check(fn)) {\n            return false;\n        }\n        this.#running.add(fn);\n        fn(() => this.#clear(fn));\n        return true;\n    }\n    #clear(fn) {\n        if (!this.#running.has(fn)) {\n            return false;\n        }\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('invalid reservation');\n        }\n        /* c8 ignore stop */\n        const { paths, dirs } = res;\n        const next = new Set();\n        for (const path of paths) {\n            const q = this.#queues.get(path);\n            /* c8 ignore start */\n            if (!q || q?.[0] !== fn) {\n                continue;\n            }\n            /* c8 ignore stop */\n            const q0 = q[1];\n            if (!q0) {\n                this.#queues.delete(path);\n                continue;\n            }\n            q.shift();\n            if (typeof q0 === 'function') {\n                next.add(q0);\n            }\n            else {\n                for (const f of q0) {\n                    next.add(f);\n                }\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            const q0 = q?.[0];\n            /* c8 ignore next - type safety only */\n            if (!q || !(q0 instanceof Set))\n                continue;\n            if (q0.size === 1 && q.length === 1) {\n                this.#queues.delete(dir);\n                continue;\n            }\n            else if (q0.size === 1) {\n                q.shift();\n                // next one must be a function,\n                // or else the Set would've been reused\n                const n = q[0];\n                if (typeof n === 'function') {\n                    next.add(n);\n                }\n            }\n            else {\n                q0.delete(fn);\n            }\n        }\n        this.#running.delete(fn);\n        next.forEach(fn => this.#run(fn));\n        return true;\n    }\n}\nexports.PathReservations = PathReservations;\n//# sourceMappingURL=path-reservations.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGF0aC1yZXNlcnZhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsb0JBQW9CLG1CQUFPLENBQUMsNEJBQVc7QUFDdkMsK0JBQStCLG1CQUFPLENBQUMscUZBQXdCO0FBQy9ELG9DQUFvQyxtQkFBTyxDQUFDLCtGQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9wYXRoLXJlc2VydmF0aW9ucy5qcz8zMDczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQSBwYXRoIGV4Y2x1c2l2ZSByZXNlcnZhdGlvbiBzeXN0ZW1cbi8vIHJlc2VydmUoW2xpc3QsIG9mLCBwYXRoc10sIGZuKVxuLy8gV2hlbiB0aGUgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgaXRcbi8vIGlzIGNhbGxlZCB3aXRoIGEgY2IgdGhhdCBjbGVhcnMgdGhlIHJlc2VydmF0aW9uLlxuLy9cbi8vIFVzZWQgYnkgYXN5bmMgdW5wYWNrIHRvIGF2b2lkIGNsb2JiZXJpbmcgcGF0aHMgaW4gdXNlLFxuLy8gd2hpbGUgc3RpbGwgYWxsb3dpbmcgbWF4aW1hbCBzYWZlIHBhcmFsbGVsaXphdGlvbi5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0aFJlc2VydmF0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfcGF0aF8xID0gcmVxdWlyZShcIm5vZGU6cGF0aFwiKTtcbmNvbnN0IG5vcm1hbGl6ZV91bmljb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdW5pY29kZS5qc1wiKTtcbmNvbnN0IHN0cmlwX3RyYWlsaW5nX3NsYXNoZXNfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanNcIik7XG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LlRFU1RJTkdfVEFSX0ZBS0VfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybTtcbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInO1xuLy8gcmV0dXJuIGEgc2V0IG9mIHBhcmVudCBkaXJzIGZvciBhIGdpdmVuIHBhdGhcbi8vICcvYS9iL2MvZCcgLT4gWycvJywgJy9hJywgJy9hL2InLCAnL2EvYi9jJywgJy9hL2IvYy9kJ11cbmNvbnN0IGdldERpcnMgPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGRpcnMgPSBwYXRoXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgICAgLnJlZHVjZSgoc2V0LCBwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoID0gKDAsIG5vZGVfcGF0aF8xLmpvaW4pKHMsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5wdXNoKHBhdGggfHwgJy8nKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGRpcnM7XG59O1xuY2xhc3MgUGF0aFJlc2VydmF0aW9ucyB7XG4gICAgLy8gcGF0aCA9PiBbZnVuY3Rpb24gb3IgU2V0XVxuICAgIC8vIEEgU2V0IG9iamVjdCBtZWFucyBhIGRpcmVjdG9yeSByZXNlcnZhdGlvblxuICAgIC8vIEEgZm4gaXMgYSBkaXJlY3QgcmVzZXJ2YXRpb24gb24gdGhhdCBwYXRoXG4gICAgI3F1ZXVlcyA9IG5ldyBNYXAoKTtcbiAgICAvLyBmbiA9PiB7cGF0aHM6W3BhdGgsLi4uXSwgZGlyczpbcGF0aCwgLi4uXX1cbiAgICAjcmVzZXJ2YXRpb25zID0gbmV3IE1hcCgpO1xuICAgIC8vIGZ1bmN0aW9ucyBjdXJyZW50bHkgcnVubmluZ1xuICAgICNydW5uaW5nID0gbmV3IFNldCgpO1xuICAgIHJlc2VydmUocGF0aHMsIGZuKSB7XG4gICAgICAgIHBhdGhzID1cbiAgICAgICAgICAgIGlzV2luZG93cyA/XG4gICAgICAgICAgICAgICAgWyd3aW4zMiBwYXJhbGxlbGl6YXRpb24gZGlzYWJsZWQnXVxuICAgICAgICAgICAgICAgIDogcGF0aHMubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBuZWVkIG5vcm1QYXRoLCBiZWNhdXNlIHdlIHNraXAgdGhpcyBlbnRpcmVseSBmb3Igd2luZG93c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHN0cmlwX3RyYWlsaW5nX3NsYXNoZXNfanNfMS5zdHJpcFRyYWlsaW5nU2xhc2hlcykoKDAsIG5vZGVfcGF0aF8xLmpvaW4pKCgwLCBub3JtYWxpemVfdW5pY29kZV9qc18xLm5vcm1hbGl6ZVVuaWNvZGUpKHApKSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQocGF0aHMubWFwKHBhdGggPT4gZ2V0RGlycyhwYXRoKSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSkpO1xuICAgICAgICB0aGlzLiNyZXNlcnZhdGlvbnMuc2V0KGZuLCB7IGRpcnMsIHBhdGhzIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSB0aGlzLiNxdWV1ZXMuZ2V0KHApO1xuICAgICAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcXVldWVzLnNldChwLCBbZm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHEucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgcSA9IHRoaXMuI3F1ZXVlcy5nZXQoZGlyKTtcbiAgICAgICAgICAgIGlmICghcSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3F1ZXVlcy5zZXQoZGlyLCBbbmV3IFNldChbZm5dKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IHFbcS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICBsLmFkZChmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxLnB1c2gobmV3IFNldChbZm5dKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNydW4oZm4pO1xuICAgIH1cbiAgICAvLyByZXR1cm4gdGhlIHF1ZXVlcyBmb3IgZWFjaCBwYXRoIHRoZSBmdW5jdGlvbiBjYXJlcyBhYm91dFxuICAgIC8vIGZuID0+IHtwYXRocywgZGlyc31cbiAgICAjZ2V0UXVldWVzKGZuKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuI3Jlc2VydmF0aW9ucy5nZXQoZm4pO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgcGF0aCByZXNlcnZhdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aHM6IHJlcy5wYXRocy5tYXAoKHBhdGgpID0+IHRoaXMuI3F1ZXVlcy5nZXQocGF0aCkpLFxuICAgICAgICAgICAgZGlyczogWy4uLnJlcy5kaXJzXS5tYXAocGF0aCA9PiB0aGlzLiNxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgYW5kIGlzXG4gICAgLy8gaW5jbHVkZWQgaW4gdGhlIGZpcnN0IHNldCBmb3IgYWxsIGl0cyBkaXIgcXVldWVzXG4gICAgY2hlY2soZm4pIHtcbiAgICAgICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gdGhpcy4jZ2V0UXVldWVzKGZuKTtcbiAgICAgICAgcmV0dXJuIChwYXRocy5ldmVyeShxID0+IHEgJiYgcVswXSA9PT0gZm4pICYmXG4gICAgICAgICAgICBkaXJzLmV2ZXJ5KHEgPT4gcSAmJiBxWzBdIGluc3RhbmNlb2YgU2V0ICYmIHFbMF0uaGFzKGZuKSkpO1xuICAgIH1cbiAgICAvLyBydW4gdGhlIGZ1bmN0aW9uIGlmIGl0J3MgZmlyc3QgaW4gbGluZSBhbmQgbm90IGFscmVhZHkgcnVubmluZ1xuICAgICNydW4oZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcuaGFzKGZuKSB8fCAhdGhpcy5jaGVjayhmbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nLmFkZChmbik7XG4gICAgICAgIGZuKCgpID0+IHRoaXMuI2NsZWFyKGZuKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAjY2xlYXIoZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nLmhhcyhmbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLiNyZXNlcnZhdGlvbnMuZ2V0KGZuKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVzZXJ2YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBjb25zdCB7IHBhdGhzLCBkaXJzIH0gPSByZXM7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgY29uc3QgcSA9IHRoaXMuI3F1ZXVlcy5nZXQocGF0aCk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICghcSB8fCBxPy5bMF0gIT09IGZuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgY29uc3QgcTAgPSBxWzFdO1xuICAgICAgICAgICAgaWYgKCFxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3F1ZXVlcy5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHEwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbmV4dC5hZGQocTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHEwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy4jcXVldWVzLmdldChkaXIpO1xuICAgICAgICAgICAgY29uc3QgcTAgPSBxPy5bMF07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAtIHR5cGUgc2FmZXR5IG9ubHkgKi9cbiAgICAgICAgICAgIGlmICghcSB8fCAhKHEwIGluc3RhbmNlb2YgU2V0KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChxMC5zaXplID09PSAxICYmIHEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcXVldWVzLmRlbGV0ZShkaXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocTAuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IG9uZSBtdXN0IGJlIGEgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgLy8gb3IgZWxzZSB0aGUgU2V0IHdvdWxkJ3ZlIGJlZW4gcmV1c2VkXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHFbMF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHEwLmRlbGV0ZShmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZy5kZWxldGUoZm4pO1xuICAgICAgICBuZXh0LmZvckVhY2goZm4gPT4gdGhpcy4jcnVuKGZuKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFJlc2VydmF0aW9ucyA9IFBhdGhSZXNlcnZhdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLXJlc2VydmF0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/path-reservations.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/pax.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/dist/commonjs/pax.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pax = void 0;\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst header_js_1 = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/dist/commonjs/header.js\");\nclass Pax {\n    atime;\n    mtime;\n    ctime;\n    charset;\n    comment;\n    gid;\n    uid;\n    gname;\n    uname;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    path;\n    size;\n    mode;\n    global;\n    constructor(obj, global = false) {\n        this.atime = obj.atime;\n        this.charset = obj.charset;\n        this.comment = obj.comment;\n        this.ctime = obj.ctime;\n        this.dev = obj.dev;\n        this.gid = obj.gid;\n        this.global = global;\n        this.gname = obj.gname;\n        this.ino = obj.ino;\n        this.linkpath = obj.linkpath;\n        this.mtime = obj.mtime;\n        this.nlink = obj.nlink;\n        this.path = obj.path;\n        this.size = obj.size;\n        this.uid = obj.uid;\n        this.uname = obj.uname;\n    }\n    encode() {\n        const body = this.encodeBody();\n        if (body === '') {\n            return Buffer.allocUnsafe(0);\n        }\n        const bodyLen = Buffer.byteLength(body);\n        // round up to 512 bytes\n        // add 512 for header\n        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);\n        const buf = Buffer.allocUnsafe(bufLen);\n        // 0-fill the header section, it might not hit every field\n        for (let i = 0; i < 512; i++) {\n            buf[i] = 0;\n        }\n        new header_js_1.Header({\n            // XXX split the path\n            // then the path should be PaxHeader + basename, but less than 99,\n            // prepend with the dirname\n            /* c8 ignore start */\n            path: ('PaxHeader/' + (0, node_path_1.basename)(this.path ?? '')).slice(0, 99),\n            /* c8 ignore stop */\n            mode: this.mode || 0o644,\n            uid: this.uid,\n            gid: this.gid,\n            size: bodyLen,\n            mtime: this.mtime,\n            type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n            linkpath: '',\n            uname: this.uname || '',\n            gname: this.gname || '',\n            devmaj: 0,\n            devmin: 0,\n            atime: this.atime,\n            ctime: this.ctime,\n        }).encode(buf);\n        buf.write(body, 512, bodyLen, 'utf8');\n        // null pad after the body\n        for (let i = bodyLen + 512; i < buf.length; i++) {\n            buf[i] = 0;\n        }\n        return buf;\n    }\n    encodeBody() {\n        return (this.encodeField('path') +\n            this.encodeField('ctime') +\n            this.encodeField('atime') +\n            this.encodeField('dev') +\n            this.encodeField('ino') +\n            this.encodeField('nlink') +\n            this.encodeField('charset') +\n            this.encodeField('comment') +\n            this.encodeField('gid') +\n            this.encodeField('gname') +\n            this.encodeField('linkpath') +\n            this.encodeField('mtime') +\n            this.encodeField('size') +\n            this.encodeField('uid') +\n            this.encodeField('uname'));\n    }\n    encodeField(field) {\n        if (this[field] === undefined) {\n            return '';\n        }\n        const r = this[field];\n        const v = r instanceof Date ? r.getTime() / 1000 : r;\n        const s = ' ' +\n            (field === 'dev' || field === 'ino' || field === 'nlink' ?\n                'SCHILY.'\n                : '') +\n            field +\n            '=' +\n            v +\n            '\\n';\n        const byteLen = Buffer.byteLength(s);\n        // the digits includes the length of the digits in ascii base-10\n        // so if it's 9 characters, then adding 1 for the 9 makes it 10\n        // which makes it 11 chars.\n        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;\n        if (byteLen + digits >= Math.pow(10, digits)) {\n            digits += 1;\n        }\n        const len = digits + byteLen;\n        return len + s;\n    }\n    static parse(str, ex, g = false) {\n        return new Pax(merge(parseKV(str), ex), g);\n    }\n}\nexports.Pax = Pax;\nconst merge = (a, b) => b ? Object.assign({}, b, a) : a;\nconst parseKV = (str) => str\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null));\nconst parseKVLine = (set, line) => {\n    const n = parseInt(line, 10);\n    // XXX Values with \\n in them will fail this.\n    // Refactor to not be a naive line-by-line parse.\n    if (n !== Buffer.byteLength(line) + 1) {\n        return set;\n    }\n    line = line.slice((n + ' ').length);\n    const kv = line.split('=');\n    const r = kv.shift();\n    if (!r) {\n        return set;\n    }\n    const k = r.replace(/^SCHILY\\.(dev|ino|nlink)/, '$1');\n    const v = kv.join('=');\n    set[k] =\n        /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ?\n            new Date(Number(v) * 1000)\n            : /^[0-9]+$/.test(v) ? +v\n                : v;\n    return set;\n};\n//# sourceMappingURL=pax.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGF4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVc7QUFDWCxvQkFBb0IsbUJBQU8sQ0FBQyw0QkFBVztBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQywrREFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcGF4LmpzPzJlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBheCA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfcGF0aF8xID0gcmVxdWlyZShcIm5vZGU6cGF0aFwiKTtcbmNvbnN0IGhlYWRlcl9qc18xID0gcmVxdWlyZShcIi4vaGVhZGVyLmpzXCIpO1xuY2xhc3MgUGF4IHtcbiAgICBhdGltZTtcbiAgICBtdGltZTtcbiAgICBjdGltZTtcbiAgICBjaGFyc2V0O1xuICAgIGNvbW1lbnQ7XG4gICAgZ2lkO1xuICAgIHVpZDtcbiAgICBnbmFtZTtcbiAgICB1bmFtZTtcbiAgICBsaW5rcGF0aDtcbiAgICBkZXY7XG4gICAgaW5vO1xuICAgIG5saW5rO1xuICAgIHBhdGg7XG4gICAgc2l6ZTtcbiAgICBtb2RlO1xuICAgIGdsb2JhbDtcbiAgICBjb25zdHJ1Y3RvcihvYmosIGdsb2JhbCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYXRpbWUgPSBvYmouYXRpbWU7XG4gICAgICAgIHRoaXMuY2hhcnNldCA9IG9iai5jaGFyc2V0O1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBvYmouY29tbWVudDtcbiAgICAgICAgdGhpcy5jdGltZSA9IG9iai5jdGltZTtcbiAgICAgICAgdGhpcy5kZXYgPSBvYmouZGV2O1xuICAgICAgICB0aGlzLmdpZCA9IG9iai5naWQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsO1xuICAgICAgICB0aGlzLmduYW1lID0gb2JqLmduYW1lO1xuICAgICAgICB0aGlzLmlubyA9IG9iai5pbm87XG4gICAgICAgIHRoaXMubGlua3BhdGggPSBvYmoubGlua3BhdGg7XG4gICAgICAgIHRoaXMubXRpbWUgPSBvYmoubXRpbWU7XG4gICAgICAgIHRoaXMubmxpbmsgPSBvYmoubmxpbms7XG4gICAgICAgIHRoaXMucGF0aCA9IG9iai5wYXRoO1xuICAgICAgICB0aGlzLnNpemUgPSBvYmouc2l6ZTtcbiAgICAgICAgdGhpcy51aWQgPSBvYmoudWlkO1xuICAgICAgICB0aGlzLnVuYW1lID0gb2JqLnVuYW1lO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmVuY29kZUJvZHkoKTtcbiAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHlMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KTtcbiAgICAgICAgLy8gcm91bmQgdXAgdG8gNTEyIGJ5dGVzXG4gICAgICAgIC8vIGFkZCA1MTIgZm9yIGhlYWRlclxuICAgICAgICBjb25zdCBidWZMZW4gPSA1MTIgKiBNYXRoLmNlaWwoMSArIGJvZHlMZW4gLyA1MTIpO1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKTtcbiAgICAgICAgLy8gMC1maWxsIHRoZSBoZWFkZXIgc2VjdGlvbiwgaXQgbWlnaHQgbm90IGhpdCBldmVyeSBmaWVsZFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICAgICAgICBidWZbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBoZWFkZXJfanNfMS5IZWFkZXIoe1xuICAgICAgICAgICAgLy8gWFhYIHNwbGl0IHRoZSBwYXRoXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSBwYXRoIHNob3VsZCBiZSBQYXhIZWFkZXIgKyBiYXNlbmFtZSwgYnV0IGxlc3MgdGhhbiA5OSxcbiAgICAgICAgICAgIC8vIHByZXBlbmQgd2l0aCB0aGUgZGlybmFtZVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBwYXRoOiAoJ1BheEhlYWRlci8nICsgKDAsIG5vZGVfcGF0aF8xLmJhc2VuYW1lKSh0aGlzLnBhdGggPz8gJycpKS5zbGljZSgwLCA5OSksXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlIHx8IDBvNjQ0LFxuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICAgICAgICBzaXplOiBib2R5TGVuLFxuICAgICAgICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdsb2JhbCA/ICdHbG9iYWxFeHRlbmRlZEhlYWRlcicgOiAnRXh0ZW5kZWRIZWFkZXInLFxuICAgICAgICAgICAgbGlua3BhdGg6ICcnLFxuICAgICAgICAgICAgdW5hbWU6IHRoaXMudW5hbWUgfHwgJycsXG4gICAgICAgICAgICBnbmFtZTogdGhpcy5nbmFtZSB8fCAnJyxcbiAgICAgICAgICAgIGRldm1hajogMCxcbiAgICAgICAgICAgIGRldm1pbjogMCxcbiAgICAgICAgICAgIGF0aW1lOiB0aGlzLmF0aW1lLFxuICAgICAgICAgICAgY3RpbWU6IHRoaXMuY3RpbWUsXG4gICAgICAgIH0pLmVuY29kZShidWYpO1xuICAgICAgICBidWYud3JpdGUoYm9keSwgNTEyLCBib2R5TGVuLCAndXRmOCcpO1xuICAgICAgICAvLyBudWxsIHBhZCBhZnRlciB0aGUgYm9keVxuICAgICAgICBmb3IgKGxldCBpID0gYm9keUxlbiArIDUxMjsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBlbmNvZGVCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZW5jb2RlRmllbGQoJ3BhdGgnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdjdGltZScpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2F0aW1lJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnZGV2JykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnaW5vJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbmxpbmsnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdjaGFyc2V0JykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY29tbWVudCcpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2dpZCcpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2duYW1lJykgK1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbGlua3BhdGgnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCdtdGltZScpICtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3NpemUnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCd1aWQnKSArXG4gICAgICAgICAgICB0aGlzLmVuY29kZUZpZWxkKCd1bmFtZScpKTtcbiAgICB9XG4gICAgZW5jb2RlRmllbGQoZmllbGQpIHtcbiAgICAgICAgaWYgKHRoaXNbZmllbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpc1tmaWVsZF07XG4gICAgICAgIGNvbnN0IHYgPSByIGluc3RhbmNlb2YgRGF0ZSA/IHIuZ2V0VGltZSgpIC8gMTAwMCA6IHI7XG4gICAgICAgIGNvbnN0IHMgPSAnICcgK1xuICAgICAgICAgICAgKGZpZWxkID09PSAnZGV2JyB8fCBmaWVsZCA9PT0gJ2lubycgfHwgZmllbGQgPT09ICdubGluaycgP1xuICAgICAgICAgICAgICAgICdTQ0hJTFkuJ1xuICAgICAgICAgICAgICAgIDogJycpICtcbiAgICAgICAgICAgIGZpZWxkICtcbiAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICB2ICtcbiAgICAgICAgICAgICdcXG4nO1xuICAgICAgICBjb25zdCBieXRlTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocyk7XG4gICAgICAgIC8vIHRoZSBkaWdpdHMgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgZGlnaXRzIGluIGFzY2lpIGJhc2UtMTBcbiAgICAgICAgLy8gc28gaWYgaXQncyA5IGNoYXJhY3RlcnMsIHRoZW4gYWRkaW5nIDEgZm9yIHRoZSA5IG1ha2VzIGl0IDEwXG4gICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IDExIGNoYXJzLlxuICAgICAgICBsZXQgZGlnaXRzID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlTGVuKSAvIE1hdGgubG9nKDEwKSkgKyAxO1xuICAgICAgICBpZiAoYnl0ZUxlbiArIGRpZ2l0cyA+PSBNYXRoLnBvdygxMCwgZGlnaXRzKSkge1xuICAgICAgICAgICAgZGlnaXRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZGlnaXRzICsgYnl0ZUxlbjtcbiAgICAgICAgcmV0dXJuIGxlbiArIHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShzdHIsIGV4LCBnID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXgobWVyZ2UocGFyc2VLVihzdHIpLCBleCksIGcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF4ID0gUGF4O1xuY29uc3QgbWVyZ2UgPSAoYSwgYikgPT4gYiA/IE9iamVjdC5hc3NpZ24oe30sIGIsIGEpIDogYTtcbmNvbnN0IHBhcnNlS1YgPSAoc3RyKSA9PiBzdHJcbiAgICAucmVwbGFjZSgvXFxuJC8sICcnKVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAucmVkdWNlKHBhcnNlS1ZMaW5lLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbmNvbnN0IHBhcnNlS1ZMaW5lID0gKHNldCwgbGluZSkgPT4ge1xuICAgIGNvbnN0IG4gPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgLy8gWFhYIFZhbHVlcyB3aXRoIFxcbiBpbiB0aGVtIHdpbGwgZmFpbCB0aGlzLlxuICAgIC8vIFJlZmFjdG9yIHRvIG5vdCBiZSBhIG5haXZlIGxpbmUtYnktbGluZSBwYXJzZS5cbiAgICBpZiAobiAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgobGluZSkgKyAxKSB7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIGxpbmUgPSBsaW5lLnNsaWNlKChuICsgJyAnKS5sZW5ndGgpO1xuICAgIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnPScpO1xuICAgIGNvbnN0IHIgPSBrdi5zaGlmdCgpO1xuICAgIGlmICghcikge1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBjb25zdCBrID0gci5yZXBsYWNlKC9eU0NISUxZXFwuKGRldnxpbm98bmxpbmspLywgJyQxJyk7XG4gICAgY29uc3QgdiA9IGt2LmpvaW4oJz0nKTtcbiAgICBzZXRba10gPVxuICAgICAgICAvXihbQS1aXStcXC4pPyhbbWFjXXxiaXJ0aHxjcmVhdGlvbil0aW1lJC8udGVzdChrKSA/XG4gICAgICAgICAgICBuZXcgRGF0ZShOdW1iZXIodikgKiAxMDAwKVxuICAgICAgICAgICAgOiAvXlswLTldKyQvLnRlc3QodikgPyArdlxuICAgICAgICAgICAgICAgIDogdjtcbiAgICByZXR1cm4gc2V0O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBheC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/pax.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/read-entry.js":
/*!******************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/read-entry.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadEntry = void 0;\nconst minipass_1 = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/dist/commonjs/index.js\");\nconst normalize_windows_path_js_1 = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/dist/commonjs/normalize-windows-path.js\");\nclass ReadEntry extends minipass_1.Minipass {\n    extended;\n    globalExtended;\n    header;\n    startBlockSize;\n    blockRemain;\n    remain;\n    type;\n    meta = false;\n    ignore = false;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    size = 0;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    invalid = false;\n    absolute;\n    unsupported = false;\n    constructor(header, ex, gex) {\n        super({});\n        // read entries always start life paused.  this is to avoid the\n        // situation where Minipass's auto-ending empty streams results\n        // in an entry ending before we're ready for it.\n        this.pause();\n        this.extended = ex;\n        this.globalExtended = gex;\n        this.header = header;\n        /* c8 ignore start */\n        this.remain = header.size ?? 0;\n        /* c8 ignore stop */\n        this.startBlockSize = 512 * Math.ceil(this.remain / 512);\n        this.blockRemain = this.startBlockSize;\n        this.type = header.type;\n        switch (this.type) {\n            case 'File':\n            case 'OldFile':\n            case 'Link':\n            case 'SymbolicLink':\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'Directory':\n            case 'FIFO':\n            case 'ContiguousFile':\n            case 'GNUDumpDir':\n                break;\n            case 'NextFileHasLongLinkpath':\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath':\n            case 'GlobalExtendedHeader':\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this.meta = true;\n                break;\n            // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n            // it may be worth doing the same, but with a warning.\n            default:\n                this.ignore = true;\n        }\n        /* c8 ignore start */\n        if (!header.path) {\n            throw new Error('no path provided for tar.ReadEntry');\n        }\n        /* c8 ignore stop */\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(header.path);\n        this.mode = header.mode;\n        if (this.mode) {\n            this.mode = this.mode & 0o7777;\n        }\n        this.uid = header.uid;\n        this.gid = header.gid;\n        this.uname = header.uname;\n        this.gname = header.gname;\n        this.size = this.remain;\n        this.mtime = header.mtime;\n        this.atime = header.atime;\n        this.ctime = header.ctime;\n        /* c8 ignore start */\n        this.linkpath =\n            header.linkpath ?\n                (0, normalize_windows_path_js_1.normalizeWindowsPath)(header.linkpath)\n                : undefined;\n        /* c8 ignore stop */\n        this.uname = header.uname;\n        this.gname = header.gname;\n        if (ex) {\n            this.#slurp(ex);\n        }\n        if (gex) {\n            this.#slurp(gex, true);\n        }\n    }\n    write(data) {\n        const writeLen = data.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        const r = this.remain;\n        const br = this.blockRemain;\n        this.remain = Math.max(0, r - writeLen);\n        this.blockRemain = Math.max(0, br - writeLen);\n        if (this.ignore) {\n            return true;\n        }\n        if (r >= writeLen) {\n            return super.write(data);\n        }\n        // r < writeLen\n        return super.write(data.subarray(0, r));\n    }\n    #slurp(ex, gex = false) {\n        if (ex.path)\n            ex.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(ex.path);\n        if (ex.linkpath)\n            ex.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(ex.linkpath);\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex));\n        })));\n    }\n}\nexports.ReadEntry = ReadEntry;\n//# sourceMappingURL=read-entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcmVhZC1lbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CLG1CQUFPLENBQUMsaUZBQVU7QUFDckMsb0NBQW9DLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL3JlYWQtZW50cnkuanM/OGY4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVhZEVudHJ5ID0gdm9pZCAwO1xuY29uc3QgbWluaXBhc3NfMSA9IHJlcXVpcmUoXCJtaW5pcGFzc1wiKTtcbmNvbnN0IG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMSA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanNcIik7XG5jbGFzcyBSZWFkRW50cnkgZXh0ZW5kcyBtaW5pcGFzc18xLk1pbmlwYXNzIHtcbiAgICBleHRlbmRlZDtcbiAgICBnbG9iYWxFeHRlbmRlZDtcbiAgICBoZWFkZXI7XG4gICAgc3RhcnRCbG9ja1NpemU7XG4gICAgYmxvY2tSZW1haW47XG4gICAgcmVtYWluO1xuICAgIHR5cGU7XG4gICAgbWV0YSA9IGZhbHNlO1xuICAgIGlnbm9yZSA9IGZhbHNlO1xuICAgIHBhdGg7XG4gICAgbW9kZTtcbiAgICB1aWQ7XG4gICAgZ2lkO1xuICAgIHVuYW1lO1xuICAgIGduYW1lO1xuICAgIHNpemUgPSAwO1xuICAgIG10aW1lO1xuICAgIGF0aW1lO1xuICAgIGN0aW1lO1xuICAgIGxpbmtwYXRoO1xuICAgIGRldjtcbiAgICBpbm87XG4gICAgbmxpbms7XG4gICAgaW52YWxpZCA9IGZhbHNlO1xuICAgIGFic29sdXRlO1xuICAgIHVuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyLCBleCwgZ2V4KSB7XG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBNaW5pcGFzcydzIGF1dG8tZW5kaW5nIGVtcHR5IHN0cmVhbXMgcmVzdWx0c1xuICAgICAgICAvLyBpbiBhbiBlbnRyeSBlbmRpbmcgYmVmb3JlIHdlJ3JlIHJlYWR5IGZvciBpdC5cbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmV4dGVuZGVkID0gZXg7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXh0ZW5kZWQgPSBnZXg7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5yZW1haW4gPSBoZWFkZXIuc2l6ZSA/PyAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnN0YXJ0QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKHRoaXMucmVtYWluIC8gNTEyKTtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiA9IHRoaXMuc3RhcnRCbG9ja1NpemU7XG4gICAgICAgIHRoaXMudHlwZSA9IGhlYWRlci50eXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0xpbmsnOlxuICAgICAgICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgICAgIGNhc2UgJ0NoYXJhY3RlckRldmljZSc6XG4gICAgICAgICAgICBjYXNlICdCbG9ja0RldmljZSc6XG4gICAgICAgICAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgICAgICAgICAgY2FzZSAnRklGTyc6XG4gICAgICAgICAgICBjYXNlICdDb250aWd1b3VzRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzpcbiAgICAgICAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ1BhdGgnOlxuICAgICAgICAgICAgY2FzZSAnT2xkR251TG9uZ1BhdGgnOlxuICAgICAgICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgY2FzZSAnRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgY2FzZSAnT2xkRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAgICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIWhlYWRlci5wYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHBhdGggcHJvdmlkZWQgZm9yIHRhci5SZWFkRW50cnknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnBhdGggPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShoZWFkZXIucGF0aCk7XG4gICAgICAgIHRoaXMubW9kZSA9IGhlYWRlci5tb2RlO1xuICAgICAgICBpZiAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSB0aGlzLm1vZGUgJiAwbzc3Nzc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aWQgPSBoZWFkZXIudWlkO1xuICAgICAgICB0aGlzLmdpZCA9IGhlYWRlci5naWQ7XG4gICAgICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWU7XG4gICAgICAgIHRoaXMuZ25hbWUgPSBoZWFkZXIuZ25hbWU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVtYWluO1xuICAgICAgICB0aGlzLm10aW1lID0gaGVhZGVyLm10aW1lO1xuICAgICAgICB0aGlzLmF0aW1lID0gaGVhZGVyLmF0aW1lO1xuICAgICAgICB0aGlzLmN0aW1lID0gaGVhZGVyLmN0aW1lO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5saW5rcGF0aCA9XG4gICAgICAgICAgICBoZWFkZXIubGlua3BhdGggP1xuICAgICAgICAgICAgICAgICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKGhlYWRlci5saW5rcGF0aClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy51bmFtZSA9IGhlYWRlci51bmFtZTtcbiAgICAgICAgdGhpcy5nbmFtZSA9IGhlYWRlci5nbmFtZTtcbiAgICAgICAgaWYgKGV4KSB7XG4gICAgICAgICAgICB0aGlzLiNzbHVycChleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdleCkge1xuICAgICAgICAgICAgdGhpcy4jc2x1cnAoZ2V4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpcy5yZW1haW47XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5ibG9ja1JlbWFpbjtcbiAgICAgICAgdGhpcy5yZW1haW4gPSBNYXRoLm1heCgwLCByIC0gd3JpdGVMZW4pO1xuICAgICAgICB0aGlzLmJsb2NrUmVtYWluID0gTWF0aC5tYXgoMCwgYnIgLSB3cml0ZUxlbik7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPj0gd3JpdGVMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByIDwgd3JpdGVMZW5cbiAgICAgICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEuc3ViYXJyYXkoMCwgcikpO1xuICAgIH1cbiAgICAjc2x1cnAoZXgsIGdleCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChleC5wYXRoKVxuICAgICAgICAgICAgZXgucGF0aCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKGV4LnBhdGgpO1xuICAgICAgICBpZiAoZXgubGlua3BhdGgpXG4gICAgICAgICAgICBleC5saW5rcGF0aCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKGV4LmxpbmtwYXRoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZXgpLmZpbHRlcigoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBzbHVycCBpbiBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIHBhdGggYXR0cmlidXRlIGluXG4gICAgICAgICAgICAvLyBhIGdsb2JhbCBleHRlbmRlZCBoZWFkZXIsIGJlY2F1c2UgdGhhdCdzIHdlaXJkLiBBbHNvLCBhbnlcbiAgICAgICAgICAgIC8vIG51bGwvdW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgICAgICAgIHJldHVybiAhKHYgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB2ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoayA9PT0gJ3BhdGgnICYmIGdleCkpO1xuICAgICAgICB9KSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZEVudHJ5ID0gUmVhZEVudHJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZC1lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/read-entry.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/replace.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/replace.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.replace = void 0;\n// tar -r\nconst fs_minipass_1 = __webpack_require__(/*! @isaacs/fs-minipass */ \"./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\");\nconst node_fs_1 = __importDefault(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst node_path_1 = __importDefault(__webpack_require__(/*! node:path */ \"node:path\"));\nconst header_js_1 = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/dist/commonjs/header.js\");\nconst list_js_1 = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/dist/commonjs/list.js\");\nconst make_command_js_1 = __webpack_require__(/*! ./make-command.js */ \"./node_modules/tar/dist/commonjs/make-command.js\");\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"./node_modules/tar/dist/commonjs/options.js\");\nconst pack_js_1 = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/dist/commonjs/pack.js\");\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\nconst replaceSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    let threw = true;\n    let fd;\n    let position;\n    try {\n        try {\n            fd = node_fs_1.default.openSync(opt.file, 'r+');\n        }\n        catch (er) {\n            if (er?.code === 'ENOENT') {\n                fd = node_fs_1.default.openSync(opt.file, 'w+');\n            }\n            else {\n                throw er;\n            }\n        }\n        const st = node_fs_1.default.fstatSync(fd);\n        const headBuf = Buffer.alloc(512);\n        POSITION: for (position = 0; position < st.size; position += 512) {\n            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n                bytes = node_fs_1.default.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n                if (position === 0 &&\n                    headBuf[0] === 0x1f &&\n                    headBuf[1] === 0x8b) {\n                    throw new Error('cannot append to compressed archives');\n                }\n                if (!bytes) {\n                    break POSITION;\n                }\n            }\n            const h = new header_js_1.Header(headBuf);\n            if (!h.cksumValid) {\n                break;\n            }\n            const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);\n            if (position + entryBlockSize + 512 > st.size) {\n                break;\n            }\n            // the 512 for the header we just parsed will be added as well\n            // also jump ahead all the blocks for the body\n            position += entryBlockSize;\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n        }\n        threw = false;\n        streamSync(opt, p, position, fd, files);\n    }\n    finally {\n        if (threw) {\n            try {\n                node_fs_1.default.closeSync(fd);\n            }\n            catch (er) { }\n        }\n    }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n    const stream = new fs_minipass_1.WriteStreamSync(opt.file, {\n        fd: fd,\n        start: position,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst replaceAsync = (opt, files) => {\n    files = Array.from(files);\n    const p = new pack_js_1.Pack(opt);\n    const getPos = (fd, size, cb_) => {\n        const cb = (er, pos) => {\n            if (er) {\n                node_fs_1.default.close(fd, _ => cb_(er));\n            }\n            else {\n                cb_(null, pos);\n            }\n        };\n        let position = 0;\n        if (size === 0) {\n            return cb(null, 0);\n        }\n        let bufPos = 0;\n        const headBuf = Buffer.alloc(512);\n        const onread = (er, bytes) => {\n            if (er || typeof bytes === 'undefined') {\n                return cb(er);\n            }\n            bufPos += bytes;\n            if (bufPos < 512 && bytes) {\n                return node_fs_1.default.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n            }\n            if (position === 0 &&\n                headBuf[0] === 0x1f &&\n                headBuf[1] === 0x8b) {\n                return cb(new Error('cannot append to compressed archives'));\n            }\n            // truncated header\n            if (bufPos < 512) {\n                return cb(null, position);\n            }\n            const h = new header_js_1.Header(headBuf);\n            if (!h.cksumValid) {\n                return cb(null, position);\n            }\n            /* c8 ignore next */\n            const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);\n            if (position + entryBlockSize + 512 > size) {\n                return cb(null, position);\n            }\n            position += entryBlockSize + 512;\n            if (position >= size) {\n                return cb(null, position);\n            }\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n            bufPos = 0;\n            node_fs_1.default.read(fd, headBuf, 0, 512, position, onread);\n        };\n        node_fs_1.default.read(fd, headBuf, 0, 512, position, onread);\n    };\n    const promise = new Promise((resolve, reject) => {\n        p.on('error', reject);\n        let flag = 'r+';\n        const onopen = (er, fd) => {\n            if (er && er.code === 'ENOENT' && flag === 'r+') {\n                flag = 'w+';\n                return node_fs_1.default.open(opt.file, flag, onopen);\n            }\n            if (er || !fd) {\n                return reject(er);\n            }\n            node_fs_1.default.fstat(fd, (er, st) => {\n                if (er) {\n                    return node_fs_1.default.close(fd, () => reject(er));\n                }\n                getPos(fd, st.size, (er, position) => {\n                    if (er) {\n                        return reject(er);\n                    }\n                    const stream = new fs_minipass_1.WriteStream(opt.file, {\n                        fd: fd,\n                        start: position,\n                    });\n                    p.pipe(stream);\n                    stream.on('error', reject);\n                    stream.on('close', resolve);\n                    addFilesAsync(p, files);\n                });\n            });\n        };\n        node_fs_1.default.open(opt.file, flag, onopen);\n    });\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0, list_js_1.list)({\n                file: node_path_1.default.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0, list_js_1.list)({\n                file: node_path_1.default.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nexports.replace = (0, make_command_js_1.makeCommand)(replaceSync, replaceAsync, \n/* c8 ignore start */\n() => {\n    throw new TypeError('file is required');\n}, () => {\n    throw new TypeError('file is required');\n}, \n/* c8 ignore stop */\n(opt, entries) => {\n    if (!(0, options_js_1.isFile)(opt)) {\n        throw new TypeError('file is required');\n    }\n    if (opt.gzip ||\n        opt.brotli ||\n        opt.file.endsWith('.br') ||\n        opt.file.endsWith('.tbr')) {\n        throw new TypeError('cannot append to compressed archives');\n    }\n    if (!entries?.length) {\n        throw new TypeError('no paths specified to add/replace');\n    }\n});\n//# sourceMappingURL=replace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvcmVwbGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHNGQUFxQjtBQUNuRCxrQ0FBa0MsbUJBQU8sQ0FBQyx3QkFBUztBQUNuRCxvQ0FBb0MsbUJBQU8sQ0FBQyw0QkFBVztBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQywrREFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQywyREFBVztBQUNyQywwQkFBMEIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsaUVBQWM7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMkRBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RCw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL3JlcGxhY2UuanM/YTU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwbGFjZSA9IHZvaWQgMDtcbi8vIHRhciAtclxuY29uc3QgZnNfbWluaXBhc3NfMSA9IHJlcXVpcmUoXCJAaXNhYWNzL2ZzLW1pbmlwYXNzXCIpO1xuY29uc3Qgbm9kZV9mc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOmZzXCIpKTtcbmNvbnN0IG5vZGVfcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnBhdGhcIikpO1xuY29uc3QgaGVhZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9oZWFkZXIuanNcIik7XG5jb25zdCBsaXN0X2pzXzEgPSByZXF1aXJlKFwiLi9saXN0LmpzXCIpO1xuY29uc3QgbWFrZV9jb21tYW5kX2pzXzEgPSByZXF1aXJlKFwiLi9tYWtlLWNvbW1hbmQuanNcIik7XG5jb25zdCBvcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xuY29uc3QgcGFja19qc18xID0gcmVxdWlyZShcIi4vcGFjay5qc1wiKTtcbi8vIHN0YXJ0aW5nIGF0IHRoZSBoZWFkIG9mIHRoZSBmaWxlLCByZWFkIGEgSGVhZGVyXG4vLyBJZiB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZCwgdGhhdCdzIG91ciBwb3NpdGlvbiB0byBzdGFydCB3cml0aW5nXG4vLyBJZiBpdCBpcywganVtcCBmb3J3YXJkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSAocm91bmQgdXAgdG8gNTEyKVxuLy8gYW5kIHRyeSBhZ2Fpbi5cbi8vIFdyaXRlIHRoZSBuZXcgUGFjayBzdHJlYW0gc3RhcnRpbmcgdGhlcmUuXG5jb25zdCByZXBsYWNlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gICAgY29uc3QgcCA9IG5ldyBwYWNrX2pzXzEuUGFja1N5bmMob3B0KTtcbiAgICBsZXQgdGhyZXcgPSB0cnVlO1xuICAgIGxldCBmZDtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgdHJ5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZkID0gbm9kZV9mc18xLmRlZmF1bHQub3BlblN5bmMob3B0LmZpbGUsICdyKycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgaWYgKGVyPy5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgIGZkID0gbm9kZV9mc18xLmRlZmF1bHQub3BlblN5bmMob3B0LmZpbGUsICd3KycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3QgPSBub2RlX2ZzXzEuZGVmYXVsdC5mc3RhdFN5bmMoZmQpO1xuICAgICAgICBjb25zdCBoZWFkQnVmID0gQnVmZmVyLmFsbG9jKDUxMik7XG4gICAgICAgIFBPU0lUSU9OOiBmb3IgKHBvc2l0aW9uID0gMDsgcG9zaXRpb24gPCBzdC5zaXplOyBwb3NpdGlvbiArPSA1MTIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGJ1ZlBvcyA9IDAsIGJ5dGVzID0gMDsgYnVmUG9zIDwgNTEyOyBidWZQb3MgKz0gYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IG5vZGVfZnNfMS5kZWZhdWx0LnJlYWRTeW5jKGZkLCBoZWFkQnVmLCBidWZQb3MsIGhlYWRCdWYubGVuZ3RoIC0gYnVmUG9zLCBwb3NpdGlvbiArIGJ1ZlBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGhlYWRCdWZbMF0gPT09IDB4MWYgJiZcbiAgICAgICAgICAgICAgICAgICAgaGVhZEJ1ZlsxXSA9PT0gMHg4Yikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhcHBlbmQgdG8gY29tcHJlc3NlZCBhcmNoaXZlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIFBPU0lUSU9OO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGggPSBuZXcgaGVhZGVyX2pzXzEuSGVhZGVyKGhlYWRCdWYpO1xuICAgICAgICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKChoLnNpemUgfHwgMCkgLyA1MTIpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzdC5zaXplKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgNTEyIGZvciB0aGUgaGVhZGVyIHdlIGp1c3QgcGFyc2VkIHdpbGwgYmUgYWRkZWQgYXMgd2VsbFxuICAgICAgICAgICAgLy8gYWxzbyBqdW1wIGFoZWFkIGFsbCB0aGUgYmxvY2tzIGZvciB0aGUgYm9keVxuICAgICAgICAgICAgcG9zaXRpb24gKz0gZW50cnlCbG9ja1NpemU7XG4gICAgICAgICAgICBpZiAob3B0Lm10aW1lQ2FjaGUgJiYgaC5tdGltZSkge1xuICAgICAgICAgICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChTdHJpbmcoaC5wYXRoKSwgaC5tdGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXcgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtU3luYyhvcHQsIHAsIHBvc2l0aW9uLCBmZCwgZmlsZXMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHsgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHN0cmVhbVN5bmMgPSAob3B0LCBwLCBwb3NpdGlvbiwgZmQsIGZpbGVzKSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzX21pbmlwYXNzXzEuV3JpdGVTdHJlYW1TeW5jKG9wdC5maWxlLCB7XG4gICAgICAgIGZkOiBmZCxcbiAgICAgICAgc3RhcnQ6IHBvc2l0aW9uLFxuICAgIH0pO1xuICAgIHAucGlwZShzdHJlYW0pO1xuICAgIGFkZEZpbGVzU3luYyhwLCBmaWxlcyk7XG59O1xuY29uc3QgcmVwbGFjZUFzeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpO1xuICAgIGNvbnN0IHAgPSBuZXcgcGFja19qc18xLlBhY2sob3B0KTtcbiAgICBjb25zdCBnZXRQb3MgPSAoZmQsIHNpemUsIGNiXykgPT4ge1xuICAgICAgICBjb25zdCBjYiA9IChlciwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5jbG9zZShmZCwgXyA9PiBjYl8oZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiXyhudWxsLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWZQb3MgPSAwO1xuICAgICAgICBjb25zdCBoZWFkQnVmID0gQnVmZmVyLmFsbG9jKDUxMik7XG4gICAgICAgIGNvbnN0IG9ucmVhZCA9IChlciwgYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlciB8fCB0eXBlb2YgYnl0ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZlBvcyArPSBieXRlcztcbiAgICAgICAgICAgIGlmIChidWZQb3MgPCA1MTIgJiYgYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZV9mc18xLmRlZmF1bHQucmVhZChmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcywgcG9zaXRpb24gKyBidWZQb3MsIG9ucmVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBoZWFkQnVmWzBdID09PSAweDFmICYmXG4gICAgICAgICAgICAgICAgaGVhZEJ1ZlsxXSA9PT0gMHg4Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2Nhbm5vdCBhcHBlbmQgdG8gY29tcHJlc3NlZCBhcmNoaXZlcycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRydW5jYXRlZCBoZWFkZXJcbiAgICAgICAgICAgIGlmIChidWZQb3MgPCA1MTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaCA9IG5ldyBoZWFkZXJfanNfMS5IZWFkZXIoaGVhZEJ1Zik7XG4gICAgICAgICAgICBpZiAoIWguY2tzdW1WYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY29uc3QgZW50cnlCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoKGguc2l6ZSA/PyAwKSAvIDUxMik7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gKyBlbnRyeUJsb2NrU2l6ZSArIDUxMiA+IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zaXRpb24gKz0gZW50cnlCbG9ja1NpemUgKyA1MTI7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lm10aW1lQ2FjaGUgJiYgaC5tdGltZSkge1xuICAgICAgICAgICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChTdHJpbmcoaC5wYXRoKSwgaC5tdGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZQb3MgPSAwO1xuICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQucmVhZChmZCwgaGVhZEJ1ZiwgMCwgNTEyLCBwb3NpdGlvbiwgb25yZWFkKTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQucmVhZChmZCwgaGVhZEJ1ZiwgMCwgNTEyLCBwb3NpdGlvbiwgb25yZWFkKTtcbiAgICB9O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHAub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgbGV0IGZsYWcgPSAncisnO1xuICAgICAgICBjb25zdCBvbm9wZW4gPSAoZXIsIGZkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcgJiYgZmxhZyA9PT0gJ3IrJykge1xuICAgICAgICAgICAgICAgIGZsYWcgPSAndysnO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlX2ZzXzEuZGVmYXVsdC5vcGVuKG9wdC5maWxlLCBmbGFnLCBvbm9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyIHx8ICFmZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQuZnN0YXQoZmQsIChlciwgc3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVfZnNfMS5kZWZhdWx0LmNsb3NlKGZkLCAoKSA9PiByZWplY3QoZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0UG9zKGZkLCBzdC5zaXplLCAoZXIsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzX21pbmlwYXNzXzEuV3JpdGVTdHJlYW0ob3B0LmZpbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkOiBmZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHAucGlwZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5vcGVuKG9wdC5maWxlLCBmbGFnLCBvbm9wZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IGFkZEZpbGVzU3luYyA9IChwLCBmaWxlcykgPT4ge1xuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAoMCwgbGlzdF9qc18xLmxpc3QpKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgICAgICAgICAgb25SZWFkRW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5hZGQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBwLmVuZCgpO1xufTtcbmNvbnN0IGFkZEZpbGVzQXN5bmMgPSBhc3luYyAocCwgZmlsZXMpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBTdHJpbmcoZmlsZXNbaV0pO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgICAgICAgYXdhaXQgKDAsIGxpc3RfanNfMS5saXN0KSh7XG4gICAgICAgICAgICAgICAgZmlsZTogbm9kZV9wYXRoXzEuZGVmYXVsdC5yZXNvbHZlKFN0cmluZyhwLmN3ZCksIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uUmVhZEVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAuYWRkKGZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAuZW5kKCk7XG59O1xuZXhwb3J0cy5yZXBsYWNlID0gKDAsIG1ha2VfY29tbWFuZF9qc18xLm1ha2VDb21tYW5kKShyZXBsYWNlU3luYywgcmVwbGFjZUFzeW5jLCBcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuKCkgPT4ge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKTtcbn0sICgpID0+IHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJyk7XG59LCBcbi8qIGM4IGlnbm9yZSBzdG9wICovXG4ob3B0LCBlbnRyaWVzKSA9PiB7XG4gICAgaWYgKCEoMCwgb3B0aW9uc19qc18xLmlzRmlsZSkob3B0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChvcHQuZ3ppcCB8fFxuICAgICAgICBvcHQuYnJvdGxpIHx8XG4gICAgICAgIG9wdC5maWxlLmVuZHNXaXRoKCcuYnInKSB8fFxuICAgICAgICBvcHQuZmlsZS5lbmRzV2l0aCgnLnRicicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBhcHBlbmQgdG8gY29tcHJlc3NlZCBhcmNoaXZlcycpO1xuICAgIH1cbiAgICBpZiAoIWVudHJpZXM/Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBwYXRocyBzcGVjaWZpZWQgdG8gYWRkL3JlcGxhY2UnKTtcbiAgICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGxhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/replace.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/strip-absolute-path.js":
/*!***************************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/strip-absolute-path.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stripAbsolutePath = void 0;\n// unix absolute paths are also absolute on win32, so we use this for both\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst { isAbsolute, parse } = node_path_1.win32;\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nconst stripAbsolutePath = (path) => {\n    let r = '';\n    let parsed = parse(path);\n    while (isAbsolute(path) || parsed.root) {\n        // windows will think that //x/y/z has a \"root\" of //x/y/\n        // but strip the //?/C:/ off of //?/C:/path\n        const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?\n            '/'\n            : parsed.root;\n        path = path.slice(root.length);\n        r += root;\n        parsed = parse(path);\n    }\n    return [r, path];\n};\nexports.stripAbsolutePath = stripAbsolutePath;\n//# sourceMappingURL=strip-absolute-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyw0QkFBVztBQUN2QyxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzPzJhYzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmlwQWJzb2x1dGVQYXRoID0gdm9pZCAwO1xuLy8gdW5peCBhYnNvbHV0ZSBwYXRocyBhcmUgYWxzbyBhYnNvbHV0ZSBvbiB3aW4zMiwgc28gd2UgdXNlIHRoaXMgZm9yIGJvdGhcbmNvbnN0IG5vZGVfcGF0aF8xID0gcmVxdWlyZShcIm5vZGU6cGF0aFwiKTtcbmNvbnN0IHsgaXNBYnNvbHV0ZSwgcGFyc2UgfSA9IG5vZGVfcGF0aF8xLndpbjMyO1xuLy8gcmV0dXJucyBbcm9vdCwgc3RyaXBwZWRdXG4vLyBOb3RlIHRoYXQgd2luZG93cyB3aWxsIHRoaW5rIHRoYXQgLy94L3kvei9hIGhhcyBhIFwicm9vdFwiIG9mIC8veC95LCBhbmQgaW5cbi8vIHRob3NlIGNhc2VzLCB3ZSB3YW50IHRvIHNhbml0aXplIGl0IHRvIHgveS96L2EsIG5vdCB6L2EsIHNvIHdlIHN0cmlwIC9cbi8vIGV4cGxpY2l0bHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyLlxuLy8gZHJpdmUtc3BlY2lmaWMgcmVsYXRpdmUgcGF0aHMgb24gV2luZG93cyBnZXQgdGhlaXIgcm9vdCBzdHJpcHBlZCBvZmYgZXZlblxuLy8gdGhvdWdoIHRoZXkgYXJlIG5vdCBhYnNvbHV0ZSwgc28gYGM6Li4vZm9vYCBiZWNvbWVzIFsnYzonLCAnLi4vZm9vJ11cbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gKHBhdGgpID0+IHtcbiAgICBsZXQgciA9ICcnO1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZShwYXRoKTtcbiAgICB3aGlsZSAoaXNBYnNvbHV0ZShwYXRoKSB8fCBwYXJzZWQucm9vdCkge1xuICAgICAgICAvLyB3aW5kb3dzIHdpbGwgdGhpbmsgdGhhdCAvL3gveS96IGhhcyBhIFwicm9vdFwiIG9mIC8veC95L1xuICAgICAgICAvLyBidXQgc3RyaXAgdGhlIC8vPy9DOi8gb2ZmIG9mIC8vPy9DOi9wYXRoXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nICYmIHBhdGguc2xpY2UoMCwgNCkgIT09ICcvLz8vJyA/XG4gICAgICAgICAgICAnLydcbiAgICAgICAgICAgIDogcGFyc2VkLnJvb3Q7XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKHJvb3QubGVuZ3RoKTtcbiAgICAgICAgciArPSByb290O1xuICAgICAgICBwYXJzZWQgPSBwYXJzZShwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyLCBwYXRoXTtcbn07XG5leHBvcnRzLnN0cmlwQWJzb2x1dGVQYXRoID0gc3RyaXBBYnNvbHV0ZVBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/strip-absolute-path.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/strip-trailing-slashes.js":
/*!******************************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/strip-trailing-slashes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stripTrailingSlashes = void 0;\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst stripTrailingSlashes = (str) => {\n    let i = str.length - 1;\n    let slashesStart = -1;\n    while (i > -1 && str.charAt(i) === '/') {\n        slashesStart = i;\n        i--;\n    }\n    return slashesStart === -1 ? str : str.slice(0, slashesStart);\n};\nexports.stripTrailingSlashes = stripTrailingSlashes;\n//# sourceMappingURL=strip-trailing-slashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzPzA0ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaGVzID0gdm9pZCAwO1xuLy8gd2FybmluZzogZXh0cmVtZWx5IGhvdCBjb2RlIHBhdGguXG4vLyBUaGlzIGhhcyBiZWVuIG1ldGljdWxvdXNseSBvcHRpbWl6ZWQgZm9yIHVzZVxuLy8gd2l0aGluIG5wbSBpbnN0YWxsIG9uIGxhcmdlIHBhY2thZ2UgdHJlZXMuXG4vLyBEbyBub3QgZWRpdCB3aXRob3V0IGNhcmVmdWwgYmVuY2htYXJraW5nLlxuY29uc3Qgc3RyaXBUcmFpbGluZ1NsYXNoZXMgPSAoc3RyKSA9PiB7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoIC0gMTtcbiAgICBsZXQgc2xhc2hlc1N0YXJ0ID0gLTE7XG4gICAgd2hpbGUgKGkgPiAtMSAmJiBzdHIuY2hhckF0KGkpID09PSAnLycpIHtcbiAgICAgICAgc2xhc2hlc1N0YXJ0ID0gaTtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gc2xhc2hlc1N0YXJ0ID09PSAtMSA/IHN0ciA6IHN0ci5zbGljZSgwLCBzbGFzaGVzU3RhcnQpO1xufTtcbmV4cG9ydHMuc3RyaXBUcmFpbGluZ1NsYXNoZXMgPSBzdHJpcFRyYWlsaW5nU2xhc2hlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/strip-trailing-slashes.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/symlink-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/symlink-error.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SymlinkError = void 0;\nclass SymlinkError extends Error {\n    path;\n    symlink;\n    syscall = 'symlink';\n    code = 'TAR_SYMLINK_ERROR';\n    constructor(symlink, path) {\n        super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link');\n        this.symlink = symlink;\n        this.path = path;\n    }\n    get name() {\n        return 'SymlinkError';\n    }\n}\nexports.SymlinkError = SymlinkError;\n//# sourceMappingURL=symlink-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvc3ltbGluay1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL3N5bWxpbmstZXJyb3IuanM/MzhkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ltbGlua0Vycm9yID0gdm9pZCAwO1xuY2xhc3MgU3ltbGlua0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHBhdGg7XG4gICAgc3ltbGluaztcbiAgICBzeXNjYWxsID0gJ3N5bWxpbmsnO1xuICAgIGNvZGUgPSAnVEFSX1NZTUxJTktfRVJST1InO1xuICAgIGNvbnN0cnVjdG9yKHN5bWxpbmssIHBhdGgpIHtcbiAgICAgICAgc3VwZXIoJ1RBUl9TWU1MSU5LX0VSUk9SOiBDYW5ub3QgZXh0cmFjdCB0aHJvdWdoIHN5bWJvbGljIGxpbmsnKTtcbiAgICAgICAgdGhpcy5zeW1saW5rID0gc3ltbGluaztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnU3ltbGlua0Vycm9yJztcbiAgICB9XG59XG5leHBvcnRzLlN5bWxpbmtFcnJvciA9IFN5bWxpbmtFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5bWxpbmstZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/symlink-error.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/types.js":
/*!*************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.code = exports.name = exports.isName = exports.isCode = void 0;\nconst isCode = (c) => exports.name.has(c);\nexports.isCode = isCode;\nconst isName = (c) => exports.code.has(c);\nexports.isName = isName;\n// map types from key to human-friendly name\nexports.name = new Map([\n    ['0', 'File'],\n    // same as File\n    ['', 'OldFile'],\n    ['1', 'Link'],\n    ['2', 'SymbolicLink'],\n    // Devices and FIFOs aren't fully supported\n    // they are parsed, but skipped when unpacking\n    ['3', 'CharacterDevice'],\n    ['4', 'BlockDevice'],\n    ['5', 'Directory'],\n    ['6', 'FIFO'],\n    // same as File\n    ['7', 'ContiguousFile'],\n    // pax headers\n    ['g', 'GlobalExtendedHeader'],\n    ['x', 'ExtendedHeader'],\n    // vendor-specific stuff\n    // skip\n    ['A', 'SolarisACL'],\n    // like 5, but with data, which should be skipped\n    ['D', 'GNUDumpDir'],\n    // metadata only, skip\n    ['I', 'Inode'],\n    // data = link path of next file\n    ['K', 'NextFileHasLongLinkpath'],\n    // data = path of next file\n    ['L', 'NextFileHasLongPath'],\n    // skip\n    ['M', 'ContinuationFile'],\n    // like L\n    ['N', 'OldGnuLongPath'],\n    // skip\n    ['S', 'SparseFile'],\n    // skip\n    ['V', 'TapeVolumeHeader'],\n    // like x\n    ['X', 'OldExtendedHeader'],\n]);\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsY0FBYztBQUM3RDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy90eXBlcy5qcz80NGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb2RlID0gZXhwb3J0cy5uYW1lID0gZXhwb3J0cy5pc05hbWUgPSBleHBvcnRzLmlzQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGlzQ29kZSA9IChjKSA9PiBleHBvcnRzLm5hbWUuaGFzKGMpO1xuZXhwb3J0cy5pc0NvZGUgPSBpc0NvZGU7XG5jb25zdCBpc05hbWUgPSAoYykgPT4gZXhwb3J0cy5jb2RlLmhhcyhjKTtcbmV4cG9ydHMuaXNOYW1lID0gaXNOYW1lO1xuLy8gbWFwIHR5cGVzIGZyb20ga2V5IHRvIGh1bWFuLWZyaWVuZGx5IG5hbWVcbmV4cG9ydHMubmFtZSA9IG5ldyBNYXAoW1xuICAgIFsnMCcsICdGaWxlJ10sXG4gICAgLy8gc2FtZSBhcyBGaWxlXG4gICAgWycnLCAnT2xkRmlsZSddLFxuICAgIFsnMScsICdMaW5rJ10sXG4gICAgWycyJywgJ1N5bWJvbGljTGluayddLFxuICAgIC8vIERldmljZXMgYW5kIEZJRk9zIGFyZW4ndCBmdWxseSBzdXBwb3J0ZWRcbiAgICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gICAgWyczJywgJ0NoYXJhY3RlckRldmljZSddLFxuICAgIFsnNCcsICdCbG9ja0RldmljZSddLFxuICAgIFsnNScsICdEaXJlY3RvcnknXSxcbiAgICBbJzYnLCAnRklGTyddLFxuICAgIC8vIHNhbWUgYXMgRmlsZVxuICAgIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAgIC8vIHBheCBoZWFkZXJzXG4gICAgWydnJywgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJ10sXG4gICAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gICAgLy8gdmVuZG9yLXNwZWNpZmljIHN0dWZmXG4gICAgLy8gc2tpcFxuICAgIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gICAgLy8gbGlrZSA1LCBidXQgd2l0aCBkYXRhLCB3aGljaCBzaG91bGQgYmUgc2tpcHBlZFxuICAgIFsnRCcsICdHTlVEdW1wRGlyJ10sXG4gICAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICAgIFsnSScsICdJbm9kZSddLFxuICAgIC8vIGRhdGEgPSBsaW5rIHBhdGggb2YgbmV4dCBmaWxlXG4gICAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gICAgLy8gZGF0YSA9IHBhdGggb2YgbmV4dCBmaWxlXG4gICAgWydMJywgJ05leHRGaWxlSGFzTG9uZ1BhdGgnXSxcbiAgICAvLyBza2lwXG4gICAgWydNJywgJ0NvbnRpbnVhdGlvbkZpbGUnXSxcbiAgICAvLyBsaWtlIExcbiAgICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgICAvLyBza2lwXG4gICAgWydTJywgJ1NwYXJzZUZpbGUnXSxcbiAgICAvLyBza2lwXG4gICAgWydWJywgJ1RhcGVWb2x1bWVIZWFkZXInXSxcbiAgICAvLyBsaWtlIHhcbiAgICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXSxcbl0pO1xuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydHMuY29kZSA9IG5ldyBNYXAoQXJyYXkuZnJvbShleHBvcnRzLm5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/types.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/unpack.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/unpack.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnpackSync = exports.Unpack = void 0;\nconst fsm = __importStar(__webpack_require__(/*! @isaacs/fs-minipass */ \"./node_modules/@isaacs/fs-minipass/dist/commonjs/index.js\"));\nconst node_assert_1 = __importDefault(__webpack_require__(/*! node:assert */ \"node:assert\"));\nconst node_crypto_1 = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nconst node_fs_1 = __importDefault(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst node_path_1 = __importDefault(__webpack_require__(/*! node:path */ \"node:path\"));\nconst get_write_flag_js_1 = __webpack_require__(/*! ./get-write-flag.js */ \"./node_modules/tar/dist/commonjs/get-write-flag.js\");\nconst mkdir_js_1 = __webpack_require__(/*! ./mkdir.js */ \"./node_modules/tar/dist/commonjs/mkdir.js\");\nconst normalize_unicode_js_1 = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/dist/commonjs/normalize-unicode.js\");\nconst normalize_windows_path_js_1 = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/dist/commonjs/normalize-windows-path.js\");\nconst parse_js_1 = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/dist/commonjs/parse.js\");\nconst strip_absolute_path_js_1 = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/dist/commonjs/strip-absolute-path.js\");\nconst strip_trailing_slashes_js_1 = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/dist/commonjs/strip-trailing-slashes.js\");\nconst wc = __importStar(__webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/dist/commonjs/winchars.js\"));\nconst path_reservations_js_1 = __webpack_require__(/*! ./path-reservations.js */ \"./node_modules/tar/dist/commonjs/path-reservations.js\");\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024;\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* c8 ignore start */\nconst unlinkFile = (path, cb) => {\n    if (!isWindows) {\n        return node_fs_1.default.unlink(path, cb);\n    }\n    const name = path + '.DELETE.' + (0, node_crypto_1.randomBytes)(16).toString('hex');\n    node_fs_1.default.rename(path, name, er => {\n        if (er) {\n            return cb(er);\n        }\n        node_fs_1.default.unlink(name, cb);\n    });\n};\n/* c8 ignore stop */\n/* c8 ignore start */\nconst unlinkFileSync = (path) => {\n    if (!isWindows) {\n        return node_fs_1.default.unlinkSync(path);\n    }\n    const name = path + '.DELETE.' + (0, node_crypto_1.randomBytes)(16).toString('hex');\n    node_fs_1.default.renameSync(path, name);\n    node_fs_1.default.unlinkSync(name);\n};\n/* c8 ignore stop */\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a\n    : b !== undefined && b === b >>> 0 ? b\n        : c;\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = (path) => (0, strip_trailing_slashes_js_1.stripTrailingSlashes)((0, normalize_windows_path_js_1.normalizeWindowsPath)((0, normalize_unicode_js_1.normalizeUnicode)(path))).toLowerCase();\n// remove all cache entries matching ${abs}/**\nconst pruneCache = (cache, abs) => {\n    abs = cacheKeyNormalize(abs);\n    for (const path of cache.keys()) {\n        const pnorm = cacheKeyNormalize(path);\n        if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n            cache.delete(path);\n        }\n    }\n};\nconst dropCache = (cache) => {\n    for (const key of cache.keys()) {\n        cache.delete(key);\n    }\n};\nclass Unpack extends parse_js_1.Parser {\n    [ENDED] = false;\n    [CHECKED_CWD] = false;\n    [PENDING] = 0;\n    reservations = new path_reservations_js_1.PathReservations();\n    transform;\n    writable = true;\n    readable = false;\n    dirCache;\n    uid;\n    gid;\n    setOwner;\n    preserveOwner;\n    processGid;\n    processUid;\n    maxDepth;\n    forceChown;\n    win32;\n    newer;\n    keep;\n    noMtime;\n    preservePaths;\n    unlink;\n    cwd;\n    strip;\n    processUmask;\n    umask;\n    dmode;\n    fmode;\n    chmod;\n    constructor(opt = {}) {\n        opt.ondone = () => {\n            this[ENDED] = true;\n            this[MAYBECLOSE]();\n        };\n        super(opt);\n        this.transform = opt.transform;\n        this.dirCache = opt.dirCache || new Map();\n        this.chmod = !!opt.chmod;\n        if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n            // need both or neither\n            if (typeof opt.uid !== 'number' ||\n                typeof opt.gid !== 'number') {\n                throw new TypeError('cannot set owner without number uid and gid');\n            }\n            if (opt.preserveOwner) {\n                throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n            }\n            this.uid = opt.uid;\n            this.gid = opt.gid;\n            this.setOwner = true;\n        }\n        else {\n            this.uid = undefined;\n            this.gid = undefined;\n            this.setOwner = false;\n        }\n        // default true for root\n        if (opt.preserveOwner === undefined &&\n            typeof opt.uid !== 'number') {\n            this.preserveOwner = !!(process.getuid && process.getuid() === 0);\n        }\n        else {\n            this.preserveOwner = !!opt.preserveOwner;\n        }\n        this.processUid =\n            (this.preserveOwner || this.setOwner) && process.getuid ?\n                process.getuid()\n                : undefined;\n        this.processGid =\n            (this.preserveOwner || this.setOwner) && process.getgid ?\n                process.getgid()\n                : undefined;\n        // prevent excessively deep nesting of subfolders\n        // set to `Infinity` to remove this restriction\n        this.maxDepth =\n            typeof opt.maxDepth === 'number' ?\n                opt.maxDepth\n                : DEFAULT_MAX_DEPTH;\n        // mostly just for testing, but useful in some cases.\n        // Forcibly trigger a chown on every entry, no matter what\n        this.forceChown = opt.forceChown === true;\n        // turn ><?| in filenames into 0xf000-higher encoded forms\n        this.win32 = !!opt.win32 || isWindows;\n        // do not unpack over files that are newer than what's in the archive\n        this.newer = !!opt.newer;\n        // do not unpack over ANY files\n        this.keep = !!opt.keep;\n        // do not set mtime/atime of extracted entries\n        this.noMtime = !!opt.noMtime;\n        // allow .., absolute path entries, and unpacking through symlinks\n        // without this, warn and skip .., relativize absolutes, and error\n        // on symlinks in extraction path\n        this.preservePaths = !!opt.preservePaths;\n        // unlink files and links before writing. This breaks existing hard\n        // links, and removes symlink directories rather than erroring\n        this.unlink = !!opt.unlink;\n        this.cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(opt.cwd || process.cwd()));\n        this.strip = Number(opt.strip) || 0;\n        // if we're not chmodding, then we don't need the process umask\n        this.processUmask =\n            !this.chmod ? 0\n                : typeof opt.processUmask === 'number' ? opt.processUmask\n                    : process.umask();\n        this.umask =\n            typeof opt.umask === 'number' ? opt.umask : this.processUmask;\n        // default mode for dirs created as parents\n        this.dmode = opt.dmode || 0o0777 & ~this.umask;\n        this.fmode = opt.fmode || 0o0666 & ~this.umask;\n        this.on('entry', entry => this[ONENTRY](entry));\n    }\n    // a bad or damaged archive is a warning for Parser, but an error\n    // when extracting.  Mark those errors as unrecoverable, because\n    // the Unpack contract cannot be met.\n    warn(code, msg, data = {}) {\n        if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n            data.recoverable = false;\n        }\n        return super.warn(code, msg, data);\n    }\n    [MAYBECLOSE]() {\n        if (this[ENDED] && this[PENDING] === 0) {\n            this.emit('prefinish');\n            this.emit('finish');\n            this.emit('end');\n        }\n    }\n    [CHECKPATH](entry) {\n        const p = (0, normalize_windows_path_js_1.normalizeWindowsPath)(entry.path);\n        const parts = p.split('/');\n        if (this.strip) {\n            if (parts.length < this.strip) {\n                return false;\n            }\n            if (entry.type === 'Link') {\n                const linkparts = (0, normalize_windows_path_js_1.normalizeWindowsPath)(String(entry.linkpath)).split('/');\n                if (linkparts.length >= this.strip) {\n                    entry.linkpath = linkparts.slice(this.strip).join('/');\n                }\n                else {\n                    return false;\n                }\n            }\n            parts.splice(0, this.strip);\n            entry.path = parts.join('/');\n        }\n        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n                entry,\n                path: p,\n                depth: parts.length,\n                maxDepth: this.maxDepth,\n            });\n            return false;\n        }\n        if (!this.preservePaths) {\n            if (parts.includes('..') ||\n                /* c8 ignore next */\n                (isWindows && /^[a-z]:\\.\\.$/i.test(parts[0] ?? ''))) {\n                this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n                    entry,\n                    path: p,\n                });\n                return false;\n            }\n            // strip off the root\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(p);\n            if (root) {\n                entry.path = String(stripped);\n                this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n                    entry,\n                    path: p,\n                });\n            }\n        }\n        if (node_path_1.default.isAbsolute(entry.path)) {\n            entry.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(entry.path));\n        }\n        else {\n            entry.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, entry.path));\n        }\n        // if we somehow ended up with a path that escapes the cwd, and we are\n        // not in preservePaths mode, then something is fishy!  This should have\n        // been prevented above, so ignore this for coverage.\n        /* c8 ignore start - defense in depth */\n        if (!this.preservePaths &&\n            typeof entry.absolute === 'string' &&\n            entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n            entry.absolute !== this.cwd) {\n            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n                entry,\n                path: (0, normalize_windows_path_js_1.normalizeWindowsPath)(entry.path),\n                resolvedPath: entry.absolute,\n                cwd: this.cwd,\n            });\n            return false;\n        }\n        /* c8 ignore stop */\n        // an archive can set properties on the extraction directory, but it\n        // may not replace the cwd with a different kind of thing entirely.\n        if (entry.absolute === this.cwd &&\n            entry.type !== 'Directory' &&\n            entry.type !== 'GNUDumpDir') {\n            return false;\n        }\n        // only encode : chars that aren't drive letter indicators\n        if (this.win32) {\n            const { root: aRoot } = node_path_1.default.win32.parse(String(entry.absolute));\n            entry.absolute =\n                aRoot + wc.encode(String(entry.absolute).slice(aRoot.length));\n            const { root: pRoot } = node_path_1.default.win32.parse(entry.path);\n            entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n        }\n        return true;\n    }\n    [ONENTRY](entry) {\n        if (!this[CHECKPATH](entry)) {\n            return entry.resume();\n        }\n        node_assert_1.default.equal(typeof entry.absolute, 'string');\n        switch (entry.type) {\n            case 'Directory':\n            case 'GNUDumpDir':\n                if (entry.mode) {\n                    entry.mode = entry.mode | 0o700;\n                }\n            // eslint-disable-next-line no-fallthrough\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n            case 'Link':\n            case 'SymbolicLink':\n                return this[CHECKFS](entry);\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'FIFO':\n            default:\n                return this[UNSUPPORTED](entry);\n        }\n    }\n    [ONERROR](er, entry) {\n        // Cwd has to exist, or else nothing works. That's serious.\n        // Other errors are warnings, which raise the error in strict\n        // mode, but otherwise continue on.\n        if (er.name === 'CwdError') {\n            this.emit('error', er);\n        }\n        else {\n            this.warn('TAR_ENTRY_ERROR', er, { entry });\n            this[UNPEND]();\n            entry.resume();\n        }\n    }\n    [MKDIR](dir, mode, cb) {\n        (0, mkdir_js_1.mkdir)((0, normalize_windows_path_js_1.normalizeWindowsPath)(dir), {\n            uid: this.uid,\n            gid: this.gid,\n            processUid: this.processUid,\n            processGid: this.processGid,\n            umask: this.processUmask,\n            preserve: this.preservePaths,\n            unlink: this.unlink,\n            cache: this.dirCache,\n            cwd: this.cwd,\n            mode: mode,\n        }, cb);\n    }\n    [DOCHOWN](entry) {\n        // in preserve owner mode, chown if the entry doesn't match process\n        // in set owner mode, chown if setting doesn't match process\n        return (this.forceChown ||\n            (this.preserveOwner &&\n                ((typeof entry.uid === 'number' &&\n                    entry.uid !== this.processUid) ||\n                    (typeof entry.gid === 'number' &&\n                        entry.gid !== this.processGid))) ||\n            (typeof this.uid === 'number' &&\n                this.uid !== this.processUid) ||\n            (typeof this.gid === 'number' && this.gid !== this.processGid));\n    }\n    [UID](entry) {\n        return uint32(this.uid, entry.uid, this.processUid);\n    }\n    [GID](entry) {\n        return uint32(this.gid, entry.gid, this.processGid);\n    }\n    [FILE](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const stream = new fsm.WriteStream(String(entry.absolute), {\n            // slight lie, but it can be numeric flags\n            flags: (0, get_write_flag_js_1.getWriteFlag)(entry.size),\n            mode: mode,\n            autoClose: false,\n        });\n        stream.on('error', (er) => {\n            if (stream.fd) {\n                node_fs_1.default.close(stream.fd, () => { });\n            }\n            // flush all the data out so that we aren't left hanging\n            // if the error wasn't actually fatal.  otherwise the parse\n            // is blocked, and we never proceed.\n            stream.write = () => true;\n            this[ONERROR](er, entry);\n            fullyDone();\n        });\n        let actions = 1;\n        const done = (er) => {\n            if (er) {\n                /* c8 ignore start - we should always have a fd by now */\n                if (stream.fd) {\n                    node_fs_1.default.close(stream.fd, () => { });\n                }\n                /* c8 ignore stop */\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            if (--actions === 0) {\n                if (stream.fd !== undefined) {\n                    node_fs_1.default.close(stream.fd, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                        }\n                        else {\n                            this[UNPEND]();\n                        }\n                        fullyDone();\n                    });\n                }\n            }\n        };\n        stream.on('finish', () => {\n            // if futimes fails, try utimes\n            // if utimes fails, fail with the original error\n            // same for fchown/chown\n            const abs = String(entry.absolute);\n            const fd = stream.fd;\n            if (typeof fd === 'number' && entry.mtime && !this.noMtime) {\n                actions++;\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                node_fs_1.default.futimes(fd, atime, mtime, er => er ?\n                    node_fs_1.default.utimes(abs, atime, mtime, er2 => done(er2 && er))\n                    : done());\n            }\n            if (typeof fd === 'number' && this[DOCHOWN](entry)) {\n                actions++;\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                if (typeof uid === 'number' && typeof gid === 'number') {\n                    node_fs_1.default.fchown(fd, uid, gid, er => er ?\n                        node_fs_1.default.chown(abs, uid, gid, er2 => done(er2 && er))\n                        : done());\n                }\n            }\n            done();\n        });\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => {\n                this[ONERROR](er, entry);\n                fullyDone();\n            });\n            entry.pipe(tx);\n        }\n        tx.pipe(stream);\n    }\n    [DIRECTORY](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        this[MKDIR](String(entry.absolute), mode, er => {\n            if (er) {\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            let actions = 1;\n            const done = () => {\n                if (--actions === 0) {\n                    fullyDone();\n                    this[UNPEND]();\n                    entry.resume();\n                }\n            };\n            if (entry.mtime && !this.noMtime) {\n                actions++;\n                node_fs_1.default.utimes(String(entry.absolute), entry.atime || new Date(), entry.mtime, done);\n            }\n            if (this[DOCHOWN](entry)) {\n                actions++;\n                node_fs_1.default.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);\n            }\n            done();\n        });\n    }\n    [UNSUPPORTED](entry) {\n        entry.unsupported = true;\n        this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, { entry });\n        entry.resume();\n    }\n    [SYMLINK](entry, done) {\n        this[LINK](entry, String(entry.linkpath), 'symlink', done);\n    }\n    [HARDLINK](entry, done) {\n        const linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, String(entry.linkpath)));\n        this[LINK](entry, linkpath, 'link', done);\n    }\n    [PEND]() {\n        this[PENDING]++;\n    }\n    [UNPEND]() {\n        this[PENDING]--;\n        this[MAYBECLOSE]();\n    }\n    [SKIP](entry) {\n        this[UNPEND]();\n        entry.resume();\n    }\n    // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n    [ISREUSABLE](entry, st) {\n        return (entry.type === 'File' &&\n            !this.unlink &&\n            st.isFile() &&\n            st.nlink <= 1 &&\n            !isWindows);\n    }\n    // check if a thing is there, and if so, try to clobber it\n    [CHECKFS](entry) {\n        this[PEND]();\n        const paths = [entry.path];\n        if (entry.linkpath) {\n            paths.push(entry.linkpath);\n        }\n        this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n    }\n    [PRUNECACHE](entry) {\n        // if we are not creating a directory, and the path is in the dirCache,\n        // then that means we are about to delete the directory we created\n        // previously, and it is no longer going to be a directory, and neither\n        // is any of its children.\n        // If a symbolic link is encountered, all bets are off.  There is no\n        // reasonable way to sanitize the cache in such a way we will be able to\n        // avoid having filesystem collisions.  If this happens with a non-symlink\n        // entry, it'll just fail to unpack, but a symlink to a directory, using an\n        // 8.3 shortname or certain unicode attacks, can evade detection and lead\n        // to arbitrary writes to anywhere on the system.\n        if (entry.type === 'SymbolicLink') {\n            dropCache(this.dirCache);\n        }\n        else if (entry.type !== 'Directory') {\n            pruneCache(this.dirCache, String(entry.absolute));\n        }\n    }\n    [CHECKFS2](entry, fullyDone) {\n        this[PRUNECACHE](entry);\n        const done = (er) => {\n            this[PRUNECACHE](entry);\n            fullyDone(er);\n        };\n        const checkCwd = () => {\n            this[MKDIR](this.cwd, this.dmode, er => {\n                if (er) {\n                    this[ONERROR](er, entry);\n                    done();\n                    return;\n                }\n                this[CHECKED_CWD] = true;\n                start();\n            });\n        };\n        const start = () => {\n            if (entry.absolute !== this.cwd) {\n                const parent = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.dirname(String(entry.absolute)));\n                if (parent !== this.cwd) {\n                    return this[MKDIR](parent, this.dmode, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                            done();\n                            return;\n                        }\n                        afterMakeParent();\n                    });\n                }\n            }\n            afterMakeParent();\n        };\n        const afterMakeParent = () => {\n            node_fs_1.default.lstat(String(entry.absolute), (lstatEr, st) => {\n                if (st &&\n                    (this.keep ||\n                        /* c8 ignore next */\n                        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n                    this[SKIP](entry);\n                    done();\n                    return;\n                }\n                if (lstatEr || this[ISREUSABLE](entry, st)) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                if (st.isDirectory()) {\n                    if (entry.type === 'Directory') {\n                        const needChmod = this.chmod &&\n                            entry.mode &&\n                            (st.mode & 0o7777) !== entry.mode;\n                        const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);\n                        if (!needChmod) {\n                            return afterChmod();\n                        }\n                        return node_fs_1.default.chmod(String(entry.absolute), Number(entry.mode), afterChmod);\n                    }\n                    // Not a dir entry, have to remove it.\n                    // NB: the only way to end up with an entry that is the cwd\n                    // itself, in such a way that == does not detect, is a\n                    // tricky windows absolute path with UNC or 8.3 parts (and\n                    // preservePaths:true, or else it will have been stripped).\n                    // In that case, the user has opted out of path protections\n                    // explicitly, so if they blow away the cwd, c'est la vie.\n                    if (entry.absolute !== this.cwd) {\n                        return node_fs_1.default.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));\n                    }\n                }\n                // not a dir, and not reusable\n                // don't remove if the cwd, we want that error\n                if (entry.absolute === this.cwd) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                unlinkFile(String(entry.absolute), er => this[MAKEFS](er ?? null, entry, done));\n            });\n        };\n        if (this[CHECKED_CWD]) {\n            start();\n        }\n        else {\n            checkCwd();\n        }\n    }\n    [MAKEFS](er, entry, done) {\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        switch (entry.type) {\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n                return this[FILE](entry, done);\n            case 'Link':\n                return this[HARDLINK](entry, done);\n            case 'SymbolicLink':\n                return this[SYMLINK](entry, done);\n            case 'Directory':\n            case 'GNUDumpDir':\n                return this[DIRECTORY](entry, done);\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        // XXX: get the type ('symlink' or 'junction') for windows\n        node_fs_1.default[link](linkpath, String(entry.absolute), er => {\n            if (er) {\n                this[ONERROR](er, entry);\n            }\n            else {\n                this[UNPEND]();\n                entry.resume();\n            }\n            done();\n        });\n    }\n}\nexports.Unpack = Unpack;\nconst callSync = (fn) => {\n    try {\n        return [null, fn()];\n    }\n    catch (er) {\n        return [er, null];\n    }\n};\nclass UnpackSync extends Unpack {\n    sync = true;\n    [MAKEFS](er, entry) {\n        return super[MAKEFS](er, entry, () => { });\n    }\n    [CHECKFS](entry) {\n        this[PRUNECACHE](entry);\n        if (!this[CHECKED_CWD]) {\n            const er = this[MKDIR](this.cwd, this.dmode);\n            if (er) {\n                return this[ONERROR](er, entry);\n            }\n            this[CHECKED_CWD] = true;\n        }\n        // don't bother to make the parent if the current entry is the cwd,\n        // we've already checked it.\n        if (entry.absolute !== this.cwd) {\n            const parent = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.dirname(String(entry.absolute)));\n            if (parent !== this.cwd) {\n                const mkParent = this[MKDIR](parent, this.dmode);\n                if (mkParent) {\n                    return this[ONERROR](mkParent, entry);\n                }\n            }\n        }\n        const [lstatEr, st] = callSync(() => node_fs_1.default.lstatSync(String(entry.absolute)));\n        if (st &&\n            (this.keep ||\n                /* c8 ignore next */\n                (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n            return this[SKIP](entry);\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n            return this[MAKEFS](null, entry);\n        }\n        if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n                const needChmod = this.chmod &&\n                    entry.mode &&\n                    (st.mode & 0o7777) !== entry.mode;\n                const [er] = needChmod ?\n                    callSync(() => {\n                        node_fs_1.default.chmodSync(String(entry.absolute), Number(entry.mode));\n                    })\n                    : [];\n                return this[MAKEFS](er, entry);\n            }\n            // not a dir entry, have to remove it\n            const [er] = callSync(() => node_fs_1.default.rmdirSync(String(entry.absolute)));\n            this[MAKEFS](er, entry);\n        }\n        // not a dir, and not reusable.\n        // don't remove if it's the cwd, since we want that error.\n        const [er] = entry.absolute === this.cwd ?\n            []\n            : callSync(() => unlinkFileSync(String(entry.absolute)));\n        this[MAKEFS](er, entry);\n    }\n    [FILE](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const oner = (er) => {\n            let closeError;\n            try {\n                node_fs_1.default.closeSync(fd);\n            }\n            catch (e) {\n                closeError = e;\n            }\n            if (er || closeError) {\n                this[ONERROR](er || closeError, entry);\n            }\n            done();\n        };\n        let fd;\n        try {\n            fd = node_fs_1.default.openSync(String(entry.absolute), (0, get_write_flag_js_1.getWriteFlag)(entry.size), mode);\n        }\n        catch (er) {\n            return oner(er);\n        }\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => this[ONERROR](er, entry));\n            entry.pipe(tx);\n        }\n        tx.on('data', (chunk) => {\n            try {\n                node_fs_1.default.writeSync(fd, chunk, 0, chunk.length);\n            }\n            catch (er) {\n                oner(er);\n            }\n        });\n        tx.on('end', () => {\n            let er = null;\n            // try both, falling futimes back to utimes\n            // if either fails, handle the first error\n            if (entry.mtime && !this.noMtime) {\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                try {\n                    node_fs_1.default.futimesSync(fd, atime, mtime);\n                }\n                catch (futimeser) {\n                    try {\n                        node_fs_1.default.utimesSync(String(entry.absolute), atime, mtime);\n                    }\n                    catch (utimeser) {\n                        er = futimeser;\n                    }\n                }\n            }\n            if (this[DOCHOWN](entry)) {\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                try {\n                    node_fs_1.default.fchownSync(fd, Number(uid), Number(gid));\n                }\n                catch (fchowner) {\n                    try {\n                        node_fs_1.default.chownSync(String(entry.absolute), Number(uid), Number(gid));\n                    }\n                    catch (chowner) {\n                        er = er || fchowner;\n                    }\n                }\n            }\n            oner(er);\n        });\n    }\n    [DIRECTORY](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        const er = this[MKDIR](String(entry.absolute), mode);\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        if (entry.mtime && !this.noMtime) {\n            try {\n                node_fs_1.default.utimesSync(String(entry.absolute), entry.atime || new Date(), entry.mtime);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n        if (this[DOCHOWN](entry)) {\n            try {\n                node_fs_1.default.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));\n            }\n            catch (er) { }\n        }\n        done();\n        entry.resume();\n    }\n    [MKDIR](dir, mode) {\n        try {\n            return (0, mkdir_js_1.mkdirSync)((0, normalize_windows_path_js_1.normalizeWindowsPath)(dir), {\n                uid: this.uid,\n                gid: this.gid,\n                processUid: this.processUid,\n                processGid: this.processGid,\n                umask: this.processUmask,\n                preserve: this.preservePaths,\n                unlink: this.unlink,\n                cache: this.dirCache,\n                cwd: this.cwd,\n                mode: mode,\n            });\n        }\n        catch (er) {\n            return er;\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        const ls = `${link}Sync`;\n        try {\n            node_fs_1.default[ls](linkpath, String(entry.absolute));\n            done();\n            entry.resume();\n        }\n        catch (er) {\n            return this[ONERROR](er, entry);\n        }\n    }\n}\nexports.UnpackSync = UnpackSync;\n//# sourceMappingURL=unpack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvdW5wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxjQUFjO0FBQ25DLHlCQUF5QixtQkFBTyxDQUFDLHNGQUFxQjtBQUN0RCxzQ0FBc0MsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzRCxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxrQ0FBa0MsbUJBQU8sQ0FBQyx3QkFBUztBQUNuRCxvQ0FBb0MsbUJBQU8sQ0FBQyw0QkFBVztBQUN2RCw0QkFBNEIsbUJBQU8sQ0FBQywrRUFBcUI7QUFDekQsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVk7QUFDdkMsK0JBQStCLG1CQUFPLENBQUMscUZBQXdCO0FBQy9ELG9DQUFvQyxtQkFBTyxDQUFDLCtGQUE2QjtBQUN6RSxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBWTtBQUN2QyxpQ0FBaUMsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDbkUsb0NBQW9DLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3pFLHdCQUF3QixtQkFBTyxDQUFDLG1FQUFlO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLHFGQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsV0FBVyxLQUFLLE9BQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvdW5wYWNrLmpzPzI3YzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0aGUgUEVORC9VTlBFTkQgc3R1ZmYgdHJhY2tzIHdoZXRoZXIgd2UncmUgcmVhZHkgdG8gZW1pdCBlbmQvY2xvc2UgeWV0LlxuLy8gYnV0IHRoZSBwYXRoIHJlc2VydmF0aW9ucyBhcmUgcmVxdWlyZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoZXJlXG4vLyBwYXJhbGxlbGl6ZWQgdW5wYWNrIG9wcyBtYXkgbWVzcyB3aXRoIG9uZSBhbm90aGVyLCBkdWUgdG8gZGVwZW5kZW5jaWVzXG4vLyAobGlrZSBhIExpbmsgZGVwZW5kaW5nIG9uIGl0cyB0YXJnZXQpIG9yIGRlc3RydWN0aXZlIG9wZXJhdGlvbnMgKGxpa2Vcbi8vIGNsb2JiZXJpbmcgYW4gZnMgb2JqZWN0IHRvIGNyZWF0ZSBvbmUgb2YgYSBkaWZmZXJlbnQgdHlwZS4pXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5wYWNrU3luYyA9IGV4cG9ydHMuVW5wYWNrID0gdm9pZCAwO1xuY29uc3QgZnNtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJAaXNhYWNzL2ZzLW1pbmlwYXNzXCIpKTtcbmNvbnN0IG5vZGVfYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6YXNzZXJ0XCIpKTtcbmNvbnN0IG5vZGVfY3J5cHRvXzEgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5jb25zdCBub2RlX2ZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6ZnNcIikpO1xuY29uc3Qgbm9kZV9wYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6cGF0aFwiKSk7XG5jb25zdCBnZXRfd3JpdGVfZmxhZ19qc18xID0gcmVxdWlyZShcIi4vZ2V0LXdyaXRlLWZsYWcuanNcIik7XG5jb25zdCBta2Rpcl9qc18xID0gcmVxdWlyZShcIi4vbWtkaXIuanNcIik7XG5jb25zdCBub3JtYWxpemVfdW5pY29kZV9qc18xID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXVuaWNvZGUuanNcIik7XG5jb25zdCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEgPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzXCIpO1xuY29uc3QgcGFyc2VfanNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpO1xuY29uc3Qgc3RyaXBfYWJzb2x1dGVfcGF0aF9qc18xID0gcmVxdWlyZShcIi4vc3RyaXAtYWJzb2x1dGUtcGF0aC5qc1wiKTtcbmNvbnN0IHN0cmlwX3RyYWlsaW5nX3NsYXNoZXNfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanNcIik7XG5jb25zdCB3YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi93aW5jaGFycy5qc1wiKSk7XG5jb25zdCBwYXRoX3Jlc2VydmF0aW9uc19qc18xID0gcmVxdWlyZShcIi4vcGF0aC1yZXNlcnZhdGlvbnMuanNcIik7XG5jb25zdCBPTkVOVFJZID0gU3ltYm9sKCdvbkVudHJ5Jyk7XG5jb25zdCBDSEVDS0ZTID0gU3ltYm9sKCdjaGVja0ZzJyk7XG5jb25zdCBDSEVDS0ZTMiA9IFN5bWJvbCgnY2hlY2tGczInKTtcbmNvbnN0IFBSVU5FQ0FDSEUgPSBTeW1ib2woJ3BydW5lQ2FjaGUnKTtcbmNvbnN0IElTUkVVU0FCTEUgPSBTeW1ib2woJ2lzUmV1c2FibGUnKTtcbmNvbnN0IE1BS0VGUyA9IFN5bWJvbCgnbWFrZUZzJyk7XG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJyk7XG5jb25zdCBESVJFQ1RPUlkgPSBTeW1ib2woJ2RpcmVjdG9yeScpO1xuY29uc3QgTElOSyA9IFN5bWJvbCgnbGluaycpO1xuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpO1xuY29uc3QgSEFSRExJTksgPSBTeW1ib2woJ2hhcmRsaW5rJyk7XG5jb25zdCBVTlNVUFBPUlRFRCA9IFN5bWJvbCgndW5zdXBwb3J0ZWQnKTtcbmNvbnN0IENIRUNLUEFUSCA9IFN5bWJvbCgnY2hlY2tQYXRoJyk7XG5jb25zdCBNS0RJUiA9IFN5bWJvbCgnbWtkaXInKTtcbmNvbnN0IE9ORVJST1IgPSBTeW1ib2woJ29uRXJyb3InKTtcbmNvbnN0IFBFTkRJTkcgPSBTeW1ib2woJ3BlbmRpbmcnKTtcbmNvbnN0IFBFTkQgPSBTeW1ib2woJ3BlbmQnKTtcbmNvbnN0IFVOUEVORCA9IFN5bWJvbCgndW5wZW5kJyk7XG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKTtcbmNvbnN0IE1BWUJFQ0xPU0UgPSBTeW1ib2woJ21heWJlQ2xvc2UnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAnKTtcbmNvbnN0IERPQ0hPV04gPSBTeW1ib2woJ2RvQ2hvd24nKTtcbmNvbnN0IFVJRCA9IFN5bWJvbCgndWlkJyk7XG5jb25zdCBHSUQgPSBTeW1ib2woJ2dpZCcpO1xuY29uc3QgQ0hFQ0tFRF9DV0QgPSBTeW1ib2woJ2NoZWNrZWRDd2QnKTtcbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgaXNXaW5kb3dzID0gcGxhdGZvcm0gPT09ICd3aW4zMic7XG5jb25zdCBERUZBVUxUX01BWF9ERVBUSCA9IDEwMjQ7XG4vLyBVbmxpbmtzIG9uIFdpbmRvd3MgYXJlIG5vdCBhdG9taWMuXG4vL1xuLy8gVGhpcyBtZWFucyB0aGF0IGlmIHlvdSBoYXZlIGEgZmlsZSBlbnRyeSwgZm9sbG93ZWQgYnkgYW5vdGhlclxuLy8gZmlsZSBlbnRyeSB3aXRoIGFuIGlkZW50aWNhbCBuYW1lLCBhbmQgeW91IGNhbm5vdCByZS11c2UgdGhlIGZpbGVcbi8vIChiZWNhdXNlIGl0J3MgYSBoYXJkbGluaywgb3IgYmVjYXVzZSB1bmxpbms6dHJ1ZSBpcyBzZXQsIG9yIGl0J3Ncbi8vIFdpbmRvd3MsIHdoaWNoIGRvZXMgbm90IGhhdmUgdXNlZnVsIG5saW5rIHZhbHVlcyksIHRoZW4gdGhlIHVubGlua1xuLy8gd2lsbCBiZSBjb21taXR0ZWQgdG8gdGhlIGRpc2sgQUZURVIgdGhlIG5ldyBmaWxlIGhhcyBiZWVuIHdyaXR0ZW5cbi8vIG92ZXIgdGhlIG9sZCBvbmUsIGRlbGV0aW5nIHRoZSBuZXcgZmlsZS5cbi8vXG4vLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBvbiBXaW5kb3dzIHN5c3RlbXMsIHdlIHJlbmFtZSB0aGUgZmlsZSBhbmQgdGhlblxuLy8gZGVsZXRlIHRoZSByZW5hbWVkIGZpbGUuICBJdCdzIGEgc2xvcHB5IGtsdWRnZSwgYnV0IGZyYW5rbHksIEkgZG8gbm90XG4vLyBrbm93IG9mIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLCBnaXZlbiB3aW5kb3dzJyBub24tYXRvbWljIHVubGlua1xuLy8gc2VtYW50aWNzLlxuLy9cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9pc3N1ZXMvMTgzXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IHVubGlua0ZpbGUgPSAocGF0aCwgY2IpID0+IHtcbiAgICBpZiAoIWlzV2luZG93cykge1xuICAgICAgICByZXR1cm4gbm9kZV9mc18xLmRlZmF1bHQudW5saW5rKHBhdGgsIGNiKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHBhdGggKyAnLkRFTEVURS4nICsgKDAsIG5vZGVfY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDE2KS50b1N0cmluZygnaGV4Jyk7XG4gICAgbm9kZV9mc18xLmRlZmF1bHQucmVuYW1lKHBhdGgsIG5hbWUsIGVyID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LnVubGluayhuYW1lLCBjYik7XG4gICAgfSk7XG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgdW5saW5rRmlsZVN5bmMgPSAocGF0aCkgPT4ge1xuICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICAgIHJldHVybiBub2RlX2ZzXzEuZGVmYXVsdC51bmxpbmtTeW5jKHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcGF0aCArICcuREVMRVRFLicgKyAoMCwgbm9kZV9jcnlwdG9fMS5yYW5kb21CeXRlcykoMTYpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBub2RlX2ZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jKHBhdGgsIG5hbWUpO1xuICAgIG5vZGVfZnNfMS5kZWZhdWx0LnVubGlua1N5bmMobmFtZSk7XG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cbi8vIHRoaXMuZ2lkLCBlbnRyeS5naWQsIHRoaXMucHJvY2Vzc1VpZFxuY29uc3QgdWludDMyID0gKGEsIGIsIGMpID0+IGEgIT09IHVuZGVmaW5lZCAmJiBhID09PSBhID4+PiAwID8gYVxuICAgIDogYiAhPT0gdW5kZWZpbmVkICYmIGIgPT09IGIgPj4+IDAgPyBiXG4gICAgICAgIDogYztcbi8vIGNsZWFyIHRoZSBjYWNoZSBpZiBpdCdzIGEgY2FzZS1pbnNlbnNpdGl2ZSB1bmljb2RlLXNxdWFzaGluZyBtYXRjaC5cbi8vIHdlIGNhbid0IGtub3cgaWYgdGhlIGN1cnJlbnQgZmlsZSBzeXN0ZW0gaXMgY2FzZS1zZW5zaXRpdmUgb3Igc3VwcG9ydHNcbi8vIHVuaWNvZGUgZnVsbHksIHNvIHdlIGNoZWNrIGZvciBzaW1pbGFyaXR5IG9uIHRoZSBtYXhpbWFsbHkgY29tcGF0aWJsZVxuLy8gcmVwcmVzZW50YXRpb24uICBFcnIgb24gdGhlIHNpZGUgb2YgcHJ1bmluZywgc2luY2UgYWxsIGl0J3MgZG9pbmcgaXNcbi8vIHByZXZlbnRpbmcgbHN0YXRzLCBhbmQgaXQncyBub3QgdGhlIGVuZCBvZiB0aGUgd29ybGQgaWYgd2UgZ2V0IGEgZmFsc2Vcbi8vIHBvc2l0aXZlLlxuLy8gTm90ZSB0aGF0IG9uIHdpbmRvd3MsIHdlIGFsd2F5cyBkcm9wIHRoZSBlbnRpcmUgY2FjaGUgd2hlbmV2ZXIgYVxuLy8gc3ltYm9saWMgbGluayBpcyBlbmNvdW50ZXJlZCwgYmVjYXVzZSA4LjMgZmlsZW5hbWVzIGFyZSBpbXBvc3NpYmxlXG4vLyB0byByZWFzb24gYWJvdXQsIGFuZCBjb2xsaXNpb25zIGFyZSBoYXphcmRzIHJhdGhlciB0aGFuIGp1c3QgZmFpbHVyZXMuXG5jb25zdCBjYWNoZUtleU5vcm1hbGl6ZSA9IChwYXRoKSA9PiAoMCwgc3RyaXBfdHJhaWxpbmdfc2xhc2hlc19qc18xLnN0cmlwVHJhaWxpbmdTbGFzaGVzKSgoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKSgoMCwgbm9ybWFsaXplX3VuaWNvZGVfanNfMS5ub3JtYWxpemVVbmljb2RlKShwYXRoKSkpLnRvTG93ZXJDYXNlKCk7XG4vLyByZW1vdmUgYWxsIGNhY2hlIGVudHJpZXMgbWF0Y2hpbmcgJHthYnN9LyoqXG5jb25zdCBwcnVuZUNhY2hlID0gKGNhY2hlLCBhYnMpID0+IHtcbiAgICBhYnMgPSBjYWNoZUtleU5vcm1hbGl6ZShhYnMpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBjYWNoZS5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgcG5vcm0gPSBjYWNoZUtleU5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgaWYgKHBub3JtID09PSBhYnMgfHwgcG5vcm0uaW5kZXhPZihhYnMgKyAnLycpID09PSAwKSB7XG4gICAgICAgICAgICBjYWNoZS5kZWxldGUocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZHJvcENhY2hlID0gKGNhY2hlKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgY2FjaGUua2V5cygpKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgIH1cbn07XG5jbGFzcyBVbnBhY2sgZXh0ZW5kcyBwYXJzZV9qc18xLlBhcnNlciB7XG4gICAgW0VOREVEXSA9IGZhbHNlO1xuICAgIFtDSEVDS0VEX0NXRF0gPSBmYWxzZTtcbiAgICBbUEVORElOR10gPSAwO1xuICAgIHJlc2VydmF0aW9ucyA9IG5ldyBwYXRoX3Jlc2VydmF0aW9uc19qc18xLlBhdGhSZXNlcnZhdGlvbnMoKTtcbiAgICB0cmFuc2Zvcm07XG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgZGlyQ2FjaGU7XG4gICAgdWlkO1xuICAgIGdpZDtcbiAgICBzZXRPd25lcjtcbiAgICBwcmVzZXJ2ZU93bmVyO1xuICAgIHByb2Nlc3NHaWQ7XG4gICAgcHJvY2Vzc1VpZDtcbiAgICBtYXhEZXB0aDtcbiAgICBmb3JjZUNob3duO1xuICAgIHdpbjMyO1xuICAgIG5ld2VyO1xuICAgIGtlZXA7XG4gICAgbm9NdGltZTtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHVubGluaztcbiAgICBjd2Q7XG4gICAgc3RyaXA7XG4gICAgcHJvY2Vzc1VtYXNrO1xuICAgIHVtYXNrO1xuICAgIGRtb2RlO1xuICAgIGZtb2RlO1xuICAgIGNobW9kO1xuICAgIGNvbnN0cnVjdG9yKG9wdCA9IHt9KSB7XG4gICAgICAgIG9wdC5vbmRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzW0VOREVEXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW01BWUJFQ0xPU0VdKCk7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gb3B0LnRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5kaXJDYWNoZSA9IG9wdC5kaXJDYWNoZSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2htb2QgPSAhIW9wdC5jaG1vZDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQudWlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgYm90aCBvciBuZWl0aGVyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5naWQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHByZXNlcnZlIG93bmVyIGluIGFyY2hpdmUgYW5kIGFsc28gc2V0IG93bmVyIGV4cGxpY2l0bHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudWlkID0gb3B0LnVpZDtcbiAgICAgICAgICAgIHRoaXMuZ2lkID0gb3B0LmdpZDtcbiAgICAgICAgICAgIHRoaXMuc2V0T3duZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmdpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2V0T3duZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZhdWx0IHRydWUgZm9yIHJvb3RcbiAgICAgICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHQudWlkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gISEocHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXNlcnZlT3duZXIgPSAhIW9wdC5wcmVzZXJ2ZU93bmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc1VpZCA9XG4gICAgICAgICAgICAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0dWlkID9cbiAgICAgICAgICAgICAgICBwcm9jZXNzLmdldHVpZCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc0dpZCA9XG4gICAgICAgICAgICAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgICAgICAgICAgICBwcm9jZXNzLmdldGdpZCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHByZXZlbnQgZXhjZXNzaXZlbHkgZGVlcCBuZXN0aW5nIG9mIHN1YmZvbGRlcnNcbiAgICAgICAgLy8gc2V0IHRvIGBJbmZpbml0eWAgdG8gcmVtb3ZlIHRoaXMgcmVzdHJpY3Rpb25cbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0Lm1heERlcHRoID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICAgICAgb3B0Lm1heERlcHRoXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX01BWF9ERVBUSDtcbiAgICAgICAgLy8gbW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcsIGJ1dCB1c2VmdWwgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgLy8gRm9yY2libHkgdHJpZ2dlciBhIGNob3duIG9uIGV2ZXJ5IGVudHJ5LCBubyBtYXR0ZXIgd2hhdFxuICAgICAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgICAgICB0aGlzLndpbjMyID0gISFvcHQud2luMzIgfHwgaXNXaW5kb3dzO1xuICAgICAgICAvLyBkbyBub3QgdW5wYWNrIG92ZXIgZmlsZXMgdGhhdCBhcmUgbmV3ZXIgdGhhbiB3aGF0J3MgaW4gdGhlIGFyY2hpdmVcbiAgICAgICAgdGhpcy5uZXdlciA9ICEhb3B0Lm5ld2VyO1xuICAgICAgICAvLyBkbyBub3QgdW5wYWNrIG92ZXIgQU5ZIGZpbGVzXG4gICAgICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXA7XG4gICAgICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICAgICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZTtcbiAgICAgICAgLy8gYWxsb3cgLi4sIGFic29sdXRlIHBhdGggZW50cmllcywgYW5kIHVucGFja2luZyB0aHJvdWdoIHN5bWxpbmtzXG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcywgd2FybiBhbmQgc2tpcCAuLiwgcmVsYXRpdml6ZSBhYnNvbHV0ZXMsIGFuZCBlcnJvclxuICAgICAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVBhdGhzID0gISFvcHQucHJlc2VydmVQYXRocztcbiAgICAgICAgLy8gdW5saW5rIGZpbGVzIGFuZCBsaW5rcyBiZWZvcmUgd3JpdGluZy4gVGhpcyBicmVha3MgZXhpc3RpbmcgaGFyZFxuICAgICAgICAvLyBsaW5rcywgYW5kIHJlbW92ZXMgc3ltbGluayBkaXJlY3RvcmllcyByYXRoZXIgdGhhbiBlcnJvcmluZ1xuICAgICAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGluaztcbiAgICAgICAgdGhpcy5jd2QgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSk7XG4gICAgICAgIHRoaXMuc3RyaXAgPSBOdW1iZXIob3B0LnN0cmlwKSB8fCAwO1xuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgY2htb2RkaW5nLCB0aGVuIHdlIGRvbid0IG5lZWQgdGhlIHByb2Nlc3MgdW1hc2tcbiAgICAgICAgdGhpcy5wcm9jZXNzVW1hc2sgPVxuICAgICAgICAgICAgIXRoaXMuY2htb2QgPyAwXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygb3B0LnByb2Nlc3NVbWFzayA9PT0gJ251bWJlcicgPyBvcHQucHJvY2Vzc1VtYXNrXG4gICAgICAgICAgICAgICAgICAgIDogcHJvY2Vzcy51bWFzaygpO1xuICAgICAgICB0aGlzLnVtYXNrID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHQudW1hc2sgPT09ICdudW1iZXInID8gb3B0LnVtYXNrIDogdGhpcy5wcm9jZXNzVW1hc2s7XG4gICAgICAgIC8vIGRlZmF1bHQgbW9kZSBmb3IgZGlycyBjcmVhdGVkIGFzIHBhcmVudHNcbiAgICAgICAgdGhpcy5kbW9kZSA9IG9wdC5kbW9kZSB8fCAwbzA3NzcgJiB+dGhpcy51bWFzaztcbiAgICAgICAgdGhpcy5mbW9kZSA9IG9wdC5mbW9kZSB8fCAwbzA2NjYgJiB+dGhpcy51bWFzaztcbiAgICAgICAgdGhpcy5vbignZW50cnknLCBlbnRyeSA9PiB0aGlzW09ORU5UUlldKGVudHJ5KSk7XG4gICAgfVxuICAgIC8vIGEgYmFkIG9yIGRhbWFnZWQgYXJjaGl2ZSBpcyBhIHdhcm5pbmcgZm9yIFBhcnNlciwgYnV0IGFuIGVycm9yXG4gICAgLy8gd2hlbiBleHRyYWN0aW5nLiAgTWFyayB0aG9zZSBlcnJvcnMgYXMgdW5yZWNvdmVyYWJsZSwgYmVjYXVzZVxuICAgIC8vIHRoZSBVbnBhY2sgY29udHJhY3QgY2Fubm90IGJlIG1ldC5cbiAgICB3YXJuKGNvZGUsIG1zZywgZGF0YSA9IHt9KSB7XG4gICAgICAgIGlmIChjb2RlID09PSAnVEFSX0JBRF9BUkNISVZFJyB8fCBjb2RlID09PSAnVEFSX0FCT1JUJykge1xuICAgICAgICAgICAgZGF0YS5yZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci53YXJuKGNvZGUsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIFtNQVlCRUNMT1NFXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbRU5ERURdICYmIHRoaXNbUEVORElOR10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbQ0hFQ0tQQVRIXShlbnRyeSkge1xuICAgICAgICBjb25zdCBwID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkoZW50cnkucGF0aCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAodGhpcy5zdHJpcCkge1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IHRoaXMuc3RyaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0xpbmsnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua3BhcnRzID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkoU3RyaW5nKGVudHJ5LmxpbmtwYXRoKSkuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpZiAobGlua3BhcnRzLmxlbmd0aCA+PSB0aGlzLnN0cmlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoMCwgdGhpcy5zdHJpcCk7XG4gICAgICAgICAgICBlbnRyeS5wYXRoID0gcGFydHMuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLm1heERlcHRoKSAmJiBwYXJ0cy5sZW5ndGggPiB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGV4Y2Vzc2l2ZWx5IGRlZXAnLCB7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcGF0aDogcCxcbiAgICAgICAgICAgICAgICBkZXB0aDogcGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fFxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgKGlzV2luZG93cyAmJiAvXlthLXpdOlxcLlxcLiQvaS50ZXN0KHBhcnRzWzBdID8/ICcnKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsIGBwYXRoIGNvbnRhaW5zICcuLidgLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cmlwIG9mZiB0aGUgcm9vdFxuICAgICAgICAgICAgY29uc3QgW3Jvb3QsIHN0cmlwcGVkXSA9ICgwLCBzdHJpcF9hYnNvbHV0ZV9wYXRoX2pzXzEuc3RyaXBBYnNvbHV0ZVBhdGgpKHApO1xuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5wYXRoID0gU3RyaW5nKHN0cmlwcGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTkZPJywgYHN0cmlwcGluZyAke3Jvb3R9IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVfcGF0aF8xLmRlZmF1bHQuaXNBYnNvbHV0ZShlbnRyeS5wYXRoKSkge1xuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUoZW50cnkucGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUodGhpcy5jd2QsIGVudHJ5LnBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBzb21laG93IGVuZGVkIHVwIHdpdGggYSBwYXRoIHRoYXQgZXNjYXBlcyB0aGUgY3dkLCBhbmQgd2UgYXJlXG4gICAgICAgIC8vIG5vdCBpbiBwcmVzZXJ2ZVBhdGhzIG1vZGUsIHRoZW4gc29tZXRoaW5nIGlzIGZpc2h5ISAgVGhpcyBzaG91bGQgaGF2ZVxuICAgICAgICAvLyBiZWVuIHByZXZlbnRlZCBhYm92ZSwgc28gaWdub3JlIHRoaXMgZm9yIGNvdmVyYWdlLlxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgLSBkZWZlbnNlIGluIGRlcHRoICovXG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzICYmXG4gICAgICAgICAgICB0eXBlb2YgZW50cnkuYWJzb2x1dGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBlbnRyeS5hYnNvbHV0ZS5pbmRleE9mKHRoaXMuY3dkICsgJy8nKSAhPT0gMCAmJlxuICAgICAgICAgICAgZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGVzY2FwZWQgZXh0cmFjdGlvbiB0YXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcGF0aDogKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkoZW50cnkucGF0aCksXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoOiBlbnRyeS5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gYW4gYXJjaGl2ZSBjYW4gc2V0IHByb3BlcnRpZXMgb24gdGhlIGV4dHJhY3Rpb24gZGlyZWN0b3J5LCBidXQgaXRcbiAgICAgICAgLy8gbWF5IG5vdCByZXBsYWNlIHRoZSBjd2Qgd2l0aCBhIGRpZmZlcmVudCBraW5kIG9mIHRoaW5nIGVudGlyZWx5LlxuICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkICYmXG4gICAgICAgICAgICBlbnRyeS50eXBlICE9PSAnRGlyZWN0b3J5JyAmJlxuICAgICAgICAgICAgZW50cnkudHlwZSAhPT0gJ0dOVUR1bXBEaXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBlbmNvZGUgOiBjaGFycyB0aGF0IGFyZW4ndCBkcml2ZSBsZXR0ZXIgaW5kaWNhdG9yc1xuICAgICAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgICAgICAgY29uc3QgeyByb290OiBhUm9vdCB9ID0gbm9kZV9wYXRoXzEuZGVmYXVsdC53aW4zMi5wYXJzZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpKTtcbiAgICAgICAgICAgIGVudHJ5LmFic29sdXRlID1cbiAgICAgICAgICAgICAgICBhUm9vdCArIHdjLmVuY29kZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLnNsaWNlKGFSb290Lmxlbmd0aCkpO1xuICAgICAgICAgICAgY29uc3QgeyByb290OiBwUm9vdCB9ID0gbm9kZV9wYXRoXzEuZGVmYXVsdC53aW4zMi5wYXJzZShlbnRyeS5wYXRoKTtcbiAgICAgICAgICAgIGVudHJ5LnBhdGggPSBwUm9vdCArIHdjLmVuY29kZShlbnRyeS5wYXRoLnNsaWNlKHBSb290Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbT05FTlRSWV0oZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzW0NIRUNLUEFUSF0oZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZV9hc3NlcnRfMS5kZWZhdWx0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpO1xuICAgICAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICAgICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5tb2RlID0gZW50cnkubW9kZSB8IDBvNzAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0xpbmsnOlxuICAgICAgICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSk7XG4gICAgICAgICAgICBjYXNlICdDaGFyYWN0ZXJEZXZpY2UnOlxuICAgICAgICAgICAgY2FzZSAnQmxvY2tEZXZpY2UnOlxuICAgICAgICAgICAgY2FzZSAnRklGTyc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1VOU1VQUE9SVEVEXShlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW09ORVJST1JdKGVyLCBlbnRyeSkge1xuICAgICAgICAvLyBDd2QgaGFzIHRvIGV4aXN0LCBvciBlbHNlIG5vdGhpbmcgd29ya3MuIFRoYXQncyBzZXJpb3VzLlxuICAgICAgICAvLyBPdGhlciBlcnJvcnMgYXJlIHdhcm5pbmdzLCB3aGljaCByYWlzZSB0aGUgZXJyb3IgaW4gc3RyaWN0XG4gICAgICAgIC8vIG1vZGUsIGJ1dCBvdGhlcndpc2UgY29udGludWUgb24uXG4gICAgICAgIGlmIChlci5uYW1lID09PSAnQ3dkRXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCBlciwgeyBlbnRyeSB9KTtcbiAgICAgICAgICAgIHRoaXNbVU5QRU5EXSgpO1xuICAgICAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW01LRElSXShkaXIsIG1vZGUsIGNiKSB7XG4gICAgICAgICgwLCBta2Rpcl9qc18xLm1rZGlyKSgoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShkaXIpLCB7XG4gICAgICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICAgICAgZ2lkOiB0aGlzLmdpZCxcbiAgICAgICAgICAgIHByb2Nlc3NVaWQ6IHRoaXMucHJvY2Vzc1VpZCxcbiAgICAgICAgICAgIHByb2Nlc3NHaWQ6IHRoaXMucHJvY2Vzc0dpZCxcbiAgICAgICAgICAgIHVtYXNrOiB0aGlzLnByb2Nlc3NVbWFzayxcbiAgICAgICAgICAgIHByZXNlcnZlOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICAgICAgICB1bmxpbms6IHRoaXMudW5saW5rLFxuICAgICAgICAgICAgY2FjaGU6IHRoaXMuZGlyQ2FjaGUsXG4gICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgfSwgY2IpO1xuICAgIH1cbiAgICBbRE9DSE9XTl0oZW50cnkpIHtcbiAgICAgICAgLy8gaW4gcHJlc2VydmUgb3duZXIgbW9kZSwgY2hvd24gaWYgdGhlIGVudHJ5IGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgICAgICAvLyBpbiBzZXQgb3duZXIgbW9kZSwgY2hvd24gaWYgc2V0dGluZyBkb2Vzbid0IG1hdGNoIHByb2Nlc3NcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvcmNlQ2hvd24gfHxcbiAgICAgICAgICAgICh0aGlzLnByZXNlcnZlT3duZXIgJiZcbiAgICAgICAgICAgICAgICAoKHR5cGVvZiBlbnRyeS51aWQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnVpZCAhPT0gdGhpcy5wcm9jZXNzVWlkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGVudHJ5LmdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHRoaXMudWlkID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHRoaXMuZ2lkID09PSAnbnVtYmVyJyAmJiB0aGlzLmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKSk7XG4gICAgfVxuICAgIFtVSURdKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiB1aW50MzIodGhpcy51aWQsIGVudHJ5LnVpZCwgdGhpcy5wcm9jZXNzVWlkKTtcbiAgICB9XG4gICAgW0dJRF0oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQzMih0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NHaWQpO1xuICAgIH1cbiAgICBbRklMRV0oZW50cnksIGZ1bGx5RG9uZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gdHlwZW9mIGVudHJ5Lm1vZGUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiAwbzc3NzdcbiAgICAgICAgICAgIDogdGhpcy5mbW9kZTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCB7XG4gICAgICAgICAgICAvLyBzbGlnaHQgbGllLCBidXQgaXQgY2FuIGJlIG51bWVyaWMgZmxhZ3NcbiAgICAgICAgICAgIGZsYWdzOiAoMCwgZ2V0X3dyaXRlX2ZsYWdfanNfMS5nZXRXcml0ZUZsYWcpKGVudHJ5LnNpemUpLFxuICAgICAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmZkKSB7XG4gICAgICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmx1c2ggYWxsIHRoZSBkYXRhIG91dCBzbyB0aGF0IHdlIGFyZW4ndCBsZWZ0IGhhbmdpbmdcbiAgICAgICAgICAgIC8vIGlmIHRoZSBlcnJvciB3YXNuJ3QgYWN0dWFsbHkgZmF0YWwuICBvdGhlcndpc2UgdGhlIHBhcnNlXG4gICAgICAgICAgICAvLyBpcyBibG9ja2VkLCBhbmQgd2UgbmV2ZXIgcHJvY2VlZC5cbiAgICAgICAgICAgIHN0cmVhbS53cml0ZSA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICBmdWxseURvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhY3Rpb25zID0gMTtcbiAgICAgICAgY29uc3QgZG9uZSA9IChlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0IC0gd2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZmQgYnkgbm93ICovXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5mZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5jbG9zZShzdHJlYW0uZmQsICgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgICAgIGZ1bGx5RG9uZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLWFjdGlvbnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmZkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQuY2xvc2Uoc3RyZWFtLmZkLCBlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1VOUEVORF0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGx5RG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN0cmVhbS5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgZnV0aW1lcyBmYWlscywgdHJ5IHV0aW1lc1xuICAgICAgICAgICAgLy8gaWYgdXRpbWVzIGZhaWxzLCBmYWlsIHdpdGggdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgICAgICAvLyBzYW1lIGZvciBmY2hvd24vY2hvd25cbiAgICAgICAgICAgIGNvbnN0IGFicyA9IFN0cmluZyhlbnRyeS5hYnNvbHV0ZSk7XG4gICAgICAgICAgICBjb25zdCBmZCA9IHN0cmVhbS5mZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInICYmIGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgY29uc3QgYXRpbWUgPSBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG10aW1lID0gZW50cnkubXRpbWU7XG4gICAgICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBlciA9PiBlciA/XG4gICAgICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LnV0aW1lcyhhYnMsIGF0aW1lLCBtdGltZSwgZXIyID0+IGRvbmUoZXIyICYmIGVyKSlcbiAgICAgICAgICAgICAgICAgICAgOiBkb25lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZCA9PT0gJ251bWJlcicgJiYgdGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZ2lkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5mY2hvd24oZmQsIHVpZCwgZ2lkLCBlciA9PiBlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5jaG93bihhYnMsIHVpZCwgZ2lkLCBlcjIgPT4gZG9uZShlcjIgJiYgZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkb25lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShlbnRyeSkgfHwgZW50cnkgOiBlbnRyeTtcbiAgICAgICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgICAgICAgdHgub24oJ2Vycm9yJywgKGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgICAgIGZ1bGx5RG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbnRyeS5waXBlKHR4KTtcbiAgICAgICAgfVxuICAgICAgICB0eC5waXBlKHN0cmVhbSk7XG4gICAgfVxuICAgIFtESVJFQ1RPUlldKGVudHJ5LCBmdWxseURvbmUpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHR5cGVvZiBlbnRyeS5tb2RlID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICBlbnRyeS5tb2RlICYgMG83Nzc3XG4gICAgICAgICAgICA6IHRoaXMuZG1vZGU7XG4gICAgICAgIHRoaXNbTUtESVJdKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIG1vZGUsIGVyID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICBmdWxseURvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IDE7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgtLWFjdGlvbnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbHlEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbVU5QRU5EXSgpO1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQudXRpbWVzKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lLCBkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMrKztcbiAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5jaG93bihTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBOdW1iZXIodGhpc1tVSURdKGVudHJ5KSksIE51bWJlcih0aGlzW0dJRF0oZW50cnkpKSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbVU5TVVBQT1JURURdKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnVuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfVU5TVVBQT1JURUQnLCBgdW5zdXBwb3J0ZWQgZW50cnkgdHlwZTogJHtlbnRyeS50eXBlfWAsIHsgZW50cnkgfSk7XG4gICAgICAgIGVudHJ5LnJlc3VtZSgpO1xuICAgIH1cbiAgICBbU1lNTElOS10oZW50cnksIGRvbmUpIHtcbiAgICAgICAgdGhpc1tMSU5LXShlbnRyeSwgU3RyaW5nKGVudHJ5LmxpbmtwYXRoKSwgJ3N5bWxpbmsnLCBkb25lKTtcbiAgICB9XG4gICAgW0hBUkRMSU5LXShlbnRyeSwgZG9uZSkge1xuICAgICAgICBjb25zdCBsaW5rcGF0aCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG5vZGVfcGF0aF8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmN3ZCwgU3RyaW5nKGVudHJ5LmxpbmtwYXRoKSkpO1xuICAgICAgICB0aGlzW0xJTktdKGVudHJ5LCBsaW5rcGF0aCwgJ2xpbmsnLCBkb25lKTtcbiAgICB9XG4gICAgW1BFTkRdKCkge1xuICAgICAgICB0aGlzW1BFTkRJTkddKys7XG4gICAgfVxuICAgIFtVTlBFTkRdKCkge1xuICAgICAgICB0aGlzW1BFTkRJTkddLS07XG4gICAgICAgIHRoaXNbTUFZQkVDTE9TRV0oKTtcbiAgICB9XG4gICAgW1NLSVBdKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbVU5QRU5EXSgpO1xuICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGFuIGV4aXN0aW5nIGZpbGVzeXN0ZW0gZW50cnkgc2FmZWx5IGFuZFxuICAgIC8vIG92ZXJ3cml0ZSBpdCwgcmF0aGVyIHRoYW4gdW5saW5raW5nIGFuZCByZWNyZWF0aW5nXG4gICAgLy8gV2luZG93cyBkb2Vzbid0IHJlcG9ydCBhIHVzZWZ1bCBubGluaywgc28gd2UganVzdCBuZXZlciByZXVzZSBlbnRyaWVzXG4gICAgW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkge1xuICAgICAgICByZXR1cm4gKGVudHJ5LnR5cGUgPT09ICdGaWxlJyAmJlxuICAgICAgICAgICAgIXRoaXMudW5saW5rICYmXG4gICAgICAgICAgICBzdC5pc0ZpbGUoKSAmJlxuICAgICAgICAgICAgc3QubmxpbmsgPD0gMSAmJlxuICAgICAgICAgICAgIWlzV2luZG93cyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGEgdGhpbmcgaXMgdGhlcmUsIGFuZCBpZiBzbywgdHJ5IHRvIGNsb2JiZXIgaXRcbiAgICBbQ0hFQ0tGU10oZW50cnkpIHtcbiAgICAgICAgdGhpc1tQRU5EXSgpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtlbnRyeS5wYXRoXTtcbiAgICAgICAgaWYgKGVudHJ5LmxpbmtwYXRoKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKGVudHJ5LmxpbmtwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2VydmF0aW9ucy5yZXNlcnZlKHBhdGhzLCBkb25lID0+IHRoaXNbQ0hFQ0tGUzJdKGVudHJ5LCBkb25lKSk7XG4gICAgfVxuICAgIFtQUlVORUNBQ0hFXShlbnRyeSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGNyZWF0aW5nIGEgZGlyZWN0b3J5LCBhbmQgdGhlIHBhdGggaXMgaW4gdGhlIGRpckNhY2hlLFxuICAgICAgICAvLyB0aGVuIHRoYXQgbWVhbnMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSB0aGUgZGlyZWN0b3J5IHdlIGNyZWF0ZWRcbiAgICAgICAgLy8gcHJldmlvdXNseSwgYW5kIGl0IGlzIG5vIGxvbmdlciBnb2luZyB0byBiZSBhIGRpcmVjdG9yeSwgYW5kIG5laXRoZXJcbiAgICAgICAgLy8gaXMgYW55IG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgLy8gSWYgYSBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBhbGwgYmV0cyBhcmUgb2ZmLiAgVGhlcmUgaXMgbm9cbiAgICAgICAgLy8gcmVhc29uYWJsZSB3YXkgdG8gc2FuaXRpemUgdGhlIGNhY2hlIGluIHN1Y2ggYSB3YXkgd2Ugd2lsbCBiZSBhYmxlIHRvXG4gICAgICAgIC8vIGF2b2lkIGhhdmluZyBmaWxlc3lzdGVtIGNvbGxpc2lvbnMuICBJZiB0aGlzIGhhcHBlbnMgd2l0aCBhIG5vbi1zeW1saW5rXG4gICAgICAgIC8vIGVudHJ5LCBpdCdsbCBqdXN0IGZhaWwgdG8gdW5wYWNrLCBidXQgYSBzeW1saW5rIHRvIGEgZGlyZWN0b3J5LCB1c2luZyBhblxuICAgICAgICAvLyA4LjMgc2hvcnRuYW1lIG9yIGNlcnRhaW4gdW5pY29kZSBhdHRhY2tzLCBjYW4gZXZhZGUgZGV0ZWN0aW9uIGFuZCBsZWFkXG4gICAgICAgIC8vIHRvIGFyYml0cmFyeSB3cml0ZXMgdG8gYW55d2hlcmUgb24gdGhlIHN5c3RlbS5cbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTeW1ib2xpY0xpbmsnKSB7XG4gICAgICAgICAgICBkcm9wQ2FjaGUodGhpcy5kaXJDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkudHlwZSAhPT0gJ0RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgIHBydW5lQ2FjaGUodGhpcy5kaXJDYWNoZSwgU3RyaW5nKGVudHJ5LmFic29sdXRlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0NIRUNLRlMyXShlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpO1xuICAgICAgICBjb25zdCBkb25lID0gKGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzW1BSVU5FQ0FDSEVdKGVudHJ5KTtcbiAgICAgICAgICAgIGZ1bGx5RG9uZShlcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrQ3dkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpc1tNS0RJUl0odGhpcy5jd2QsIHRoaXMuZG1vZGUsIGVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1tDSEVDS0VEX0NXRF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkobm9kZV9wYXRoXzEuZGVmYXVsdC5kaXJuYW1lKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTWFrZVBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZnRlck1ha2VQYXJlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWZ0ZXJNYWtlUGFyZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQubHN0YXQoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgKGxzdGF0RXIsIHN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmtlZXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5uZXdlciAmJiBzdC5tdGltZSA+IChlbnRyeS5tdGltZSA/PyBzdC5tdGltZSkpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1NLSVBdKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkQ2htb2QgPSB0aGlzLmNobW9kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubW9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdC5tb2RlICYgMG83Nzc3KSAhPT0gZW50cnkubW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyQ2htb2QgPSAoZXIpID0+IHRoaXNbTUFLRUZTXShlciA/PyBudWxsLCBlbnRyeSwgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5lZWRDaG1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZnRlckNobW9kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZV9mc18xLmRlZmF1bHQuY2htb2QoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgTnVtYmVyKGVudHJ5Lm1vZGUpLCBhZnRlckNobW9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSBkaXIgZW50cnksIGhhdmUgdG8gcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBOQjogdGhlIG9ubHkgd2F5IHRvIGVuZCB1cCB3aXRoIGFuIGVudHJ5IHRoYXQgaXMgdGhlIGN3ZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdHNlbGYsIGluIHN1Y2ggYSB3YXkgdGhhdCA9PSBkb2VzIG5vdCBkZXRlY3QsIGlzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpY2t5IHdpbmRvd3MgYWJzb2x1dGUgcGF0aCB3aXRoIFVOQyBvciA4LjMgcGFydHMgKGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZVBhdGhzOnRydWUsIG9yIGVsc2UgaXQgd2lsbCBoYXZlIGJlZW4gc3RyaXBwZWQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgcGF0aCBwcm90ZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBleHBsaWNpdGx5LCBzbyBpZiB0aGV5IGJsb3cgYXdheSB0aGUgY3dkLCBjJ2VzdCBsYSB2aWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlX2ZzXzEuZGVmYXVsdC5ybWRpcihTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCAoZXIpID0+IHRoaXNbTUFLRUZTXShlciA/PyBudWxsLCBlbnRyeSwgZG9uZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgY3dkLCB3ZSB3YW50IHRoYXQgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnksIGRvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmxpbmtGaWxlKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIGVyID0+IHRoaXNbTUFLRUZTXShlciA/PyBudWxsLCBlbnRyeSwgZG9uZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NIRUNLRURfQ1dEXSkge1xuICAgICAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrQ3dkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW01BS0VGU10oZXIsIGVudHJ5LCBkb25lKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZW50cnkudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICAgICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSwgZG9uZSk7XG4gICAgICAgICAgICBjYXNlICdMaW5rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10oZW50cnksIGRvbmUpO1xuICAgICAgICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tTWU1MSU5LXShlbnRyeSwgZG9uZSk7XG4gICAgICAgICAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgICAgICAgICAgY2FzZSAnR05VRHVtcERpcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSwgZG9uZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0xJTktdKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgICAgICAvLyBYWFg6IGdldCB0aGUgdHlwZSAoJ3N5bWxpbmsnIG9yICdqdW5jdGlvbicpIGZvciB3aW5kb3dzXG4gICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0W2xpbmtdKGxpbmtwYXRoLCBTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBlciA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW1VOUEVORF0oKTtcbiAgICAgICAgICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbnBhY2sgPSBVbnBhY2s7XG5jb25zdCBjYWxsU3luYyA9IChmbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZm4oKV07XG4gICAgfVxuICAgIGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gW2VyLCBudWxsXTtcbiAgICB9XG59O1xuY2xhc3MgVW5wYWNrU3luYyBleHRlbmRzIFVucGFjayB7XG4gICAgc3luYyA9IHRydWU7XG4gICAgW01BS0VGU10oZXIsIGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgKCkgPT4geyB9KTtcbiAgICB9XG4gICAgW0NIRUNLRlNdKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpO1xuICAgICAgICBpZiAoIXRoaXNbQ0hFQ0tFRF9DV0RdKSB7XG4gICAgICAgICAgICBjb25zdCBlciA9IHRoaXNbTUtESVJdKHRoaXMuY3dkLCB0aGlzLmRtb2RlKTtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHRvIG1ha2UgdGhlIHBhcmVudCBpZiB0aGUgY3VycmVudCBlbnRyeSBpcyB0aGUgY3dkLFxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgaXQuXG4gICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKG5vZGVfcGF0aF8xLmRlZmF1bHQuZGlybmFtZShTdHJpbmcoZW50cnkuYWJzb2x1dGUpKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1rUGFyZW50ID0gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWtQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0obWtQYXJlbnQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2xzdGF0RXIsIHN0XSA9IGNhbGxTeW5jKCgpID0+IG5vZGVfZnNfMS5kZWZhdWx0LmxzdGF0U3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpKSk7XG4gICAgICAgIGlmIChzdCAmJlxuICAgICAgICAgICAgKHRoaXMua2VlcCB8fFxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgKHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiAoZW50cnkubXRpbWUgPz8gc3QubXRpbWUpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1NLSVBdKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHN0YXRFciB8fCB0aGlzW0lTUkVVU0FCTEVdKGVudHJ5LCBzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWVkQ2htb2QgPSB0aGlzLmNobW9kICYmXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgP1xuICAgICAgICAgICAgICAgICAgICBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5jaG1vZFN5bmMoU3RyaW5nKGVudHJ5LmFic29sdXRlKSwgTnVtYmVyKGVudHJ5Lm1vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3QgYSBkaXIgZW50cnksIGhhdmUgdG8gcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBbZXJdID0gY2FsbFN5bmMoKCkgPT4gbm9kZV9mc18xLmRlZmF1bHQucm1kaXJTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpKTtcbiAgICAgICAgICAgIHRoaXNbTUFLRUZTXShlciwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAgICAgLy8gZG9uJ3QgcmVtb3ZlIGlmIGl0J3MgdGhlIGN3ZCwgc2luY2Ugd2Ugd2FudCB0aGF0IGVycm9yLlxuICAgICAgICBjb25zdCBbZXJdID0gZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkID9cbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSkpKTtcbiAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSk7XG4gICAgfVxuICAgIFtGSUxFXShlbnRyeSwgZG9uZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gdHlwZW9mIGVudHJ5Lm1vZGUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiAwbzc3NzdcbiAgICAgICAgICAgIDogdGhpcy5mbW9kZTtcbiAgICAgICAgY29uc3Qgb25lciA9IChlcikgPT4ge1xuICAgICAgICAgICAgbGV0IGNsb3NlRXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNsb3NlRXJyb3IgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyIHx8IGNsb3NlRXJyb3IsIGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmQgPSBub2RlX2ZzXzEuZGVmYXVsdC5vcGVuU3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCAoMCwgZ2V0X3dyaXRlX2ZsYWdfanNfMS5nZXRXcml0ZUZsYWcpKGVudHJ5LnNpemUpLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBvbmVyKGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oZW50cnkpIHx8IGVudHJ5IDogZW50cnk7XG4gICAgICAgIGlmICh0eCAhPT0gZW50cnkpIHtcbiAgICAgICAgICAgIHR4Lm9uKCdlcnJvcicsIChlcikgPT4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpKTtcbiAgICAgICAgICAgIGVudHJ5LnBpcGUodHgpO1xuICAgICAgICB9XG4gICAgICAgIHR4Lm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LndyaXRlU3luYyhmZCwgY2h1bmssIDAsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICBvbmVyKGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHR4Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXIgPSBudWxsO1xuICAgICAgICAgICAgLy8gdHJ5IGJvdGgsIGZhbGxpbmcgZnV0aW1lcyBiYWNrIHRvIHV0aW1lc1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIGZhaWxzLCBoYW5kbGUgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZnV0aW1lc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC51dGltZXNTeW5jKFN0cmluZyhlbnRyeS5hYnNvbHV0ZSksIGF0aW1lLCBtdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHV0aW1lc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlciA9IGZ1dGltZXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpZCA9IHRoaXNbVUlEXShlbnRyeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2lkID0gdGhpc1tHSURdKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlX2ZzXzEuZGVmYXVsdC5mY2hvd25TeW5jKGZkLCBOdW1iZXIodWlkKSwgTnVtYmVyKGdpZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZmNob3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmNob3duU3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBOdW1iZXIodWlkKSwgTnVtYmVyKGdpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChjaG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlciA9IGVyIHx8IGZjaG93bmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lcihlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbRElSRUNUT1JZXShlbnRyeSwgZG9uZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gdHlwZW9mIGVudHJ5Lm1vZGUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgIGVudHJ5Lm1vZGUgJiAwbzc3NzdcbiAgICAgICAgICAgIDogdGhpcy5kbW9kZTtcbiAgICAgICAgY29uc3QgZXIgPSB0aGlzW01LRElSXShTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBtb2RlKTtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9kZV9mc18xLmRlZmF1bHQudXRpbWVzU3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpLCBlbnRyeS5tdGltZSk7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0LmNob3duU3luYyhTdHJpbmcoZW50cnkuYWJzb2x1dGUpLCBOdW1iZXIodGhpc1tVSURdKGVudHJ5KSksIE51bWJlcih0aGlzW0dJRF0oZW50cnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgZW50cnkucmVzdW1lKCk7XG4gICAgfVxuICAgIFtNS0RJUl0oZGlyLCBtb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1rZGlyX2pzXzEubWtkaXJTeW5jKSgoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShkaXIpLCB7XG4gICAgICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NVaWQ6IHRoaXMucHJvY2Vzc1VpZCxcbiAgICAgICAgICAgICAgICBwcm9jZXNzR2lkOiB0aGlzLnByb2Nlc3NHaWQsXG4gICAgICAgICAgICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICAgICAgICAgICAgdW5saW5rOiB0aGlzLnVubGluayxcbiAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbTElOS10oZW50cnksIGxpbmtwYXRoLCBsaW5rLCBkb25lKSB7XG4gICAgICAgIGNvbnN0IGxzID0gYCR7bGlua31TeW5jYDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGVfZnNfMS5kZWZhdWx0W2xzXShsaW5rcGF0aCwgU3RyaW5nKGVudHJ5LmFic29sdXRlKSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICBlbnRyeS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlVucGFja1N5bmMgPSBVbnBhY2tTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5wYWNrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/unpack.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/update.js":
/*!**************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/update.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// tar -u\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.update = void 0;\nconst make_command_js_1 = __webpack_require__(/*! ./make-command.js */ \"./node_modules/tar/dist/commonjs/make-command.js\");\nconst replace_js_1 = __webpack_require__(/*! ./replace.js */ \"./node_modules/tar/dist/commonjs/replace.js\");\n// just call tar.r with the filter and mtimeCache\nexports.update = (0, make_command_js_1.makeCommand)(replace_js_1.replace.syncFile, replace_js_1.replace.asyncFile, replace_js_1.replace.syncNoFile, replace_js_1.replace.asyncNoFile, (opt, entries = []) => {\n    replace_js_1.replace.validate?.(opt, entries);\n    mtimeFilter(opt);\n});\nconst mtimeFilter = (opt) => {\n    const filter = opt.filter;\n    if (!opt.mtimeCache) {\n        opt.mtimeCache = new Map();\n    }\n    opt.filter =\n        filter ?\n            (path, stat) => filter(path, stat) &&\n                !(\n                /* c8 ignore start */\n                ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                    (stat.mtime ?? 0))\n                /* c8 ignore stop */\n                )\n            : (path, stat) => !(\n            /* c8 ignore start */\n            ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                (stat.mtime ?? 0))\n            /* c8 ignore stop */\n            );\n};\n//# sourceMappingURL=update.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvdXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDBCQUEwQixtQkFBTyxDQUFDLDJFQUFtQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQyxpRUFBYztBQUMzQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvdXBkYXRlLmpzP2RmNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0YXIgLXVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXBkYXRlID0gdm9pZCAwO1xuY29uc3QgbWFrZV9jb21tYW5kX2pzXzEgPSByZXF1aXJlKFwiLi9tYWtlLWNvbW1hbmQuanNcIik7XG5jb25zdCByZXBsYWNlX2pzXzEgPSByZXF1aXJlKFwiLi9yZXBsYWNlLmpzXCIpO1xuLy8ganVzdCBjYWxsIHRhci5yIHdpdGggdGhlIGZpbHRlciBhbmQgbXRpbWVDYWNoZVxuZXhwb3J0cy51cGRhdGUgPSAoMCwgbWFrZV9jb21tYW5kX2pzXzEubWFrZUNvbW1hbmQpKHJlcGxhY2VfanNfMS5yZXBsYWNlLnN5bmNGaWxlLCByZXBsYWNlX2pzXzEucmVwbGFjZS5hc3luY0ZpbGUsIHJlcGxhY2VfanNfMS5yZXBsYWNlLnN5bmNOb0ZpbGUsIHJlcGxhY2VfanNfMS5yZXBsYWNlLmFzeW5jTm9GaWxlLCAob3B0LCBlbnRyaWVzID0gW10pID0+IHtcbiAgICByZXBsYWNlX2pzXzEucmVwbGFjZS52YWxpZGF0ZT8uKG9wdCwgZW50cmllcyk7XG4gICAgbXRpbWVGaWx0ZXIob3B0KTtcbn0pO1xuY29uc3QgbXRpbWVGaWx0ZXIgPSAob3B0KSA9PiB7XG4gICAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlcjtcbiAgICBpZiAoIW9wdC5tdGltZUNhY2hlKSB7XG4gICAgICAgIG9wdC5tdGltZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBvcHQuZmlsdGVyID1cbiAgICAgICAgZmlsdGVyID9cbiAgICAgICAgICAgIChwYXRoLCBzdGF0KSA9PiBmaWx0ZXIocGF0aCwgc3RhdCkgJiZcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICgob3B0Lm10aW1lQ2FjaGU/LmdldChwYXRoKSA/PyBzdGF0Lm10aW1lID8/IDApID5cbiAgICAgICAgICAgICAgICAgICAgKHN0YXQubXRpbWUgPz8gMCkpXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IChwYXRoLCBzdGF0KSA9PiAhKFxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAoKG9wdC5tdGltZUNhY2hlPy5nZXQocGF0aCkgPz8gc3RhdC5tdGltZSA/PyAwKSA+XG4gICAgICAgICAgICAgICAgKHN0YXQubXRpbWUgPz8gMCkpXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGRhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/update.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/warn-method.js":
/*!*******************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/warn-method.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.warnMethod = void 0;\nconst warnMethod = (self, code, message, data = {}) => {\n    if (self.file) {\n        data.file = self.file;\n    }\n    if (self.cwd) {\n        data.cwd = self.cwd;\n    }\n    data.code =\n        (message instanceof Error &&\n            message.code) ||\n            code;\n    data.tarCode = code;\n    if (!self.strict && data.recoverable !== false) {\n        if (message instanceof Error) {\n            data = Object.assign(message, data);\n            message = message.message;\n        }\n        self.emit('warn', code, message, data);\n    }\n    else if (message instanceof Error) {\n        self.emit('error', Object.assign(message, data));\n    }\n    else {\n        self.emit('error', Object.assign(new Error(`${code}: ${message}`), data));\n    }\n};\nexports.warnMethod = warnMethod;\n//# sourceMappingURL=warn-method.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvd2Fybi1tZXRob2QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLElBQUksUUFBUTtBQUN2RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvd2Fybi1tZXRob2QuanM/NmE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2Fybk1ldGhvZCA9IHZvaWQgMDtcbmNvbnN0IHdhcm5NZXRob2QgPSAoc2VsZiwgY29kZSwgbWVzc2FnZSwgZGF0YSA9IHt9KSA9PiB7XG4gICAgaWYgKHNlbGYuZmlsZSkge1xuICAgICAgICBkYXRhLmZpbGUgPSBzZWxmLmZpbGU7XG4gICAgfVxuICAgIGlmIChzZWxmLmN3ZCkge1xuICAgICAgICBkYXRhLmN3ZCA9IHNlbGYuY3dkO1xuICAgIH1cbiAgICBkYXRhLmNvZGUgPVxuICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICBtZXNzYWdlLmNvZGUpIHx8XG4gICAgICAgICAgICBjb2RlO1xuICAgIGRhdGEudGFyQ29kZSA9IGNvZGU7XG4gICAgaWYgKCFzZWxmLnN0cmljdCAmJiBkYXRhLnJlY292ZXJhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBkYXRhID0gT2JqZWN0LmFzc2lnbihtZXNzYWdlLCBkYXRhKTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbWl0KCd3YXJuJywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihtZXNzYWdlLCBkYXRhKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX1gKSwgZGF0YSkpO1xuICAgIH1cbn07XG5leHBvcnRzLndhcm5NZXRob2QgPSB3YXJuTWV0aG9kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fybi1tZXRob2QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/warn-method.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/winchars.js":
/*!****************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/winchars.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst raw = ['|', '<', '>', '?', ':'];\nconst win = raw.map(char => String.fromCharCode(0xf000 + char.charCodeAt(0)));\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]));\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]));\nconst encode = (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s);\nexports.encode = encode;\nconst decode = (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s);\nexports.decode = decode;\n//# sourceMappingURL=winchars.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvd2luY2hhcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvZGlzdC9jb21tb25qcy93aW5jaGFycy5qcz8wMjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gV2hlbiB3cml0aW5nIGZpbGVzIG9uIFdpbmRvd3MsIHRyYW5zbGF0ZSB0aGUgY2hhcmFjdGVycyB0byB0aGVpclxuLy8gMHhmMDAwIGhpZ2hlci1lbmNvZGVkIHZlcnNpb25zLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IHJhdyA9IFsnfCcsICc8JywgJz4nLCAnPycsICc6J107XG5jb25zdCB3aW4gPSByYXcubWFwKGNoYXIgPT4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwMDAgKyBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IHRvV2luID0gbmV3IE1hcChyYXcubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgd2luW2ldXSkpO1xuY29uc3QgdG9SYXcgPSBuZXcgTWFwKHdpbi5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCByYXdbaV1dKSk7XG5jb25zdCBlbmNvZGUgPSAocykgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5jb25zdCBkZWNvZGUgPSAocykgPT4gd2luLnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvUmF3LmdldChjKSksIHMpO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5jaGFycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/winchars.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/dist/commonjs/write-entry.js":
/*!*******************************************************!*\
  !*** ./node_modules/tar/dist/commonjs/write-entry.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WriteEntryTar = exports.WriteEntrySync = exports.WriteEntry = void 0;\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst minipass_1 = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/dist/commonjs/index.js\");\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst header_js_1 = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/dist/commonjs/header.js\");\nconst mode_fix_js_1 = __webpack_require__(/*! ./mode-fix.js */ \"./node_modules/tar/dist/commonjs/mode-fix.js\");\nconst normalize_windows_path_js_1 = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/dist/commonjs/normalize-windows-path.js\");\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"./node_modules/tar/dist/commonjs/options.js\");\nconst pax_js_1 = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/dist/commonjs/pax.js\");\nconst strip_absolute_path_js_1 = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/dist/commonjs/strip-absolute-path.js\");\nconst strip_trailing_slashes_js_1 = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/dist/commonjs/strip-trailing-slashes.js\");\nconst warn_method_js_1 = __webpack_require__(/*! ./warn-method.js */ \"./node_modules/tar/dist/commonjs/warn-method.js\");\nconst winchars = __importStar(__webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/dist/commonjs/winchars.js\"));\nconst prefixPath = (path, prefix) => {\n    if (!prefix) {\n        return (0, normalize_windows_path_js_1.normalizeWindowsPath)(path);\n    }\n    path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path).replace(/^\\.(\\/|$)/, '');\n    return (0, strip_trailing_slashes_js_1.stripTrailingSlashes)(prefix) + '/' + path;\n};\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nclass WriteEntry extends minipass_1.Minipass {\n    path;\n    portable;\n    myuid = (process.getuid && process.getuid()) || 0;\n    // until node has builtin pwnam functions, this'll have to do\n    myuser = process.env.USER || '';\n    maxReadSize;\n    linkCache;\n    statCache;\n    preservePaths;\n    cwd;\n    strict;\n    mtime;\n    noPax;\n    noMtime;\n    prefix;\n    fd;\n    blockLen = 0;\n    blockRemain = 0;\n    buf;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    offset = 0;\n    win32;\n    absolute;\n    header;\n    type;\n    linkpath;\n    stat;\n    onWriteEntry;\n    #hadError = false;\n    constructor(p, opt_ = {}) {\n        const opt = (0, options_js_1.dealias)(opt_);\n        super();\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(p);\n        // suppress atime, ctime, uid, gid, uname, gname\n        this.portable = !!opt.portable;\n        this.maxReadSize = opt.maxReadSize || maxReadSize;\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.preservePaths = !!opt.preservePaths;\n        this.cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd || process.cwd());\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.mtime = opt.mtime;\n        this.prefix =\n            opt.prefix ? (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix) : undefined;\n        this.onWriteEntry = opt.onWriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.win32 = !!opt.win32 || process.platform === 'win32';\n        if (this.win32) {\n            // force the \\ to / normalization, since we might not *actually*\n            // be on windows, but want \\ to be considered a path separator.\n            this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n            p = p.replace(/\\\\/g, '/');\n        }\n        this.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.absolute || path_1.default.resolve(this.cwd, p));\n        if (this.path === '') {\n            this.path = './';\n        }\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        const cs = this.statCache.get(this.absolute);\n        if (cs) {\n            this[ONLSTAT](cs);\n        }\n        else {\n            this[LSTAT]();\n        }\n    }\n    warn(code, message, data = {}) {\n        return (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    emit(ev, ...data) {\n        if (ev === 'error') {\n            this.#hadError = true;\n        }\n        return super.emit(ev, ...data);\n    }\n    [LSTAT]() {\n        fs_1.default.lstat(this.absolute, (er, stat) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONLSTAT](stat);\n        });\n    }\n    [ONLSTAT](stat) {\n        this.statCache.set(this.absolute, stat);\n        this.stat = stat;\n        if (!stat.isFile()) {\n            stat.size = 0;\n        }\n        this.type = getType(stat);\n        this.emit('stat', stat);\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        switch (this.type) {\n            case 'File':\n                return this[FILE]();\n            case 'Directory':\n                return this[DIRECTORY]();\n            case 'SymbolicLink':\n                return this[SYMLINK]();\n            // unsupported types are ignored.\n            default:\n                return this.end();\n        }\n    }\n    [MODE](mode) {\n        return (0, mode_fix_js_1.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [HEADER]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot write header before stat');\n        }\n        /* c8 ignore stop */\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.onWriteEntry?.(this);\n        this.header = new header_js_1.Header({\n            path: this[PREFIX](this.path),\n            // only apply the prefix to hard links.\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this[MODE](this.stat.mode),\n            uid: this.portable ? undefined : this.stat.uid,\n            gid: this.portable ? undefined : this.stat.gid,\n            size: this.stat.size,\n            mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,\n            /* c8 ignore next */\n            type: this.type === 'Unsupported' ? undefined : this.type,\n            uname: this.portable ? undefined\n                : this.stat.uid === this.myuid ? this.myuser\n                    : '',\n            atime: this.portable ? undefined : this.stat.atime,\n            ctime: this.portable ? undefined : this.stat.ctime,\n        });\n        if (this.header.encode() && !this.noPax) {\n            super.write(new pax_js_1.Pax({\n                atime: this.portable ? undefined : this.header.atime,\n                ctime: this.portable ? undefined : this.header.ctime,\n                gid: this.portable ? undefined : this.header.gid,\n                mtime: this.noMtime ? undefined : (this.mtime || this.header.mtime),\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.header.size,\n                uid: this.portable ? undefined : this.header.uid,\n                uname: this.portable ? undefined : this.header.uname,\n                dev: this.portable ? undefined : this.stat.dev,\n                ino: this.portable ? undefined : this.stat.ino,\n                nlink: this.portable ? undefined : this.stat.nlink,\n            }).encode());\n        }\n        const block = this.header?.block;\n        /* c8 ignore start */\n        if (!block) {\n            throw new Error('failed to encode header');\n        }\n        /* c8 ignore stop */\n        super.write(block);\n    }\n    [DIRECTORY]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create directory entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.path.slice(-1) !== '/') {\n            this.path += '/';\n        }\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [SYMLINK]() {\n        fs_1.default.readlink(this.absolute, (er, linkpath) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADLINK](linkpath);\n        });\n    }\n    [ONREADLINK](linkpath) {\n        this.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(linkpath);\n        this[HEADER]();\n        this.end();\n    }\n    [HARDLINK](linkpath) {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create link entry without stat');\n        }\n        /* c8 ignore stop */\n        this.type = 'Link';\n        this.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.relative(this.cwd, linkpath));\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [FILE]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create file entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.stat.nlink > 1) {\n            const linkKey = `${this.stat.dev}:${this.stat.ino}`;\n            const linkpath = this.linkCache.get(linkKey);\n            if (linkpath?.indexOf(this.cwd) === 0) {\n                return this[HARDLINK](linkpath);\n            }\n            this.linkCache.set(linkKey, this.absolute);\n        }\n        this[HEADER]();\n        if (this.stat.size === 0) {\n            return this.end();\n        }\n        this[OPENFILE]();\n    }\n    [OPENFILE]() {\n        fs_1.default.open(this.absolute, 'r', (er, fd) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONOPENFILE](fd);\n        });\n    }\n    [ONOPENFILE](fd) {\n        this.fd = fd;\n        if (this.#hadError) {\n            return this[CLOSE]();\n        }\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('should stat before calling onopenfile');\n        }\n        /* c8 ignore start */\n        this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n        this.blockRemain = this.blockLen;\n        const bufLen = Math.min(this.blockLen, this.maxReadSize);\n        this.buf = Buffer.allocUnsafe(bufLen);\n        this.offset = 0;\n        this.pos = 0;\n        this.remain = this.stat.size;\n        this.length = this.buf.length;\n        this[READ]();\n    }\n    [READ]() {\n        const { fd, buf, offset, length, pos } = this;\n        if (fd === undefined || buf === undefined) {\n            throw new Error('cannot read file without first opening');\n        }\n        fs_1.default.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n            if (er) {\n                // ignoring the error from close(2) is a bad practice, but at\n                // this point we already have an error, don't need another one\n                return this[CLOSE](() => this.emit('error', er));\n            }\n            this[ONREAD](bytesRead);\n        });\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs_1.default.close(this.fd, cb);\n    }\n    [ONREAD](bytesRead) {\n        if (bytesRead <= 0 && this.remain > 0) {\n            const er = Object.assign(new Error('encountered unexpected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        if (bytesRead > this.remain) {\n            const er = Object.assign(new Error('did not encounter expected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('should have created buffer prior to reading');\n        }\n        /* c8 ignore stop */\n        // null out the rest of the buffer, if we could fit the block padding\n        // at the end of this loop, we've incremented bytesRead and this.remain\n        // to be incremented up to the blockRemain level, as if we had expected\n        // to get a null-padded file, and read it until the end.  then we will\n        // decrement both remain and blockRemain by bytesRead, and know that we\n        // reached the expected EOF, without any null buffer to append.\n        if (bytesRead === this.remain) {\n            for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n                this.buf[i + this.offset] = 0;\n                bytesRead++;\n                this.remain++;\n            }\n        }\n        const chunk = this.offset === 0 && bytesRead === this.buf.length ?\n            this.buf\n            : this.buf.subarray(this.offset, this.offset + bytesRead);\n        const flushed = this.write(chunk);\n        if (!flushed) {\n            this[AWAITDRAIN](() => this[ONDRAIN]());\n        }\n        else {\n            this[ONDRAIN]();\n        }\n    }\n    [AWAITDRAIN](cb) {\n        this.once('drain', cb);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        if (this.blockRemain < chunk.length) {\n            const er = Object.assign(new Error('writing more data than expected'), {\n                path: this.absolute,\n            });\n            return this.emit('error', er);\n        }\n        this.remain -= chunk.length;\n        this.blockRemain -= chunk.length;\n        this.pos += chunk.length;\n        this.offset += chunk.length;\n        return super.write(chunk, null, cb);\n    }\n    [ONDRAIN]() {\n        if (!this.remain) {\n            if (this.blockRemain) {\n                super.write(Buffer.alloc(this.blockRemain));\n            }\n            return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('buffer lost somehow in ONDRAIN');\n        }\n        /* c8 ignore stop */\n        if (this.offset >= this.length) {\n            // if we only have a smaller bit left to read, alloc a smaller buffer\n            // otherwise, keep it the same length it was before.\n            this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n            this.offset = 0;\n        }\n        this.length = this.buf.length - this.offset;\n        this[READ]();\n    }\n}\nexports.WriteEntry = WriteEntry;\nclass WriteEntrySync extends WriteEntry {\n    sync = true;\n    [LSTAT]() {\n        this[ONLSTAT](fs_1.default.lstatSync(this.absolute));\n    }\n    [SYMLINK]() {\n        this[ONREADLINK](fs_1.default.readlinkSync(this.absolute));\n    }\n    [OPENFILE]() {\n        this[ONOPENFILE](fs_1.default.openSync(this.absolute, 'r'));\n    }\n    [READ]() {\n        let threw = true;\n        try {\n            const { fd, buf, offset, length, pos } = this;\n            /* c8 ignore start */\n            if (fd === undefined || buf === undefined) {\n                throw new Error('fd and buf must be set in READ method');\n            }\n            /* c8 ignore stop */\n            const bytesRead = fs_1.default.readSync(fd, buf, offset, length, pos);\n            this[ONREAD](bytesRead);\n            threw = false;\n        }\n        finally {\n            // ignoring the error from close(2) is a bad practice, but at\n            // this point we already have an error, don't need another one\n            if (threw) {\n                try {\n                    this[CLOSE](() => { });\n                }\n                catch (er) { }\n            }\n        }\n    }\n    [AWAITDRAIN](cb) {\n        cb();\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs_1.default.closeSync(this.fd);\n        cb();\n    }\n}\nexports.WriteEntrySync = WriteEntrySync;\nclass WriteEntryTar extends minipass_1.Minipass {\n    blockLen = 0;\n    blockRemain = 0;\n    buf = 0;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    preservePaths;\n    portable;\n    strict;\n    noPax;\n    noMtime;\n    readEntry;\n    type;\n    prefix;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    header;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    size;\n    onWriteEntry;\n    warn(code, message, data = {}) {\n        return (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    constructor(readEntry, opt_ = {}) {\n        const opt = (0, options_js_1.dealias)(opt_);\n        super();\n        this.preservePaths = !!opt.preservePaths;\n        this.portable = !!opt.portable;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.onWriteEntry = opt.onWriteEntry;\n        this.readEntry = readEntry;\n        const { type } = readEntry;\n        /* c8 ignore start */\n        if (type === 'Unsupported') {\n            throw new Error('writing entry that should be ignored');\n        }\n        /* c8 ignore stop */\n        this.type = type;\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.prefix = opt.prefix;\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.path);\n        this.mode =\n            readEntry.mode !== undefined ?\n                this[MODE](readEntry.mode)\n                : undefined;\n        this.uid = this.portable ? undefined : readEntry.uid;\n        this.gid = this.portable ? undefined : readEntry.gid;\n        this.uname = this.portable ? undefined : readEntry.uname;\n        this.gname = this.portable ? undefined : readEntry.gname;\n        this.size = readEntry.size;\n        this.mtime =\n            this.noMtime ? undefined : opt.mtime || readEntry.mtime;\n        this.atime = this.portable ? undefined : readEntry.atime;\n        this.ctime = this.portable ? undefined : readEntry.ctime;\n        this.linkpath =\n            readEntry.linkpath !== undefined ?\n                (0, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.linkpath)\n                : undefined;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.remain = readEntry.size;\n        this.blockRemain = readEntry.startBlockSize;\n        this.onWriteEntry?.(this);\n        this.header = new header_js_1.Header({\n            path: this[PREFIX](this.path),\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this.mode,\n            uid: this.portable ? undefined : this.uid,\n            gid: this.portable ? undefined : this.gid,\n            size: this.size,\n            mtime: this.noMtime ? undefined : this.mtime,\n            type: this.type,\n            uname: this.portable ? undefined : this.uname,\n            atime: this.portable ? undefined : this.atime,\n            ctime: this.portable ? undefined : this.ctime,\n        });\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        if (this.header.encode() && !this.noPax) {\n            super.write(new pax_js_1.Pax({\n                atime: this.portable ? undefined : this.atime,\n                ctime: this.portable ? undefined : this.ctime,\n                gid: this.portable ? undefined : this.gid,\n                mtime: this.noMtime ? undefined : this.mtime,\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.size,\n                uid: this.portable ? undefined : this.uid,\n                uname: this.portable ? undefined : this.uname,\n                dev: this.portable ? undefined : this.readEntry.dev,\n                ino: this.portable ? undefined : this.readEntry.ino,\n                nlink: this.portable ? undefined : this.readEntry.nlink,\n            }).encode());\n        }\n        const b = this.header?.block;\n        /* c8 ignore start */\n        if (!b)\n            throw new Error('failed to encode header');\n        /* c8 ignore stop */\n        super.write(b);\n        readEntry.pipe(this);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [MODE](mode) {\n        return (0, mode_fix_js_1.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        const writeLen = chunk.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        this.blockRemain -= writeLen;\n        return super.write(chunk, cb);\n    }\n    end(chunk, encoding, cb) {\n        if (this.blockRemain) {\n            super.write(Buffer.alloc(this.blockRemain));\n        }\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding ?? 'utf8');\n        }\n        if (cb)\n            this.once('finish', cb);\n        chunk ? super.end(chunk, cb) : super.end(cb);\n        /* c8 ignore stop */\n        return this;\n    }\n}\nexports.WriteEntryTar = WriteEntryTar;\nconst getType = (stat) => stat.isFile() ? 'File'\n    : stat.isDirectory() ? 'Directory'\n        : stat.isSymbolicLink() ? 'SymbolicLink'\n            : 'Unsupported';\n//# sourceMappingURL=write-entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2Rpc3QvY29tbW9uanMvd3JpdGUtZW50cnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCO0FBQ25FLDZCQUE2QixtQkFBTyxDQUFDLGNBQUk7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsaUZBQVU7QUFDckMsK0JBQStCLG1CQUFPLENBQUMsa0JBQU07QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsK0RBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsbUVBQWU7QUFDN0Msb0NBQW9DLG1CQUFPLENBQUMsK0ZBQTZCO0FBQ3pFLHFCQUFxQixtQkFBTyxDQUFDLGlFQUFjO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLHlEQUFVO0FBQ25DLGlDQUFpQyxtQkFBTyxDQUFDLHlGQUEwQjtBQUNuRSxvQ0FBb0MsbUJBQU8sQ0FBQywrRkFBNkI7QUFDekUseUJBQXlCLG1CQUFPLENBQUMseUVBQWtCO0FBQ25ELDhCQUE4QixtQkFBTyxDQUFDLG1FQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9kaXN0L2NvbW1vbmpzL3dyaXRlLWVudHJ5LmpzP2Y0ODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV3JpdGVFbnRyeVRhciA9IGV4cG9ydHMuV3JpdGVFbnRyeVN5bmMgPSBleHBvcnRzLldyaXRlRW50cnkgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBtaW5pcGFzc18xID0gcmVxdWlyZShcIm1pbmlwYXNzXCIpO1xuY29uc3QgcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtcbmNvbnN0IGhlYWRlcl9qc18xID0gcmVxdWlyZShcIi4vaGVhZGVyLmpzXCIpO1xuY29uc3QgbW9kZV9maXhfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtZml4LmpzXCIpO1xuY29uc3Qgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qc1wiKTtcbmNvbnN0IG9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnMuanNcIik7XG5jb25zdCBwYXhfanNfMSA9IHJlcXVpcmUoXCIuL3BheC5qc1wiKTtcbmNvbnN0IHN0cmlwX2Fic29sdXRlX3BhdGhfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmlwLWFic29sdXRlLXBhdGguanNcIik7XG5jb25zdCBzdHJpcF90cmFpbGluZ19zbGFzaGVzX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzXCIpO1xuY29uc3Qgd2Fybl9tZXRob2RfanNfMSA9IHJlcXVpcmUoXCIuL3dhcm4tbWV0aG9kLmpzXCIpO1xuY29uc3Qgd2luY2hhcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vd2luY2hhcnMuanNcIikpO1xuY29uc3QgcHJlZml4UGF0aCA9IChwYXRoLCBwcmVmaXgpID0+IHtcbiAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICByZXR1cm4gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkocGF0aCk7XG4gICAgfVxuICAgIHBhdGggPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShwYXRoKS5yZXBsYWNlKC9eXFwuKFxcL3wkKS8sICcnKTtcbiAgICByZXR1cm4gKDAsIHN0cmlwX3RyYWlsaW5nX3NsYXNoZXNfanNfMS5zdHJpcFRyYWlsaW5nU2xhc2hlcykocHJlZml4KSArICcvJyArIHBhdGg7XG59O1xuY29uc3QgbWF4UmVhZFNpemUgPSAxNiAqIDEwMjQgKiAxMDI0O1xuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpO1xuY29uc3QgRklMRSA9IFN5bWJvbCgnZmlsZScpO1xuY29uc3QgRElSRUNUT1JZID0gU3ltYm9sKCdkaXJlY3RvcnknKTtcbmNvbnN0IFNZTUxJTksgPSBTeW1ib2woJ3N5bWxpbmsnKTtcbmNvbnN0IEhBUkRMSU5LID0gU3ltYm9sKCdoYXJkbGluaycpO1xuY29uc3QgSEVBREVSID0gU3ltYm9sKCdoZWFkZXInKTtcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKTtcbmNvbnN0IExTVEFUID0gU3ltYm9sKCdsc3RhdCcpO1xuY29uc3QgT05MU1RBVCA9IFN5bWJvbCgnb25sc3RhdCcpO1xuY29uc3QgT05SRUFEID0gU3ltYm9sKCdvbnJlYWQnKTtcbmNvbnN0IE9OUkVBRExJTksgPSBTeW1ib2woJ29ucmVhZGxpbmsnKTtcbmNvbnN0IE9QRU5GSUxFID0gU3ltYm9sKCdvcGVuZmlsZScpO1xuY29uc3QgT05PUEVORklMRSA9IFN5bWJvbCgnb25vcGVuZmlsZScpO1xuY29uc3QgQ0xPU0UgPSBTeW1ib2woJ2Nsb3NlJyk7XG5jb25zdCBNT0RFID0gU3ltYm9sKCdtb2RlJyk7XG5jb25zdCBBV0FJVERSQUlOID0gU3ltYm9sKCdhd2FpdERyYWluJyk7XG5jb25zdCBPTkRSQUlOID0gU3ltYm9sKCdvbmRyYWluJyk7XG5jb25zdCBQUkVGSVggPSBTeW1ib2woJ3ByZWZpeCcpO1xuY2xhc3MgV3JpdGVFbnRyeSBleHRlbmRzIG1pbmlwYXNzXzEuTWluaXBhc3Mge1xuICAgIHBhdGg7XG4gICAgcG9ydGFibGU7XG4gICAgbXl1aWQgPSAocHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSkgfHwgMDtcbiAgICAvLyB1bnRpbCBub2RlIGhhcyBidWlsdGluIHB3bmFtIGZ1bmN0aW9ucywgdGhpcydsbCBoYXZlIHRvIGRvXG4gICAgbXl1c2VyID0gcHJvY2Vzcy5lbnYuVVNFUiB8fCAnJztcbiAgICBtYXhSZWFkU2l6ZTtcbiAgICBsaW5rQ2FjaGU7XG4gICAgc3RhdENhY2hlO1xuICAgIHByZXNlcnZlUGF0aHM7XG4gICAgY3dkO1xuICAgIHN0cmljdDtcbiAgICBtdGltZTtcbiAgICBub1BheDtcbiAgICBub010aW1lO1xuICAgIHByZWZpeDtcbiAgICBmZDtcbiAgICBibG9ja0xlbiA9IDA7XG4gICAgYmxvY2tSZW1haW4gPSAwO1xuICAgIGJ1ZjtcbiAgICBwb3MgPSAwO1xuICAgIHJlbWFpbiA9IDA7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBvZmZzZXQgPSAwO1xuICAgIHdpbjMyO1xuICAgIGFic29sdXRlO1xuICAgIGhlYWRlcjtcbiAgICB0eXBlO1xuICAgIGxpbmtwYXRoO1xuICAgIHN0YXQ7XG4gICAgb25Xcml0ZUVudHJ5O1xuICAgICNoYWRFcnJvciA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHAsIG9wdF8gPSB7fSkge1xuICAgICAgICBjb25zdCBvcHQgPSAoMCwgb3B0aW9uc19qc18xLmRlYWxpYXMpKG9wdF8pO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhdGggPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShwKTtcbiAgICAgICAgLy8gc3VwcHJlc3MgYXRpbWUsIGN0aW1lLCB1aWQsIGdpZCwgdW5hbWUsIGduYW1lXG4gICAgICAgIHRoaXMucG9ydGFibGUgPSAhIW9wdC5wb3J0YWJsZTtcbiAgICAgICAgdGhpcy5tYXhSZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCBtYXhSZWFkU2l6ZTtcbiAgICAgICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVBhdGhzID0gISFvcHQucHJlc2VydmVQYXRocztcbiAgICAgICAgdGhpcy5jd2QgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShvcHQuY3dkIHx8IHByb2Nlc3MuY3dkKCkpO1xuICAgICAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdDtcbiAgICAgICAgdGhpcy5ub1BheCA9ICEhb3B0Lm5vUGF4O1xuICAgICAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lO1xuICAgICAgICB0aGlzLm10aW1lID0gb3B0Lm10aW1lO1xuICAgICAgICB0aGlzLnByZWZpeCA9XG4gICAgICAgICAgICBvcHQucHJlZml4ID8gKDAsIG5vcm1hbGl6ZV93aW5kb3dzX3BhdGhfanNfMS5ub3JtYWxpemVXaW5kb3dzUGF0aCkob3B0LnByZWZpeCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25Xcml0ZUVudHJ5ID0gb3B0Lm9uV3JpdGVFbnRyeTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2Fybik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGhXYXJuID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBbcm9vdCwgc3RyaXBwZWRdID0gKDAsIHN0cmlwX2Fic29sdXRlX3BhdGhfanNfMS5zdHJpcEFic29sdXRlUGF0aCkodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGlmIChyb290ICYmIHR5cGVvZiBzdHJpcHBlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBzdHJpcHBlZDtcbiAgICAgICAgICAgICAgICBwYXRoV2FybiA9IHJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIGlmICh0aGlzLndpbjMyKSB7XG4gICAgICAgICAgICAvLyBmb3JjZSB0aGUgXFwgdG8gLyBub3JtYWxpemF0aW9uLCBzaW5jZSB3ZSBtaWdodCBub3QgKmFjdHVhbGx5KlxuICAgICAgICAgICAgLy8gYmUgb24gd2luZG93cywgYnV0IHdhbnQgXFwgdG8gYmUgY29uc2lkZXJlZCBhIHBhdGggc2VwYXJhdG9yLlxuICAgICAgICAgICAgdGhpcy5wYXRoID0gd2luY2hhcnMuZGVjb2RlKHRoaXMucGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykpO1xuICAgICAgICAgICAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWJzb2x1dGUgPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShvcHQuYWJzb2x1dGUgfHwgcGF0aF8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmN3ZCwgcCkpO1xuICAgICAgICBpZiAodGhpcy5wYXRoID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gJy4vJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aFdhcm4pIHtcbiAgICAgICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cGF0aFdhcm59IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgICAgICAgICBlbnRyeTogdGhpcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoV2FybiArIHRoaXMucGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNzID0gdGhpcy5zdGF0Q2FjaGUuZ2V0KHRoaXMuYWJzb2x1dGUpO1xuICAgICAgICBpZiAoY3MpIHtcbiAgICAgICAgICAgIHRoaXNbT05MU1RBVF0oY3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tMU1RBVF0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXJuKGNvZGUsIG1lc3NhZ2UsIGRhdGEgPSB7fSkge1xuICAgICAgICByZXR1cm4gKDAsIHdhcm5fbWV0aG9kX2pzXzEud2Fybk1ldGhvZCkodGhpcywgY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmRhdGEpIHtcbiAgICAgICAgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLiNoYWRFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmRhdGEpO1xuICAgIH1cbiAgICBbTFNUQVRdKCkge1xuICAgICAgICBmc18xLmRlZmF1bHQubHN0YXQodGhpcy5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbT05MU1RBVF0oc3RhdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbT05MU1RBVF0oc3RhdCkge1xuICAgICAgICB0aGlzLnN0YXRDYWNoZS5zZXQodGhpcy5hYnNvbHV0ZSwgc3RhdCk7XG4gICAgICAgIHRoaXMuc3RhdCA9IHN0YXQ7XG4gICAgICAgIGlmICghc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgc3RhdC5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBnZXRUeXBlKHN0YXQpO1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YXQnLCBzdGF0KTtcbiAgICAgICAgdGhpc1tQUk9DRVNTXSgpO1xuICAgIH1cbiAgICBbUFJPQ0VTU10oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdGaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tGSUxFXSgpO1xuICAgICAgICAgICAgY2FzZSAnRGlyZWN0b3J5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tESVJFQ1RPUlldKCk7XG4gICAgICAgICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1NZTUxJTktdKCk7XG4gICAgICAgICAgICAvLyB1bnN1cHBvcnRlZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW01PREVdKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBtb2RlX2ZpeF9qc18xLm1vZGVGaXgpKG1vZGUsIHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScsIHRoaXMucG9ydGFibGUpO1xuICAgIH1cbiAgICBbUFJFRklYXShwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhQYXRoKHBhdGgsIHRoaXMucHJlZml4KTtcbiAgICB9XG4gICAgW0hFQURFUl0oKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgaGVhZGVyIGJlZm9yZSBzdGF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uV3JpdGVFbnRyeT8uKHRoaXMpO1xuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyBoZWFkZXJfanNfMS5IZWFkZXIoe1xuICAgICAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgICAgICAvLyBvbmx5IGFwcGx5IHRoZSBwcmVmaXggdG8gaGFyZCBsaW5rcy5cbiAgICAgICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyAmJiB0aGlzLmxpbmtwYXRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICAgICAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICAgICAgICBtb2RlOiB0aGlzW01PREVdKHRoaXMuc3RhdC5tb2RlKSxcbiAgICAgICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuc3RhdC51aWQsXG4gICAgICAgICAgICBnaWQ6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXQuZ2lkLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zdGF0LnNpemUsXG4gICAgICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gdW5kZWZpbmVkIDogdGhpcy5tdGltZSB8fCB0aGlzLnN0YXQubXRpbWUsXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlID09PSAnVW5zdXBwb3J0ZWQnID8gdW5kZWZpbmVkIDogdGhpcy50eXBlLFxuICAgICAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHRoaXMuc3RhdC51aWQgPT09IHRoaXMubXl1aWQgPyB0aGlzLm15dXNlclxuICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXQuYXRpbWUsXG4gICAgICAgICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuc3RhdC5jdGltZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlci5lbmNvZGUoKSAmJiAhdGhpcy5ub1BheCkge1xuICAgICAgICAgICAgc3VwZXIud3JpdGUobmV3IHBheF9qc18xLlBheCh7XG4gICAgICAgICAgICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmhlYWRlci5hdGltZSxcbiAgICAgICAgICAgICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuaGVhZGVyLmN0aW1lLFxuICAgICAgICAgICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuaGVhZGVyLmdpZCxcbiAgICAgICAgICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gdW5kZWZpbmVkIDogKHRoaXMubXRpbWUgfHwgdGhpcy5oZWFkZXIubXRpbWUpLFxuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyAmJiB0aGlzLmxpbmtwYXRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuaGVhZGVyLnNpemUsXG4gICAgICAgICAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5oZWFkZXIudWlkLFxuICAgICAgICAgICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5oZWFkZXIudW5hbWUsXG4gICAgICAgICAgICAgICAgZGV2OiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5zdGF0LmRldixcbiAgICAgICAgICAgICAgICBpbm86IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXQuaW5vLFxuICAgICAgICAgICAgICAgIG5saW5rOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5zdGF0Lm5saW5rLFxuICAgICAgICAgICAgfSkuZW5jb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5oZWFkZXI/LmJsb2NrO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZW5jb2RlIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHN1cGVyLndyaXRlKGJsb2NrKTtcbiAgICB9XG4gICAgW0RJUkVDVE9SWV0oKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIGRpcmVjdG9yeSBlbnRyeSB3aXRob3V0IHN0YXQnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAodGhpcy5wYXRoLnNsaWNlKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdC5zaXplID0gMDtcbiAgICAgICAgdGhpc1tIRUFERVJdKCk7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIFtTWU1MSU5LXSgpIHtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnJlYWRsaW5rKHRoaXMuYWJzb2x1dGUsIChlciwgbGlua3BhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tPTlJFQURMSU5LXShsaW5rcGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbT05SRUFETElOS10obGlua3BhdGgpIHtcbiAgICAgICAgdGhpcy5saW5rcGF0aCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKGxpbmtwYXRoKTtcbiAgICAgICAgdGhpc1tIRUFERVJdKCk7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIFtIQVJETElOS10obGlua3BhdGgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5zdGF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgbGluayBlbnRyeSB3aXRob3V0IHN0YXQnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnTGluayc7XG4gICAgICAgIHRoaXMubGlua3BhdGggPSAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShwYXRoXzEuZGVmYXVsdC5yZWxhdGl2ZSh0aGlzLmN3ZCwgbGlua3BhdGgpKTtcbiAgICAgICAgdGhpcy5zdGF0LnNpemUgPSAwO1xuICAgICAgICB0aGlzW0hFQURFUl0oKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gICAgW0ZJTEVdKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN0YXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNyZWF0ZSBmaWxlIGVudHJ5IHdpdGhvdXQgc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmICh0aGlzLnN0YXQubmxpbmsgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rS2V5ID0gYCR7dGhpcy5zdGF0LmRldn06JHt0aGlzLnN0YXQuaW5vfWA7XG4gICAgICAgICAgICBjb25zdCBsaW5rcGF0aCA9IHRoaXMubGlua0NhY2hlLmdldChsaW5rS2V5KTtcbiAgICAgICAgICAgIGlmIChsaW5rcGF0aD8uaW5kZXhPZih0aGlzLmN3ZCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10obGlua3BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saW5rQ2FjaGUuc2V0KGxpbmtLZXksIHRoaXMuYWJzb2x1dGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbSEVBREVSXSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbT1BFTkZJTEVdKCk7XG4gICAgfVxuICAgIFtPUEVORklMRV0oKSB7XG4gICAgICAgIGZzXzEuZGVmYXVsdC5vcGVuKHRoaXMuYWJzb2x1dGUsICdyJywgKGVyLCBmZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW09OT1BFTkZJTEVdKGZkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFtPTk9QRU5GSUxFXShmZCkge1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgICAgIGlmICh0aGlzLiNoYWRFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5zdGF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBzdGF0IGJlZm9yZSBjYWxsaW5nIG9ub3BlbmZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IDUxMiAqIE1hdGguY2VpbCh0aGlzLnN0YXQuc2l6ZSAvIDUxMik7XG4gICAgICAgIHRoaXMuYmxvY2tSZW1haW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBidWZMZW4gPSBNYXRoLm1pbih0aGlzLmJsb2NrTGVuLCB0aGlzLm1heFJlYWRTaXplKTtcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucmVtYWluID0gdGhpcy5zdGF0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xuICAgICAgICB0aGlzW1JFQURdKCk7XG4gICAgfVxuICAgIFtSRUFEXSgpIHtcbiAgICAgICAgY29uc3QgeyBmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZmQgPT09IHVuZGVmaW5lZCB8fCBidWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVhZCBmaWxlIHdpdGhvdXQgZmlyc3Qgb3BlbmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZzXzEuZGVmYXVsdC5yZWFkKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MsIChlciwgYnl0ZXNSZWFkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmluZyB0aGUgZXJyb3IgZnJvbSBjbG9zZSgyKSBpcyBhIGJhZCBwcmFjdGljZSwgYnV0IGF0XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwb2ludCB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IsIGRvbid0IG5lZWQgYW5vdGhlciBvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW09OUkVBRF0oYnl0ZXNSZWFkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIFtDTE9TRV0oY2IgPSAoKSA9PiB7IH0pIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuZmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZSh0aGlzLmZkLCBjYik7XG4gICAgfVxuICAgIFtPTlJFQURdKGJ5dGVzUmVhZCkge1xuICAgICAgICBpZiAoYnl0ZXNSZWFkIDw9IDAgJiYgdGhpcy5yZW1haW4gPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdlbmNvdW50ZXJlZCB1bmV4cGVjdGVkIEVPRicpLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBzeXNjYWxsOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VPRicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXNSZWFkID4gdGhpcy5yZW1haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ2RpZCBub3QgZW5jb3VudGVyIGV4cGVjdGVkIEVPRicpLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICBzeXNjYWxsOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VPRicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCF0aGlzLmJ1Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgaGF2ZSBjcmVhdGVkIGJ1ZmZlciBwcmlvciB0byByZWFkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gbnVsbCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciwgaWYgd2UgY291bGQgZml0IHRoZSBibG9jayBwYWRkaW5nXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhpcyBsb29wLCB3ZSd2ZSBpbmNyZW1lbnRlZCBieXRlc1JlYWQgYW5kIHRoaXMucmVtYWluXG4gICAgICAgIC8vIHRvIGJlIGluY3JlbWVudGVkIHVwIHRvIHRoZSBibG9ja1JlbWFpbiBsZXZlbCwgYXMgaWYgd2UgaGFkIGV4cGVjdGVkXG4gICAgICAgIC8vIHRvIGdldCBhIG51bGwtcGFkZGVkIGZpbGUsIGFuZCByZWFkIGl0IHVudGlsIHRoZSBlbmQuICB0aGVuIHdlIHdpbGxcbiAgICAgICAgLy8gZGVjcmVtZW50IGJvdGggcmVtYWluIGFuZCBibG9ja1JlbWFpbiBieSBieXRlc1JlYWQsIGFuZCBrbm93IHRoYXQgd2VcbiAgICAgICAgLy8gcmVhY2hlZCB0aGUgZXhwZWN0ZWQgRU9GLCB3aXRob3V0IGFueSBudWxsIGJ1ZmZlciB0byBhcHBlbmQuXG4gICAgICAgIGlmIChieXRlc1JlYWQgPT09IHRoaXMucmVtYWluKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYnl0ZXNSZWFkOyBpIDwgdGhpcy5sZW5ndGggJiYgYnl0ZXNSZWFkIDwgdGhpcy5ibG9ja1JlbWFpbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZbaSArIHRoaXMub2Zmc2V0XSA9IDA7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMub2Zmc2V0ID09PSAwICYmIGJ5dGVzUmVhZCA9PT0gdGhpcy5idWYubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuYnVmXG4gICAgICAgICAgICA6IHRoaXMuYnVmLnN1YmFycmF5KHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGJ5dGVzUmVhZCk7XG4gICAgICAgIGNvbnN0IGZsdXNoZWQgPSB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgICAgaWYgKCFmbHVzaGVkKSB7XG4gICAgICAgICAgICB0aGlzW0FXQUlURFJBSU5dKCgpID0+IHRoaXNbT05EUkFJTl0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW09ORFJBSU5dKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0FXQUlURFJBSU5dKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBjYik7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0IC0ganVzdCBqdW5rIHRvIGNvbXBseSB3aXRoIE5vZGVKUy5Xcml0YWJsZVN0cmVhbSAqL1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgPyBlbmNvZGluZyA6ICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZW1haW4gPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSBkYXRhIHRoYW4gZXhwZWN0ZWQnKSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtYWluIC09IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ibG9ja1JlbWFpbiAtPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMucG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmssIG51bGwsIGNiKTtcbiAgICB9XG4gICAgW09ORFJBSU5dKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVtYWluKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja1JlbWFpbikge1xuICAgICAgICAgICAgICAgIHN1cGVyLndyaXRlKEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrUmVtYWluKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oZXIgPT4gZXIgPyB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpIDogdGhpcy5lbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5idWYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGxvc3Qgc29tZWhvdyBpbiBPTkRSQUlOJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgYSBzbWFsbGVyIGJpdCBsZWZ0IHRvIHJlYWQsIGFsbG9jIGEgc21hbGxlciBidWZmZXJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCB0aGUgc2FtZSBsZW5ndGggaXQgd2FzIGJlZm9yZS5cbiAgICAgICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWluKHRoaXMuYmxvY2tSZW1haW4sIHRoaXMuYnVmLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHRoaXNbUkVBRF0oKTtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlRW50cnkgPSBXcml0ZUVudHJ5O1xuY2xhc3MgV3JpdGVFbnRyeVN5bmMgZXh0ZW5kcyBXcml0ZUVudHJ5IHtcbiAgICBzeW5jID0gdHJ1ZTtcbiAgICBbTFNUQVRdKCkge1xuICAgICAgICB0aGlzW09OTFNUQVRdKGZzXzEuZGVmYXVsdC5sc3RhdFN5bmModGhpcy5hYnNvbHV0ZSkpO1xuICAgIH1cbiAgICBbU1lNTElOS10oKSB7XG4gICAgICAgIHRoaXNbT05SRUFETElOS10oZnNfMS5kZWZhdWx0LnJlYWRsaW5rU3luYyh0aGlzLmFic29sdXRlKSk7XG4gICAgfVxuICAgIFtPUEVORklMRV0oKSB7XG4gICAgICAgIHRoaXNbT05PUEVORklMRV0oZnNfMS5kZWZhdWx0Lm9wZW5TeW5jKHRoaXMuYWJzb2x1dGUsICdyJykpO1xuICAgIH1cbiAgICBbUkVBRF0oKSB7XG4gICAgICAgIGxldCB0aHJldyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChmZCA9PT0gdW5kZWZpbmVkIHx8IGJ1ZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZCBhbmQgYnVmIG11c3QgYmUgc2V0IGluIFJFQUQgbWV0aG9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnNfMS5kZWZhdWx0LnJlYWRTeW5jKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MpO1xuICAgICAgICAgICAgdGhpc1tPTlJFQURdKGJ5dGVzUmVhZCk7XG4gICAgICAgICAgICB0aHJldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gaWdub3JpbmcgdGhlIGVycm9yIGZyb20gY2xvc2UoMikgaXMgYSBiYWQgcHJhY3RpY2UsIGJ1dCBhdFxuICAgICAgICAgICAgLy8gdGhpcyBwb2ludCB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IsIGRvbid0IG5lZWQgYW5vdGhlciBvbmVcbiAgICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbQ0xPU0VdKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgW0FXQUlURFJBSU5dKGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIFtDTE9TRV0oY2IgPSAoKSA9PiB7IH0pIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuZmQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmModGhpcy5mZCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZUVudHJ5U3luYyA9IFdyaXRlRW50cnlTeW5jO1xuY2xhc3MgV3JpdGVFbnRyeVRhciBleHRlbmRzIG1pbmlwYXNzXzEuTWluaXBhc3Mge1xuICAgIGJsb2NrTGVuID0gMDtcbiAgICBibG9ja1JlbWFpbiA9IDA7XG4gICAgYnVmID0gMDtcbiAgICBwb3MgPSAwO1xuICAgIHJlbWFpbiA9IDA7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBwcmVzZXJ2ZVBhdGhzO1xuICAgIHBvcnRhYmxlO1xuICAgIHN0cmljdDtcbiAgICBub1BheDtcbiAgICBub010aW1lO1xuICAgIHJlYWRFbnRyeTtcbiAgICB0eXBlO1xuICAgIHByZWZpeDtcbiAgICBwYXRoO1xuICAgIG1vZGU7XG4gICAgdWlkO1xuICAgIGdpZDtcbiAgICB1bmFtZTtcbiAgICBnbmFtZTtcbiAgICBoZWFkZXI7XG4gICAgbXRpbWU7XG4gICAgYXRpbWU7XG4gICAgY3RpbWU7XG4gICAgbGlua3BhdGg7XG4gICAgc2l6ZTtcbiAgICBvbldyaXRlRW50cnk7XG4gICAgd2Fybihjb2RlLCBtZXNzYWdlLCBkYXRhID0ge30pIHtcbiAgICAgICAgcmV0dXJuICgwLCB3YXJuX21ldGhvZF9qc18xLndhcm5NZXRob2QpKHRoaXMsIGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihyZWFkRW50cnksIG9wdF8gPSB7fSkge1xuICAgICAgICBjb25zdCBvcHQgPSAoMCwgb3B0aW9uc19qc18xLmRlYWxpYXMpKG9wdF8pO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzO1xuICAgICAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGU7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gISFvcHQuc3RyaWN0O1xuICAgICAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXg7XG4gICAgICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWU7XG4gICAgICAgIHRoaXMub25Xcml0ZUVudHJ5ID0gb3B0Lm9uV3JpdGVFbnRyeTtcbiAgICAgICAgdGhpcy5yZWFkRW50cnkgPSByZWFkRW50cnk7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcmVhZEVudHJ5O1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHR5cGUgPT09ICdVbnN1cHBvcnRlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBlbnRyeSB0aGF0IHNob3VsZCBiZSBpZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWZpeCA9IG9wdC5wcmVmaXg7XG4gICAgICAgIHRoaXMucGF0aCA9ICgwLCBub3JtYWxpemVfd2luZG93c19wYXRoX2pzXzEubm9ybWFsaXplV2luZG93c1BhdGgpKHJlYWRFbnRyeS5wYXRoKTtcbiAgICAgICAgdGhpcy5tb2RlID1cbiAgICAgICAgICAgIHJlYWRFbnRyeS5tb2RlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXNbTU9ERV0ocmVhZEVudHJ5Lm1vZGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudWlkID0gdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHJlYWRFbnRyeS51aWQ7XG4gICAgICAgIHRoaXMuZ2lkID0gdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHJlYWRFbnRyeS5naWQ7XG4gICAgICAgIHRoaXMudW5hbWUgPSB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogcmVhZEVudHJ5LnVuYW1lO1xuICAgICAgICB0aGlzLmduYW1lID0gdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHJlYWRFbnRyeS5nbmFtZTtcbiAgICAgICAgdGhpcy5zaXplID0gcmVhZEVudHJ5LnNpemU7XG4gICAgICAgIHRoaXMubXRpbWUgPVxuICAgICAgICAgICAgdGhpcy5ub010aW1lID8gdW5kZWZpbmVkIDogb3B0Lm10aW1lIHx8IHJlYWRFbnRyeS5tdGltZTtcbiAgICAgICAgdGhpcy5hdGltZSA9IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiByZWFkRW50cnkuYXRpbWU7XG4gICAgICAgIHRoaXMuY3RpbWUgPSB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogcmVhZEVudHJ5LmN0aW1lO1xuICAgICAgICB0aGlzLmxpbmtwYXRoID1cbiAgICAgICAgICAgIHJlYWRFbnRyeS5saW5rcGF0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAoMCwgbm9ybWFsaXplX3dpbmRvd3NfcGF0aF9qc18xLm5vcm1hbGl6ZVdpbmRvd3NQYXRoKShyZWFkRW50cnkubGlua3BhdGgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXRoV2FybiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVQYXRocykge1xuICAgICAgICAgICAgY29uc3QgW3Jvb3QsIHN0cmlwcGVkXSA9ICgwLCBzdHJpcF9hYnNvbHV0ZV9wYXRoX2pzXzEuc3RyaXBBYnNvbHV0ZVBhdGgpKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBpZiAocm9vdCAmJiB0eXBlb2Ygc3RyaXBwZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gc3RyaXBwZWQ7XG4gICAgICAgICAgICAgICAgcGF0aFdhcm4gPSByb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtYWluID0gcmVhZEVudHJ5LnNpemU7XG4gICAgICAgIHRoaXMuYmxvY2tSZW1haW4gPSByZWFkRW50cnkuc3RhcnRCbG9ja1NpemU7XG4gICAgICAgIHRoaXMub25Xcml0ZUVudHJ5Py4odGhpcyk7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IGhlYWRlcl9qc18xLkhlYWRlcih7XG4gICAgICAgICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyAmJiB0aGlzLmxpbmtwYXRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICAgICAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICAgICAgbXRpbWU6IHRoaXMubm9NdGltZSA/IHVuZGVmaW5lZCA6IHRoaXMubXRpbWUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMudW5hbWUsXG4gICAgICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuYXRpbWUsXG4gICAgICAgICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMuY3RpbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF0aFdhcm4pIHtcbiAgICAgICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cGF0aFdhcm59IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgICAgICAgICBlbnRyeTogdGhpcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoV2FybiArIHRoaXMucGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRlci5lbmNvZGUoKSAmJiAhdGhpcy5ub1BheCkge1xuICAgICAgICAgICAgc3VwZXIud3JpdGUobmV3IHBheF9qc18xLlBheCh7XG4gICAgICAgICAgICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmF0aW1lLFxuICAgICAgICAgICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy5jdGltZSxcbiAgICAgICAgICAgICAgICBnaWQ6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLmdpZCxcbiAgICAgICAgICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gdW5kZWZpbmVkIDogdGhpcy5tdGltZSxcbiAgICAgICAgICAgICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgICAgICAgICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgJiYgdGhpcy5saW5rcGF0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgICAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gdW5kZWZpbmVkIDogdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnVuYW1lLFxuICAgICAgICAgICAgICAgIGRldjogdGhpcy5wb3J0YWJsZSA/IHVuZGVmaW5lZCA6IHRoaXMucmVhZEVudHJ5LmRldixcbiAgICAgICAgICAgICAgICBpbm86IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnJlYWRFbnRyeS5pbm8sXG4gICAgICAgICAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyB1bmRlZmluZWQgOiB0aGlzLnJlYWRFbnRyeS5ubGluayxcbiAgICAgICAgICAgIH0pLmVuY29kZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiID0gdGhpcy5oZWFkZXI/LmJsb2NrO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZW5jb2RlIGhlYWRlcicpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBzdXBlci53cml0ZShiKTtcbiAgICAgICAgcmVhZEVudHJ5LnBpcGUodGhpcyk7XG4gICAgfVxuICAgIFtQUkVGSVhdKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpO1xuICAgIH1cbiAgICBbTU9ERV0obW9kZSkge1xuICAgICAgICByZXR1cm4gKDAsIG1vZGVfZml4X2pzXzEubW9kZUZpeCkobW9kZSwgdGhpcy50eXBlID09PSAnRGlyZWN0b3J5JywgdGhpcy5wb3J0YWJsZSk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0IC0ganVzdCBqdW5rIHRvIGNvbXBseSB3aXRoIE5vZGVKUy5Xcml0YWJsZVN0cmVhbSAqL1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgPyBlbmNvZGluZyA6ICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgY29uc3Qgd3JpdGVMZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2NrUmVtYWluIC09IHdyaXRlTGVuO1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmssIGNiKTtcbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgICAgIHN1cGVyLndyaXRlKEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrUmVtYWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0IC0ganVzdCBqdW5rIHRvIGNvbXBseSB3aXRoIE5vZGVKUy5Xcml0YWJsZVN0cmVhbSAqL1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGNodW5rO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjaHVuayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nID8/ICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgdGhpcy5vbmNlKCdmaW5pc2gnLCBjYik7XG4gICAgICAgIGNodW5rID8gc3VwZXIuZW5kKGNodW5rLCBjYikgOiBzdXBlci5lbmQoY2IpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLldyaXRlRW50cnlUYXIgPSBXcml0ZUVudHJ5VGFyO1xuY29uc3QgZ2V0VHlwZSA9IChzdGF0KSA9PiBzdGF0LmlzRmlsZSgpID8gJ0ZpbGUnXG4gICAgOiBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRGlyZWN0b3J5J1xuICAgICAgICA6IHN0YXQuaXNTeW1ib2xpY0xpbmsoKSA/ICdTeW1ib2xpY0xpbmsnXG4gICAgICAgICAgICA6ICdVbnN1cHBvcnRlZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cml0ZS1lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/dist/commonjs/write-entry.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/chownr/dist/commonjs/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tar/node_modules/chownr/dist/commonjs/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chownrSync = exports.chownr = void 0;\nconst node_fs_1 = __importDefault(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst node_path_1 = __importDefault(__webpack_require__(/*! node:path */ \"node:path\"));\nconst lchownSync = (path, uid, gid) => {\n    try {\n        return node_fs_1.default.lchownSync(path, uid, gid);\n    }\n    catch (er) {\n        if (er?.code !== 'ENOENT')\n            throw er;\n    }\n};\nconst chown = (cpath, uid, gid, cb) => {\n    node_fs_1.default.lchown(cpath, uid, gid, er => {\n        // Skip ENOENT error\n        cb(er && er?.code !== 'ENOENT' ? er : null);\n    });\n};\nconst chownrKid = (p, child, uid, gid, cb) => {\n    if (child.isDirectory()) {\n        (0, exports.chownr)(node_path_1.default.resolve(p, child.name), uid, gid, (er) => {\n            if (er)\n                return cb(er);\n            const cpath = node_path_1.default.resolve(p, child.name);\n            chown(cpath, uid, gid, cb);\n        });\n    }\n    else {\n        const cpath = node_path_1.default.resolve(p, child.name);\n        chown(cpath, uid, gid, cb);\n    }\n};\nconst chownr = (p, uid, gid, cb) => {\n    node_fs_1.default.readdir(p, { withFileTypes: true }, (er, children) => {\n        // any error other than ENOTDIR or ENOTSUP means it's not readable,\n        // or doesn't exist.  give up.\n        if (er) {\n            if (er.code === 'ENOENT')\n                return cb();\n            else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n                return cb(er);\n        }\n        if (er || !children.length)\n            return chown(p, uid, gid, cb);\n        let len = children.length;\n        let errState = null;\n        const then = (er) => {\n            /* c8 ignore start */\n            if (errState)\n                return;\n            /* c8 ignore stop */\n            if (er)\n                return cb((errState = er));\n            if (--len === 0)\n                return chown(p, uid, gid, cb);\n        };\n        for (const child of children) {\n            chownrKid(p, child, uid, gid, then);\n        }\n    });\n};\nexports.chownr = chownr;\nconst chownrKidSync = (p, child, uid, gid) => {\n    if (child.isDirectory())\n        (0, exports.chownrSync)(node_path_1.default.resolve(p, child.name), uid, gid);\n    lchownSync(node_path_1.default.resolve(p, child.name), uid, gid);\n};\nconst chownrSync = (p, uid, gid) => {\n    let children;\n    try {\n        children = node_fs_1.default.readdirSync(p, { withFileTypes: true });\n    }\n    catch (er) {\n        const e = er;\n        if (e?.code === 'ENOENT')\n            return;\n        else if (e?.code === 'ENOTDIR' || e?.code === 'ENOTSUP')\n            return lchownSync(p, uid, gid);\n        else\n            throw e;\n    }\n    for (const child of children) {\n        chownrKidSync(p, child, uid, gid);\n    }\n    return lchownSync(p, uid, gid);\n};\nexports.chownrSync = chownrSync;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9jaG93bnIvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWM7QUFDbkMsa0NBQWtDLG1CQUFPLENBQUMsd0JBQVM7QUFDbkQsb0NBQW9DLG1CQUFPLENBQUMsNEJBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9jaG93bnIvZGlzdC9jb21tb25qcy9pbmRleC5qcz85ODg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaG93bnJTeW5jID0gZXhwb3J0cy5jaG93bnIgPSB2b2lkIDA7XG5jb25zdCBub2RlX2ZzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6ZnNcIikpO1xuY29uc3Qgbm9kZV9wYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6cGF0aFwiKSk7XG5jb25zdCBsY2hvd25TeW5jID0gKHBhdGgsIHVpZCwgZ2lkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5vZGVfZnNfMS5kZWZhdWx0LmxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKGVyPy5jb2RlICE9PSAnRU5PRU5UJylcbiAgICAgICAgICAgIHRocm93IGVyO1xuICAgIH1cbn07XG5jb25zdCBjaG93biA9IChjcGF0aCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gICAgbm9kZV9mc18xLmRlZmF1bHQubGNob3duKGNwYXRoLCB1aWQsIGdpZCwgZXIgPT4ge1xuICAgICAgICAvLyBTa2lwIEVOT0VOVCBlcnJvclxuICAgICAgICBjYihlciAmJiBlcj8uY29kZSAhPT0gJ0VOT0VOVCcgPyBlciA6IG51bGwpO1xuICAgIH0pO1xufTtcbmNvbnN0IGNob3ducktpZCA9IChwLCBjaGlsZCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gICAgaWYgKGNoaWxkLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMuY2hvd25yKShub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUocCwgY2hpbGQubmFtZSksIHVpZCwgZ2lkLCAoZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICAgICAgY29uc3QgY3BhdGggPSBub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUocCwgY2hpbGQubmFtZSk7XG4gICAgICAgICAgICBjaG93bihjcGF0aCwgdWlkLCBnaWQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjcGF0aCA9IG5vZGVfcGF0aF8xLmRlZmF1bHQucmVzb2x2ZShwLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgY2hvd24oY3BhdGgsIHVpZCwgZ2lkLCBjYik7XG4gICAgfVxufTtcbmNvbnN0IGNob3duciA9IChwLCB1aWQsIGdpZCwgY2IpID0+IHtcbiAgICBub2RlX2ZzXzEuZGVmYXVsdC5yZWFkZGlyKHAsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9LCAoZXIsIGNoaWxkcmVuKSA9PiB7XG4gICAgICAgIC8vIGFueSBlcnJvciBvdGhlciB0aGFuIEVOT1RESVIgb3IgRU5PVFNVUCBtZWFucyBpdCdzIG5vdCByZWFkYWJsZSxcbiAgICAgICAgLy8gb3IgZG9lc24ndCBleGlzdC4gIGdpdmUgdXAuXG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZXIuY29kZSAhPT0gJ0VOT1RESVInICYmIGVyLmNvZGUgIT09ICdFTk9UU1VQJylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlciB8fCAhY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGNob3duKHAsIHVpZCwgZ2lkLCBjYik7XG4gICAgICAgIGxldCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBlcnJTdGF0ZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRoZW4gPSAoZXIpID0+IHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGVyclN0YXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKChlcnJTdGF0ZSA9IGVyKSk7XG4gICAgICAgICAgICBpZiAoLS1sZW4gPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNob3duKHAsIHVpZCwgZ2lkLCBjYik7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNob3ducktpZChwLCBjaGlsZCwgdWlkLCBnaWQsIHRoZW4pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5jaG93bnIgPSBjaG93bnI7XG5jb25zdCBjaG93bnJLaWRTeW5jID0gKHAsIGNoaWxkLCB1aWQsIGdpZCkgPT4ge1xuICAgIGlmIChjaGlsZC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAoMCwgZXhwb3J0cy5jaG93bnJTeW5jKShub2RlX3BhdGhfMS5kZWZhdWx0LnJlc29sdmUocCwgY2hpbGQubmFtZSksIHVpZCwgZ2lkKTtcbiAgICBsY2hvd25TeW5jKG5vZGVfcGF0aF8xLmRlZmF1bHQucmVzb2x2ZShwLCBjaGlsZC5uYW1lKSwgdWlkLCBnaWQpO1xufTtcbmNvbnN0IGNob3duclN5bmMgPSAocCwgdWlkLCBnaWQpID0+IHtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgdHJ5IHtcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlX2ZzXzEuZGVmYXVsdC5yZWFkZGlyU3luYyhwLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcikge1xuICAgICAgICBjb25zdCBlID0gZXI7XG4gICAgICAgIGlmIChlPy5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZSBpZiAoZT8uY29kZSA9PT0gJ0VOT1RESVInIHx8IGU/LmNvZGUgPT09ICdFTk9UU1VQJylcbiAgICAgICAgICAgIHJldHVybiBsY2hvd25TeW5jKHAsIHVpZCwgZ2lkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjaG93bnJLaWRTeW5jKHAsIGNoaWxkLCB1aWQsIGdpZCk7XG4gICAgfVxuICAgIHJldHVybiBsY2hvd25TeW5jKHAsIHVpZCwgZ2lkKTtcbn07XG5leHBvcnRzLmNob3duclN5bmMgPSBjaG93bnJTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/chownr/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/minipass/dist/commonjs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tar/node_modules/minipass/dist/commonjs/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pcGFzcy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLHNDQUFzQyxtQkFBTyxDQUFDLGdDQUFhO0FBQzNELDhCQUE4QixtQkFBTyxDQUFDLGdEQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQXlDO0FBQ2pELFFBQVEsc0NBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLDhCQUE4QjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pcGFzcy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzP2EzYjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pbmlwYXNzID0gZXhwb3J0cy5pc1dyaXRhYmxlID0gZXhwb3J0cy5pc1JlYWRhYmxlID0gZXhwb3J0cy5pc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHByb2MgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gcHJvY2Vzc1xuICAgIDoge1xuICAgICAgICBzdGRvdXQ6IG51bGwsXG4gICAgICAgIHN0ZGVycjogbnVsbCxcbiAgICB9O1xuY29uc3Qgbm9kZV9ldmVudHNfMSA9IHJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKTtcbmNvbnN0IG5vZGVfc3RyZWFtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6c3RyZWFtXCIpKTtcbmNvbnN0IG5vZGVfc3RyaW5nX2RlY29kZXJfMSA9IHJlcXVpcmUoXCJub2RlOnN0cmluZ19kZWNvZGVyXCIpO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBNaW5pcGFzcyBzdHJlYW0sIE5vZGUgc3RyZWFtLCBvciBzb21ldGhpbmdcbiAqIGVsc2UgdGhhdCBNaW5pcGFzcyBjYW4gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgKHMgaW5zdGFuY2VvZiBNaW5pcGFzcyB8fFxuICAgICAgICBzIGluc3RhbmNlb2Ygbm9kZV9zdHJlYW1fMS5kZWZhdWx0IHx8XG4gICAgICAgICgwLCBleHBvcnRzLmlzUmVhZGFibGUpKHMpIHx8XG4gICAgICAgICgwLCBleHBvcnRzLmlzV3JpdGFibGUpKHMpKTtcbmV4cG9ydHMuaXNTdHJlYW0gPSBpc1N0cmVhbTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQge0BsaW5rIE1pbmlwYXNzLlJlYWRhYmxlfVxuICovXG5jb25zdCBpc1JlYWRhYmxlID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIHMgaW5zdGFuY2VvZiBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciAmJlxuICAgIHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBub2RlIGNvcmUgV3JpdGFibGUgc3RyZWFtcyBoYXZlIGEgcGlwZSgpIG1ldGhvZCwgYnV0IGl0IHRocm93c1xuICAgIHMucGlwZSAhPT0gbm9kZV9zdHJlYW1fMS5kZWZhdWx0LldyaXRhYmxlLnByb3RvdHlwZS5waXBlO1xuZXhwb3J0cy5pc1JlYWRhYmxlID0gaXNSZWFkYWJsZTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQge0BsaW5rIE1pbmlwYXNzLldyaXRhYmxlfVxuICovXG5jb25zdCBpc1dyaXRhYmxlID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIHMgaW5zdGFuY2VvZiBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciAmJlxuICAgIHR5cGVvZiBzLndyaXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1dyaXRhYmxlID0gaXNXcml0YWJsZTtcbmNvbnN0IEVPRiA9IFN5bWJvbCgnRU9GJyk7XG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJyk7XG5jb25zdCBFTUlUVEVEX0VORCA9IFN5bWJvbCgnZW1pdHRlZEVuZCcpO1xuY29uc3QgRU1JVFRJTkdfRU5EID0gU3ltYm9sKCdlbWl0dGluZ0VuZCcpO1xuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJyk7XG5jb25zdCBDTE9TRUQgPSBTeW1ib2woJ2Nsb3NlZCcpO1xuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpO1xuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJyk7XG5jb25zdCBGTFVTSENIVU5LID0gU3ltYm9sKCdmbHVzaENodW5rJyk7XG5jb25zdCBFTkNPRElORyA9IFN5bWJvbCgnZW5jb2RpbmcnKTtcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKTtcbmNvbnN0IEZMT1dJTkcgPSBTeW1ib2woJ2Zsb3dpbmcnKTtcbmNvbnN0IFBBVVNFRCA9IFN5bWJvbCgncGF1c2VkJyk7XG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpO1xuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKTtcbmNvbnN0IFBJUEVTID0gU3ltYm9sKCdwaXBlcycpO1xuY29uc3QgQlVGRkVSTEVOR1RIID0gU3ltYm9sKCdidWZmZXJMZW5ndGgnKTtcbmNvbnN0IEJVRkZFUlBVU0ggPSBTeW1ib2woJ2J1ZmZlclB1c2gnKTtcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpO1xuY29uc3QgT0JKRUNUTU9ERSA9IFN5bWJvbCgnb2JqZWN0TW9kZScpO1xuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaXMgZGVzdHJveWVkXG5jb25zdCBERVNUUk9ZRUQgPSBTeW1ib2woJ2Rlc3Ryb3llZCcpO1xuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaGFzIGFuIGVycm9yXG5jb25zdCBFUlJPUiA9IFN5bWJvbCgnZXJyb3InKTtcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpO1xuY29uc3QgRU1JVEVORCA9IFN5bWJvbCgnZW1pdEVuZCcpO1xuY29uc3QgRU1JVEVORDIgPSBTeW1ib2woJ2VtaXRFbmQyJyk7XG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKTtcbmNvbnN0IEFCT1JUID0gU3ltYm9sKCdhYm9ydCcpO1xuY29uc3QgQUJPUlRFRCA9IFN5bWJvbCgnYWJvcnRlZCcpO1xuY29uc3QgU0lHTkFMID0gU3ltYm9sKCdzaWduYWwnKTtcbmNvbnN0IERBVEFMSVNURU5FUlMgPSBTeW1ib2woJ2RhdGFMaXN0ZW5lcnMnKTtcbmNvbnN0IERJU0NBUkRFRCA9IFN5bWJvbCgnZGlzY2FyZGVkJyk7XG5jb25zdCBkZWZlciA9IChmbikgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbik7XG5jb25zdCBub2RlZmVyID0gKGZuKSA9PiBmbigpO1xuY29uc3QgaXNFbmRpc2ggPSAoZXYpID0+IGV2ID09PSAnZW5kJyB8fCBldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnO1xuY29uc3QgaXNBcnJheUJ1ZmZlckxpa2UgPSAoYikgPT4gYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKCEhYiAmJlxuICAgICAgICB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgYi5jb25zdHJ1Y3RvciAmJlxuICAgICAgICBiLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgICAgICAgYi5ieXRlTGVuZ3RoID49IDApO1xuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSAoYikgPT4gIUJ1ZmZlci5pc0J1ZmZlcihiKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYik7XG4vKipcbiAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHBpcGUgdG8gYSBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBpcGUge1xuICAgIHNyYztcbiAgICBkZXN0O1xuICAgIG9wdHM7XG4gICAgb25kcmFpbjtcbiAgICBjb25zdHJ1Y3RvcihzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuZGVzdCA9IGRlc3Q7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMub25kcmFpbiA9ICgpID0+IHNyY1tSRVNVTUVdKCk7XG4gICAgICAgIHRoaXMuZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pO1xuICAgIH1cbiAgICB1bnBpcGUoKSB7XG4gICAgICAgIHRoaXMuZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCB0aGlzLm9uZHJhaW4pO1xuICAgIH1cbiAgICAvLyBvbmx5IGhlcmUgZm9yIHRoZSBwcm90b3R5cGVcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBwcm94eUVycm9ycyhfZXIpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnVucGlwZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmVuZClcbiAgICAgICAgICAgIHRoaXMuZGVzdC5lbmQoKTtcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIHBpcGUgdG8gYSBkZXN0aW5hdGlvbiBzdHJlYW0gd2hlcmVcbiAqIGVycm9ycyBhcmUgcHJveGllZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gICAgdW5waXBlKCkge1xuICAgICAgICB0aGlzLnNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLnByb3h5RXJyb3JzKTtcbiAgICAgICAgc3VwZXIudW5waXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgICAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpO1xuICAgICAgICB0aGlzLnByb3h5RXJyb3JzID0gZXIgPT4gZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgc3JjLm9uKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpO1xuICAgIH1cbn1cbmNvbnN0IGlzT2JqZWN0TW9kZU9wdGlvbnMgPSAobykgPT4gISFvLm9iamVjdE1vZGU7XG5jb25zdCBpc0VuY29kaW5nT3B0aW9ucyA9IChvKSA9PiAhby5vYmplY3RNb2RlICYmICEhby5lbmNvZGluZyAmJiBvLmVuY29kaW5nICE9PSAnYnVmZmVyJztcbi8qKlxuICogTWFpbiBleHBvcnQsIHRoZSBNaW5pcGFzcyBjbGFzc1xuICpcbiAqIGBSVHlwZWAgaXMgdGhlIHR5cGUgb2YgZGF0YSBlbWl0dGVkLCBkZWZhdWx0cyB0byBCdWZmZXJcbiAqXG4gKiBgV1R5cGVgIGlzIHRoZSB0eXBlIG9mIGRhdGEgdG8gYmUgd3JpdHRlbiwgaWYgUlR5cGUgaXMgYnVmZmVyIG9yIHN0cmluZyxcbiAqIHRoZW4gYW55IHtAbGluayBNaW5pcGFzcy5Db250aWd1b3VzRGF0YX0gaXMgYWxsb3dlZC5cbiAqXG4gKiBgRXZlbnRzYCBpcyB0aGUgc2V0IG9mIGV2ZW50IGhhbmRsZXIgc2lnbmF0dXJlcyB0aGF0IHRoaXMgb2JqZWN0XG4gKiB3aWxsIGVtaXQsIHNlZSB7QGxpbmsgTWluaXBhc3MuRXZlbnRzfVxuICovXG5jbGFzcyBNaW5pcGFzcyBleHRlbmRzIG5vZGVfZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBbRkxPV0lOR10gPSBmYWxzZTtcbiAgICBbUEFVU0VEXSA9IGZhbHNlO1xuICAgIFtQSVBFU10gPSBbXTtcbiAgICBbQlVGRkVSXSA9IFtdO1xuICAgIFtPQkpFQ1RNT0RFXTtcbiAgICBbRU5DT0RJTkddO1xuICAgIFtBU1lOQ107XG4gICAgW0RFQ09ERVJdO1xuICAgIFtFT0ZdID0gZmFsc2U7XG4gICAgW0VNSVRURURfRU5EXSA9IGZhbHNlO1xuICAgIFtFTUlUVElOR19FTkRdID0gZmFsc2U7XG4gICAgW0NMT1NFRF0gPSBmYWxzZTtcbiAgICBbRU1JVFRFRF9FUlJPUl0gPSBudWxsO1xuICAgIFtCVUZGRVJMRU5HVEhdID0gMDtcbiAgICBbREVTVFJPWUVEXSA9IGZhbHNlO1xuICAgIFtTSUdOQUxdO1xuICAgIFtBQk9SVEVEXSA9IGZhbHNlO1xuICAgIFtEQVRBTElTVEVORVJTXSA9IDA7XG4gICAgW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gY2FuIGJlIHdyaXR0ZW5cbiAgICAgKi9cbiAgICB3cml0YWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGNhbiBiZSByZWFkXG4gICAgICovXG4gICAgcmVhZGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIElmIGBSVHlwZWAgaXMgQnVmZmVyLCB0aGVuIG9wdGlvbnMgZG8gbm90IG5lZWQgdG8gYmUgcHJvdmlkZWQuXG4gICAgICogT3RoZXJ3aXNlLCBhbiBvcHRpb25zIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkIHRvIHNwZWNpZnkgZWl0aGVyXG4gICAgICoge0BsaW5rIE1pbmlwYXNzLlNoYXJlZE9wdGlvbnMub2JqZWN0TW9kZX0gb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MuU2hhcmVkT3B0aW9ucy5lbmNvZGluZ30sIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IChhcmdzWzBdIHx8XG4gICAgICAgICAgICB7fSk7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChvcHRpb25zLm9iamVjdE1vZGUgJiYgdHlwZW9mIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGluZyBhbmQgb2JqZWN0TW9kZSBtYXkgbm90IGJlIHVzZWQgdG9nZXRoZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RNb2RlT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmNvZGluZ09wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0FTWU5DXSA9ICEhb3B0aW9ucy5hc3luYztcbiAgICAgICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICA/IG5ldyBub2RlX3N0cmluZ19kZWNvZGVyXzEuU3RyaW5nRGVjb2Rlcih0aGlzW0VOQ09ESU5HXSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy9AdHMtaWdub3JlIC0gcHJpdmF0ZSBvcHRpb24gZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlQnVmZmVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHsgZ2V0OiAoKSA9PiB0aGlzW0JVRkZFUl0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9AdHMtaWdub3JlIC0gcHJpdmF0ZSBvcHRpb24gZm9yIGRlYnVnZ2luZyBhbmQgdGVzdGluZ1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlUGlwZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGlwZXMnLCB7IGdldDogKCkgPT4gdGhpc1tQSVBFU10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXNbU0lHTkFMXSA9IHNpZ25hbDtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbQUJPUlRdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzW0FCT1JUXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIGRhdGEgc3RvcmVkIGluIHRoZSBidWZmZXIgd2FpdGluZyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogRm9yIEJ1ZmZlciBzdHJpbmdzLCB0aGlzIHdpbGwgYmUgdGhlIHRvdGFsIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEZvciBzdHJpbmcgZW5jb2Rpbmcgc3RyZWFtcywgdGhpcyB3aWxsIGJlIHRoZSBzdHJpbmcgY2hhcmFjdGVyIGxlbmd0aCxcbiAgICAgKiBhY2NvcmRpbmcgdG8gSmF2YVNjcmlwdCdzIGBzdHJpbmcubGVuZ3RoYCBsb2dpYy5cbiAgICAgKiBGb3Igb2JqZWN0TW9kZSBzdHJlYW1zLCB0aGlzIGlzIGEgY291bnQgb2YgdGhlIGl0ZW1zIHdhaXRpbmcgdG8gYmVcbiAgICAgKiBlbWl0dGVkLlxuICAgICAqL1xuICAgIGdldCBidWZmZXJMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0JVRkZFUkxFTkdUSF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgQnVmZmVyRW5jb2RpbmdgIGN1cnJlbnRseSBpbiB1c2UsIG9yIGBudWxsYFxuICAgICAqL1xuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRU5DT0RJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIFRoaXMgaXMgYSByZWFkIG9ubHkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzZXQgZW5jb2RpbmcoX2VuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCAtIEVuY29kaW5nIG1heSBvbmx5IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgICAgKi9cbiAgICBzZXRFbmNvZGluZyhfZW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jb2RpbmcgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBhbiBvYmplY3RNb2RlIHN0cmVhbVxuICAgICAqL1xuICAgIGdldCBvYmplY3RNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUaGlzIGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0IG9iamVjdE1vZGUoX29tKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb2JqZWN0TW9kZSBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGlzIGlzIGFuIGFzeW5jIHN0cmVhbVxuICAgICAqL1xuICAgIGdldCBbJ2FzeW5jJ10oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0FTWU5DXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFrZSB0aGlzIHN0cmVhbSBhc3luYy5cbiAgICAgKlxuICAgICAqIE9uY2Ugc2V0LCBpdCBjYW5ub3QgYmUgdW5zZXQsIGFzIHRoaXMgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgaW5jb3JyZWN0XG4gICAgICogYmVoYXZpb3IuICBJZSwgYSBzeW5jIHN0cmVhbSBjYW4gYmUgbWFkZSBhc3luYywgYnV0IGFuIGFzeW5jIHN0cmVhbVxuICAgICAqIGNhbm5vdCBiZSBzYWZlbHkgbWFkZSBzeW5jLlxuICAgICAqL1xuICAgIHNldCBbJ2FzeW5jJ10oYSkge1xuICAgICAgICB0aGlzW0FTWU5DXSA9IHRoaXNbQVNZTkNdIHx8ICEhYTtcbiAgICB9XG4gICAgLy8gZHJvcCBldmVyeXRoaW5nIGFuZCBnZXQgb3V0IG9mIHRoZSBmbG93IGNvbXBsZXRlbHlcbiAgICBbQUJPUlRdKCkge1xuICAgICAgICB0aGlzW0FCT1JURURdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdhYm9ydCcsIHRoaXNbU0lHTkFMXT8ucmVhc29uKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KHRoaXNbU0lHTkFMXT8ucmVhc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgc3RyZWFtIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0FCT1JURURdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOby1vcCBzZXR0ZXIuIFN0cmVhbSBhYm9ydGVkIHN0YXR1cyBpcyBzZXQgdmlhIHRoZSBBYm9ydFNpZ25hbCBwcm92aWRlZFxuICAgICAqIGluIHRoZSBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqL1xuICAgIHNldCBhYm9ydGVkKF8pIHsgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgaWYgKHRoaXNbQUJPUlRFRF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHdyaXRlIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSwgeyBjb2RlOiAnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVuY29kaW5nKVxuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIGNvbnN0IGZuID0gdGhpc1tBU1lOQ10gPyBkZWZlciA6IG5vZGVmZXI7XG4gICAgICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgICAgIC8vIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gZG8gdGhlIG9wcG9zaXRlIVxuICAgICAgICAvLyBsZWF2ZSBzdHJpbmdzIGFuZCBidWZmZXJzIGFzLWlzXG4gICAgICAgIC8vIGFueXRoaW5nIGlzIG9ubHkgYWxsb3dlZCBpZiBpbiBvYmplY3QgbW9kZSwgc28gdGhyb3dcbiAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlckxpa2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29udGlndW91cyBkYXRhIHdyaXR0ZW4gdG8gbm9uLW9iamVjdE1vZGUgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIG9iamVjdCBtb2RlIHVwIGZyb250LCBzaW5jZSBpdCdzIHNpbXBsZXJcbiAgICAgICAgLy8gdGhpcyB5aWVsZHMgYmV0dGVyIHBlcmZvcm1hbmNlLCBmZXdlciBjaGVja3MgbGF0ZXIuXG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICAvLyBtYXliZSBpbXBvc3NpYmxlP1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpc1tGTFVTSF0odHJ1ZSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10pXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspO1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgY2h1bmsgaXMgYSBidWZmZXIgb3Igc3RyaW5nXG4gICAgICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKTtcbiAgICAgICAgICAgIGlmIChjYilcbiAgICAgICAgICAgICAgICBmbihjYik7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgICAgICAvLyBhbiBlbXB0eSBidWZmZXIsIHNraXBwaW5nIHRoZSBidWZmZXIvZGVjb2RlciBkYW5jZVxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAgICAgIShlbmNvZGluZyA9PT0gdGhpc1tFTkNPRElOR10gJiYgIXRoaXNbREVDT0RFUl0/Lmxhc3ROZWVkKSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5nZVxuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmUgLSBzaW5mdWwgdW5zYWZlIHR5cGUgY2hhbmdlXG4gICAgICAgICAgICBjaHVuayA9IHRoaXNbREVDT0RFUl0ud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGZsdXNoaW5nIENBTiBwb3RlbnRpYWxseSBzd2l0Y2ggdXMgaW50byBub3QtZmxvd2luZyBtb2RlXG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgIHRoaXNbRkxVU0hdKHRydWUpO1xuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuayk7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvdy1sZXZlbCBleHBsaWNpdCByZWFkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEluIG9iamVjdE1vZGUsIHRoZSBhcmd1bWVudCBpcyBpZ25vcmVkLCBhbmQgb25lIGl0ZW0gaXMgcmV0dXJuZWQgaWZcbiAgICAgKiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBgbmAgaXMgdGhlIG51bWJlciBvZiBieXRlcyAob3IgaW4gdGhlIGNhc2Ugb2YgZW5jb2Rpbmcgc3RyZWFtcyxcbiAgICAgKiBjaGFyYWN0ZXJzKSB0byBjb25zdW1lLiBJZiBgbmAgaXMgbm90IHByb3ZpZGVkLCB0aGVuIHRoZSBlbnRpcmUgYnVmZmVyXG4gICAgICogaXMgcmV0dXJuZWQsIG9yIGBudWxsYCBpcyByZXR1cm5lZCBpZiBubyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIElmIGBuYCBpcyBncmVhdGVyIHRoYXQgdGhlIGFtb3VudCBvZiBkYXRhIGluIHRoZSBpbnRlcm5hbCBidWZmZXIsXG4gICAgICogdGhlbiBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgcmVhZChuKSB7XG4gICAgICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gPT09IDAgfHxcbiAgICAgICAgICAgIG4gPT09IDAgfHxcbiAgICAgICAgICAgIChuICYmIG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pKSB7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGggPiAxICYmICF0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgICAgICAvLyBub3Qgb2JqZWN0IG1vZGUsIHNvIGlmIHdlIGhhdmUgYW4gZW5jb2RpbmcsIHRoZW4gUlR5cGUgaXMgc3RyaW5nXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIG11c3QgYmUgQnVmZmVyXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0gPSBbXG4gICAgICAgICAgICAgICAgKHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICAgICAgICAgID8gdGhpc1tCVUZGRVJdLmpvaW4oJycpXG4gICAgICAgICAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzW0JVRkZFUl0sIHRoaXNbQlVGRkVSTEVOR1RIXSkpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpc1tCVUZGRVJdWzBdKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW1JFQURdKG4sIGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2h1bms7XG4gICAgICAgICAgICBpZiAobiA9PT0gYy5sZW5ndGggfHwgbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUlNISUZUXSgpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdWzBdID0gYy5zbGljZShuKTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGMuc2xpY2UoMCwgbik7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUl1bMF0gPSBjLnN1YmFycmF5KG4pO1xuICAgICAgICAgICAgICAgIGNodW5rID0gYy5zdWJhcnJheSgwLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGlmICghdGhpc1tCVUZGRVJdLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGVuZChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gY2h1bms7XG4gICAgICAgICAgICBjaHVuayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIHRoaXMub25jZSgnZW5kJywgY2IpO1xuICAgICAgICB0aGlzW0VPRl0gPSB0cnVlO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbnl0aGluZywgdGhlbiBnbyBhaGVhZCBhbmQgZW1pdCxcbiAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAgICAgLy8gd2UnbGwgcmUtZW1pdCBpZiBhIG5ldyAnZW5kJyBsaXN0ZW5lciBpcyBhZGRlZCBhbnl3YXkuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgTVAgbW9yZSBzdWl0YWJsZSB0byB3cml0ZS1vbmx5IHVzZSBjYXNlcy5cbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gfHwgIXRoaXNbUEFVU0VEXSlcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICAgIFtSRVNVTUVdKCkge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXNbREFUQUxJU1RFTkVSU10gJiYgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpc1tESVNDQVJERURdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tGTE9XSU5HXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpc1tGTFVTSF0oKTtcbiAgICAgICAgZWxzZSBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIHN0cmVhbSBpZiBpdCBpcyBjdXJyZW50bHkgaW4gYSBwYXVzZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIElmIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyBvciBgZGF0YWAgZXZlbnQgbGlzdGVuZXJzLFxuICAgICAqIHRoaXMgd2lsbCBwbGFjZSB0aGUgc3RyZWFtIGluIGEgXCJkaXNjYXJkZWRcIiBzdGF0ZSwgd2hlcmUgYWxsIGRhdGEgd2lsbFxuICAgICAqIGJlIHRocm93biBhd2F5LiBUaGUgZGlzY2FyZGVkIHN0YXRlIGlzIHJlbW92ZWQgaWYgYSBwaXBlIGRlc3RpbmF0aW9uIG9yXG4gICAgICogZGF0YSBoYW5kbGVyIGlzIGFkZGVkLCBpZiBwYXVzZSgpIGlzIGNhbGxlZCwgb3IgaWYgYW55IHN5bmNocm9ub3VzIG9yXG4gICAgICogYXN5bmNocm9ub3VzIGl0ZXJhdGlvbiBpcyBzdGFydGVkLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tQQVVTRURdID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBmb3JjaWJseSBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tERVNUUk9ZRURdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGluIGEgZmxvd2luZyBzdGF0ZSwgbWVhbmluZyB0aGF0XG4gICAgICogYW55IHdyaXRlcyB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQuXG4gICAgICovXG4gICAgZ2V0IGZsb3dpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGluIGEgcGF1c2VkIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbUEFVU0VEXTtcbiAgICB9XG4gICAgW0JVRkZFUlBVU0hdKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXNbQlVGRkVSXS5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgW0JVRkZFUlNISUZUXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IHRoaXNbQlVGRkVSXVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzW0JVRkZFUl0uc2hpZnQoKTtcbiAgICB9XG4gICAgW0ZMVVNIXShub0RyYWluID0gZmFsc2UpIHtcbiAgICAgICAgZG8geyB9IHdoaWxlICh0aGlzW0ZMVVNIQ0hVTktdKHRoaXNbQlVGRkVSU0hJRlRdKCkpICYmXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFub0RyYWluICYmICF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgfVxuICAgIFtGTFVTSENIVU5LXShjaHVuaykge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaXBlIGFsbCBkYXRhIGVtaXR0ZWQgYnkgdGhpcyBzdHJlYW0gaW50byB0aGUgZGVzdGluYXRpb24gcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyB0aGUgZmxvdyBvZiBkYXRhLlxuICAgICAqL1xuICAgIHBpcGUoZGVzdCwgb3B0cykge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgaWYgKGRlc3QgPT09IHByb2Muc3Rkb3V0IHx8IGRlc3QgPT09IHByb2Muc3RkZXJyKVxuICAgICAgICAgICAgb3B0cy5lbmQgPSBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2U7XG4gICAgICAgIG9wdHMucHJveHlFcnJvcnMgPSAhIW9wdHMucHJveHlFcnJvcnM7XG4gICAgICAgIC8vIHBpcGluZyBhbiBlbmRlZCBzdHJlYW0gZW5kcyBpbW1lZGlhdGVseVxuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgICAgICAgICBkZXN0LmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJhc1wiIGhlcmUganVzdCBpZ25vcmVzIHRoZSBXVHlwZSwgd2hpY2ggcGlwZXMgZG9uJ3QgY2FyZSBhYm91dCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkncmUgb25seSBjb25zdW1pbmcgZnJvbSB1cywgYW5kIHdyaXRpbmcgdG8gdGhlIGRlc3RcbiAgICAgICAgICAgIHRoaXNbUElQRVNdLnB1c2goIW9wdHMucHJveHlFcnJvcnNcbiAgICAgICAgICAgICAgICA/IG5ldyBQaXBlKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICAgICAgICAgICAgOiBuZXcgUGlwZVByb3h5RXJyb3JzKHRoaXMsIGRlc3QsIG9wdHMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgICAgICAgICBkZWZlcigoKSA9PiB0aGlzW1JFU1VNRV0oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tSRVNVTUVdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bGx5IHVuaG9vayBhIHBpcGVkIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0gd2FzIHRoZSBvbmx5IGNvbnN1bWVyIG9mIHRoaXMgc3RyZWFtIChpZSxcbiAgICAgKiB0aGVyZSBhcmUgbm8gb3RoZXIgcGlwZWQgZGVzdGluYXRpb25zIG9yIGAnZGF0YSdgIGV2ZW50IGxpc3RlbmVycylcbiAgICAgKiB0aGVuIHRoZSBmbG93IG9mIGRhdGEgd2lsbCBzdG9wIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MjcmVzdW1lfSBpcyBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKi9cbiAgICB1bnBpcGUoZGVzdCkge1xuICAgICAgICBjb25zdCBwID0gdGhpc1tQSVBFU10uZmluZChwID0+IHAuZGVzdCA9PT0gZGVzdCk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tQSVBFU10ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tEQVRBTElTVEVORVJTXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbUElQRVNdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpc1tQSVBFU10uc3BsaWNlKHRoaXNbUElQRVNdLmluZGV4T2YocCksIDEpO1xuICAgICAgICAgICAgcC51bnBpcGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE1pbmlwYXNzI29ufVxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLm9uYCwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgICogYmVoYXZpb3IgZGlmZmVyZW5jZXMgdG8gcHJldmVudCBkYXRhIGxvc3MgYW5kIHVubmVjZXNzYXJ5IGhhbmdzOlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYSAnZGF0YScgZXZlbnQgaGFuZGxlciB3aWxsIHRyaWdnZXIgdGhlIGZsb3cgb2YgZGF0YVxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGhhbmRsZXIgd2hlbiB0aGVyZSBpcyBkYXRhIHdhaXRpbmcgdG8gYmUgcmVhZFxuICAgICAqICAgd2lsbCBjYXVzZSAncmVhZGFibGUnIHRvIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiAtIEFkZGluZyBhbiAnZW5kaXNoJyBldmVudCBoYW5kbGVyICgnZW5kJywgJ2ZpbmlzaCcsIGV0Yy4pIHdoaWNoIGhhc1xuICAgICAqICAgYWxyZWFkeSBwYXNzZWQgd2lsbCBjYXVzZSB0aGUgZXZlbnQgdG8gYmUgZW1pdHRlZCBpbW1lZGlhdGVseSBhbmQgYWxsXG4gICAgICogICBoYW5kbGVycyByZW1vdmVkLlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYW4gJ2Vycm9yJyBldmVudCBoYW5kbGVyIGFmdGVyIGFuIGVycm9yIGhhcyBiZWVuIGVtaXR0ZWQgd2lsbFxuICAgICAqICAgY2F1c2UgdGhlIGV2ZW50IHRvIGJlIHJlLWVtaXR0ZWQgaW1tZWRpYXRlbHkgd2l0aCB0aGUgZXJyb3IgcHJldmlvdXNseVxuICAgICAqICAgcmFpc2VkLlxuICAgICAqL1xuICAgIG9uKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9uKGV2LCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSsrO1xuICAgICAgICAgICAgaWYgKCF0aGlzW1BJUEVTXS5sZW5ndGggJiYgIXRoaXNbRkxPV0lOR10pIHtcbiAgICAgICAgICAgICAgICB0aGlzW1JFU1VNRV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApIHtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmRpc2goZXYpICYmIHRoaXNbRU1JVFRFRF9FTkRdKSB7XG4gICAgICAgICAgICBzdXBlci5lbWl0KGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Vycm9yJyAmJiB0aGlzW0VNSVRURURfRVJST1JdKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gaGFuZGxlcjtcbiAgICAgICAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgICAgICAgICBkZWZlcigoKSA9PiBoLmNhbGwodGhpcywgdGhpc1tFTUlUVEVEX0VSUk9SXSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGguY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE1pbmlwYXNzI29mZn1cbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcihldiwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXYsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIub2ZmYFxuICAgICAqXG4gICAgICogSWYgYSAnZGF0YScgZXZlbnQgaGFuZGxlciBpcyByZW1vdmVkLCBhbmQgaXQgd2FzIHRoZSBsYXN0IGNvbnN1bWVyXG4gICAgICogKGllLCB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMgb3Igb3RoZXIgJ2RhdGEnIGV2ZW50IGxpc3RlbmVycyksXG4gICAgICogdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcCB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICovXG4gICAgb2ZmKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9mZihldiwgaGFuZGxlcik7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGxpc3RlbmVycywgYW5kIG5vdyB3ZSBkb24ndCwgYW5kIHdlIGRvbid0XG4gICAgICAgIC8vIGhhdmUgYW55IHBpcGVzLCB0aGVuIHN0b3AgdGhlIGZsb3csIHVubGVzcyBpdCdzIGJlZW4gZXhwbGljaXRseVxuICAgICAgICAvLyBwdXQgaW4gYSBkaXNjYXJkZWQgZmxvd2luZyBzdGF0ZSB2aWEgc3RyZWFtLnJlc3VtZSgpLlxuICAgICAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSA9IHRoaXMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXNbREFUQUxJU1RFTkVSU10gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhdGhpc1tESVNDQVJERURdICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzYFxuICAgICAqXG4gICAgICogSWYgYWxsICdkYXRhJyBldmVudCBoYW5kbGVycyBhcmUgcmVtb3ZlZCwgYW5kIHRoZXkgd2VyZSB0aGUgbGFzdCBjb25zdW1lclxuICAgICAqIChpZSwgdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zKSwgdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcFxuICAgICAqIHVudGlsIHRoZXJlIGlzIGFub3RoZXIgY29uc3VtZXIgb3Ige0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseVxuICAgICAqIGNhbGxlZC5cbiAgICAgKi9cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXYpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpc1tEQVRBTElTVEVORVJTXSA9IDA7XG4gICAgICAgICAgICBpZiAoIXRoaXNbRElTQ0FSREVEXSAmJiAhdGhpc1tQSVBFU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlICdlbmQnIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWRcbiAgICAgKi9cbiAgICBnZXQgZW1pdHRlZEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdO1xuICAgIH1cbiAgICBbTUFZQkVfRU1JVF9FTkRdKCkge1xuICAgICAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAgICAgIXRoaXNbRU1JVFRFRF9FTkRdICYmXG4gICAgICAgICAgICAhdGhpc1tERVNUUk9ZRURdICYmXG4gICAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICB0aGlzW0VPRl0pIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5lbWl0YCwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgICogYmVoYXZpb3IgZGlmZmVyZW5jZXMgdG8gcHJldmVudCBkYXRhIGxvc3MgYW5kIHVubmVjZXNzYXJ5IGhhbmdzOlxuICAgICAqXG4gICAgICogSWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBkZXN0cm95ZWQsIGFuZCB0aGUgZXZlbnQgaXMgc29tZXRoaW5nIG90aGVyXG4gICAgICogdGhhbiAnY2xvc2UnIG9yICdlcnJvcicsIHRoZW4gYGZhbHNlYCBpcyByZXR1cm5lZCBhbmQgbm8gaGFuZGxlcnNcbiAgICAgKiBhcmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdlbmQnLCBhbmQgaGFzIGFscmVhZHkgYmVlbiBlbWl0dGVkLCB0aGVuIHRoZSBldmVudFxuICAgICAqIGlzIGlnbm9yZWQuIElmIHRoZSBzdHJlYW0gaXMgaW4gYSBwYXVzZWQgb3Igbm9uLWZsb3dpbmcgc3RhdGUsIHRoZW5cbiAgICAgKiB0aGUgZXZlbnQgd2lsbCBiZSBkZWZlcnJlZCB1bnRpbCBkYXRhIGZsb3cgcmVzdW1lcy4gSWYgdGhlIHN0cmVhbSBpc1xuICAgICAqIGFzeW5jLCB0aGVuIGhhbmRsZXJzIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBuZXh0IHRpY2sgcmF0aGVyIHRoYW5cbiAgICAgKiBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnY2xvc2UnLCBhbmQgJ2VuZCcgaGFzIG5vdCB5ZXQgYmVlbiBlbWl0dGVkLCB0aGVuXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgYWZ0ZXIgJ2VuZCcgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZXJyb3InLCBhbmQgYW4gQWJvcnRTaWduYWwgd2FzIHByb3ZpZGVkIGZvciB0aGUgc3RyZWFtLFxuICAgICAqIGFuZCB0aGVyZSBhcmUgbm8gbGlzdGVuZXJzLCB0aGVuIHRoZSBldmVudCBpcyBpZ25vcmVkLCBtYXRjaGluZyB0aGVcbiAgICAgKiBiZWhhdmlvciBvZiBub2RlIGNvcmUgc3RyZWFtcyBpbiB0aGUgcHJlc2Vuc2Ugb2YgYW4gQWJvcnRTaWduYWwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2ZpbmlzaCcgb3IgJ3ByZWZpbmlzaCcsIHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBlbWl0dGluZyB0aGUgZXZlbnQsIHRvIHByZXZlbnQgZG91YmxlLWZpcmluZy5cbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICAvLyBlcnJvciBhbmQgY2xvc2UgYXJlIG9ubHkgZXZlbnRzIGFsbG93ZWQgYWZ0ZXIgY2FsbGluZyBkZXN0cm95KClcbiAgICAgICAgaWYgKGV2ICE9PSAnZXJyb3InICYmXG4gICAgICAgICAgICBldiAhPT0gJ2Nsb3NlJyAmJlxuICAgICAgICAgICAgZXYgIT09IERFU1RST1lFRCAmJlxuICAgICAgICAgICAgdGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzW09CSkVDVE1PREVdICYmICFkYXRhXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpc1tBU1lOQ11cbiAgICAgICAgICAgICAgICAgICAgPyAoZGVmZXIoKCkgPT4gdGhpc1tFTUlUREFUQV0oZGF0YSkpLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRU1JVEVORF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgICAgdGhpc1tDTE9TRURdID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGRvbid0IGVtaXQgY2xvc2UgYmVmb3JlICdlbmQnIGFuZCAnZmluaXNoJ1xuICAgICAgICAgICAgaWYgKCF0aGlzW0VNSVRURURfRU5EXSAmJiAhdGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhO1xuICAgICAgICAgICAgc3VwZXIuZW1pdChFUlJPUiwgZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSAhdGhpc1tTSUdOQUxdIHx8IHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gc3VwZXIuZW1pdCgnZXJyb3InLCBkYXRhKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdmaW5pc2gnIHx8IGV2ID09PSAncHJlZmluaXNoJykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgb3RoZXIgdW5rbm93biBldmVudFxuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVREQVRBXShkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXNbRElTQ0FSREVEXSA/IGZhbHNlIDogc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBbRU1JVEVORF0oKSB7XG4gICAgICAgIGlmICh0aGlzW0VNSVRURURfRU5EXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpc1tFTUlUVEVEX0VORF0gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzW0FTWU5DXVxuICAgICAgICAgICAgPyAoZGVmZXIoKCkgPT4gdGhpc1tFTUlURU5EMl0oKSksIHRydWUpXG4gICAgICAgICAgICA6IHRoaXNbRU1JVEVORDJdKCk7XG4gICAgfVxuICAgIFtFTUlURU5EMl0oKSB7XG4gICAgICAgIGlmICh0aGlzW0RFQ09ERVJdKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpc1tERUNPREVSXS5lbmQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW0RJU0NBUkRFRF0pXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgIHAuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnZW5kJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGFsbCBlbWl0dGVkIGRhdGEgb25jZVxuICAgICAqIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb2xsZWN0KCkge1xuICAgICAgICBjb25zdCBidWYgPSBPYmplY3QuYXNzaWduKFtdLCB7XG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgYnVmLmRhdGFMZW5ndGggPSAwO1xuICAgICAgICAvLyBzZXQgdGhlIHByb21pc2UgZmlyc3QsIGluIGNhc2UgYW4gZXJyb3IgaXMgcmFpc2VkXG4gICAgICAgIC8vIGJ5IHRyaWdnZXJpbmcgdGhlIGZsb3cgaGVyZS5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpO1xuICAgICAgICB0aGlzLm9uKCdkYXRhJywgYyA9PiB7XG4gICAgICAgICAgICBidWYucHVzaChjKTtcbiAgICAgICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgICAgICBidWYuZGF0YUxlbmd0aCArPSBjLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHA7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZW1pdHRlZCBkYXRhXG4gICAgICogb25jZSB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICpcbiAgICAgKiBOb3QgYWxsb3dlZCBvbiBvYmplY3RNb2RlIHN0cmVhbXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uY2F0KCkge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBhd2FpdCB0aGlzLmNvbGxlY3QoKTtcbiAgICAgICAgcmV0dXJuICh0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgPyBidWYuam9pbignJylcbiAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdChidWYsIGJ1Zi5kYXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHZvaWQgUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uKERFU1RST1lFRCwgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHJlamVjdChlcikpO1xuICAgICAgICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91cyBgZm9yIGF3YWl0IG9mYCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgY29udGludWUgZW1pdHRpbmcgYWxsIGNodW5rcyB1bnRpbCB0aGUgc3RyZWFtIHRlcm1pbmF0ZXMuXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgLy8gc2V0IHRoaXMgdXAgZnJvbnQsIGluIGNhc2UgdGhlIGNvbnN1bWVyIGRvZXNuJ3QgY2FsbCBuZXh0KClcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChyZXMgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZTogcmVzIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgbGV0IHJlc29sdmU7XG4gICAgICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICAgICAgY29uc3Qgb25lcnIgPSAoZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25kYXRhID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6ICEhdGhpc1tFT0ZdIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmRlc3Ryb3kgPSAoKSA9PiBvbmVycihuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25lcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZSgnZGF0YScsIG9uZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB0aHJvdzogc3RvcCxcbiAgICAgICAgICAgIHJldHVybjogc3RvcCxcbiAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyBgZm9yIG9mYCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0aW9uIHdpbGwgdGVybWluYXRlIHdoZW4gdGhlIGludGVybmFsIGJ1ZmZlciBydW5zIG91dCwgZXZlblxuICAgICAqIGlmIHRoZSBzdHJlYW0gaGFzIG5vdCB5ZXQgdGVybWluYXRlZC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgLy8gc2V0IHRoaXMgdXAgZnJvbnQsIGluIGNhc2UgdGhlIGNvbnN1bWVyIGRvZXNuJ3QgY2FsbCBuZXh0KClcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cbiAgICAgICAgdGhpc1tESVNDQVJERURdID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLm9mZihFUlJPUiwgc3RvcCk7XG4gICAgICAgICAgICB0aGlzLm9mZihERVNUUk9ZRUQsIHN0b3ApO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2VuZCcsIHN0b3ApO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHN0b3AoKSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgc3RvcCk7XG4gICAgICAgIHRoaXMub25jZShFUlJPUiwgc3RvcCk7XG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIHN0b3ApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIHRocm93OiBzdG9wLFxuICAgICAgICAgICAgcmV0dXJuOiBzdG9wLFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGEgc3RyZWFtLCBwcmV2ZW50aW5nIGl0IGZyb20gYmVpbmcgdXNlZCBmb3IgYW55IGZ1cnRoZXIgcHVycG9zZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzdHJlYW0gaGFzIGEgYGNsb3NlKClgIG1ldGhvZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBvblxuICAgICAqIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQWZ0ZXIgZGVzdHJ1Y3Rpb24sIGFueSBhdHRlbXB0IHRvIHdyaXRlIGRhdGEsIHJlYWQgZGF0YSwgb3IgZW1pdCBtb3N0XG4gICAgICogZXZlbnRzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIElmIGFuIGVycm9yIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgZW1pdHRlZCBpbiBhblxuICAgICAqICdlcnJvcicgZXZlbnQuXG4gICAgICovXG4gICAgZGVzdHJveShlcikge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbREVTVFJPWUVEXSA9IHRydWU7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IHRydWU7XG4gICAgICAgIC8vIHRocm93IGF3YXkgYWxsIGJ1ZmZlcmVkIGRhdGEsIGl0J3MgbmV2ZXIgY29taW5nIG91dFxuICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMDtcbiAgICAgICAgY29uc3Qgd2MgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHdjLmNsb3NlID09PSAnZnVuY3Rpb24nICYmICF0aGlzW0NMT1NFRF0pXG4gICAgICAgICAgICB3Yy5jbG9zZSgpO1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgaXNTdHJlYW19XG4gICAgICpcbiAgICAgKiBGb3JtZXIgZXhwb3J0IGxvY2F0aW9uLCBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpc1N0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNTdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5NaW5pcGFzcyA9IE1pbmlwYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/minipass/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/minizlib/dist/commonjs/constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tar/node_modules/minizlib/dist/commonjs/constants.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.constants = void 0;\n// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst zlib_1 = __importDefault(__webpack_require__(/*! zlib */ \"zlib\"));\n/* c8 ignore start */\nconst realZlibConstants = zlib_1.default.constants || { ZLIB_VERNUM: 4736 };\n/* c8 ignore stop */\nexports.constants = Object.freeze(Object.assign(Object.create(null), {\n    Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    Z_MEM_ERROR: -4,\n    Z_BUF_ERROR: -5,\n    Z_VERSION_ERROR: -6,\n    Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    DEFLATE: 1,\n    INFLATE: 2,\n    GZIP: 3,\n    GUNZIP: 4,\n    DEFLATERAW: 5,\n    INFLATERAW: 6,\n    UNZIP: 7,\n    BROTLI_DECODE: 8,\n    BROTLI_ENCODE: 9,\n    Z_MIN_WINDOWBITS: 8,\n    Z_MAX_WINDOWBITS: 15,\n    Z_DEFAULT_WINDOWBITS: 15,\n    Z_MIN_CHUNK: 64,\n    Z_MAX_CHUNK: Infinity,\n    Z_DEFAULT_CHUNK: 16384,\n    Z_MIN_MEMLEVEL: 1,\n    Z_MAX_MEMLEVEL: 9,\n    Z_DEFAULT_MEMLEVEL: 8,\n    Z_MIN_LEVEL: -1,\n    Z_MAX_LEVEL: 9,\n    Z_DEFAULT_LEVEL: -1,\n    BROTLI_OPERATION_PROCESS: 0,\n    BROTLI_OPERATION_FLUSH: 1,\n    BROTLI_OPERATION_FINISH: 2,\n    BROTLI_OPERATION_EMIT_METADATA: 3,\n    BROTLI_MODE_GENERIC: 0,\n    BROTLI_MODE_TEXT: 1,\n    BROTLI_MODE_FONT: 2,\n    BROTLI_DEFAULT_MODE: 0,\n    BROTLI_MIN_QUALITY: 0,\n    BROTLI_MAX_QUALITY: 11,\n    BROTLI_DEFAULT_QUALITY: 11,\n    BROTLI_MIN_WINDOW_BITS: 10,\n    BROTLI_MAX_WINDOW_BITS: 24,\n    BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n    BROTLI_DEFAULT_WINDOW: 22,\n    BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n    BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n    BROTLI_PARAM_MODE: 0,\n    BROTLI_PARAM_QUALITY: 1,\n    BROTLI_PARAM_LGWIN: 2,\n    BROTLI_PARAM_LGBLOCK: 3,\n    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n    BROTLI_PARAM_SIZE_HINT: 5,\n    BROTLI_PARAM_LARGE_WINDOW: 6,\n    BROTLI_PARAM_NPOSTFIX: 7,\n    BROTLI_PARAM_NDIRECT: 8,\n    BROTLI_DECODER_RESULT_ERROR: 0,\n    BROTLI_DECODER_RESULT_SUCCESS: 1,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n    BROTLI_DECODER_NO_ERROR: 0,\n    BROTLI_DECODER_SUCCESS: 1,\n    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n    BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pemxpYi9kaXN0L2NvbW1vbmpzL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pemxpYi9kaXN0L2NvbW1vbmpzL2NvbnN0YW50cy5qcz8yZDE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25zdGFudHMgPSB2b2lkIDA7XG4vLyBVcGRhdGUgd2l0aCBhbnkgemxpYiBjb25zdGFudHMgdGhhdCBhcmUgYWRkZWQgb3IgY2hhbmdlZCBpbiB0aGUgZnV0dXJlLlxuLy8gTm9kZSB2NiBkaWRuJ3QgZXhwb3J0IHRoaXMsIHNvIHdlIGp1c3QgaGFyZCBjb2RlIHRoZSB2ZXJzaW9uIGFuZCByZWx5XG4vLyBvbiBhbGwgdGhlIG90aGVyIGhhcmQtY29kZWQgdmFsdWVzIGZyb20gemxpYiB2NDczNi4gIFdoZW4gbm9kZSB2NlxuLy8gc3VwcG9ydCBkcm9wcywgd2UgY2FuIGp1c3QgZXhwb3J0IHRoZSByZWFsWmxpYkNvbnN0YW50cyBvYmplY3QuXG5jb25zdCB6bGliXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInpsaWJcIikpO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCByZWFsWmxpYkNvbnN0YW50cyA9IHpsaWJfMS5kZWZhdWx0LmNvbnN0YW50cyB8fCB7IFpMSUJfVkVSTlVNOiA0NzM2IH07XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0cy5jb25zdGFudHMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgIFpfTk9fRkxVU0g6IDAsXG4gICAgWl9QQVJUSUFMX0ZMVVNIOiAxLFxuICAgIFpfU1lOQ19GTFVTSDogMixcbiAgICBaX0ZVTExfRkxVU0g6IDMsXG4gICAgWl9GSU5JU0g6IDQsXG4gICAgWl9CTE9DSzogNSxcbiAgICBaX09LOiAwLFxuICAgIFpfU1RSRUFNX0VORDogMSxcbiAgICBaX05FRURfRElDVDogMixcbiAgICBaX0VSUk5POiAtMSxcbiAgICBaX1NUUkVBTV9FUlJPUjogLTIsXG4gICAgWl9EQVRBX0VSUk9SOiAtMyxcbiAgICBaX01FTV9FUlJPUjogLTQsXG4gICAgWl9CVUZfRVJST1I6IC01LFxuICAgIFpfVkVSU0lPTl9FUlJPUjogLTYsXG4gICAgWl9OT19DT01QUkVTU0lPTjogMCxcbiAgICBaX0JFU1RfU1BFRUQ6IDEsXG4gICAgWl9CRVNUX0NPTVBSRVNTSU9OOiA5LFxuICAgIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsXG4gICAgWl9GSUxURVJFRDogMSxcbiAgICBaX0hVRkZNQU5fT05MWTogMixcbiAgICBaX1JMRTogMyxcbiAgICBaX0ZJWEVEOiA0LFxuICAgIFpfREVGQVVMVF9TVFJBVEVHWTogMCxcbiAgICBERUZMQVRFOiAxLFxuICAgIElORkxBVEU6IDIsXG4gICAgR1pJUDogMyxcbiAgICBHVU5aSVA6IDQsXG4gICAgREVGTEFURVJBVzogNSxcbiAgICBJTkZMQVRFUkFXOiA2LFxuICAgIFVOWklQOiA3LFxuICAgIEJST1RMSV9ERUNPREU6IDgsXG4gICAgQlJPVExJX0VOQ09ERTogOSxcbiAgICBaX01JTl9XSU5ET1dCSVRTOiA4LFxuICAgIFpfTUFYX1dJTkRPV0JJVFM6IDE1LFxuICAgIFpfREVGQVVMVF9XSU5ET1dCSVRTOiAxNSxcbiAgICBaX01JTl9DSFVOSzogNjQsXG4gICAgWl9NQVhfQ0hVTks6IEluZmluaXR5LFxuICAgIFpfREVGQVVMVF9DSFVOSzogMTYzODQsXG4gICAgWl9NSU5fTUVNTEVWRUw6IDEsXG4gICAgWl9NQVhfTUVNTEVWRUw6IDksXG4gICAgWl9ERUZBVUxUX01FTUxFVkVMOiA4LFxuICAgIFpfTUlOX0xFVkVMOiAtMSxcbiAgICBaX01BWF9MRVZFTDogOSxcbiAgICBaX0RFRkFVTFRfTEVWRUw6IC0xLFxuICAgIEJST1RMSV9PUEVSQVRJT05fUFJPQ0VTUzogMCxcbiAgICBCUk9UTElfT1BFUkFUSU9OX0ZMVVNIOiAxLFxuICAgIEJST1RMSV9PUEVSQVRJT05fRklOSVNIOiAyLFxuICAgIEJST1RMSV9PUEVSQVRJT05fRU1JVF9NRVRBREFUQTogMyxcbiAgICBCUk9UTElfTU9ERV9HRU5FUklDOiAwLFxuICAgIEJST1RMSV9NT0RFX1RFWFQ6IDEsXG4gICAgQlJPVExJX01PREVfRk9OVDogMixcbiAgICBCUk9UTElfREVGQVVMVF9NT0RFOiAwLFxuICAgIEJST1RMSV9NSU5fUVVBTElUWTogMCxcbiAgICBCUk9UTElfTUFYX1FVQUxJVFk6IDExLFxuICAgIEJST1RMSV9ERUZBVUxUX1FVQUxJVFk6IDExLFxuICAgIEJST1RMSV9NSU5fV0lORE9XX0JJVFM6IDEwLFxuICAgIEJST1RMSV9NQVhfV0lORE9XX0JJVFM6IDI0LFxuICAgIEJST1RMSV9MQVJHRV9NQVhfV0lORE9XX0JJVFM6IDMwLFxuICAgIEJST1RMSV9ERUZBVUxUX1dJTkRPVzogMjIsXG4gICAgQlJPVExJX01JTl9JTlBVVF9CTE9DS19CSVRTOiAxNixcbiAgICBCUk9UTElfTUFYX0lOUFVUX0JMT0NLX0JJVFM6IDI0LFxuICAgIEJST1RMSV9QQVJBTV9NT0RFOiAwLFxuICAgIEJST1RMSV9QQVJBTV9RVUFMSVRZOiAxLFxuICAgIEJST1RMSV9QQVJBTV9MR1dJTjogMixcbiAgICBCUk9UTElfUEFSQU1fTEdCTE9DSzogMyxcbiAgICBCUk9UTElfUEFSQU1fRElTQUJMRV9MSVRFUkFMX0NPTlRFWFRfTU9ERUxJTkc6IDQsXG4gICAgQlJPVExJX1BBUkFNX1NJWkVfSElOVDogNSxcbiAgICBCUk9UTElfUEFSQU1fTEFSR0VfV0lORE9XOiA2LFxuICAgIEJST1RMSV9QQVJBTV9OUE9TVEZJWDogNyxcbiAgICBCUk9UTElfUEFSQU1fTkRJUkVDVDogOCxcbiAgICBCUk9UTElfREVDT0RFUl9SRVNVTFRfRVJST1I6IDAsXG4gICAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX1NVQ0NFU1M6IDEsXG4gICAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gICAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICAgIEJST1RMSV9ERUNPREVSX1BBUkFNX0RJU0FCTEVfUklOR19CVUZGRVJfUkVBTExPQ0FUSU9OOiAwLFxuICAgIEJST1RMSV9ERUNPREVSX1BBUkFNX0xBUkdFX1dJTkRPVzogMSxcbiAgICBCUk9UTElfREVDT0RFUl9OT19FUlJPUjogMCxcbiAgICBCUk9UTElfREVDT0RFUl9TVUNDRVNTOiAxLFxuICAgIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gICAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9OSUJCTEU6IC0xLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9SRVNFUlZFRDogLTIsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9NRVRBX05JQkJMRTogLTMsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1NJTVBMRV9IVUZGTUFOX0FMUEhBQkVUOiAtNCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fU0FNRTogLTUsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NMX1NQQUNFOiAtNixcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfSFVGRk1BTl9TUEFDRTogLTcsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NPTlRFWFRfTUFQX1JFUEVBVDogLTgsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0JMT0NLX0xFTkdUSF8xOiAtOSxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzI6IC0xMCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfVFJBTlNGT1JNOiAtMTEsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJQ1RJT05BUlk6IC0xMixcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfV0lORE9XX0JJVFM6IC0xMyxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18xOiAtMTQsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1BBRERJTkdfMjogLTE1LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESVNUQU5DRTogLTE2LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0RJQ1RJT05BUllfTk9UX1NFVDogLTE5LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0lOVkFMSURfQVJHVU1FTlRTOiAtMjAsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NT0RFUzogLTIxLFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1RSRUVfR1JPVVBTOiAtMjIsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NQVA6IC0yNSxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8xOiAtMjYsXG4gICAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMjogLTI3LFxuICAgIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0JMT0NLX1RZUEVfVFJFRVM6IC0zMCxcbiAgICBCUk9UTElfREVDT0RFUl9FUlJPUl9VTlJFQUNIQUJMRTogLTMxLFxufSwgcmVhbFpsaWJDb25zdGFudHMpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/minizlib/dist/commonjs/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/minizlib/dist/commonjs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tar/node_modules/minizlib/dist/commonjs/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrotliDecompress = exports.BrotliCompress = exports.Brotli = exports.Unzip = exports.InflateRaw = exports.DeflateRaw = exports.Gunzip = exports.Gzip = exports.Inflate = exports.Deflate = exports.Zlib = exports.ZlibError = exports.constants = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst minipass_1 = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/dist/commonjs/index.js\");\nconst realZlib = __importStar(__webpack_require__(/*! zlib */ \"zlib\"));\nconst constants_js_1 = __webpack_require__(/*! ./constants.js */ \"./node_modules/tar/node_modules/minizlib/dist/commonjs/constants.js\");\nvar constants_js_2 = __webpack_require__(/*! ./constants.js */ \"./node_modules/tar/node_modules/minizlib/dist/commonjs/constants.js\");\nObject.defineProperty(exports, \"constants\", ({ enumerable: true, get: function () { return constants_js_2.constants; } }));\nconst OriginalBufferConcat = buffer_1.Buffer.concat;\nconst desc = Object.getOwnPropertyDescriptor(buffer_1.Buffer, 'concat');\nconst noop = (args) => args;\nconst passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined\n    ? (makeNoOp) => {\n        buffer_1.Buffer.concat = makeNoOp ? noop : OriginalBufferConcat;\n    }\n    : (_) => { };\nconst _superWrite = Symbol('_superWrite');\nclass ZlibError extends Error {\n    code;\n    errno;\n    constructor(err) {\n        super('zlib: ' + err.message);\n        this.code = err.code;\n        this.errno = err.errno;\n        /* c8 ignore next */\n        if (!this.code)\n            this.code = 'ZLIB_ERROR';\n        this.message = 'zlib: ' + err.message;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return 'ZlibError';\n    }\n}\nexports.ZlibError = ZlibError;\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _flushFlag = Symbol('flushFlag');\nclass ZlibBase extends minipass_1.Minipass {\n    #sawError = false;\n    #ended = false;\n    #flushFlag;\n    #finishFlushFlag;\n    #fullFlushFlag;\n    #handle;\n    #onError;\n    get sawError() {\n        return this.#sawError;\n    }\n    get handle() {\n        return this.#handle;\n    }\n    /* c8 ignore start */\n    get flushFlag() {\n        return this.#flushFlag;\n    }\n    /* c8 ignore stop */\n    constructor(opts, mode) {\n        if (!opts || typeof opts !== 'object')\n            throw new TypeError('invalid options for ZlibBase constructor');\n        //@ts-ignore\n        super(opts);\n        /* c8 ignore start */\n        this.#flushFlag = opts.flush ?? 0;\n        this.#finishFlushFlag = opts.finishFlush ?? 0;\n        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;\n        /* c8 ignore stop */\n        // this will throw if any options are invalid for the class selected\n        try {\n            // @types/node doesn't know that it exports the classes, but they're there\n            //@ts-ignore\n            this.#handle = new realZlib[mode](opts);\n        }\n        catch (er) {\n            // make sure that all errors get decorated properly\n            throw new ZlibError(er);\n        }\n        this.#onError = err => {\n            // no sense raising multiple errors, since we abort on the first one.\n            if (this.#sawError)\n                return;\n            this.#sawError = true;\n            // there is no way to cleanly recover.\n            // continuing only obscures problems.\n            this.close();\n            this.emit('error', err);\n        };\n        this.#handle?.on('error', er => this.#onError(new ZlibError(er)));\n        this.once('end', () => this.close);\n    }\n    close() {\n        if (this.#handle) {\n            this.#handle.close();\n            this.#handle = undefined;\n            this.emit('close');\n        }\n    }\n    reset() {\n        if (!this.#sawError) {\n            (0, assert_1.default)(this.#handle, 'zlib binding closed');\n            //@ts-ignore\n            return this.#handle.reset?.();\n        }\n    }\n    flush(flushFlag) {\n        if (this.ended)\n            return;\n        if (typeof flushFlag !== 'number')\n            flushFlag = this.#fullFlushFlag;\n        this.write(Object.assign(buffer_1.Buffer.alloc(0), { [_flushFlag]: flushFlag }));\n    }\n    end(chunk, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (chunk) {\n            if (encoding)\n                this.write(chunk, encoding);\n            else\n                this.write(chunk);\n        }\n        this.flush(this.#finishFlushFlag);\n        this.#ended = true;\n        return super.end(cb);\n    }\n    get ended() {\n        return this.#ended;\n    }\n    // overridden in the gzip classes to do portable writes\n    [_superWrite](data) {\n        return super.write(data);\n    }\n    write(chunk, encoding, cb) {\n        // process the chunk using the sync process\n        // then super.write() all the outputted chunks\n        if (typeof encoding === 'function')\n            (cb = encoding), (encoding = 'utf8');\n        if (typeof chunk === 'string')\n            chunk = buffer_1.Buffer.from(chunk, encoding);\n        if (this.#sawError)\n            return;\n        (0, assert_1.default)(this.#handle, 'zlib binding closed');\n        // _processChunk tries to .close() the native handle after it's done, so we\n        // intercept that by temporarily making it a no-op.\n        // diving into the node:zlib internals a bit here\n        const nativeHandle = this.#handle\n            ._handle;\n        const originalNativeClose = nativeHandle.close;\n        nativeHandle.close = () => { };\n        const originalClose = this.#handle.close;\n        this.#handle.close = () => { };\n        // It also calls `Buffer.concat()` at the end, which may be convenient\n        // for some, but which we are not interested in as it slows us down.\n        passthroughBufferConcat(true);\n        let result = undefined;\n        try {\n            const flushFlag = typeof chunk[_flushFlag] === 'number'\n                ? chunk[_flushFlag]\n                : this.#flushFlag;\n            result = this.#handle._processChunk(chunk, flushFlag);\n            // if we don't throw, reset it back how it was\n            passthroughBufferConcat(false);\n        }\n        catch (err) {\n            // or if we do, put Buffer.concat() back before we emit error\n            // Error events call into user code, which may call Buffer.concat()\n            passthroughBufferConcat(false);\n            this.#onError(new ZlibError(err));\n        }\n        finally {\n            if (this.#handle) {\n                // Core zlib resets `_handle` to null after attempting to close the\n                // native handle. Our no-op handler prevented actual closure, but we\n                // need to restore the `._handle` property.\n                ;\n                this.#handle._handle =\n                    nativeHandle;\n                nativeHandle.close = originalNativeClose;\n                this.#handle.close = originalClose;\n                // `_processChunk()` adds an 'error' listener. If we don't remove it\n                // after each call, these handlers start piling up.\n                this.#handle.removeAllListeners('error');\n                // make sure OUR error listener is still attached tho\n            }\n        }\n        if (this.#handle)\n            this.#handle.on('error', er => this.#onError(new ZlibError(er)));\n        let writeReturn;\n        if (result) {\n            if (Array.isArray(result) && result.length > 0) {\n                const r = result[0];\n                // The first buffer is always `handle._outBuffer`, which would be\n                // re-used for later invocations; so, we always have to copy that one.\n                writeReturn = this[_superWrite](buffer_1.Buffer.from(r));\n                for (let i = 1; i < result.length; i++) {\n                    writeReturn = this[_superWrite](result[i]);\n                }\n            }\n            else {\n                // either a single Buffer or an empty array\n                writeReturn = this[_superWrite](buffer_1.Buffer.from(result));\n            }\n        }\n        if (cb)\n            cb();\n        return writeReturn;\n    }\n}\nclass Zlib extends ZlibBase {\n    #level;\n    #strategy;\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants_js_1.constants.Z_NO_FLUSH;\n        opts.finishFlush = opts.finishFlush || constants_js_1.constants.Z_FINISH;\n        opts.fullFlushFlag = constants_js_1.constants.Z_FULL_FLUSH;\n        super(opts, mode);\n        this.#level = opts.level;\n        this.#strategy = opts.strategy;\n    }\n    params(level, strategy) {\n        if (this.sawError)\n            return;\n        if (!this.handle)\n            throw new Error('cannot switch params when binding is closed');\n        // no way to test this without also not supporting params at all\n        /* c8 ignore start */\n        if (!this.handle.params)\n            throw new Error('not supported in this implementation');\n        /* c8 ignore stop */\n        if (this.#level !== level || this.#strategy !== strategy) {\n            this.flush(constants_js_1.constants.Z_SYNC_FLUSH);\n            (0, assert_1.default)(this.handle, 'zlib binding closed');\n            // .params() calls .flush(), but the latter is always async in the\n            // core zlib. We override .flush() temporarily to intercept that and\n            // flush synchronously.\n            const origFlush = this.handle.flush;\n            this.handle.flush = (flushFlag, cb) => {\n                /* c8 ignore start */\n                if (typeof flushFlag === 'function') {\n                    cb = flushFlag;\n                    flushFlag = this.flushFlag;\n                }\n                /* c8 ignore stop */\n                this.flush(flushFlag);\n                cb?.();\n            };\n            try {\n                ;\n                this.handle.params(level, strategy);\n            }\n            finally {\n                this.handle.flush = origFlush;\n            }\n            /* c8 ignore start */\n            if (this.handle) {\n                this.#level = level;\n                this.#strategy = strategy;\n            }\n            /* c8 ignore stop */\n        }\n    }\n}\nexports.Zlib = Zlib;\n// minimal 2-byte header\nclass Deflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Deflate');\n    }\n}\nexports.Deflate = Deflate;\nclass Inflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Inflate');\n    }\n}\nexports.Inflate = Inflate;\nclass Gzip extends Zlib {\n    #portable;\n    constructor(opts) {\n        super(opts, 'Gzip');\n        this.#portable = opts && !!opts.portable;\n    }\n    [_superWrite](data) {\n        if (!this.#portable)\n            return super[_superWrite](data);\n        // we'll always get the header emitted in one first chunk\n        // overwrite the OS indicator byte with 0xFF\n        this.#portable = false;\n        data[9] = 255;\n        return super[_superWrite](data);\n    }\n}\nexports.Gzip = Gzip;\nclass Gunzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Gunzip');\n    }\n}\nexports.Gunzip = Gunzip;\n// raw - no header\nclass DeflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'DeflateRaw');\n    }\n}\nexports.DeflateRaw = DeflateRaw;\nclass InflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'InflateRaw');\n    }\n}\nexports.InflateRaw = InflateRaw;\n// auto-detect header.\nclass Unzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Unzip');\n    }\n}\nexports.Unzip = Unzip;\nclass Brotli extends ZlibBase {\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants_js_1.constants.BROTLI_OPERATION_PROCESS;\n        opts.finishFlush =\n            opts.finishFlush || constants_js_1.constants.BROTLI_OPERATION_FINISH;\n        opts.fullFlushFlag = constants_js_1.constants.BROTLI_OPERATION_FLUSH;\n        super(opts, mode);\n    }\n}\nexports.Brotli = Brotli;\nclass BrotliCompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliCompress');\n    }\n}\nexports.BrotliCompress = BrotliCompress;\nclass BrotliDecompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliDecompress');\n    }\n}\nexports.BrotliDecompress = BrotliDecompress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pemxpYi9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN2UCxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRkFBVTtBQUNyQyw4QkFBOEIsbUJBQU8sQ0FBQyxrQkFBTTtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsMkZBQWdCO0FBQzdDLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pemxpYi9kaXN0L2NvbW1vbmpzL2luZGV4LmpzP2ZjMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IGV4cG9ydHMuQnJvdGxpQ29tcHJlc3MgPSBleHBvcnRzLkJyb3RsaSA9IGV4cG9ydHMuVW56aXAgPSBleHBvcnRzLkluZmxhdGVSYXcgPSBleHBvcnRzLkRlZmxhdGVSYXcgPSBleHBvcnRzLkd1bnppcCA9IGV4cG9ydHMuR3ppcCA9IGV4cG9ydHMuSW5mbGF0ZSA9IGV4cG9ydHMuRGVmbGF0ZSA9IGV4cG9ydHMuWmxpYiA9IGV4cG9ydHMuWmxpYkVycm9yID0gZXhwb3J0cy5jb25zdGFudHMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IG1pbmlwYXNzXzEgPSByZXF1aXJlKFwibWluaXBhc3NcIik7XG5jb25zdCByZWFsWmxpYiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiemxpYlwiKSk7XG5jb25zdCBjb25zdGFudHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbnZhciBjb25zdGFudHNfanNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzX2pzXzIuY29uc3RhbnRzOyB9IH0pO1xuY29uc3QgT3JpZ2luYWxCdWZmZXJDb25jYXQgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0O1xuY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYnVmZmVyXzEuQnVmZmVyLCAnY29uY2F0Jyk7XG5jb25zdCBub29wID0gKGFyZ3MpID0+IGFyZ3M7XG5jb25zdCBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdCA9IGRlc2M/LndyaXRhYmxlID09PSB0cnVlIHx8IGRlc2M/LnNldCAhPT0gdW5kZWZpbmVkXG4gICAgPyAobWFrZU5vT3ApID0+IHtcbiAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmNvbmNhdCA9IG1ha2VOb09wID8gbm9vcCA6IE9yaWdpbmFsQnVmZmVyQ29uY2F0O1xuICAgIH1cbiAgICA6IChfKSA9PiB7IH07XG5jb25zdCBfc3VwZXJXcml0ZSA9IFN5bWJvbCgnX3N1cGVyV3JpdGUnKTtcbmNsYXNzIFpsaWJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlO1xuICAgIGVycm5vO1xuICAgIGNvbnN0cnVjdG9yKGVycikge1xuICAgICAgICBzdXBlcignemxpYjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gZXJyLmNvZGU7XG4gICAgICAgIHRoaXMuZXJybm8gPSBlcnIuZXJybm87XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghdGhpcy5jb2RlKVxuICAgICAgICAgICAgdGhpcy5jb2RlID0gJ1pMSUJfRVJST1InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnemxpYjogJyArIGVyci5tZXNzYWdlO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnWmxpYkVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLlpsaWJFcnJvciA9IFpsaWJFcnJvcjtcbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5jb25zdCBfZmx1c2hGbGFnID0gU3ltYm9sKCdmbHVzaEZsYWcnKTtcbmNsYXNzIFpsaWJCYXNlIGV4dGVuZHMgbWluaXBhc3NfMS5NaW5pcGFzcyB7XG4gICAgI3Nhd0Vycm9yID0gZmFsc2U7XG4gICAgI2VuZGVkID0gZmFsc2U7XG4gICAgI2ZsdXNoRmxhZztcbiAgICAjZmluaXNoRmx1c2hGbGFnO1xuICAgICNmdWxsRmx1c2hGbGFnO1xuICAgICNoYW5kbGU7XG4gICAgI29uRXJyb3I7XG4gICAgZ2V0IHNhd0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2F3RXJyb3I7XG4gICAgfVxuICAgIGdldCBoYW5kbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNoYW5kbGU7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGdldCBmbHVzaEZsYWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmbHVzaEZsYWc7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgY29uc3RydWN0b3Iob3B0cywgbW9kZSkge1xuICAgICAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zIGZvciBabGliQmFzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB0aGlzLiNmbHVzaEZsYWcgPSBvcHRzLmZsdXNoID8/IDA7XG4gICAgICAgIHRoaXMuI2ZpbmlzaEZsdXNoRmxhZyA9IG9wdHMuZmluaXNoRmx1c2ggPz8gMDtcbiAgICAgICAgdGhpcy4jZnVsbEZsdXNoRmxhZyA9IG9wdHMuZnVsbEZsdXNoRmxhZyA/PyAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgYW55IG9wdGlvbnMgYXJlIGludmFsaWQgZm9yIHRoZSBjbGFzcyBzZWxlY3RlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHR5cGVzL25vZGUgZG9lc24ndCBrbm93IHRoYXQgaXQgZXhwb3J0cyB0aGUgY2xhc3NlcywgYnV0IHRoZXkncmUgdGhlcmVcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy4jaGFuZGxlID0gbmV3IHJlYWxabGliW21vZGVdKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYWxsIGVycm9ycyBnZXQgZGVjb3JhdGVkIHByb3Blcmx5XG4gICAgICAgICAgICB0aHJvdyBuZXcgWmxpYkVycm9yKGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICAgIC8vIG5vIHNlbnNlIHJhaXNpbmcgbXVsdGlwbGUgZXJyb3JzLCBzaW5jZSB3ZSBhYm9ydCBvbiB0aGUgZmlyc3Qgb25lLlxuICAgICAgICAgICAgaWYgKHRoaXMuI3Nhd0Vycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuI3Nhd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgICAgICAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jaGFuZGxlPy5vbignZXJyb3InLCBlciA9PiB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXIpKSk7XG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5jbG9zZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy4jaGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLiNoYW5kbGUuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuI2hhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNzYXdFcnJvcikge1xuICAgICAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHRoaXMuI2hhbmRsZSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2hhbmRsZS5yZXNldD8uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goZmx1c2hGbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGZsdXNoRmxhZyAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICBmbHVzaEZsYWcgPSB0aGlzLiNmdWxsRmx1c2hGbGFnO1xuICAgICAgICB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24oYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApLCB7IFtfZmx1c2hGbGFnXTogZmx1c2hGbGFnIH0pKTtcbiAgICB9XG4gICAgZW5kKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gY2h1bms7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNodW5rID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZylcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCh0aGlzLiNmaW5pc2hGbHVzaEZsYWcpO1xuICAgICAgICB0aGlzLiNlbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoY2IpO1xuICAgIH1cbiAgICBnZXQgZW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNlbmRlZDtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGRlbiBpbiB0aGUgZ3ppcCBjbGFzc2VzIHRvIGRvIHBvcnRhYmxlIHdyaXRlc1xuICAgIFtfc3VwZXJXcml0ZV0oZGF0YSkge1xuICAgICAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgY2h1bmsgdXNpbmcgdGhlIHN5bmMgcHJvY2Vzc1xuICAgICAgICAvLyB0aGVuIHN1cGVyLndyaXRlKCkgYWxsIHRoZSBvdXRwdXR0ZWQgY2h1bmtzXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAoY2IgPSBlbmNvZGluZyksIChlbmNvZGluZyA9ICd1dGY4Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgY2h1bmsgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy4jc2F3RXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSh0aGlzLiNoYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICAgIC8vIF9wcm9jZXNzQ2h1bmsgdHJpZXMgdG8gLmNsb3NlKCkgdGhlIG5hdGl2ZSBoYW5kbGUgYWZ0ZXIgaXQncyBkb25lLCBzbyB3ZVxuICAgICAgICAvLyBpbnRlcmNlcHQgdGhhdCBieSB0ZW1wb3JhcmlseSBtYWtpbmcgaXQgYSBuby1vcC5cbiAgICAgICAgLy8gZGl2aW5nIGludG8gdGhlIG5vZGU6emxpYiBpbnRlcm5hbHMgYSBiaXQgaGVyZVxuICAgICAgICBjb25zdCBuYXRpdmVIYW5kbGUgPSB0aGlzLiNoYW5kbGVcbiAgICAgICAgICAgIC5faGFuZGxlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbE5hdGl2ZUNsb3NlID0gbmF0aXZlSGFuZGxlLmNsb3NlO1xuICAgICAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSB0aGlzLiNoYW5kbGUuY2xvc2U7XG4gICAgICAgIHRoaXMuI2hhbmRsZS5jbG9zZSA9ICgpID0+IHsgfTtcbiAgICAgICAgLy8gSXQgYWxzbyBjYWxscyBgQnVmZmVyLmNvbmNhdCgpYCBhdCB0aGUgZW5kLCB3aGljaCBtYXkgYmUgY29udmVuaWVudFxuICAgICAgICAvLyBmb3Igc29tZSwgYnV0IHdoaWNoIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhcyBpdCBzbG93cyB1cyBkb3duLlxuICAgICAgICBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdCh0cnVlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZsdXNoRmxhZyA9IHR5cGVvZiBjaHVua1tfZmx1c2hGbGFnXSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGNodW5rW19mbHVzaEZsYWddXG4gICAgICAgICAgICAgICAgOiB0aGlzLiNmbHVzaEZsYWc7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLiNoYW5kbGUuX3Byb2Nlc3NDaHVuayhjaHVuaywgZmx1c2hGbGFnKTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IHRocm93LCByZXNldCBpdCBiYWNrIGhvdyBpdCB3YXNcbiAgICAgICAgICAgIHBhc3N0aHJvdWdoQnVmZmVyQ29uY2F0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBvciBpZiB3ZSBkbywgcHV0IEJ1ZmZlci5jb25jYXQoKSBiYWNrIGJlZm9yZSB3ZSBlbWl0IGVycm9yXG4gICAgICAgICAgICAvLyBFcnJvciBldmVudHMgY2FsbCBpbnRvIHVzZXIgY29kZSwgd2hpY2ggbWF5IGNhbGwgQnVmZmVyLmNvbmNhdCgpXG4gICAgICAgICAgICBwYXNzdGhyb3VnaEJ1ZmZlckNvbmNhdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29yZSB6bGliIHJlc2V0cyBgX2hhbmRsZWAgdG8gbnVsbCBhZnRlciBhdHRlbXB0aW5nIHRvIGNsb3NlIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBoYW5kbGUuIE91ciBuby1vcCBoYW5kbGVyIHByZXZlbnRlZCBhY3R1YWwgY2xvc3VyZSwgYnV0IHdlXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZXN0b3JlIHRoZSBgLl9oYW5kbGVgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYW5kbGUuX2hhbmRsZSA9XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUhhbmRsZTtcbiAgICAgICAgICAgICAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSBvcmlnaW5hbE5hdGl2ZUNsb3NlO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhbmRsZS5jbG9zZSA9IG9yaWdpbmFsQ2xvc2U7XG4gICAgICAgICAgICAgICAgLy8gYF9wcm9jZXNzQ2h1bmsoKWAgYWRkcyBhbiAnZXJyb3InIGxpc3RlbmVyLiBJZiB3ZSBkb24ndCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBlYWNoIGNhbGwsIHRoZXNlIGhhbmRsZXJzIHN0YXJ0IHBpbGluZyB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLiNoYW5kbGUucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBPVVIgZXJyb3IgbGlzdGVuZXIgaXMgc3RpbGwgYXR0YWNoZWQgdGhvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2hhbmRsZSlcbiAgICAgICAgICAgIHRoaXMuI2hhbmRsZS5vbignZXJyb3InLCBlciA9PiB0aGlzLiNvbkVycm9yKG5ldyBabGliRXJyb3IoZXIpKSk7XG4gICAgICAgIGxldCB3cml0ZVJldHVybjtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyBhbHdheXMgYGhhbmRsZS5fb3V0QnVmZmVyYCwgd2hpY2ggd291bGQgYmVcbiAgICAgICAgICAgICAgICAvLyByZS11c2VkIGZvciBsYXRlciBpbnZvY2F0aW9uczsgc28sIHdlIGFsd2F5cyBoYXZlIHRvIGNvcHkgdGhhdCBvbmUuXG4gICAgICAgICAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShidWZmZXJfMS5CdWZmZXIuZnJvbShyKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShyZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciBhIHNpbmdsZSBCdWZmZXIgb3IgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICB3cml0ZVJldHVybiA9IHRoaXNbX3N1cGVyV3JpdGVdKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYilcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybiB3cml0ZVJldHVybjtcbiAgICB9XG59XG5jbGFzcyBabGliIGV4dGVuZHMgWmxpYkJhc2Uge1xuICAgICNsZXZlbDtcbiAgICAjc3RyYXRlZ3k7XG4gICAgY29uc3RydWN0b3Iob3B0cywgbW9kZSkge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzX2pzXzEuY29uc3RhbnRzLlpfTk9fRkxVU0g7XG4gICAgICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50c19qc18xLmNvbnN0YW50cy5aX0ZJTklTSDtcbiAgICAgICAgb3B0cy5mdWxsRmx1c2hGbGFnID0gY29uc3RhbnRzX2pzXzEuY29uc3RhbnRzLlpfRlVMTF9GTFVTSDtcbiAgICAgICAgc3VwZXIob3B0cywgbW9kZSk7XG4gICAgICAgIHRoaXMuI2xldmVsID0gb3B0cy5sZXZlbDtcbiAgICAgICAgdGhpcy4jc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuICAgIH1cbiAgICBwYXJhbXMobGV2ZWwsIHN0cmF0ZWd5KSB7XG4gICAgICAgIGlmICh0aGlzLnNhd0Vycm9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIHBhcmFtcyB3aGVuIGJpbmRpbmcgaXMgY2xvc2VkJyk7XG4gICAgICAgIC8vIG5vIHdheSB0byB0ZXN0IHRoaXMgd2l0aG91dCBhbHNvIG5vdCBzdXBwb3J0aW5nIHBhcmFtcyBhdCBhbGxcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUucGFyYW1zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGluIHRoaXMgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuI2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLiNzdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goY29uc3RhbnRzX2pzXzEuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCk7XG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkodGhpcy5oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICAgICAgICAvLyAucGFyYW1zKCkgY2FsbHMgLmZsdXNoKCksIGJ1dCB0aGUgbGF0dGVyIGlzIGFsd2F5cyBhc3luYyBpbiB0aGVcbiAgICAgICAgICAgIC8vIGNvcmUgemxpYi4gV2Ugb3ZlcnJpZGUgLmZsdXNoKCkgdGVtcG9yYXJpbHkgdG8gaW50ZXJjZXB0IHRoYXQgYW5kXG4gICAgICAgICAgICAvLyBmbHVzaCBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgY29uc3Qgb3JpZ0ZsdXNoID0gdGhpcy5oYW5kbGUuZmx1c2g7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZS5mbHVzaCA9IChmbHVzaEZsYWcsIGNiKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbHVzaEZsYWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IgPSBmbHVzaEZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoRmxhZyA9IHRoaXMuZmx1c2hGbGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goZmx1c2hGbGFnKTtcbiAgICAgICAgICAgICAgICBjYj8uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGUucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZS5mbHVzaCA9IG9yaWdGbHVzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNzdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuWmxpYiA9IFpsaWI7XG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmNsYXNzIERlZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlJyk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmNsYXNzIEluZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlJyk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmNsYXNzIEd6aXAgZXh0ZW5kcyBabGliIHtcbiAgICAjcG9ydGFibGU7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnR3ppcCcpO1xuICAgICAgICB0aGlzLiNwb3J0YWJsZSA9IG9wdHMgJiYgISFvcHRzLnBvcnRhYmxlO1xuICAgIH1cbiAgICBbX3N1cGVyV3JpdGVdKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNwb3J0YWJsZSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlcltfc3VwZXJXcml0ZV0oZGF0YSk7XG4gICAgICAgIC8vIHdlJ2xsIGFsd2F5cyBnZXQgdGhlIGhlYWRlciBlbWl0dGVkIGluIG9uZSBmaXJzdCBjaHVua1xuICAgICAgICAvLyBvdmVyd3JpdGUgdGhlIE9TIGluZGljYXRvciBieXRlIHdpdGggMHhGRlxuICAgICAgICB0aGlzLiNwb3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICBkYXRhWzldID0gMjU1O1xuICAgICAgICByZXR1cm4gc3VwZXJbX3N1cGVyV3JpdGVdKGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5jbGFzcyBHdW56aXAgZXh0ZW5kcyBabGliIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdHdW56aXAnKTtcbiAgICB9XG59XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbi8vIHJhdyAtIG5vIGhlYWRlclxuY2xhc3MgRGVmbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cywgJ0RlZmxhdGVSYXcnKTtcbiAgICB9XG59XG5leHBvcnRzLkRlZmxhdGVSYXcgPSBEZWZsYXRlUmF3O1xuY2xhc3MgSW5mbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cywgJ0luZmxhdGVSYXcnKTtcbiAgICB9XG59XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuY2xhc3MgVW56aXAgZXh0ZW5kcyBabGliIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdVbnppcCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW56aXAgPSBVbnppcDtcbmNsYXNzIEJyb3RsaSBleHRlbmRzIFpsaWJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzLCBtb2RlKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHNfanNfMS5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9QUk9DRVNTO1xuICAgICAgICBvcHRzLmZpbmlzaEZsdXNoID1cbiAgICAgICAgICAgIG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzX2pzXzEuY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRklOSVNIO1xuICAgICAgICBvcHRzLmZ1bGxGbHVzaEZsYWcgPSBjb25zdGFudHNfanNfMS5jb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSDtcbiAgICAgICAgc3VwZXIob3B0cywgbW9kZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm90bGkgPSBCcm90bGk7XG5jbGFzcyBCcm90bGlDb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzLCAnQnJvdGxpQ29tcHJlc3MnKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3RsaUNvbXByZXNzID0gQnJvdGxpQ29tcHJlc3M7XG5jbGFzcyBCcm90bGlEZWNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMsICdCcm90bGlEZWNvbXByZXNzJyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gQnJvdGxpRGVjb21wcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/minizlib/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/find-made.js":
/*!************************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/find-made.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findMadeSync = exports.findMade = void 0;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst findMade = async (opts, parent, path) => {\n    // we never want the 'made' return value to be a root directory\n    if (path === parent) {\n        return;\n    }\n    return opts.statAsync(parent).then(st => (st.isDirectory() ? path : undefined), // will fail later\n    // will fail later\n    er => {\n        const fer = er;\n        return fer && fer.code === 'ENOENT'\n            ? (0, exports.findMade)(opts, (0, path_1.dirname)(parent), parent)\n            : undefined;\n    });\n};\nexports.findMade = findMade;\nconst findMadeSync = (opts, parent, path) => {\n    if (path === parent) {\n        return undefined;\n    }\n    try {\n        return opts.statSync(parent).isDirectory() ? path : undefined;\n    }\n    catch (er) {\n        const fer = er;\n        return fer && fer.code === 'ENOENT'\n            ? (0, exports.findMadeSync)(opts, (0, path_1.dirname)(parent), parent)\n            : undefined;\n    }\n};\nexports.findMadeSync = findMadeSync;\n//# sourceMappingURL=find-made.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL2ZpbmQtbWFkZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxnQkFBZ0I7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL2ZpbmQtbWFkZS5qcz8xMGI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW5kTWFkZVN5bmMgPSBleHBvcnRzLmZpbmRNYWRlID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBmaW5kTWFkZSA9IGFzeW5jIChvcHRzLCBwYXJlbnQsIHBhdGgpID0+IHtcbiAgICAvLyB3ZSBuZXZlciB3YW50IHRoZSAnbWFkZScgcmV0dXJuIHZhbHVlIHRvIGJlIGEgcm9vdCBkaXJlY3RvcnlcbiAgICBpZiAocGF0aCA9PT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuc3RhdEFzeW5jKHBhcmVudCkudGhlbihzdCA9PiAoc3QuaXNEaXJlY3RvcnkoKSA/IHBhdGggOiB1bmRlZmluZWQpLCAvLyB3aWxsIGZhaWwgbGF0ZXJcbiAgICAvLyB3aWxsIGZhaWwgbGF0ZXJcbiAgICBlciA9PiB7XG4gICAgICAgIGNvbnN0IGZlciA9IGVyO1xuICAgICAgICByZXR1cm4gZmVyICYmIGZlci5jb2RlID09PSAnRU5PRU5UJ1xuICAgICAgICAgICAgPyAoMCwgZXhwb3J0cy5maW5kTWFkZSkob3B0cywgKDAsIHBhdGhfMS5kaXJuYW1lKShwYXJlbnQpLCBwYXJlbnQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbn07XG5leHBvcnRzLmZpbmRNYWRlID0gZmluZE1hZGU7XG5jb25zdCBmaW5kTWFkZVN5bmMgPSAob3B0cywgcGFyZW50LCBwYXRoKSA9PiB7XG4gICAgaWYgKHBhdGggPT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3B0cy5zdGF0U3luYyhwYXJlbnQpLmlzRGlyZWN0b3J5KCkgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgY29uc3QgZmVyID0gZXI7XG4gICAgICAgIHJldHVybiBmZXIgJiYgZmVyLmNvZGUgPT09ICdFTk9FTlQnXG4gICAgICAgICAgICA/ICgwLCBleHBvcnRzLmZpbmRNYWRlU3luYykob3B0cywgKDAsIHBhdGhfMS5kaXJuYW1lKShwYXJlbnQpLCBwYXJlbnQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG59O1xuZXhwb3J0cy5maW5kTWFkZVN5bmMgPSBmaW5kTWFkZVN5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLW1hZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/find-made.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mkdirp = exports.nativeSync = exports.native = exports.manualSync = exports.manual = exports.sync = exports.mkdirpSync = exports.useNativeSync = exports.useNative = exports.mkdirpNativeSync = exports.mkdirpNative = exports.mkdirpManualSync = exports.mkdirpManual = void 0;\nconst mkdirp_manual_js_1 = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js\");\nconst mkdirp_native_js_1 = __webpack_require__(/*! ./mkdirp-native.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-native.js\");\nconst opts_arg_js_1 = __webpack_require__(/*! ./opts-arg.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js\");\nconst path_arg_js_1 = __webpack_require__(/*! ./path-arg.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/path-arg.js\");\nconst use_native_js_1 = __webpack_require__(/*! ./use-native.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/use-native.js\");\n/* c8 ignore start */\nvar mkdirp_manual_js_2 = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js\");\nObject.defineProperty(exports, \"mkdirpManual\", ({ enumerable: true, get: function () { return mkdirp_manual_js_2.mkdirpManual; } }));\nObject.defineProperty(exports, \"mkdirpManualSync\", ({ enumerable: true, get: function () { return mkdirp_manual_js_2.mkdirpManualSync; } }));\nvar mkdirp_native_js_2 = __webpack_require__(/*! ./mkdirp-native.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-native.js\");\nObject.defineProperty(exports, \"mkdirpNative\", ({ enumerable: true, get: function () { return mkdirp_native_js_2.mkdirpNative; } }));\nObject.defineProperty(exports, \"mkdirpNativeSync\", ({ enumerable: true, get: function () { return mkdirp_native_js_2.mkdirpNativeSync; } }));\nvar use_native_js_2 = __webpack_require__(/*! ./use-native.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/use-native.js\");\nObject.defineProperty(exports, \"useNative\", ({ enumerable: true, get: function () { return use_native_js_2.useNative; } }));\nObject.defineProperty(exports, \"useNativeSync\", ({ enumerable: true, get: function () { return use_native_js_2.useNativeSync; } }));\n/* c8 ignore stop */\nconst mkdirpSync = (path, opts) => {\n    path = (0, path_arg_js_1.pathArg)(path);\n    const resolved = (0, opts_arg_js_1.optsArg)(opts);\n    return (0, use_native_js_1.useNativeSync)(resolved)\n        ? (0, mkdirp_native_js_1.mkdirpNativeSync)(path, resolved)\n        : (0, mkdirp_manual_js_1.mkdirpManualSync)(path, resolved);\n};\nexports.mkdirpSync = mkdirpSync;\nexports.sync = exports.mkdirpSync;\nexports.manual = mkdirp_manual_js_1.mkdirpManual;\nexports.manualSync = mkdirp_manual_js_1.mkdirpManualSync;\nexports.native = mkdirp_native_js_1.mkdirpNative;\nexports.nativeSync = mkdirp_native_js_1.mkdirpNativeSync;\nexports.mkdirp = Object.assign(async (path, opts) => {\n    path = (0, path_arg_js_1.pathArg)(path);\n    const resolved = (0, opts_arg_js_1.optsArg)(opts);\n    return (0, use_native_js_1.useNative)(resolved)\n        ? (0, mkdirp_native_js_1.mkdirpNative)(path, resolved)\n        : (0, mkdirp_manual_js_1.mkdirpManual)(path, resolved);\n}, {\n    mkdirpSync: exports.mkdirpSync,\n    mkdirpNative: mkdirp_native_js_1.mkdirpNative,\n    mkdirpNativeSync: mkdirp_native_js_1.mkdirpNativeSync,\n    mkdirpManual: mkdirp_manual_js_1.mkdirpManual,\n    mkdirpManualSync: mkdirp_manual_js_1.mkdirpManualSync,\n    sync: exports.mkdirpSync,\n    native: mkdirp_native_js_1.mkdirpNative,\n    nativeSync: mkdirp_native_js_1.mkdirpNativeSync,\n    manual: mkdirp_manual_js_1.mkdirpManual,\n    manualSync: mkdirp_manual_js_1.mkdirpManualSync,\n    useNative: use_native_js_1.useNative,\n    useNativeSync: use_native_js_1.useNativeSync,\n});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0I7QUFDOVEsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQ3ZELDJCQUEyQixtQkFBTyxDQUFDLGdHQUFvQjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBZTtBQUM3QyxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBZTtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBaUI7QUFDakQ7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDckQsZ0RBQStDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ2xJLG9EQUFtRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMxSSx5QkFBeUIsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDckQsZ0RBQStDLEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ2xJLG9EQUFtRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMxSSxzQkFBc0IsbUJBQU8sQ0FBQywwRkFBaUI7QUFDL0MsNkNBQTRDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQ3pILGlEQUFnRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL2luZGV4LmpzPzNiOWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1rZGlycCA9IGV4cG9ydHMubmF0aXZlU3luYyA9IGV4cG9ydHMubmF0aXZlID0gZXhwb3J0cy5tYW51YWxTeW5jID0gZXhwb3J0cy5tYW51YWwgPSBleHBvcnRzLnN5bmMgPSBleHBvcnRzLm1rZGlycFN5bmMgPSBleHBvcnRzLnVzZU5hdGl2ZVN5bmMgPSBleHBvcnRzLnVzZU5hdGl2ZSA9IGV4cG9ydHMubWtkaXJwTmF0aXZlU3luYyA9IGV4cG9ydHMubWtkaXJwTmF0aXZlID0gZXhwb3J0cy5ta2RpcnBNYW51YWxTeW5jID0gZXhwb3J0cy5ta2RpcnBNYW51YWwgPSB2b2lkIDA7XG5jb25zdCBta2RpcnBfbWFudWFsX2pzXzEgPSByZXF1aXJlKFwiLi9ta2RpcnAtbWFudWFsLmpzXCIpO1xuY29uc3QgbWtkaXJwX25hdGl2ZV9qc18xID0gcmVxdWlyZShcIi4vbWtkaXJwLW5hdGl2ZS5qc1wiKTtcbmNvbnN0IG9wdHNfYXJnX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRzLWFyZy5qc1wiKTtcbmNvbnN0IHBhdGhfYXJnX2pzXzEgPSByZXF1aXJlKFwiLi9wYXRoLWFyZy5qc1wiKTtcbmNvbnN0IHVzZV9uYXRpdmVfanNfMSA9IHJlcXVpcmUoXCIuL3VzZS1uYXRpdmUuanNcIik7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnZhciBta2RpcnBfbWFudWFsX2pzXzIgPSByZXF1aXJlKFwiLi9ta2RpcnAtbWFudWFsLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWtkaXJwTWFudWFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBta2RpcnBfbWFudWFsX2pzXzIubWtkaXJwTWFudWFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWtkaXJwTWFudWFsU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWtkaXJwX21hbnVhbF9qc18yLm1rZGlycE1hbnVhbFN5bmM7IH0gfSk7XG52YXIgbWtkaXJwX25hdGl2ZV9qc18yID0gcmVxdWlyZShcIi4vbWtkaXJwLW5hdGl2ZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1rZGlycE5hdGl2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWtkaXJwX25hdGl2ZV9qc18yLm1rZGlycE5hdGl2ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1rZGlycE5hdGl2ZVN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1rZGlycF9uYXRpdmVfanNfMi5ta2RpcnBOYXRpdmVTeW5jOyB9IH0pO1xudmFyIHVzZV9uYXRpdmVfanNfMiA9IHJlcXVpcmUoXCIuL3VzZS1uYXRpdmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VOYXRpdmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVzZV9uYXRpdmVfanNfMi51c2VOYXRpdmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VOYXRpdmVTeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VfbmF0aXZlX2pzXzIudXNlTmF0aXZlU3luYzsgfSB9KTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jb25zdCBta2RpcnBTeW5jID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgICBwYXRoID0gKDAsIHBhdGhfYXJnX2pzXzEucGF0aEFyZykocGF0aCk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSAoMCwgb3B0c19hcmdfanNfMS5vcHRzQXJnKShvcHRzKTtcbiAgICByZXR1cm4gKDAsIHVzZV9uYXRpdmVfanNfMS51c2VOYXRpdmVTeW5jKShyZXNvbHZlZClcbiAgICAgICAgPyAoMCwgbWtkaXJwX25hdGl2ZV9qc18xLm1rZGlycE5hdGl2ZVN5bmMpKHBhdGgsIHJlc29sdmVkKVxuICAgICAgICA6ICgwLCBta2RpcnBfbWFudWFsX2pzXzEubWtkaXJwTWFudWFsU3luYykocGF0aCwgcmVzb2x2ZWQpO1xufTtcbmV4cG9ydHMubWtkaXJwU3luYyA9IG1rZGlycFN5bmM7XG5leHBvcnRzLnN5bmMgPSBleHBvcnRzLm1rZGlycFN5bmM7XG5leHBvcnRzLm1hbnVhbCA9IG1rZGlycF9tYW51YWxfanNfMS5ta2RpcnBNYW51YWw7XG5leHBvcnRzLm1hbnVhbFN5bmMgPSBta2RpcnBfbWFudWFsX2pzXzEubWtkaXJwTWFudWFsU3luYztcbmV4cG9ydHMubmF0aXZlID0gbWtkaXJwX25hdGl2ZV9qc18xLm1rZGlycE5hdGl2ZTtcbmV4cG9ydHMubmF0aXZlU3luYyA9IG1rZGlycF9uYXRpdmVfanNfMS5ta2RpcnBOYXRpdmVTeW5jO1xuZXhwb3J0cy5ta2RpcnAgPSBPYmplY3QuYXNzaWduKGFzeW5jIChwYXRoLCBvcHRzKSA9PiB7XG4gICAgcGF0aCA9ICgwLCBwYXRoX2FyZ19qc18xLnBhdGhBcmcpKHBhdGgpO1xuICAgIGNvbnN0IHJlc29sdmVkID0gKDAsIG9wdHNfYXJnX2pzXzEub3B0c0FyZykob3B0cyk7XG4gICAgcmV0dXJuICgwLCB1c2VfbmF0aXZlX2pzXzEudXNlTmF0aXZlKShyZXNvbHZlZClcbiAgICAgICAgPyAoMCwgbWtkaXJwX25hdGl2ZV9qc18xLm1rZGlycE5hdGl2ZSkocGF0aCwgcmVzb2x2ZWQpXG4gICAgICAgIDogKDAsIG1rZGlycF9tYW51YWxfanNfMS5ta2RpcnBNYW51YWwpKHBhdGgsIHJlc29sdmVkKTtcbn0sIHtcbiAgICBta2RpcnBTeW5jOiBleHBvcnRzLm1rZGlycFN5bmMsXG4gICAgbWtkaXJwTmF0aXZlOiBta2RpcnBfbmF0aXZlX2pzXzEubWtkaXJwTmF0aXZlLFxuICAgIG1rZGlycE5hdGl2ZVN5bmM6IG1rZGlycF9uYXRpdmVfanNfMS5ta2RpcnBOYXRpdmVTeW5jLFxuICAgIG1rZGlycE1hbnVhbDogbWtkaXJwX21hbnVhbF9qc18xLm1rZGlycE1hbnVhbCxcbiAgICBta2RpcnBNYW51YWxTeW5jOiBta2RpcnBfbWFudWFsX2pzXzEubWtkaXJwTWFudWFsU3luYyxcbiAgICBzeW5jOiBleHBvcnRzLm1rZGlycFN5bmMsXG4gICAgbmF0aXZlOiBta2RpcnBfbmF0aXZlX2pzXzEubWtkaXJwTmF0aXZlLFxuICAgIG5hdGl2ZVN5bmM6IG1rZGlycF9uYXRpdmVfanNfMS5ta2RpcnBOYXRpdmVTeW5jLFxuICAgIG1hbnVhbDogbWtkaXJwX21hbnVhbF9qc18xLm1rZGlycE1hbnVhbCxcbiAgICBtYW51YWxTeW5jOiBta2RpcnBfbWFudWFsX2pzXzEubWtkaXJwTWFudWFsU3luYyxcbiAgICB1c2VOYXRpdmU6IHVzZV9uYXRpdmVfanNfMS51c2VOYXRpdmUsXG4gICAgdXNlTmF0aXZlU3luYzogdXNlX25hdGl2ZV9qc18xLnVzZU5hdGl2ZVN5bmMsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mkdirpManual = exports.mkdirpManualSync = void 0;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst opts_arg_js_1 = __webpack_require__(/*! ./opts-arg.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js\");\nconst mkdirpManualSync = (path, options, made) => {\n    const parent = (0, path_1.dirname)(path);\n    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: false };\n    if (parent === path) {\n        try {\n            return opts.mkdirSync(path, opts);\n        }\n        catch (er) {\n            // swallowed by recursive implementation on posix systems\n            // any other error is a failure\n            const fer = er;\n            if (fer && fer.code !== 'EISDIR') {\n                throw er;\n            }\n            return;\n        }\n    }\n    try {\n        opts.mkdirSync(path, opts);\n        return made || path;\n    }\n    catch (er) {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, exports.mkdirpManualSync)(path, opts, (0, exports.mkdirpManualSync)(parent, opts, made));\n        }\n        if (fer && fer.code !== 'EEXIST' && fer && fer.code !== 'EROFS') {\n            throw er;\n        }\n        try {\n            if (!opts.statSync(path).isDirectory())\n                throw er;\n        }\n        catch (_) {\n            throw er;\n        }\n    }\n};\nexports.mkdirpManualSync = mkdirpManualSync;\nexports.mkdirpManual = Object.assign(async (path, options, made) => {\n    const opts = (0, opts_arg_js_1.optsArg)(options);\n    opts.recursive = false;\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return opts.mkdirAsync(path, opts).catch(er => {\n            // swallowed by recursive implementation on posix systems\n            // any other error is a failure\n            const fer = er;\n            if (fer && fer.code !== 'EISDIR') {\n                throw er;\n            }\n        });\n    }\n    return opts.mkdirAsync(path, opts).then(() => made || path, async (er) => {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, exports.mkdirpManual)(parent, opts).then((made) => (0, exports.mkdirpManual)(path, opts, made));\n        }\n        if (fer && fer.code !== 'EEXIST' && fer.code !== 'EROFS') {\n            throw er;\n        }\n        return opts.statAsync(path).then(st => {\n            if (st.isDirectory()) {\n                return made;\n            }\n            else {\n                throw er;\n            }\n        }, () => {\n            throw er;\n        });\n    });\n}, { sync: exports.mkdirpManualSync });\n//# sourceMappingURL=mkdirp-manual.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL21rZGlycC1tYW51YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBZTtBQUM3QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUMsSUFBSSxnQ0FBZ0M7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvbm9kZV9tb2R1bGVzL21rZGlycC9kaXN0L2Nqcy9zcmMvbWtkaXJwLW1hbnVhbC5qcz80MDg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ta2RpcnBNYW51YWwgPSBleHBvcnRzLm1rZGlycE1hbnVhbFN5bmMgPSB2b2lkIDA7XG5jb25zdCBwYXRoXzEgPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IG9wdHNfYXJnX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRzLWFyZy5qc1wiKTtcbmNvbnN0IG1rZGlycE1hbnVhbFN5bmMgPSAocGF0aCwgb3B0aW9ucywgbWFkZSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9ICgwLCBwYXRoXzEuZGlybmFtZSkocGF0aCk7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uKDAsIG9wdHNfYXJnX2pzXzEub3B0c0FyZykob3B0aW9ucyksIHJlY3Vyc2l2ZTogZmFsc2UgfTtcbiAgICBpZiAocGFyZW50ID09PSBwYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5ta2RpclN5bmMocGF0aCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93ZWQgYnkgcmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9uIHBvc2l4IHN5c3RlbXNcbiAgICAgICAgICAgIC8vIGFueSBvdGhlciBlcnJvciBpcyBhIGZhaWx1cmVcbiAgICAgICAgICAgIGNvbnN0IGZlciA9IGVyO1xuICAgICAgICAgICAgaWYgKGZlciAmJiBmZXIuY29kZSAhPT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBvcHRzLm1rZGlyU3luYyhwYXRoLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIG1hZGUgfHwgcGF0aDtcbiAgICB9XG4gICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnN0IGZlciA9IGVyO1xuICAgICAgICBpZiAoZmVyICYmIGZlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLm1rZGlycE1hbnVhbFN5bmMpKHBhdGgsIG9wdHMsICgwLCBleHBvcnRzLm1rZGlycE1hbnVhbFN5bmMpKHBhcmVudCwgb3B0cywgbWFkZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZXIgJiYgZmVyLmNvZGUgIT09ICdFRVhJU1QnICYmIGZlciAmJiBmZXIuY29kZSAhPT0gJ0VST0ZTJykge1xuICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghb3B0cy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLm1rZGlycE1hbnVhbFN5bmMgPSBta2RpcnBNYW51YWxTeW5jO1xuZXhwb3J0cy5ta2RpcnBNYW51YWwgPSBPYmplY3QuYXNzaWduKGFzeW5jIChwYXRoLCBvcHRpb25zLCBtYWRlKSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRzX2FyZ19qc18xLm9wdHNBcmcpKG9wdGlvbnMpO1xuICAgIG9wdHMucmVjdXJzaXZlID0gZmFsc2U7XG4gICAgY29uc3QgcGFyZW50ID0gKDAsIHBhdGhfMS5kaXJuYW1lKShwYXRoKTtcbiAgICBpZiAocGFyZW50ID09PSBwYXRoKSB7XG4gICAgICAgIHJldHVybiBvcHRzLm1rZGlyQXN5bmMocGF0aCwgb3B0cykuY2F0Y2goZXIgPT4ge1xuICAgICAgICAgICAgLy8gc3dhbGxvd2VkIGJ5IHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvbiBwb3NpeCBzeXN0ZW1zXG4gICAgICAgICAgICAvLyBhbnkgb3RoZXIgZXJyb3IgaXMgYSBmYWlsdXJlXG4gICAgICAgICAgICBjb25zdCBmZXIgPSBlcjtcbiAgICAgICAgICAgIGlmIChmZXIgJiYgZmVyLmNvZGUgIT09ICdFSVNESVInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5ta2RpckFzeW5jKHBhdGgsIG9wdHMpLnRoZW4oKCkgPT4gbWFkZSB8fCBwYXRoLCBhc3luYyAoZXIpID0+IHtcbiAgICAgICAgY29uc3QgZmVyID0gZXI7XG4gICAgICAgIGlmIChmZXIgJiYgZmVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMubWtkaXJwTWFudWFsKShwYXJlbnQsIG9wdHMpLnRoZW4oKG1hZGUpID0+ICgwLCBleHBvcnRzLm1rZGlycE1hbnVhbCkocGF0aCwgb3B0cywgbWFkZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZXIgJiYgZmVyLmNvZGUgIT09ICdFRVhJU1QnICYmIGZlci5jb2RlICE9PSAnRVJPRlMnKSB7XG4gICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cy5zdGF0QXN5bmMocGF0aCkudGhlbihzdCA9PiB7XG4gICAgICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0sIHsgc3luYzogZXhwb3J0cy5ta2RpcnBNYW51YWxTeW5jIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWtkaXJwLW1hbnVhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-native.js":
/*!****************************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-native.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mkdirpNative = exports.mkdirpNativeSync = void 0;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst find_made_js_1 = __webpack_require__(/*! ./find-made.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/find-made.js\");\nconst mkdirp_manual_js_1 = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js\");\nconst opts_arg_js_1 = __webpack_require__(/*! ./opts-arg.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js\");\nconst mkdirpNativeSync = (path, options) => {\n    const opts = (0, opts_arg_js_1.optsArg)(options);\n    opts.recursive = true;\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return opts.mkdirSync(path, opts);\n    }\n    const made = (0, find_made_js_1.findMadeSync)(opts, path);\n    try {\n        opts.mkdirSync(path, opts);\n        return made;\n    }\n    catch (er) {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, mkdirp_manual_js_1.mkdirpManualSync)(path, opts);\n        }\n        else {\n            throw er;\n        }\n    }\n};\nexports.mkdirpNativeSync = mkdirpNativeSync;\nexports.mkdirpNative = Object.assign(async (path, options) => {\n    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: true };\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return await opts.mkdirAsync(path, opts);\n    }\n    return (0, find_made_js_1.findMade)(opts, path).then((made) => opts\n        .mkdirAsync(path, opts)\n        .then(m => made || m)\n        .catch(er => {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, mkdirp_manual_js_1.mkdirpManual)(path, opts);\n        }\n        else {\n            throw er;\n        }\n    }));\n}, { sync: exports.mkdirpNativeSync });\n//# sourceMappingURL=mkdirp-native.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL21rZGlycC1uYXRpdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBZ0I7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLHNGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsSUFBSSxnQ0FBZ0M7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvbm9kZV9tb2R1bGVzL21rZGlycC9kaXN0L2Nqcy9zcmMvbWtkaXJwLW5hdGl2ZS5qcz8yM2UwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ta2RpcnBOYXRpdmUgPSBleHBvcnRzLm1rZGlycE5hdGl2ZVN5bmMgPSB2b2lkIDA7XG5jb25zdCBwYXRoXzEgPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGZpbmRfbWFkZV9qc18xID0gcmVxdWlyZShcIi4vZmluZC1tYWRlLmpzXCIpO1xuY29uc3QgbWtkaXJwX21hbnVhbF9qc18xID0gcmVxdWlyZShcIi4vbWtkaXJwLW1hbnVhbC5qc1wiKTtcbmNvbnN0IG9wdHNfYXJnX2pzXzEgPSByZXF1aXJlKFwiLi9vcHRzLWFyZy5qc1wiKTtcbmNvbnN0IG1rZGlycE5hdGl2ZVN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgb3B0c19hcmdfanNfMS5vcHRzQXJnKShvcHRpb25zKTtcbiAgICBvcHRzLnJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgY29uc3QgcGFyZW50ID0gKDAsIHBhdGhfMS5kaXJuYW1lKShwYXRoKTtcbiAgICBpZiAocGFyZW50ID09PSBwYXRoKSB7XG4gICAgICAgIHJldHVybiBvcHRzLm1rZGlyU3luYyhwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgY29uc3QgbWFkZSA9ICgwLCBmaW5kX21hZGVfanNfMS5maW5kTWFkZVN5bmMpKG9wdHMsIHBhdGgpO1xuICAgIHRyeSB7XG4gICAgICAgIG9wdHMubWtkaXJTeW5jKHBhdGgsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbWFkZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnN0IGZlciA9IGVyO1xuICAgICAgICBpZiAoZmVyICYmIGZlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBta2RpcnBfbWFudWFsX2pzXzEubWtkaXJwTWFudWFsU3luYykocGF0aCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLm1rZGlycE5hdGl2ZVN5bmMgPSBta2RpcnBOYXRpdmVTeW5jO1xuZXhwb3J0cy5ta2RpcnBOYXRpdmUgPSBPYmplY3QuYXNzaWduKGFzeW5jIChwYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IHsgLi4uKDAsIG9wdHNfYXJnX2pzXzEub3B0c0FyZykob3B0aW9ucyksIHJlY3Vyc2l2ZTogdHJ1ZSB9O1xuICAgIGNvbnN0IHBhcmVudCA9ICgwLCBwYXRoXzEuZGlybmFtZSkocGF0aCk7XG4gICAgaWYgKHBhcmVudCA9PT0gcGF0aCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgb3B0cy5ta2RpckFzeW5jKHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGZpbmRfbWFkZV9qc18xLmZpbmRNYWRlKShvcHRzLCBwYXRoKS50aGVuKChtYWRlKSA9PiBvcHRzXG4gICAgICAgIC5ta2RpckFzeW5jKHBhdGgsIG9wdHMpXG4gICAgICAgIC50aGVuKG0gPT4gbWFkZSB8fCBtKVxuICAgICAgICAuY2F0Y2goZXIgPT4ge1xuICAgICAgICBjb25zdCBmZXIgPSBlcjtcbiAgICAgICAgaWYgKGZlciAmJiBmZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWtkaXJwX21hbnVhbF9qc18xLm1rZGlycE1hbnVhbCkocGF0aCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgfVxuICAgIH0pKTtcbn0sIHsgc3luYzogZXhwb3J0cy5ta2RpcnBOYXRpdmVTeW5jIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWtkaXJwLW5hdGl2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/mkdirp-native.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.optsArg = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst optsArg = (opts) => {\n    if (!opts) {\n        opts = { mode: 0o777 };\n    }\n    else if (typeof opts === 'object') {\n        opts = { mode: 0o777, ...opts };\n    }\n    else if (typeof opts === 'number') {\n        opts = { mode: opts };\n    }\n    else if (typeof opts === 'string') {\n        opts = { mode: parseInt(opts, 8) };\n    }\n    else {\n        throw new TypeError('invalid options argument');\n    }\n    const resolved = opts;\n    const optsFs = opts.fs || {};\n    opts.mkdir = opts.mkdir || optsFs.mkdir || fs_1.mkdir;\n    opts.mkdirAsync = opts.mkdirAsync\n        ? opts.mkdirAsync\n        : async (path, options) => {\n            return new Promise((res, rej) => resolved.mkdir(path, options, (er, made) => er ? rej(er) : res(made)));\n        };\n    opts.stat = opts.stat || optsFs.stat || fs_1.stat;\n    opts.statAsync = opts.statAsync\n        ? opts.statAsync\n        : async (path) => new Promise((res, rej) => resolved.stat(path, (err, stats) => (err ? rej(err) : res(stats))));\n    opts.statSync = opts.statSync || optsFs.statSync || fs_1.statSync;\n    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || fs_1.mkdirSync;\n    return resolved;\n};\nexports.optsArg = optsArg;\n//# sourceMappingURL=opts-arg.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL29wdHMtYXJnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsY0FBSTtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy90YXIvbm9kZV9tb2R1bGVzL21rZGlycC9kaXN0L2Nqcy9zcmMvb3B0cy1hcmcuanM/MzRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3B0c0FyZyA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvcHRzQXJnID0gKG9wdHMpID0+IHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogMG83NzcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IDBvNzc3LCAuLi5vcHRzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBwYXJzZUludChvcHRzLCA4KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gb3B0cztcbiAgICBjb25zdCBvcHRzRnMgPSBvcHRzLmZzIHx8IHt9O1xuICAgIG9wdHMubWtkaXIgPSBvcHRzLm1rZGlyIHx8IG9wdHNGcy5ta2RpciB8fCBmc18xLm1rZGlyO1xuICAgIG9wdHMubWtkaXJBc3luYyA9IG9wdHMubWtkaXJBc3luY1xuICAgICAgICA/IG9wdHMubWtkaXJBc3luY1xuICAgICAgICA6IGFzeW5jIChwYXRoLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiByZXNvbHZlZC5ta2RpcihwYXRoLCBvcHRpb25zLCAoZXIsIG1hZGUpID0+IGVyID8gcmVqKGVyKSA6IHJlcyhtYWRlKSkpO1xuICAgICAgICB9O1xuICAgIG9wdHMuc3RhdCA9IG9wdHMuc3RhdCB8fCBvcHRzRnMuc3RhdCB8fCBmc18xLnN0YXQ7XG4gICAgb3B0cy5zdGF0QXN5bmMgPSBvcHRzLnN0YXRBc3luY1xuICAgICAgICA/IG9wdHMuc3RhdEFzeW5jXG4gICAgICAgIDogYXN5bmMgKHBhdGgpID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4gcmVzb2x2ZWQuc3RhdChwYXRoLCAoZXJyLCBzdGF0cykgPT4gKGVyciA/IHJlaihlcnIpIDogcmVzKHN0YXRzKSkpKTtcbiAgICBvcHRzLnN0YXRTeW5jID0gb3B0cy5zdGF0U3luYyB8fCBvcHRzRnMuc3RhdFN5bmMgfHwgZnNfMS5zdGF0U3luYztcbiAgICBvcHRzLm1rZGlyU3luYyA9IG9wdHMubWtkaXJTeW5jIHx8IG9wdHNGcy5ta2RpclN5bmMgfHwgZnNfMS5ta2RpclN5bmM7XG4gICAgcmV0dXJuIHJlc29sdmVkO1xufTtcbmV4cG9ydHMub3B0c0FyZyA9IG9wdHNBcmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRzLWFyZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/path-arg.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/path-arg.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pathArg = void 0;\nconst platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst pathArg = (path) => {\n    if (/\\0/.test(path)) {\n        // simulate same failure that node raises\n        throw Object.assign(new TypeError('path must be a string without null bytes'), {\n            path,\n            code: 'ERR_INVALID_ARG_VALUE',\n        });\n    }\n    path = (0, path_1.resolve)(path);\n    if (platform === 'win32') {\n        const badWinChars = /[*|\"<>?:]/;\n        const { root } = (0, path_1.parse)(path);\n        if (badWinChars.test(path.substring(root.length))) {\n            throw Object.assign(new Error('Illegal characters in path.'), {\n                path,\n                code: 'EINVAL',\n            });\n        }\n    }\n    return path;\n};\nexports.pathArg = pathArg;\n//# sourceMappingURL=path-arg.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL3BhdGgtYXJnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMvbWtkaXJwL2Rpc3QvY2pzL3NyYy9wYXRoLWFyZy5qcz9iN2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRoQXJnID0gdm9pZCAwO1xuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5fX1RFU1RJTkdfTUtESVJQX1BMQVRGT1JNX18gfHwgcHJvY2Vzcy5wbGF0Zm9ybTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgcGF0aEFyZyA9IChwYXRoKSA9PiB7XG4gICAgaWYgKC9cXDAvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgLy8gc2ltdWxhdGUgc2FtZSBmYWlsdXJlIHRoYXQgbm9kZSByYWlzZXNcbiAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzJyksIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBjb2RlOiAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdGggPSAoMCwgcGF0aF8xLnJlc29sdmUpKHBhdGgpO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICBjb25zdCBiYWRXaW5DaGFycyA9IC9bKnxcIjw+PzpdLztcbiAgICAgICAgY29uc3QgeyByb290IH0gPSAoMCwgcGF0aF8xLnBhcnNlKShwYXRoKTtcbiAgICAgICAgaWYgKGJhZFdpbkNoYXJzLnRlc3QocGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGgpKSkge1xuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVycyBpbiBwYXRoLicpLCB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRUlOVkFMJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcbmV4cG9ydHMucGF0aEFyZyA9IHBhdGhBcmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLWFyZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/path-arg.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/mkdirp/dist/cjs/src/use-native.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tar/node_modules/mkdirp/dist/cjs/src/use-native.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useNative = exports.useNativeSync = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst opts_arg_js_1 = __webpack_require__(/*! ./opts-arg.js */ \"./node_modules/tar/node_modules/mkdirp/dist/cjs/src/opts-arg.js\");\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;\nconst versArr = version.replace(/^v/, '').split('.');\nconst hasNative = +versArr[0] > 10 || (+versArr[0] === 10 && +versArr[1] >= 12);\nexports.useNativeSync = !hasNative\n    ? () => false\n    : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdirSync === fs_1.mkdirSync;\nexports.useNative = Object.assign(!hasNative\n    ? () => false\n    : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdir === fs_1.mkdir, {\n    sync: exports.useNativeSync,\n});\n//# sourceMappingURL=use-native.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvZGlzdC9janMvc3JjL3VzZS1uYXRpdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcscUJBQXFCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLHNCQUFzQixtQkFBTyxDQUFDLHNGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMvbWtkaXJwL2Rpc3QvY2pzL3NyYy91c2UtbmF0aXZlLmpzPzY5YTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZU5hdGl2ZSA9IGV4cG9ydHMudXNlTmF0aXZlU3luYyA9IHZvaWQgMDtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvcHRzX2FyZ19qc18xID0gcmVxdWlyZShcIi4vb3B0cy1hcmcuanNcIik7XG5jb25zdCB2ZXJzaW9uID0gcHJvY2Vzcy5lbnYuX19URVNUSU5HX01LRElSUF9OT0RFX1ZFUlNJT05fXyB8fCBwcm9jZXNzLnZlcnNpb247XG5jb25zdCB2ZXJzQXJyID0gdmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKS5zcGxpdCgnLicpO1xuY29uc3QgaGFzTmF0aXZlID0gK3ZlcnNBcnJbMF0gPiAxMCB8fCAoK3ZlcnNBcnJbMF0gPT09IDEwICYmICt2ZXJzQXJyWzFdID49IDEyKTtcbmV4cG9ydHMudXNlTmF0aXZlU3luYyA9ICFoYXNOYXRpdmVcbiAgICA/ICgpID0+IGZhbHNlXG4gICAgOiAob3B0cykgPT4gKDAsIG9wdHNfYXJnX2pzXzEub3B0c0FyZykob3B0cykubWtkaXJTeW5jID09PSBmc18xLm1rZGlyU3luYztcbmV4cG9ydHMudXNlTmF0aXZlID0gT2JqZWN0LmFzc2lnbighaGFzTmF0aXZlXG4gICAgPyAoKSA9PiBmYWxzZVxuICAgIDogKG9wdHMpID0+ICgwLCBvcHRzX2FyZ19qc18xLm9wdHNBcmcpKG9wdHMpLm1rZGlyID09PSBmc18xLm1rZGlyLCB7XG4gICAgc3luYzogZXhwb3J0cy51c2VOYXRpdmVTeW5jLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtbmF0aXZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/mkdirp/dist/cjs/src/use-native.js\n\n}");

/***/ }),

/***/ "./node_modules/tar/node_modules/yallist/dist/commonjs/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tar/node_modules/yallist/dist/commonjs/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Node = exports.Yallist = void 0;\nclass Yallist {\n    tail;\n    head;\n    length = 0;\n    static create(list = []) {\n        return new Yallist(list);\n    }\n    constructor(list = []) {\n        for (const item of list) {\n            this.push(item);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let walker = this.head; walker; walker = walker.next) {\n            yield walker.value;\n        }\n    }\n    removeNode(node) {\n        if (node.list !== this) {\n            throw new Error('removing node which does not belong to this list');\n        }\n        const next = node.next;\n        const prev = node.prev;\n        if (next) {\n            next.prev = prev;\n        }\n        if (prev) {\n            prev.next = next;\n        }\n        if (node === this.head) {\n            this.head = next;\n        }\n        if (node === this.tail) {\n            this.tail = prev;\n        }\n        this.length--;\n        node.next = undefined;\n        node.prev = undefined;\n        node.list = undefined;\n        return next;\n    }\n    unshiftNode(node) {\n        if (node === this.head) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const head = this.head;\n        node.list = this;\n        node.next = head;\n        if (head) {\n            head.prev = node;\n        }\n        this.head = node;\n        if (!this.tail) {\n            this.tail = node;\n        }\n        this.length++;\n    }\n    pushNode(node) {\n        if (node === this.tail) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const tail = this.tail;\n        node.list = this;\n        node.prev = tail;\n        if (tail) {\n            tail.next = node;\n        }\n        this.tail = node;\n        if (!this.head) {\n            this.head = node;\n        }\n        this.length++;\n    }\n    push(...args) {\n        for (let i = 0, l = args.length; i < l; i++) {\n            push(this, args[i]);\n        }\n        return this.length;\n    }\n    unshift(...args) {\n        for (var i = 0, l = args.length; i < l; i++) {\n            unshift(this, args[i]);\n        }\n        return this.length;\n    }\n    pop() {\n        if (!this.tail) {\n            return undefined;\n        }\n        const res = this.tail.value;\n        const t = this.tail;\n        this.tail = this.tail.prev;\n        if (this.tail) {\n            this.tail.next = undefined;\n        }\n        else {\n            this.head = undefined;\n        }\n        t.list = undefined;\n        this.length--;\n        return res;\n    }\n    shift() {\n        if (!this.head) {\n            return undefined;\n        }\n        const res = this.head.value;\n        const h = this.head;\n        this.head = this.head.next;\n        if (this.head) {\n            this.head.prev = undefined;\n        }\n        else {\n            this.tail = undefined;\n        }\n        h.list = undefined;\n        this.length--;\n        return res;\n    }\n    forEach(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.head, i = 0; !!walker; i++) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.next;\n        }\n    }\n    forEachReverse(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.tail, i = this.length - 1; !!walker; i--) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.prev;\n        }\n    }\n    get(n) {\n        let i = 0;\n        let walker = this.head;\n        for (; !!walker && i < n; i++) {\n            walker = walker.next;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    getReverse(n) {\n        let i = 0;\n        let walker = this.tail;\n        for (; !!walker && i < n; i++) {\n            // abort out of the list early if we hit a cycle\n            walker = walker.prev;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    map(fn, thisp) {\n        thisp = thisp || this;\n        const res = new Yallist();\n        for (let walker = this.head; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.next;\n        }\n        return res;\n    }\n    mapReverse(fn, thisp) {\n        thisp = thisp || this;\n        var res = new Yallist();\n        for (let walker = this.tail; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.prev;\n        }\n        return res;\n    }\n    reduce(fn, initial) {\n        let acc;\n        let walker = this.head;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.head) {\n            walker = this.head.next;\n            acc = this.head.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (var i = 0; !!walker; i++) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.next;\n        }\n        return acc;\n    }\n    reduceReverse(fn, initial) {\n        let acc;\n        let walker = this.tail;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.tail) {\n            walker = this.tail.prev;\n            acc = this.tail.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (let i = this.length - 1; !!walker; i--) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.prev;\n        }\n        return acc;\n    }\n    toArray() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.head; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.next;\n        }\n        return arr;\n    }\n    toArrayReverse() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.tail; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.prev;\n        }\n        return arr;\n    }\n    slice(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let walker = this.head;\n        let i = 0;\n        for (i = 0; !!walker && i < from; i++) {\n            walker = walker.next;\n        }\n        for (; !!walker && i < to; i++, walker = walker.next) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    sliceReverse(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let i = this.length;\n        let walker = this.tail;\n        for (; !!walker && i > to; i--) {\n            walker = walker.prev;\n        }\n        for (; !!walker && i > from; i--, walker = walker.prev) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    splice(start, deleteCount = 0, ...nodes) {\n        if (start > this.length) {\n            start = this.length - 1;\n        }\n        if (start < 0) {\n            start = this.length + start;\n        }\n        let walker = this.head;\n        for (let i = 0; !!walker && i < start; i++) {\n            walker = walker.next;\n        }\n        const ret = [];\n        for (let i = 0; !!walker && i < deleteCount; i++) {\n            ret.push(walker.value);\n            walker = this.removeNode(walker);\n        }\n        if (!walker) {\n            walker = this.tail;\n        }\n        else if (walker !== this.tail) {\n            walker = walker.prev;\n        }\n        for (const v of nodes) {\n            walker = insertAfter(this, walker, v);\n        }\n        return ret;\n    }\n    reverse() {\n        const head = this.head;\n        const tail = this.tail;\n        for (let walker = head; !!walker; walker = walker.prev) {\n            const p = walker.prev;\n            walker.prev = walker.next;\n            walker.next = p;\n        }\n        this.head = tail;\n        this.tail = head;\n        return this;\n    }\n}\nexports.Yallist = Yallist;\n// insertAfter undefined means \"make the node the new head of list\"\nfunction insertAfter(self, node, value) {\n    const prev = node;\n    const next = node ? node.next : self.head;\n    const inserted = new Node(value, prev, next, self);\n    if (inserted.next === undefined) {\n        self.tail = inserted;\n    }\n    if (inserted.prev === undefined) {\n        self.head = inserted;\n    }\n    self.length++;\n    return inserted;\n}\nfunction push(self, item) {\n    self.tail = new Node(item, self.tail, undefined, self);\n    if (!self.head) {\n        self.head = self.tail;\n    }\n    self.length++;\n}\nfunction unshift(self, item) {\n    self.head = new Node(item, undefined, self.head, self);\n    if (!self.tail) {\n        self.tail = self.head;\n    }\n    self.length++;\n}\nclass Node {\n    list;\n    next;\n    prev;\n    value;\n    constructor(value, prev, next, list) {\n        this.list = list;\n        this.value = value;\n        if (prev) {\n            prev.next = this;\n            this.prev = prev;\n        }\n        else {\n            this.prev = undefined;\n        }\n        if (next) {\n            next.prev = this;\n            this.next = next;\n        }\n        else {\n            this.next = undefined;\n        }\n    }\n}\nexports.Node = Node;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy95YWxsaXN0L2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy95YWxsaXN0L2Rpc3QvY29tbW9uanMvaW5kZXguanM/N2Q0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9kZSA9IGV4cG9ydHMuWWFsbGlzdCA9IHZvaWQgMDtcbmNsYXNzIFlhbGxpc3Qge1xuICAgIHRhaWw7XG4gICAgaGVhZDtcbiAgICBsZW5ndGggPSAwO1xuICAgIHN0YXRpYyBjcmVhdGUobGlzdCA9IFtdKSB7XG4gICAgICAgIHJldHVybiBuZXcgWWFsbGlzdChsaXN0KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlzdCA9IFtdKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgICAgICAgIHlpZWxkIHdhbGtlci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBjb25zdCBwcmV2ID0gbm9kZS5wcmV2O1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgbm9kZS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBub2RlLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUubGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHVuc2hpZnROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxpc3QpIHtcbiAgICAgICAgICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIG5vZGUubGlzdCA9IHRoaXM7XG4gICAgICAgIG5vZGUubmV4dCA9IGhlYWQ7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBoZWFkLnByZXYgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHB1c2hOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxpc3QpIHtcbiAgICAgICAgICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICAgIG5vZGUubGlzdCA9IHRoaXM7XG4gICAgICAgIG5vZGUucHJldiA9IHRhaWw7XG4gICAgICAgIGlmICh0YWlsKSB7XG4gICAgICAgICAgICB0YWlsLm5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHB1c2goLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBwdXNoKHRoaXMsIGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHVuc2hpZnQodGhpcywgYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMudGFpbC52YWx1ZTtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXY7XG4gICAgICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHQubGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVhZDtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGgubGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZm9yRWFjaChmbiwgdGhpc3ApIHtcbiAgICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICAgICAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQsIGkgPSAwOyAhIXdhbGtlcjsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaFJldmVyc2UoZm4sIHRoaXNwKSB7XG4gICAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgICAgZm9yIChsZXQgd2Fsa2VyID0gdGhpcy50YWlsLCBpID0gdGhpcy5sZW5ndGggLSAxOyAhIXdhbGtlcjsgaS0tKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KG4pIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgd2Fsa2VyID0gdGhpcy5oZWFkO1xuICAgICAgICBmb3IgKDsgISF3YWxrZXIgJiYgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gJiYgISF3YWxrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmV2ZXJzZShuKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IHdhbGtlciA9IHRoaXMudGFpbDtcbiAgICAgICAgZm9yICg7ICEhd2Fsa2VyICYmIGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gJiYgISF3YWxrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFwKGZuLCB0aGlzcCkge1xuICAgICAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgISF3YWxrZXI7KSB7XG4gICAgICAgICAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICAgICAgICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIG1hcFJldmVyc2UoZm4sIHRoaXNwKSB7XG4gICAgICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMudGFpbDsgISF3YWxrZXI7KSB7XG4gICAgICAgICAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICAgICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJlZHVjZShmbiwgaW5pdGlhbCkge1xuICAgICAgICBsZXQgYWNjO1xuICAgICAgICBsZXQgd2Fsa2VyID0gdGhpcy5oZWFkO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFjYyA9IGluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgICAgICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAhIXdhbGtlcjsgaSsrKSB7XG4gICAgICAgICAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSk7XG4gICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICByZWR1Y2VSZXZlcnNlKGZuLCBpbml0aWFsKSB7XG4gICAgICAgIGxldCBhY2M7XG4gICAgICAgIGxldCB3YWxrZXIgPSB0aGlzLnRhaWw7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYWNjID0gaW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2O1xuICAgICAgICAgICAgYWNjID0gdGhpcy50YWlsLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoIC0gMTsgISF3YWxrZXI7IGktLSkge1xuICAgICAgICAgICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpO1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgISF3YWxrZXI7IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlO1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgdG9BcnJheVJldmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7ICEhd2Fsa2VyOyBpKyspIHtcbiAgICAgICAgICAgIGFycltpXSA9IHdhbGtlci52YWx1ZTtcbiAgICAgICAgICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20gPSAwLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICAgIHRvICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgZnJvbSArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBuZXcgWWFsbGlzdCgpO1xuICAgICAgICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0byA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgISF3YWxrZXIgJiYgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7ICEhd2Fsa2VyICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgICAgICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBzbGljZVJldmVyc2UoZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICBmcm9tICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBZYWxsaXN0KCk7XG4gICAgICAgIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgbGV0IHdhbGtlciA9IHRoaXMudGFpbDtcbiAgICAgICAgZm9yICg7ICEhd2Fsa2VyICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgISF3YWxrZXIgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCA9IDAsIC4uLm5vZGVzKSB7XG4gICAgICAgIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhbGtlciA9IHRoaXMuaGVhZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7ICEhd2Fsa2VyICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7ICEhd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICAgICAgICAgICAgd2Fsa2VyID0gdGhpcy5yZW1vdmVOb2RlKHdhbGtlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YWxrZXIpIHtcbiAgICAgICAgICAgIHdhbGtlciA9IHRoaXMudGFpbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG5vZGVzKSB7XG4gICAgICAgICAgICB3YWxrZXIgPSBpbnNlcnRBZnRlcih0aGlzLCB3YWxrZXIsIHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICAgIGZvciAobGV0IHdhbGtlciA9IGhlYWQ7ICEhd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgICAgICAgICAgY29uc3QgcCA9IHdhbGtlci5wcmV2O1xuICAgICAgICAgICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgICAgIHdhbGtlci5uZXh0ID0gcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWQgPSB0YWlsO1xuICAgICAgICB0aGlzLnRhaWwgPSBoZWFkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLllhbGxpc3QgPSBZYWxsaXN0O1xuLy8gaW5zZXJ0QWZ0ZXIgdW5kZWZpbmVkIG1lYW5zIFwibWFrZSB0aGUgbm9kZSB0aGUgbmV3IGhlYWQgb2YgbGlzdFwiXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihzZWxmLCBub2RlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByZXYgPSBub2RlO1xuICAgIGNvbnN0IG5leHQgPSBub2RlID8gbm9kZS5uZXh0IDogc2VsZi5oZWFkO1xuICAgIGNvbnN0IGluc2VydGVkID0gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIHNlbGYpO1xuICAgIGlmIChpbnNlcnRlZC5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZi50YWlsID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZC5wcmV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIHNlbGYubGVuZ3RoKys7XG4gICAgcmV0dXJuIGluc2VydGVkO1xufVxuZnVuY3Rpb24gcHVzaChzZWxmLCBpdGVtKSB7XG4gICAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCB1bmRlZmluZWQsIHNlbGYpO1xuICAgIGlmICghc2VsZi5oZWFkKSB7XG4gICAgICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbDtcbiAgICB9XG4gICAgc2VsZi5sZW5ndGgrKztcbn1cbmZ1bmN0aW9uIHVuc2hpZnQoc2VsZiwgaXRlbSkge1xuICAgIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIHVuZGVmaW5lZCwgc2VsZi5oZWFkLCBzZWxmKTtcbiAgICBpZiAoIXNlbGYudGFpbCkge1xuICAgICAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWQ7XG4gICAgfVxuICAgIHNlbGYubGVuZ3RoKys7XG59XG5jbGFzcyBOb2RlIHtcbiAgICBsaXN0O1xuICAgIG5leHQ7XG4gICAgcHJldjtcbiAgICB2YWx1ZTtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dC5wcmV2ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/yallist/dist/commonjs/index.js\n\n}");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLHVGQUF1RixTQUFTLGdCQUFnQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanM/NDFhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSk7XG4gIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG59XG5cbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9XG4gIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgIHJba10gPSBhW2pdO1xuICByZXR1cm4gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gIHZhciBpLCBwO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICByZXR1cm4gY29va2VkO1xufTtcblxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufTtcblxudmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBhciA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgcmV0dXJuIGFyO1xuICB9O1xuICByZXR1cm4gb3duS2V5cyhvKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xuICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudiwgdmFsdWUsIGFzeW5jKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XG4gICAgdmFyIGRpc3Bvc2UsIGlubmVyO1xuICAgIGlmIChhc3luYykge1xuICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG4gICAgfVxuICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgICAgaWYgKGFzeW5jKSBpbm5lciA9IGRpc3Bvc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICBpZiAoaW5uZXIpIGRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgdHJ5IHsgaW5uZXIuY2FsbCh0aGlzKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IH0gfTtcbiAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICB9XG4gIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcbiAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gIH1cbiAgdmFyIHIsIHMgPSAwO1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHdoaWxlIChyID0gZW52LnN0YWNrLnBvcCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXIuYXN5bmMgJiYgcyA9PT0gMSkgcmV0dXJuIHMgPSAwLCBlbnYuc3RhY2sucHVzaChyKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcbiAgICAgICAgaWYgKHIuZGlzcG9zZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByLmRpc3Bvc2UuY2FsbChyLnZhbHVlKTtcbiAgICAgICAgICBpZiAoci5hc3luYykgcmV0dXJuIHMgfD0gMiwgUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcyB8PSAxO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZmFpbChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMgPT09IDEpIHJldHVybiBlbnYuaGFzRXJyb3IgPyBQcm9taXNlLnJlamVjdChlbnYuZXJyb3IpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xuICB9XG4gIHJldHVybiBuZXh0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jld3JpdGVSZWxhdGl2ZUltcG9ydEV4dGVuc2lvbihwYXRoLCBwcmVzZXJ2ZUpzeCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgJiYgL15cXC5cXC4/XFwvLy50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC4odHN4KSR8KCg/OlxcLmQpPykoKD86XFwuW14uL10rPyk/KVxcLihbY21dPyl0cyQvaSwgZnVuY3Rpb24gKG0sIHRzeCwgZCwgZXh0LCBjbSkge1xuICAgICAgICAgIHJldHVybiB0c3ggPyBwcmVzZXJ2ZUpzeCA/IFwiLmpzeFwiIDogXCIuanNcIiA6IGQgJiYgKCFleHQgfHwgIWNtKSA/IG0gOiAoZCArIGV4dCArIFwiLlwiICsgY20udG9Mb3dlckNhc2UoKSArIFwianNcIik7XG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fZXNEZWNvcmF0ZSxcbiAgX19ydW5Jbml0aWFsaXplcnMsXG4gIF9fcHJvcEtleSxcbiAgX19zZXRGdW5jdGlvbk5hbWUsXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxuICBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcbiAgX19kaXNwb3NlUmVzb3VyY2VzLFxuICBfX3Jld3JpdGVSZWxhdGl2ZUltcG9ydEV4dGVuc2lvbixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.mjs\n\n}");

/***/ }),

/***/ "./node_modules/uint8array-extras/index.js":
/*!*************************************************!*\
  !*** ./node_modules/uint8array-extras/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areUint8ArraysEqual: () => (/* binding */ areUint8ArraysEqual),\n/* harmony export */   assertUint8Array: () => (/* binding */ assertUint8Array),\n/* harmony export */   assertUint8ArrayOrArrayBuffer: () => (/* binding */ assertUint8ArrayOrArrayBuffer),\n/* harmony export */   base64ToString: () => (/* binding */ base64ToString),\n/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array),\n/* harmony export */   compareUint8Arrays: () => (/* binding */ compareUint8Arrays),\n/* harmony export */   concatUint8Arrays: () => (/* binding */ concatUint8Arrays),\n/* harmony export */   getUintBE: () => (/* binding */ getUintBE),\n/* harmony export */   hexToUint8Array: () => (/* binding */ hexToUint8Array),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   indexOf: () => (/* binding */ indexOf),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   stringToBase64: () => (/* binding */ stringToBase64),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array),\n/* harmony export */   toUint8Array: () => (/* binding */ toUint8Array),\n/* harmony export */   uint8ArrayToBase64: () => (/* binding */ uint8ArrayToBase64),\n/* harmony export */   uint8ArrayToHex: () => (/* binding */ uint8ArrayToHex),\n/* harmony export */   uint8ArrayToString: () => (/* binding */ uint8ArrayToString)\n/* harmony export */ });\nconst objectToString = Object.prototype.toString;\nconst uint8ArrayStringified = '[object Uint8Array]';\nconst arrayBufferStringified = '[object ArrayBuffer]';\n\nfunction isType(value, typeConstructor, typeStringified) {\n\tif (!value) {\n\t\treturn false;\n\t}\n\n\tif (value.constructor === typeConstructor) {\n\t\treturn true;\n\t}\n\n\treturn objectToString.call(value) === typeStringified;\n}\n\nfunction isUint8Array(value) {\n\treturn isType(value, Uint8Array, uint8ArrayStringified);\n}\n\nfunction isArrayBuffer(value) {\n\treturn isType(value, ArrayBuffer, arrayBufferStringified);\n}\n\nfunction isUint8ArrayOrArrayBuffer(value) {\n\treturn isUint8Array(value) || isArrayBuffer(value);\n}\n\nfunction assertUint8Array(value) {\n\tif (!isUint8Array(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nfunction assertUint8ArrayOrArrayBuffer(value) {\n\tif (!isUint8ArrayOrArrayBuffer(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\` or \\`ArrayBuffer\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nfunction toUint8Array(value) {\n\tif (value instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(value);\n\t}\n\n\tif (ArrayBuffer.isView(value)) {\n\t\treturn new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t}\n\n\tthrow new TypeError(`Unsupported value, got \\`${typeof value}\\`.`);\n}\n\nfunction concatUint8Arrays(arrays, totalLength) {\n\tif (arrays.length === 0) {\n\t\treturn new Uint8Array(0);\n\t}\n\n\ttotalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n\n\tconst returnValue = new Uint8Array(totalLength);\n\n\tlet offset = 0;\n\tfor (const array of arrays) {\n\t\tassertUint8Array(array);\n\t\treturnValue.set(array, offset);\n\t\toffset += array.length;\n\t}\n\n\treturn returnValue;\n}\n\nfunction areUint8ArraysEqual(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line unicorn/no-for-loop\n\tfor (let index = 0; index < a.length; index++) {\n\t\tif (a[index] !== b[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction compareUint8Arrays(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tconst length = Math.min(a.length, b.length);\n\n\tfor (let index = 0; index < length; index++) {\n\t\tconst diff = a[index] - b[index];\n\t\tif (diff !== 0) {\n\t\t\treturn Math.sign(diff);\n\t\t}\n\t}\n\n\t// At this point, all the compared elements are equal.\n\t// The shorter array should come first if the arrays are of different lengths.\n\treturn Math.sign(a.length - b.length);\n}\n\nconst cachedDecoders = {\n\tutf8: new globalThis.TextDecoder('utf8'),\n};\n\nfunction uint8ArrayToString(array, encoding = 'utf8') {\n\tassertUint8ArrayOrArrayBuffer(array);\n\tcachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);\n\treturn cachedDecoders[encoding].decode(array);\n}\n\nfunction assertString(value) {\n\tif (typeof value !== 'string') {\n\t\tthrow new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction stringToUint8Array(string) {\n\tassertString(string);\n\treturn cachedEncoder.encode(string);\n}\n\nfunction base64ToBase64Url(base64) {\n\treturn base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');\n}\n\nfunction base64UrlToBase64(base64url) {\n\treturn base64url.replaceAll('-', '+').replaceAll('_', '/');\n}\n\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\n\nfunction uint8ArrayToBase64(array, {urlSafe = false} = {}) {\n\tassertUint8Array(array);\n\n\tlet base64;\n\n\tif (array.length < MAX_BLOCK_SIZE) {\n\t// Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n\t\tbase64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n\t} else {\n\t\tbase64 = '';\n\t\tfor (const value of array) {\n\t\t\tbase64 += String.fromCodePoint(value);\n\t\t}\n\n\t\tbase64 = globalThis.btoa(base64);\n\t}\n\n\treturn urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nfunction base64ToUint8Array(base64String) {\n\tassertString(base64String);\n\treturn Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), x => x.codePointAt(0));\n}\n\nfunction stringToBase64(string, {urlSafe = false} = {}) {\n\tassertString(string);\n\treturn uint8ArrayToBase64(stringToUint8Array(string), {urlSafe});\n}\n\nfunction base64ToString(base64String) {\n\tassertString(base64String);\n\treturn uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nconst byteToHexLookupTable = Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));\n\nfunction uint8ArrayToHex(array) {\n\tassertUint8Array(array);\n\n\t// Concatenating a string is faster than using an array.\n\tlet hexString = '';\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.\n\tfor (let index = 0; index < array.length; index++) {\n\t\thexString += byteToHexLookupTable[array[index]];\n\t}\n\n\treturn hexString;\n}\n\nconst hexToDecimalLookupTable = {\n\t0: 0,\n\t1: 1,\n\t2: 2,\n\t3: 3,\n\t4: 4,\n\t5: 5,\n\t6: 6,\n\t7: 7,\n\t8: 8,\n\t9: 9,\n\ta: 10,\n\tb: 11,\n\tc: 12,\n\td: 13,\n\te: 14,\n\tf: 15,\n\tA: 10,\n\tB: 11,\n\tC: 12,\n\tD: 13,\n\tE: 14,\n\tF: 15,\n};\n\nfunction hexToUint8Array(hexString) {\n\tassertString(hexString);\n\n\tif (hexString.length % 2 !== 0) {\n\t\tthrow new Error('Invalid Hex string length.');\n\t}\n\n\tconst resultLength = hexString.length / 2;\n\tconst bytes = new Uint8Array(resultLength);\n\n\tfor (let index = 0; index < resultLength; index++) {\n\t\tconst highNibble = hexToDecimalLookupTable[hexString[index * 2]];\n\t\tconst lowNibble = hexToDecimalLookupTable[hexString[(index * 2) + 1]];\n\n\t\tif (highNibble === undefined || lowNibble === undefined) {\n\t\t\tthrow new Error(`Invalid Hex character encountered at position ${index * 2}`);\n\t\t}\n\n\t\tbytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise\n\t}\n\n\treturn bytes;\n}\n\n/**\n@param {DataView} view\n@returns {number}\n*/\nfunction getUintBE(view) {\n\tconst {byteLength} = view;\n\n\tif (byteLength === 6) {\n\t\treturn (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);\n\t}\n\n\tif (byteLength === 5) {\n\t\treturn (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);\n\t}\n\n\tif (byteLength === 4) {\n\t\treturn view.getUint32(0);\n\t}\n\n\tif (byteLength === 3) {\n\t\treturn (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);\n\t}\n\n\tif (byteLength === 2) {\n\t\treturn view.getUint16(0);\n\t}\n\n\tif (byteLength === 1) {\n\t\treturn view.getUint8(0);\n\t}\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {number}\n*/\nfunction indexOf(array, value) {\n\tconst arrayLength = array.length;\n\tconst valueLength = value.length;\n\n\tif (valueLength === 0) {\n\t\treturn -1;\n\t}\n\n\tif (valueLength > arrayLength) {\n\t\treturn -1;\n\t}\n\n\tconst validOffsetLength = arrayLength - valueLength;\n\n\tfor (let index = 0; index <= validOffsetLength; index++) {\n\t\tlet isMatch = true;\n\t\tfor (let index2 = 0; index2 < valueLength; index2++) {\n\t\t\tif (array[index + index2] !== value[index2]) {\n\t\t\t\tisMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (isMatch) {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n@param {Uint8Array} array\n@param {Uint8Array} value\n@returns {boolean}\n*/\nfunction includes(array, value) {\n\treturn indexOf(array, value) !== -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdWludDhhcnJheS1leHRyYXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTtBQUM5RDs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsYUFBYTtBQUNqRTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTyxvQ0FBb0MsaUJBQWlCLElBQUk7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTyxpQ0FBaUMsaUJBQWlCLElBQUk7QUFDN0Q7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsWUFBWTs7QUFFOUM7QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7O0FBRUEsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFVBQVU7QUFDbEIsVUFBVTtBQUNWO0FBQ087QUFDUCxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFlBQVk7QUFDcEIsUUFBUSxZQUFZO0FBQ3BCLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVEsWUFBWTtBQUNwQixRQUFRLFlBQVk7QUFDcEIsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvdWludDhhcnJheS1leHRyYXMvaW5kZXguanM/NmE4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB1aW50OEFycmF5U3RyaW5naWZpZWQgPSAnW29iamVjdCBVaW50OEFycmF5XSc7XG5jb25zdCBhcnJheUJ1ZmZlclN0cmluZ2lmaWVkID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcblxuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlQ29uc3RydWN0b3IsIHR5cGVTdHJpbmdpZmllZCkge1xuXHRpZiAoIXZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB0eXBlQ29uc3RydWN0b3IpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gdHlwZVN0cmluZ2lmaWVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiBpc1R5cGUodmFsdWUsIFVpbnQ4QXJyYXksIHVpbnQ4QXJyYXlTdHJpbmdpZmllZCk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcblx0cmV0dXJuIGlzVHlwZSh2YWx1ZSwgQXJyYXlCdWZmZXIsIGFycmF5QnVmZmVyU3RyaW5naWZpZWQpO1xufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXlPckFycmF5QnVmZmVyKHZhbHVlKSB7XG5cdHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpIHx8IGlzQXJyYXlCdWZmZXIodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VWludDhBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVWludDhBcnJheSh2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBVaW50OEFycmF5XFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVpbnQ4QXJyYXlPckFycmF5QnVmZmVyKHZhbHVlKSB7XG5cdGlmICghaXNVaW50OEFycmF5T3JBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBVaW50OEFycmF5XFxgIG9yIFxcYEFycmF5QnVmZmVyXFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDhBcnJheSh2YWx1ZSkge1xuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZS5idWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpO1xuXHR9XG5cblx0dGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUsIGdvdCBcXGAke3R5cGVvZiB2YWx1ZX1cXGAuYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhhcnJheXMsIHRvdGFsTGVuZ3RoKSB7XG5cdGlmIChhcnJheXMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuXHR9XG5cblx0dG90YWxMZW5ndGggPz89IGFycmF5cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlLmxlbmd0aCwgMCk7XG5cblx0Y29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cblx0bGV0IG9mZnNldCA9IDA7XG5cdGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG5cdFx0YXNzZXJ0VWludDhBcnJheShhcnJheSk7XG5cdFx0cmV0dXJuVmFsdWUuc2V0KGFycmF5LCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVVaW50OEFycmF5c0VxdWFsKGEsIGIpIHtcblx0YXNzZXJ0VWludDhBcnJheShhKTtcblx0YXNzZXJ0VWludDhBcnJheShiKTtcblxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZvci1sb29wXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdGlmIChhW2luZGV4XSAhPT0gYltpbmRleF0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVVaW50OEFycmF5cyhhLCBiKSB7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYSk7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYik7XG5cblx0Y29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3QgZGlmZiA9IGFbaW5kZXhdIC0gYltpbmRleF07XG5cdFx0aWYgKGRpZmYgIT09IDApIHtcblx0XHRcdHJldHVybiBNYXRoLnNpZ24oZGlmZik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQXQgdGhpcyBwb2ludCwgYWxsIHRoZSBjb21wYXJlZCBlbGVtZW50cyBhcmUgZXF1YWwuXG5cdC8vIFRoZSBzaG9ydGVyIGFycmF5IHNob3VsZCBjb21lIGZpcnN0IGlmIHRoZSBhcnJheXMgYXJlIG9mIGRpZmZlcmVudCBsZW5ndGhzLlxuXHRyZXR1cm4gTWF0aC5zaWduKGEubGVuZ3RoIC0gYi5sZW5ndGgpO1xufVxuXG5jb25zdCBjYWNoZWREZWNvZGVycyA9IHtcblx0dXRmODogbmV3IGdsb2JhbFRoaXMuVGV4dERlY29kZXIoJ3V0ZjgnKSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9TdHJpbmcoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG5cdGFzc2VydFVpbnQ4QXJyYXlPckFycmF5QnVmZmVyKGFycmF5KTtcblx0Y2FjaGVkRGVjb2RlcnNbZW5jb2RpbmddID8/PSBuZXcgZ2xvYmFsVGhpcy5UZXh0RGVjb2RlcihlbmNvZGluZyk7XG5cdHJldHVybiBjYWNoZWREZWNvZGVyc1tlbmNvZGluZ10uZGVjb2RlKGFycmF5KTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG5cdH1cbn1cblxuY29uc3QgY2FjaGVkRW5jb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHRFbmNvZGVyKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXkoc3RyaW5nKSB7XG5cdGFzc2VydFN0cmluZyhzdHJpbmcpO1xuXHRyZXR1cm4gY2FjaGVkRW5jb2Rlci5lbmNvZGUoc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSB7XG5cdHJldHVybiBiYXNlNjQucmVwbGFjZUFsbCgnKycsICctJykucmVwbGFjZUFsbCgnLycsICdfJykucmVwbGFjZSgvPSskLywgJycpO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRVcmxUb0Jhc2U2NChiYXNlNjR1cmwpIHtcblx0cmV0dXJuIGJhc2U2NHVybC5yZXBsYWNlQWxsKCctJywgJysnKS5yZXBsYWNlQWxsKCdfJywgJy8nKTtcbn1cblxuLy8gUmVmZXJlbmNlOiBodHRwczovL3BodW9jLm5nL2NvbGxlY3Rpb24vdGhpcy12cy10aGF0L2NvbmNhdC12cy1wdXNoL1xuY29uc3QgTUFYX0JMT0NLX1NJWkUgPSA2NV81MzU7XG5cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9CYXNlNjQoYXJyYXksIHt1cmxTYWZlID0gZmFsc2V9ID0ge30pIHtcblx0YXNzZXJ0VWludDhBcnJheShhcnJheSk7XG5cblx0bGV0IGJhc2U2NDtcblxuXHRpZiAoYXJyYXkubGVuZ3RoIDwgTUFYX0JMT0NLX1NJWkUpIHtcblx0Ly8gUmVxdWlyZWQgYXMgYGJ0b2FgIGFuZCBgYXRvYmAgZG9uJ3QgcHJvcGVybHkgc3VwcG9ydCBVbmljb2RlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCN0aGVfdW5pY29kZV9wcm9ibGVtXG5cdFx0YmFzZTY0ID0gZ2xvYmFsVGhpcy5idG9hKFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KHRoaXMsIGFycmF5KSk7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZTY0ID0gJyc7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuXHRcdFx0YmFzZTY0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHZhbHVlKTtcblx0XHR9XG5cblx0XHRiYXNlNjQgPSBnbG9iYWxUaGlzLmJ0b2EoYmFzZTY0KTtcblx0fVxuXG5cdHJldHVybiB1cmxTYWZlID8gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSA6IGJhc2U2NDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcblx0YXNzZXJ0U3RyaW5nKGJhc2U2NFN0cmluZyk7XG5cdHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5hdG9iKGJhc2U2NFVybFRvQmFzZTY0KGJhc2U2NFN0cmluZykpLCB4ID0+IHguY29kZVBvaW50QXQoMCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjQoc3RyaW5nLCB7dXJsU2FmZSA9IGZhbHNlfSA9IHt9KSB7XG5cdGFzc2VydFN0cmluZyhzdHJpbmcpO1xuXHRyZXR1cm4gdWludDhBcnJheVRvQmFzZTY0KHN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpLCB7dXJsU2FmZX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9TdHJpbmcoYmFzZTY0U3RyaW5nKSB7XG5cdGFzc2VydFN0cmluZyhiYXNlNjRTdHJpbmcpO1xuXHRyZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpKTtcbn1cblxuY29uc3QgYnl0ZVRvSGV4TG9va3VwVGFibGUgPSBBcnJheS5mcm9tKHtsZW5ndGg6IDI1Nn0sIChfLCBpbmRleCkgPT4gaW5kZXgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuXG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvSGV4KGFycmF5KSB7XG5cdGFzc2VydFVpbnQ4QXJyYXkoYXJyYXkpO1xuXG5cdC8vIENvbmNhdGVuYXRpbmcgYSBzdHJpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgYW4gYXJyYXkuXG5cdGxldCBoZXhTdHJpbmcgPSAnJztcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcCAtLSBNYXggcGVyZm9ybWFuY2UgaXMgY3JpdGljYWwuXG5cdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRoZXhTdHJpbmcgKz0gYnl0ZVRvSGV4TG9va3VwVGFibGVbYXJyYXlbaW5kZXhdXTtcblx0fVxuXG5cdHJldHVybiBoZXhTdHJpbmc7XG59XG5cbmNvbnN0IGhleFRvRGVjaW1hbExvb2t1cFRhYmxlID0ge1xuXHQwOiAwLFxuXHQxOiAxLFxuXHQyOiAyLFxuXHQzOiAzLFxuXHQ0OiA0LFxuXHQ1OiA1LFxuXHQ2OiA2LFxuXHQ3OiA3LFxuXHQ4OiA4LFxuXHQ5OiA5LFxuXHRhOiAxMCxcblx0YjogMTEsXG5cdGM6IDEyLFxuXHRkOiAxMyxcblx0ZTogMTQsXG5cdGY6IDE1LFxuXHRBOiAxMCxcblx0QjogMTEsXG5cdEM6IDEyLFxuXHREOiAxMyxcblx0RTogMTQsXG5cdEY6IDE1LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvVWludDhBcnJheShoZXhTdHJpbmcpIHtcblx0YXNzZXJ0U3RyaW5nKGhleFN0cmluZyk7XG5cblx0aWYgKGhleFN0cmluZy5sZW5ndGggJSAyICE9PSAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhleCBzdHJpbmcgbGVuZ3RoLicpO1xuXHR9XG5cblx0Y29uc3QgcmVzdWx0TGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG5cdGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0TGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0TGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0Y29uc3QgaGlnaE5pYmJsZSA9IGhleFRvRGVjaW1hbExvb2t1cFRhYmxlW2hleFN0cmluZ1tpbmRleCAqIDJdXTtcblx0XHRjb25zdCBsb3dOaWJibGUgPSBoZXhUb0RlY2ltYWxMb29rdXBUYWJsZVtoZXhTdHJpbmdbKGluZGV4ICogMikgKyAxXV07XG5cblx0XHRpZiAoaGlnaE5pYmJsZSA9PT0gdW5kZWZpbmVkIHx8IGxvd05pYmJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSGV4IGNoYXJhY3RlciBlbmNvdW50ZXJlZCBhdCBwb3NpdGlvbiAke2luZGV4ICogMn1gKTtcblx0XHR9XG5cblx0XHRieXRlc1tpbmRleF0gPSAoaGlnaE5pYmJsZSA8PCA0KSB8IGxvd05pYmJsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cdH1cblxuXHRyZXR1cm4gYnl0ZXM7XG59XG5cbi8qKlxuQHBhcmFtIHtEYXRhVmlld30gdmlld1xuQHJldHVybnMge251bWJlcn1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludEJFKHZpZXcpIHtcblx0Y29uc3Qge2J5dGVMZW5ndGh9ID0gdmlldztcblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gNikge1xuXHRcdHJldHVybiAodmlldy5nZXRVaW50MTYoMCkgKiAoMiAqKiAzMikpICsgdmlldy5nZXRVaW50MzIoMik7XG5cdH1cblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gNSkge1xuXHRcdHJldHVybiAodmlldy5nZXRVaW50OCgwKSAqICgyICoqIDMyKSkgKyB2aWV3LmdldFVpbnQzMigxKTtcblx0fVxuXG5cdGlmIChieXRlTGVuZ3RoID09PSA0KSB7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0VWludDMyKDApO1xuXHR9XG5cblx0aWYgKGJ5dGVMZW5ndGggPT09IDMpIHtcblx0XHRyZXR1cm4gKHZpZXcuZ2V0VWludDgoMCkgKiAoMiAqKiAxNikpICsgdmlldy5nZXRVaW50MTYoMSk7XG5cdH1cblxuXHRpZiAoYnl0ZUxlbmd0aCA9PT0gMikge1xuXHRcdHJldHVybiB2aWV3LmdldFVpbnQxNigwKTtcblx0fVxuXG5cdGlmIChieXRlTGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0VWludDgoMCk7XG5cdH1cbn1cblxuLyoqXG5AcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5XG5AcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG5AcmV0dXJucyB7bnVtYmVyfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRjb25zdCBhcnJheUxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0Y29uc3QgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cblx0aWYgKHZhbHVlTGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0aWYgKHZhbHVlTGVuZ3RoID4gYXJyYXlMZW5ndGgpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRjb25zdCB2YWxpZE9mZnNldExlbmd0aCA9IGFycmF5TGVuZ3RoIC0gdmFsdWVMZW5ndGg7XG5cblx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8PSB2YWxpZE9mZnNldExlbmd0aDsgaW5kZXgrKykge1xuXHRcdGxldCBpc01hdGNoID0gdHJ1ZTtcblx0XHRmb3IgKGxldCBpbmRleDIgPSAwOyBpbmRleDIgPCB2YWx1ZUxlbmd0aDsgaW5kZXgyKyspIHtcblx0XHRcdGlmIChhcnJheVtpbmRleCArIGluZGV4Ml0gIT09IHZhbHVlW2luZGV4Ml0pIHtcblx0XHRcdFx0aXNNYXRjaCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNNYXRjaCkge1xuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAtMTtcbn1cblxuLyoqXG5AcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5XG5AcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG5AcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG5cdHJldHVybiBpbmRleE9mKGFycmF5LCB2YWx1ZSkgIT09IC0xO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uint8array-extras/index.js\n\n}");

/***/ }),

/***/ "./node_modules/when-exit/dist/node/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/when-exit/dist/node/constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IS_LINUX: () => (/* binding */ IS_LINUX),\n/* harmony export */   IS_WINDOWS: () => (/* binding */ IS_WINDOWS)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* IMPORT */\n\n/* MAIN */\nconst IS_LINUX = (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'linux');\nconst IS_WINDOWS = (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32');\n/* EXPORT */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDbUM7QUFDbkM7QUFDQSxrQkFBa0Isa0RBQWdCO0FBQ2xDLG9CQUFvQixrREFBZ0I7QUFDcEM7QUFDZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL25vZGVfbW9kdWxlcy93aGVuLWV4aXQvZGlzdC9ub2RlL2NvbnN0YW50cy5qcz81YTA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbi8qIE1BSU4gKi9cbmNvbnN0IElTX0xJTlVYID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpO1xuY29uc3QgSVNfV0lORE9XUyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IHsgSVNfTElOVVgsIElTX1dJTkRPV1MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/when-exit/dist/node/constants.js\n\n}");

/***/ }),

/***/ "./node_modules/when-exit/dist/node/index.js":
/*!***************************************************!*\
  !*** ./node_modules/when-exit/dist/node/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _interceptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interceptor.js */ \"./node_modules/when-exit/dist/node/interceptor.js\");\n/* IMPORT */\n\n/* MAIN */\nconst whenExit = _interceptor_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].register;\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (whenExit);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzJDO0FBQzNDO0FBQ0EsaUJBQWlCLHVEQUFXO0FBQzVCO0FBQ0EsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9pbmRleC5qcz8xZTUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IEludGVyY2VwdG9yIGZyb20gJy4vaW50ZXJjZXB0b3IuanMnO1xuLyogTUFJTiAqL1xuY29uc3Qgd2hlbkV4aXQgPSBJbnRlcmNlcHRvci5yZWdpc3Rlcjtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0IGRlZmF1bHQgd2hlbkV4aXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/when-exit/dist/node/index.js\n\n}");

/***/ }),

/***/ "./node_modules/when-exit/dist/node/interceptor.js":
/*!*********************************************************!*\
  !*** ./node_modules/when-exit/dist/node/interceptor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/when-exit/dist/node/constants.js\");\n/* harmony import */ var _signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signals.js */ \"./node_modules/when-exit/dist/node/signals.js\");\n/* IMPORT */\n\n\n\n/* MAIN */\nclass Interceptor {\n    /* CONSTRUCTOR */\n    constructor() {\n        /* VARIABLES */\n        this.callbacks = new Set();\n        this.exited = false;\n        /* API */\n        this.exit = (signal) => {\n            if (this.exited)\n                return;\n            this.exited = true;\n            for (const callback of this.callbacks) {\n                callback();\n            }\n            if (signal) {\n                if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.IS_WINDOWS && (signal !== 'SIGINT' && signal !== 'SIGTERM' && signal !== 'SIGKILL')) { // Windows doesn't support POSIX signals, but Node emulates these 3 signals for us\n                    node_process__WEBPACK_IMPORTED_MODULE_0__.kill(node_process__WEBPACK_IMPORTED_MODULE_0__.pid, 'SIGTERM');\n                }\n                else {\n                    node_process__WEBPACK_IMPORTED_MODULE_0__.kill(node_process__WEBPACK_IMPORTED_MODULE_0__.pid, signal);\n                }\n            }\n        };\n        this.hook = () => {\n            node_process__WEBPACK_IMPORTED_MODULE_0__.once('exit', () => this.exit());\n            for (const signal of _signals_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n                try {\n                    node_process__WEBPACK_IMPORTED_MODULE_0__.once(signal, () => this.exit(signal));\n                }\n                catch {\n                    // Sometimes \"process.once\" can throw...\n                }\n            }\n        };\n        this.register = (callback) => {\n            this.callbacks.add(callback);\n            return () => {\n                this.callbacks.delete(callback);\n            };\n        };\n        this.hook();\n    }\n}\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Interceptor());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDbUM7QUFDUztBQUNUO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVLDZFQUE2RTtBQUMzRyxvQkFBb0IsOENBQVksQ0FBQyw2Q0FBVztBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLDhDQUFZLENBQUMsNkNBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUFZO0FBQ3hCLGlDQUFpQyxtREFBTztBQUN4QztBQUNBLG9CQUFvQiw4Q0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9pbnRlcmNlcHRvci5qcz8yOGFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIElNUE9SVCAqL1xuaW1wb3J0IHByb2Nlc3MgZnJvbSAnbm9kZTpwcm9jZXNzJztcbmltcG9ydCB7IElTX1dJTkRPV1MgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgU2lnbmFscyBmcm9tICcuL3NpZ25hbHMuanMnO1xuLyogTUFJTiAqL1xuY2xhc3MgSW50ZXJjZXB0b3Ige1xuICAgIC8qIENPTlNUUlVDVE9SICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qIFZBUklBQkxFUyAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leGl0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyogQVBJICovXG4gICAgICAgIHRoaXMuZXhpdCA9IChzaWduYWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoSVNfV0lORE9XUyAmJiAoc2lnbmFsICE9PSAnU0lHSU5UJyAmJiBzaWduYWwgIT09ICdTSUdURVJNJyAmJiBzaWduYWwgIT09ICdTSUdLSUxMJykpIHsgLy8gV2luZG93cyBkb2Vzbid0IHN1cHBvcnQgUE9TSVggc2lnbmFscywgYnV0IE5vZGUgZW11bGF0ZXMgdGhlc2UgMyBzaWduYWxzIGZvciB1c1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsICdTSUdURVJNJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwocHJvY2Vzcy5waWQsIHNpZ25hbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhvb2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLm9uY2UoJ2V4aXQnLCAoKSA9PiB0aGlzLmV4aXQoKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBTaWduYWxzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5vbmNlKHNpZ25hbCwgKCkgPT4gdGhpcy5leGl0KHNpZ25hbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBcInByb2Nlc3Mub25jZVwiIGNhbiB0aHJvdy4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaG9vaygpO1xuICAgIH1cbn1cbi8qIEVYUE9SVCAqL1xuZXhwb3J0IGRlZmF1bHQgbmV3IEludGVyY2VwdG9yKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/when-exit/dist/node/interceptor.js\n\n}");

/***/ }),

/***/ "./node_modules/when-exit/dist/node/signals.js":
/*!*****************************************************!*\
  !*** ./node_modules/when-exit/dist/node/signals.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/when-exit/dist/node/constants.js\");\n/* IMPORT */\n\n/* MAIN */\n//URL: https://github.com/tapjs/signal-exit/blob/03dd77a96caa309c6a02c59274d58c812a2dce45/signals.js\nconst Signals = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\nif (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_WINDOWS) {\n    Signals.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');\n}\nif (_constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LINUX) {\n    Signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n}\n/* EXPORT */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Signals);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9zaWduYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxREFBVTtBQUNmO0FBQ0E7QUFDQSxJQUFJLG1EQUFRO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9ub2RlX21vZHVsZXMvd2hlbi1leGl0L2Rpc3Qvbm9kZS9zaWduYWxzLmpzPzU2MWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogSU1QT1JUICovXG5pbXBvcnQgeyBJU19MSU5VWCwgSVNfV0lORE9XUyB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbi8qIE1BSU4gKi9cbi8vVVJMOiBodHRwczovL2dpdGh1Yi5jb20vdGFwanMvc2lnbmFsLWV4aXQvYmxvYi8wM2RkNzdhOTZjYWEzMDljNmEwMmM1OTI3NGQ1OGM4MTJhMmRjZTQ1L3NpZ25hbHMuanNcbmNvbnN0IFNpZ25hbHMgPSBbJ1NJR0FCUlQnLCAnU0lHQUxSTScsICdTSUdIVVAnLCAnU0lHSU5UJywgJ1NJR1RFUk0nXTtcbmlmICghSVNfV0lORE9XUykge1xuICAgIFNpZ25hbHMucHVzaCgnU0lHVlRBTFJNJywgJ1NJR1hDUFUnLCAnU0lHWEZTWicsICdTSUdVU1IyJywgJ1NJR1RSQVAnLCAnU0lHU1lTJywgJ1NJR1FVSVQnLCAnU0lHSU9UJyk7XG59XG5pZiAoSVNfTElOVVgpIHtcbiAgICBTaWduYWxzLnB1c2goJ1NJR0lPJywgJ1NJR1BPTEwnLCAnU0lHUFdSJywgJ1NJR1NUS0ZMVCcsICdTSUdVTlVTRUQnKTtcbn1cbi8qIEVYUE9SVCAqL1xuZXhwb3J0IGRlZmF1bHQgU2lnbmFscztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/when-exit/dist/node/signals.js\n\n}");

/***/ }),

/***/ "./src/backend/config/dependency-config.ts":
/*!*************************************************!*\
  !*** ./src/backend/config/dependency-config.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Platform-specific dependency configuration\n * Defines download URLs and file information for yt-dlp and FFmpeg on different platforms\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDependencyConfig = getDependencyConfig;\nexports.getDependenciesDirectory = getDependenciesDirectory;\nexports.getDependencyDirectory = getDependencyDirectory;\nexports.getDependencyExecutablePath = getDependencyExecutablePath;\nexports.isPlatformSupported = isPlatformSupported;\nexports.getExecutablePermissions = getExecutablePermissions;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst os = tslib_1.__importStar(__webpack_require__(/*! os */ \"os\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst PLATFORM = os.platform();\nconst ARCH = os.arch();\n/**\n * Get platform-specific dependency configuration\n */\nfunction getDependencyConfig() {\n    switch (PLATFORM) {\n        case 'win32':\n            return getWindowsConfig();\n        case 'darwin':\n            return getMacOSConfig();\n        case 'linux':\n            return getLinuxConfig();\n        default:\n            throw new Error(`Unsupported platform: ${PLATFORM}`);\n    }\n}\nfunction getWindowsConfig() {\n    return {\n        ytdlp: {\n            downloadUrl: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp.exe',\n            filename: 'yt-dlp.exe',\n            executable: 'yt-dlp.exe',\n        },\n        ffmpeg: {\n            downloadUrl: ARCH === 'x64'\n                ? 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\n                : 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win32-gpl.zip',\n            filename: ARCH === 'x64' ? 'ffmpeg-win64-gpl.zip' : 'ffmpeg-win32-gpl.zip',\n            executable: 'ffmpeg.exe',\n        },\n    };\n}\nfunction getMacOSConfig() {\n    return {\n        ytdlp: {\n            downloadUrl: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp_macos',\n            filename: 'yt-dlp',\n            executable: 'yt-dlp',\n        },\n        ffmpeg: {\n            downloadUrl: ARCH === 'arm64'\n                ? 'https://evermeet.cx/ffmpeg/getrelease/zip'\n                : 'https://evermeet.cx/ffmpeg/getrelease/zip',\n            filename: 'ffmpeg-macos.zip',\n            executable: 'ffmpeg',\n        },\n    };\n}\nfunction getLinuxConfig() {\n    return {\n        ytdlp: {\n            downloadUrl: 'https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp',\n            filename: 'yt-dlp',\n            executable: 'yt-dlp',\n        },\n        ffmpeg: {\n            downloadUrl: ARCH === 'x64'\n                ? 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz'\n                : 'https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-i686-static.tar.xz',\n            filename: ARCH === 'x64' ? 'ffmpeg-linux-amd64.tar.xz' : 'ffmpeg-linux-i686.tar.xz',\n            executable: 'ffmpeg',\n        },\n    };\n}\n/**\n * Get the dependencies directory path\n */\nfunction getDependenciesDirectory() {\n    const { app } = __webpack_require__(/*! electron */ \"electron\");\n    const userDataPath = app.getPath('userData');\n    return path.join(userDataPath, 'dependencies');\n}\n/**\n * Get the path for a specific dependency\n */\nfunction getDependencyDirectory(dependencyName) {\n    return path.join(getDependenciesDirectory(), dependencyName);\n}\n/**\n * Get the full path to a dependency executable\n */\nfunction getDependencyExecutablePath(dependencyName) {\n    const config = getDependencyConfig();\n    const dependencyDir = getDependencyDirectory(dependencyName);\n    if (dependencyName === 'ytdlp') {\n        return path.join(dependencyDir, 'bin', config.ytdlp.executable);\n    }\n    else {\n        return path.join(dependencyDir, 'bin', config.ffmpeg.executable);\n    }\n}\n/**\n * Check if the current platform is supported\n */\nfunction isPlatformSupported() {\n    return ['win32', 'darwin', 'linux'].includes(PLATFORM);\n}\n/**\n * Get platform-specific file permissions for executables\n */\nfunction getExecutablePermissions() {\n    return PLATFORM === 'win32' ? 0o755 : 0o755;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9jb25maWcvZGVwZW5kZW5jeS1jb25maWcudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7QUFZSCxrREFXQztBQXdERCw0REFJQztBQUtELHdEQUVDO0FBS0Qsa0VBU0M7QUFLRCxrREFFQztBQUtELDREQUVDOztBQXBIRCxxRUFBeUI7QUFDekIsMkVBQTZCO0FBRzdCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUMvQixNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFFdkI7O0dBRUc7QUFDSCxTQUFnQixtQkFBbUI7SUFDakMsUUFBUSxRQUFRLEVBQUUsQ0FBQztRQUNqQixLQUFLLE9BQU87WUFDVixPQUFPLGdCQUFnQixFQUFFLENBQUM7UUFDNUIsS0FBSyxRQUFRO1lBQ1gsT0FBTyxjQUFjLEVBQUUsQ0FBQztRQUMxQixLQUFLLE9BQU87WUFDVixPQUFPLGNBQWMsRUFBRSxDQUFDO1FBQzFCO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsZ0JBQWdCO0lBQ3ZCLE9BQU87UUFDTCxLQUFLLEVBQUU7WUFDTCxXQUFXLEVBQUUsc0VBQXNFO1lBQ25GLFFBQVEsRUFBRSxZQUFZO1lBQ3RCLFVBQVUsRUFBRSxZQUFZO1NBQ3pCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sV0FBVyxFQUFFLElBQUksS0FBSyxLQUFLO2dCQUN6QixDQUFDLENBQUMsbUdBQW1HO2dCQUNyRyxDQUFDLENBQUMsbUdBQW1HO1lBQ3ZHLFFBQVEsRUFBRSxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsc0JBQXNCO1lBQzFFLFVBQVUsRUFBRSxZQUFZO1NBQ3pCO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLGNBQWM7SUFDckIsT0FBTztRQUNMLEtBQUssRUFBRTtZQUNMLFdBQVcsRUFBRSx3RUFBd0U7WUFDckYsUUFBUSxFQUFFLFFBQVE7WUFDbEIsVUFBVSxFQUFFLFFBQVE7U0FDckI7UUFDRCxNQUFNLEVBQUU7WUFDTixXQUFXLEVBQUUsSUFBSSxLQUFLLE9BQU87Z0JBQzNCLENBQUMsQ0FBQywyQ0FBMkM7Z0JBQzdDLENBQUMsQ0FBQywyQ0FBMkM7WUFDL0MsUUFBUSxFQUFFLGtCQUFrQjtZQUM1QixVQUFVLEVBQUUsUUFBUTtTQUNyQjtLQUNGLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxjQUFjO0lBQ3JCLE9BQU87UUFDTCxLQUFLLEVBQUU7WUFDTCxXQUFXLEVBQUUsa0VBQWtFO1lBQy9FLFFBQVEsRUFBRSxRQUFRO1lBQ2xCLFVBQVUsRUFBRSxRQUFRO1NBQ3JCO1FBQ0QsTUFBTSxFQUFFO1lBQ04sV0FBVyxFQUFFLElBQUksS0FBSyxLQUFLO2dCQUN6QixDQUFDLENBQUMsOEVBQThFO2dCQUNoRixDQUFDLENBQUMsNkVBQTZFO1lBQ2pGLFFBQVEsRUFBRSxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUMsMEJBQTBCO1lBQ25GLFVBQVUsRUFBRSxRQUFRO1NBQ3JCO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHdCQUF3QjtJQUN0QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsbUJBQU8sQ0FBQywwQkFBVSxDQUFDLENBQUM7SUFDcEMsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM3QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLGNBQWtDO0lBQ3ZFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLDJCQUEyQixDQUFDLGNBQWtDO0lBQzVFLE1BQU0sTUFBTSxHQUFHLG1CQUFtQixFQUFFLENBQUM7SUFDckMsTUFBTSxhQUFhLEdBQUcsc0JBQXNCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFFN0QsSUFBSSxjQUFjLEtBQUssT0FBTyxFQUFFLENBQUM7UUFDL0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsRSxDQUFDO1NBQU0sQ0FBQztRQUNOLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbkUsQ0FBQztBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLG1CQUFtQjtJQUNqQyxPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDekQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isd0JBQXdCO0lBQ3RDLE9BQU8sUUFBUSxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDOUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vc3JjL2JhY2tlbmQvY29uZmlnL2RlcGVuZGVuY3ktY29uZmlnLnRzP2MzNDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFBsYXRmb3JtLXNwZWNpZmljIGRlcGVuZGVuY3kgY29uZmlndXJhdGlvblxyXG4gKiBEZWZpbmVzIGRvd25sb2FkIFVSTHMgYW5kIGZpbGUgaW5mb3JtYXRpb24gZm9yIHl0LWRscCBhbmQgRkZtcGVnIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB0eXBlIHsgUGxhdGZvcm1EZXBlbmRlbmN5Q29uZmlnIH0gZnJvbSAnQC9zaGFyZWQvaW50ZXJmYWNlcy9kZXBlbmRlbmN5LW1hbmFnZXInO1xyXG5cclxuY29uc3QgUExBVEZPUk0gPSBvcy5wbGF0Zm9ybSgpO1xyXG5jb25zdCBBUkNIID0gb3MuYXJjaCgpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBwbGF0Zm9ybS1zcGVjaWZpYyBkZXBlbmRlbmN5IGNvbmZpZ3VyYXRpb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRlbmN5Q29uZmlnKCk6IFBsYXRmb3JtRGVwZW5kZW5jeUNvbmZpZyB7XHJcbiAgc3dpdGNoIChQTEFURk9STSkge1xyXG4gICAgY2FzZSAnd2luMzInOlxyXG4gICAgICByZXR1cm4gZ2V0V2luZG93c0NvbmZpZygpO1xyXG4gICAgY2FzZSAnZGFyd2luJzpcclxuICAgICAgcmV0dXJuIGdldE1hY09TQ29uZmlnKCk7XHJcbiAgICBjYXNlICdsaW51eCc6XHJcbiAgICAgIHJldHVybiBnZXRMaW51eENvbmZpZygpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwbGF0Zm9ybTogJHtQTEFURk9STX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdpbmRvd3NDb25maWcoKTogUGxhdGZvcm1EZXBlbmRlbmN5Q29uZmlnIHtcclxuICByZXR1cm4ge1xyXG4gICAgeXRkbHA6IHtcclxuICAgICAgZG93bmxvYWRVcmw6ICdodHRwczovL2dpdGh1Yi5jb20veXQtZGxwL3l0LWRscC9yZWxlYXNlcy9sYXRlc3QvZG93bmxvYWQveXQtZGxwLmV4ZScsXHJcbiAgICAgIGZpbGVuYW1lOiAneXQtZGxwLmV4ZScsXHJcbiAgICAgIGV4ZWN1dGFibGU6ICd5dC1kbHAuZXhlJyxcclxuICAgIH0sXHJcbiAgICBmZm1wZWc6IHtcclxuICAgICAgZG93bmxvYWRVcmw6IEFSQ0ggPT09ICd4NjQnIFxyXG4gICAgICAgID8gJ2h0dHBzOi8vZ2l0aHViLmNvbS9CdGJOL0ZGbXBlZy1CdWlsZHMvcmVsZWFzZXMvZG93bmxvYWQvbGF0ZXN0L2ZmbXBlZy1tYXN0ZXItbGF0ZXN0LXdpbjY0LWdwbC56aXAnXHJcbiAgICAgICAgOiAnaHR0cHM6Ly9naXRodWIuY29tL0J0Yk4vRkZtcGVnLUJ1aWxkcy9yZWxlYXNlcy9kb3dubG9hZC9sYXRlc3QvZmZtcGVnLW1hc3Rlci1sYXRlc3Qtd2luMzItZ3BsLnppcCcsXHJcbiAgICAgIGZpbGVuYW1lOiBBUkNIID09PSAneDY0JyA/ICdmZm1wZWctd2luNjQtZ3BsLnppcCcgOiAnZmZtcGVnLXdpbjMyLWdwbC56aXAnLFxyXG4gICAgICBleGVjdXRhYmxlOiAnZmZtcGVnLmV4ZScsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1hY09TQ29uZmlnKCk6IFBsYXRmb3JtRGVwZW5kZW5jeUNvbmZpZyB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHl0ZGxwOiB7XHJcbiAgICAgIGRvd25sb2FkVXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL3l0LWRscC95dC1kbHAvcmVsZWFzZXMvbGF0ZXN0L2Rvd25sb2FkL3l0LWRscF9tYWNvcycsXHJcbiAgICAgIGZpbGVuYW1lOiAneXQtZGxwJyxcclxuICAgICAgZXhlY3V0YWJsZTogJ3l0LWRscCcsXHJcbiAgICB9LFxyXG4gICAgZmZtcGVnOiB7XHJcbiAgICAgIGRvd25sb2FkVXJsOiBBUkNIID09PSAnYXJtNjQnXHJcbiAgICAgICAgPyAnaHR0cHM6Ly9ldmVybWVldC5jeC9mZm1wZWcvZ2V0cmVsZWFzZS96aXAnXHJcbiAgICAgICAgOiAnaHR0cHM6Ly9ldmVybWVldC5jeC9mZm1wZWcvZ2V0cmVsZWFzZS96aXAnLFxyXG4gICAgICBmaWxlbmFtZTogJ2ZmbXBlZy1tYWNvcy56aXAnLFxyXG4gICAgICBleGVjdXRhYmxlOiAnZmZtcGVnJyxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGludXhDb25maWcoKTogUGxhdGZvcm1EZXBlbmRlbmN5Q29uZmlnIHtcclxuICByZXR1cm4ge1xyXG4gICAgeXRkbHA6IHtcclxuICAgICAgZG93bmxvYWRVcmw6ICdodHRwczovL2dpdGh1Yi5jb20veXQtZGxwL3l0LWRscC9yZWxlYXNlcy9sYXRlc3QvZG93bmxvYWQveXQtZGxwJyxcclxuICAgICAgZmlsZW5hbWU6ICd5dC1kbHAnLFxyXG4gICAgICBleGVjdXRhYmxlOiAneXQtZGxwJyxcclxuICAgIH0sXHJcbiAgICBmZm1wZWc6IHtcclxuICAgICAgZG93bmxvYWRVcmw6IEFSQ0ggPT09ICd4NjQnXHJcbiAgICAgICAgPyAnaHR0cHM6Ly9qb2hudmFuc2lja2xlLmNvbS9mZm1wZWcvcmVsZWFzZXMvZmZtcGVnLXJlbGVhc2UtYW1kNjQtc3RhdGljLnRhci54eidcclxuICAgICAgICA6ICdodHRwczovL2pvaG52YW5zaWNrbGUuY29tL2ZmbXBlZy9yZWxlYXNlcy9mZm1wZWctcmVsZWFzZS1pNjg2LXN0YXRpYy50YXIueHonLFxyXG4gICAgICBmaWxlbmFtZTogQVJDSCA9PT0gJ3g2NCcgPyAnZmZtcGVnLWxpbnV4LWFtZDY0LnRhci54eicgOiAnZmZtcGVnLWxpbnV4LWk2ODYudGFyLnh6JyxcclxuICAgICAgZXhlY3V0YWJsZTogJ2ZmbXBlZycsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRlcGVuZGVuY2llcyBkaXJlY3RvcnkgcGF0aFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZGVuY2llc0RpcmVjdG9yeSgpOiBzdHJpbmcge1xyXG4gIGNvbnN0IHsgYXBwIH0gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xyXG4gIGNvbnN0IHVzZXJEYXRhUGF0aCA9IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpO1xyXG4gIHJldHVybiBwYXRoLmpvaW4odXNlckRhdGFQYXRoLCAnZGVwZW5kZW5jaWVzJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHBhdGggZm9yIGEgc3BlY2lmaWMgZGVwZW5kZW5jeVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZGVuY3lEaXJlY3RvcnkoZGVwZW5kZW5jeU5hbWU6ICd5dGRscCcgfCAnZmZtcGVnJyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhdGguam9pbihnZXREZXBlbmRlbmNpZXNEaXJlY3RvcnkoKSwgZGVwZW5kZW5jeU5hbWUpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBmdWxsIHBhdGggdG8gYSBkZXBlbmRlbmN5IGV4ZWN1dGFibGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRlbmN5RXhlY3V0YWJsZVBhdGgoZGVwZW5kZW5jeU5hbWU6ICd5dGRscCcgfCAnZmZtcGVnJyk6IHN0cmluZyB7XHJcbiAgY29uc3QgY29uZmlnID0gZ2V0RGVwZW5kZW5jeUNvbmZpZygpO1xyXG4gIGNvbnN0IGRlcGVuZGVuY3lEaXIgPSBnZXREZXBlbmRlbmN5RGlyZWN0b3J5KGRlcGVuZGVuY3lOYW1lKTtcclxuICBcclxuICBpZiAoZGVwZW5kZW5jeU5hbWUgPT09ICd5dGRscCcpIHtcclxuICAgIHJldHVybiBwYXRoLmpvaW4oZGVwZW5kZW5jeURpciwgJ2JpbicsIGNvbmZpZy55dGRscC5leGVjdXRhYmxlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHBhdGguam9pbihkZXBlbmRlbmN5RGlyLCAnYmluJywgY29uZmlnLmZmbXBlZy5leGVjdXRhYmxlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBwbGF0Zm9ybSBpcyBzdXBwb3J0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYXRmb3JtU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBbJ3dpbjMyJywgJ2RhcndpbicsICdsaW51eCddLmluY2x1ZGVzKFBMQVRGT1JNKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHBlcm1pc3Npb25zIGZvciBleGVjdXRhYmxlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVQZXJtaXNzaW9ucygpOiBudW1iZXIge1xyXG4gIHJldHVybiBQTEFURk9STSA9PT0gJ3dpbjMyJyA/IDBvNzU1IDogMG83NTU7XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/backend/config/dependency-config.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/app/app-handlers.ts":
/*!**************************************************!*\
  !*** ./src/backend/handlers/app/app-handlers.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * IPC handlers for application-level operations\n * Handles window management, application lifecycle, and system operations\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerAppHandlers = registerAppHandlers;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst index_1 = __webpack_require__(/*! ../index */ \"./src/backend/handlers/index.ts\");\n/**\n * Register all application-related IPC handlers\n */\nfunction registerAppHandlers() {\n    // Get application version\n    electron_1.ipcMain.handle('app:getVersion', (0, index_1.createIPCHandler)(async () => {\n        return electron_1.app.getVersion();\n    }));\n    // Quit application\n    electron_1.ipcMain.handle('app:quit', (0, index_1.createIPCHandler)(async () => {\n        electron_1.app.quit();\n        return { success: true };\n    }));\n    // Minimize window\n    electron_1.ipcMain.handle('app:minimize', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        if (focusedWindow) {\n            focusedWindow.minimize();\n        }\n        return { success: true };\n    }));\n    // Maximize/unmaximize window\n    electron_1.ipcMain.handle('app:maximize', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        if (focusedWindow) {\n            if (focusedWindow.isMaximized()) {\n                focusedWindow.unmaximize();\n            }\n            else {\n                focusedWindow.maximize();\n            }\n        }\n        return { success: true };\n    }));\n    // Check if window is maximized\n    electron_1.ipcMain.handle('app:isMaximized', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        return focusedWindow ? focusedWindow.isMaximized() : false;\n    }));\n    // Unmaximize window\n    electron_1.ipcMain.handle('app:unmaximize', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        if (focusedWindow && focusedWindow.isMaximized()) {\n            focusedWindow.unmaximize();\n        }\n        return { success: true };\n    }));\n    // Close window\n    electron_1.ipcMain.handle('app:close', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        if (focusedWindow) {\n            focusedWindow.close();\n        }\n        return { success: true };\n    }));\n    // Show error dialog\n    electron_1.ipcMain.handle('app:showErrorDialog', (0, index_1.createIPCHandler)(async (title, content) => {\n        const result = await electron_1.dialog.showErrorBox(title, content);\n        return { success: true };\n    }));\n    // Show message dialog\n    electron_1.ipcMain.handle('app:showMessageDialog', (0, index_1.createIPCHandler)(async (options) => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        const result = await electron_1.dialog.showMessageBox(focusedWindow || new electron_1.BrowserWindow(), options);\n        return result;\n    }));\n    // Select directory dialog\n    electron_1.ipcMain.handle('app:selectDirectory', (0, index_1.createIPCHandler)(async (options) => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        const result = await electron_1.dialog.showOpenDialog(focusedWindow || new electron_1.BrowserWindow(), {\n            properties: ['openDirectory'],\n            ...options,\n        });\n        if (result.canceled || result.filePaths.length === 0) {\n            return null;\n        }\n        return result.filePaths[0];\n    }));\n    // Select file dialog\n    electron_1.ipcMain.handle('app:selectFile', (0, index_1.createIPCHandler)(async (options) => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        const result = await electron_1.dialog.showOpenDialog(focusedWindow || new electron_1.BrowserWindow(), {\n            properties: ['openFile'],\n            ...options,\n        });\n        if (result.canceled || result.filePaths.length === 0) {\n            return null;\n        }\n        return result.filePaths[0];\n    }));\n    // Save file dialog\n    electron_1.ipcMain.handle('app:saveFile', (0, index_1.createIPCHandler)(async (options) => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        const result = await electron_1.dialog.showSaveDialog(focusedWindow || new electron_1.BrowserWindow(), options || {});\n        if (result.canceled || !result.filePath) {\n            return null;\n        }\n        return result.filePath;\n    }));\n    console.log(' App IPC handlers registered');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9oYW5kbGVycy9hcHAvYXBwLWhhbmRsZXJzLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBUUgsa0RBa0hDO0FBeEhELG1FQUErRDtBQUMvRCx1RkFBNEM7QUFFNUM7O0dBRUc7QUFDSCxTQUFnQixtQkFBbUI7SUFDakMsMEJBQTBCO0lBQzFCLGtCQUFPLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQzNELE9BQU8sY0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixtQkFBbUI7SUFDbkIsa0JBQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3JELGNBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNYLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLGtCQUFrQjtJQUNsQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxJQUFJLEVBQUU7UUFDekQsTUFBTSxhQUFhLEdBQUcsd0JBQWEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3ZELElBQUksYUFBYSxFQUFFLENBQUM7WUFDbEIsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzNCLENBQUM7UUFDRCxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSiw2QkFBNkI7SUFDN0Isa0JBQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3pELE1BQU0sYUFBYSxHQUFHLHdCQUFhLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN2RCxJQUFJLGFBQWEsRUFBRSxDQUFDO1lBQ2xCLElBQUksYUFBYSxD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QU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosT0FBTyxDQUFDLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBQy9DLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL2hhbmRsZXJzL2FwcC9hcHAtaGFuZGxlcnMudHM/MGVhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSVBDIGhhbmRsZXJzIGZvciBhcHBsaWNhdGlvbi1sZXZlbCBvcGVyYXRpb25zXHJcbiAqIEhhbmRsZXMgd2luZG93IG1hbmFnZW1lbnQsIGFwcGxpY2F0aW9uIGxpZmVjeWNsZSwgYW5kIHN5c3RlbSBvcGVyYXRpb25zXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgaXBjTWFpbiwgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2cgfSBmcm9tICdlbGVjdHJvbic7XHJcbmltcG9ydCB7IGNyZWF0ZUlQQ0hhbmRsZXIgfSBmcm9tICcuLi9pbmRleCc7XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXIgYWxsIGFwcGxpY2F0aW9uLXJlbGF0ZWQgSVBDIGhhbmRsZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJBcHBIYW5kbGVycygpOiB2b2lkIHtcclxuICAvLyBHZXQgYXBwbGljYXRpb24gdmVyc2lvblxyXG4gIGlwY01haW4uaGFuZGxlKCdhcHA6Z2V0VmVyc2lvbicsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgcmV0dXJuIGFwcC5nZXRWZXJzaW9uKCk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBRdWl0IGFwcGxpY2F0aW9uXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2FwcDpxdWl0JywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICBhcHAucXVpdCgpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gTWluaW1pemUgd2luZG93XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2FwcDptaW5pbWl6ZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZm9jdXNlZFdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgaWYgKGZvY3VzZWRXaW5kb3cpIHtcclxuICAgICAgZm9jdXNlZFdpbmRvdy5taW5pbWl6ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gTWF4aW1pemUvdW5tYXhpbWl6ZSB3aW5kb3dcclxuICBpcGNNYWluLmhhbmRsZSgnYXBwOm1heGltaXplJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XHJcbiAgICBpZiAoZm9jdXNlZFdpbmRvdykge1xyXG4gICAgICBpZiAoZm9jdXNlZFdpbmRvdy5pc01heGltaXplZCgpKSB7XHJcbiAgICAgICAgZm9jdXNlZFdpbmRvdy51bm1heGltaXplKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9jdXNlZFdpbmRvdy5tYXhpbWl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDaGVjayBpZiB3aW5kb3cgaXMgbWF4aW1pemVkXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2FwcDppc01heGltaXplZCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZm9jdXNlZFdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgcmV0dXJuIGZvY3VzZWRXaW5kb3cgPyBmb2N1c2VkV2luZG93LmlzTWF4aW1pemVkKCkgOiBmYWxzZTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFVubWF4aW1pemUgd2luZG93XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2FwcDp1bm1heGltaXplJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XHJcbiAgICBpZiAoZm9jdXNlZFdpbmRvdyAmJiBmb2N1c2VkV2luZG93LmlzTWF4aW1pemVkKCkpIHtcclxuICAgICAgZm9jdXNlZFdpbmRvdy51bm1heGltaXplKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDbG9zZSB3aW5kb3dcclxuICBpcGNNYWluLmhhbmRsZSgnYXBwOmNsb3NlJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XHJcbiAgICBpZiAoZm9jdXNlZFdpbmRvdykge1xyXG4gICAgICBmb2N1c2VkV2luZG93LmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBTaG93IGVycm9yIGRpYWxvZ1xyXG4gIGlwY01haW4uaGFuZGxlKCdhcHA6c2hvd0Vycm9yRGlhbG9nJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAodGl0bGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkaWFsb2cuc2hvd0Vycm9yQm94KHRpdGxlLCBjb250ZW50KTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFNob3cgbWVzc2FnZSBkaWFsb2dcclxuICBpcGNNYWluLmhhbmRsZSgnYXBwOnNob3dNZXNzYWdlRGlhbG9nJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAob3B0aW9uczogRWxlY3Ryb24uTWVzc2FnZUJveE9wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRpYWxvZy5zaG93TWVzc2FnZUJveChmb2N1c2VkV2luZG93IHx8IG5ldyBCcm93c2VyV2luZG93KCksIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9KSk7XHJcblxyXG4gIC8vIFNlbGVjdCBkaXJlY3RvcnkgZGlhbG9nXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2FwcDpzZWxlY3REaXJlY3RvcnknLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChvcHRpb25zPzogRWxlY3Ryb24uT3BlbkRpYWxvZ09wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRpYWxvZy5zaG93T3BlbkRpYWxvZyhmb2N1c2VkV2luZG93IHx8IG5ldyBCcm93c2VyV2luZG93KCksIHtcclxuICAgICAgcHJvcGVydGllczogWydvcGVuRGlyZWN0b3J5J10sXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKHJlc3VsdC5jYW5jZWxlZCB8fCByZXN1bHQuZmlsZVBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdC5maWxlUGF0aHNbMF07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBTZWxlY3QgZmlsZSBkaWFsb2dcclxuICBpcGNNYWluLmhhbmRsZSgnYXBwOnNlbGVjdEZpbGUnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChvcHRpb25zPzogRWxlY3Ryb24uT3BlbkRpYWxvZ09wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRpYWxvZy5zaG93T3BlbkRpYWxvZyhmb2N1c2VkV2luZG93IHx8IG5ldyBCcm93c2VyV2luZG93KCksIHtcclxuICAgICAgcHJvcGVydGllczogWydvcGVuRmlsZSddLFxyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQuY2FuY2VsZWQgfHwgcmVzdWx0LmZpbGVQYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQuZmlsZVBhdGhzWzBdO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gU2F2ZSBmaWxlIGRpYWxvZ1xyXG4gIGlwY01haW4uaGFuZGxlKCdhcHA6c2F2ZUZpbGUnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChvcHRpb25zPzogRWxlY3Ryb24uU2F2ZURpYWxvZ09wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IGZvY3VzZWRXaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRpYWxvZy5zaG93U2F2ZURpYWxvZyhmb2N1c2VkV2luZG93IHx8IG5ldyBCcm93c2VyV2luZG93KCksIG9wdGlvbnMgfHwge30pO1xyXG4gICAgXHJcbiAgICBpZiAocmVzdWx0LmNhbmNlbGVkIHx8ICFyZXN1bHQuZmlsZVBhdGgpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQuZmlsZVBhdGg7XHJcbiAgfSkpO1xyXG5cclxuICBjb25zb2xlLmxvZygn4pyFIEFwcCBJUEMgaGFuZGxlcnMgcmVnaXN0ZXJlZCcpO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/backend/handlers/app/app-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/app/playlist-handlers.ts":
/*!*******************************************************!*\
  !*** ./src/backend/handlers/app/playlist-handlers.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerPlaylistHandlers = registerPlaylistHandlers;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst index_1 = __webpack_require__(/*! ../index */ \"./src/backend/handlers/index.ts\");\n// Note: These services will be implemented in later tasks\n// For now, we'll create placeholder implementations\nfunction registerPlaylistHandlers() {\n    // Playlist operations (placeholder implementations for future tasks)\n    // Get all playlists\n    electron_1.ipcMain.handle('playlist:getAll', (0, index_1.createIPCHandler)(async (options) => {\n        // Placeholder - will be implemented in later tasks\n        return [];\n    }));\n    // Get playlist by ID\n    electron_1.ipcMain.handle('playlist:getById', (0, index_1.createIPCHandler)(async (playlistId) => {\n        // Placeholder - will be implemented in later tasks\n        return null;\n    }));\n    // Create a new playlist\n    electron_1.ipcMain.handle('playlist:create', (0, index_1.createIPCHandler)(async (input) => {\n        // Placeholder - will be implemented in later tasks\n        return { id: 1, title: input.title, description: input.description };\n    }));\n    // Update a playlist\n    electron_1.ipcMain.handle('playlist:update', (0, index_1.createIPCHandler)(async (playlistId, updates) => {\n        // Placeholder - will be implemented in later tasks\n        return { id: playlistId, ...updates };\n    }));\n    // Delete a playlist\n    electron_1.ipcMain.handle('playlist:delete', (0, index_1.createIPCHandler)(async (playlistId) => {\n        // Placeholder - will be implemented in later tasks\n        return { success: true };\n    }));\n    // Search videos in a playlist\n    electron_1.ipcMain.handle('playlist:searchVideos', (0, index_1.createIPCHandler)(async (options) => {\n        // Placeholder - will be implemented in later tasks\n        return [];\n    }));\n    // Add video to playlist\n    electron_1.ipcMain.handle('playlist:addVideo', (0, index_1.createIPCHandler)(async (playlistId, videoId) => {\n        // Placeholder - will be implemented in later tasks\n        return { success: true };\n    }));\n    // Remove video from playlist\n    electron_1.ipcMain.handle('playlist:removeVideo', (0, index_1.createIPCHandler)(async (playlistId, videoId) => {\n        // Placeholder - will be implemented in later tasks\n        return { success: true };\n    }));\n    // Reorder videos in playlist\n    electron_1.ipcMain.handle('playlist:reorderVideos', (0, index_1.createIPCHandler)(async (playlistId, videoOrders) => {\n        // Placeholder - will be implemented in later tasks\n        return { success: true };\n    }));\n    // Get playlist statistics\n    electron_1.ipcMain.handle('playlist:getStats', (0, index_1.createIPCHandler)(async (playlistId) => {\n        // Placeholder - will be implemented in later tasks\n        return { videoCount: 0, totalDuration: 0 };\n    }));\n    // YouTube operations (placeholder implementations for future tasks)\n    // Get YouTube playlist metadata\n    electron_1.ipcMain.handle('youtube:getPlaylistMetadata', (0, index_1.createIPCHandler)(async (url) => {\n        // Placeholder - will be implemented in later tasks\n        return { title: 'Sample Playlist', description: 'Sample Description' };\n    }));\n    // Import YouTube playlist\n    electron_1.ipcMain.handle('youtube:importPlaylist', (0, index_1.createIPCHandler)(async (url) => {\n        // Placeholder - will be implemented in later tasks\n        return { playlist: { id: 1, title: 'Imported Playlist' }, videoCount: 0 };\n    }));\n    // Get video qualities\n    electron_1.ipcMain.handle('youtube:getVideoQualities', (0, index_1.createIPCHandler)(async (videoId) => {\n        // Placeholder - will be implemented in later tasks\n        return ['720p', '480p', '360p'];\n    }));\n    // Check yt-dlp availability\n    electron_1.ipcMain.handle('youtube:checkAvailability', (0, index_1.createIPCHandler)(async () => {\n        // Placeholder - will be implemented in later tasks\n        return { available: false, version: null };\n    }));\n    // Update yt-dlp\n    electron_1.ipcMain.handle('youtube:updateYtDlp', (0, index_1.createIPCHandler)(async () => {\n        // Placeholder - will be implemented in later tasks\n        return { success: false, message: 'Not implemented yet' };\n    }));\n    // Validate YouTube URL\n    electron_1.ipcMain.handle('youtube:validateUrl', (0, index_1.createIPCHandler)(async (url) => {\n        // Placeholder - will be implemented in later tasks\n        const isValid = url.includes('youtube.com') || url.includes('youtu.be');\n        return { isValid, playlistId: null, sanitizedUrl: isValid ? url : null };\n    }));\n    // Legacy handlers for backward compatibility\n    electron_1.ipcMain.handle('playlist:getMetadata', (0, index_1.createIPCHandler)(async (url) => {\n        // Placeholder - will be implemented in later tasks\n        return { error: 'Not implemented yet - will be added in later tasks' };\n    }));\n    electron_1.ipcMain.handle('import:start', (0, index_1.createIPCHandler)(async (url) => {\n        // Placeholder - will be implemented in later tasks\n        return { error: 'Not implemented yet - will be added in later tasks' };\n    }));\n    electron_1.ipcMain.handle('getPlaylistDetails', (0, index_1.createIPCHandler)(async (playlistId) => {\n        // Placeholder - will be implemented in later tasks\n        return { error: 'Not implemented yet - will be added in later tasks' };\n    }));\n    electron_1.ipcMain.handle('getPlaylists', (0, index_1.createIPCHandler)(async () => {\n        // Placeholder - will be implemented in later tasks\n        return [{ id: '1', title: 'Sample Playlist' }];\n    }));\n    console.log(' Playlist IPC handlers registered (placeholder implementations)');\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9oYW5kbGVycy9hcHAvcGxheWxpc3QtaGFuZGxlcnMudHMiLCJtYXBwaW5ncyI6Ijs7QUFLQSw0REE0SEM7QUFqSUQsbUVBQW1DO0FBQ25DLHVGQUE0QztBQUM1QywwREFBMEQ7QUFDMUQsb0RBQW9EO0FBRXBELFNBQWdCLHdCQUF3QjtJQUN0QyxxRUFBcUU7SUFFckUsb0JBQW9CO0lBQ3BCLGtCQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxPQUFhLEVBQUUsRUFBRTtRQUN6RSxtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUoscUJBQXFCO0lBQ3JCLGtCQUFPLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxVQUFrQixFQUFFLEVBQUU7UUFDL0UsbURBQW1EO1FBQ25ELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLHdCQUF3QjtJQUN4QixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsS0FBVSxFQUFFLEVBQUU7UUFDdEUsbURBQW1EO1FBQ25ELE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdkUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLG9CQUFvQjtJQUNwQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsVUFBa0IsRUFBRSxPQUFZLEVBQUUsRUFBRTtRQUM1RixtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsR0FBRyxPQUFPLEVBQUUsQ0FBQztJQUN4QyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosb0JBQW9CO0lBQ3BCLGtCQUFPLENBQUMsTUFBTSxDQUFDLGlCQUFpQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxVQUFrQixFQUFFLEVBQUU7UUFDOUUsbURBQW1EO1FBQ25ELE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLDhCQUE4QjtJQUM5QixrQkFBTyxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsT0FBWSxFQUFFLEVBQUU7UUFDOUUsbURBQW1EO1FBQ25ELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLHdCQUF3QjtJQUN4QixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsVUFBa0IsRUFBRSxPQUFlLEVBQUUsRUFBRTtRQUNqRyxtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosNkJBQTZCO0lBQzdCLGtCQUFPLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxVQUFrQixFQUFFLE9BQWUsRUFBRSxFQUFFO1FBQ3BHLG1EQUFtRDtRQUNuRCxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSiw2QkFBNkI7SUFDN0Isa0JBQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFVBQWtCLEVBQUUsV0FBa0IsRUFBRSxFQUFFO1FBQ3pHLG1EQUFtRDtRQUNuRCxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSiwwQkFBMEI7SUFDMUIsa0JBQU8sQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFVBQWtCLEVBQUUsRUFBRTtRQUNoRixtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsYUFBYSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixvRUFBb0U7SUFFcEUsZ0NBQWdDO0lBQ2hDLGtCQUFPLENBQUMsTUFBTSxDQUFDLDZCQUE2QixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxHQUFXLEVBQUUsRUFBRTtRQUNuRixtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQztJQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosMEJBQTBCO0lBQzFCLGtCQUFPLENBQUMsTUFBTSxDQUFDLHdCQUF3QixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxHQUFXLEVBQUUsRUFBRTtRQUM5RSxtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLG1CQUFtQixFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQzVFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixzQkFBc0I7SUFDdEIsa0JBQU8sQ0FBQyxNQUFNLENBQUMsMkJBQTJCLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLE9BQWUsRUFBRSxFQUFFO1FBQ3JGLG1EQUFtRDtRQUNuRCxPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosNEJBQTRCO0lBQzVCLGtCQUFPLENBQUMsTUFBTSxDQUFDLDJCQUEyQixFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3RFLG1EQUFtRDtRQUNuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLGdCQUFnQjtJQUNoQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUNoRSxtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLENBQUM7SUFDNUQsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLHVCQUF1QjtJQUN2QixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsR0FBVyxFQUFFLEVBQUU7UUFDM0UsbURBQW1EO1FBQ25ELE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN4RSxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosNkNBQTZDO0lBQzdDLGtCQUFPLENBQUMsTUFBTSxDQUFDLHNCQUFzQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxHQUFXLEVBQUUsRUFBRTtRQUM1RSxtREFBbUQ7UUFDbkQsT0FBTyxFQUFFLEtBQUssRUFBRSxvREFBb0QsRUFBRSxDQUFDO0lBQ3pFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLEdBQVcsRUFBRSxFQUFFO1FBQ3BFLG1EQUFtRDtRQUNuRCxPQUFPLEVBQUUsS0FBSyxFQUFFLG9EQUFvRCxFQUFFLENBQUM7SUFDekUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLGtCQUFPLENBQUMsTUFBTSxDQUFDLG9CQUFvQixFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxVQUFrQixFQUFFLEVBQUU7UUFDakYsbURBQW1EO1FBQ25ELE9BQU8sRUFBRSxLQUFLLEVBQUUsb0RBQW9ELEVBQUUsQ0FBQztJQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosa0JBQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3pELG1EQUFtRDtRQUNuRCxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7SUFDakQsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0VBQWtFLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBQUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vc3JjL2JhY2tlbmQvaGFuZGxlcnMvYXBwL3BsYXlsaXN0LWhhbmRsZXJzLnRzP2Y4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXBjTWFpbiB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgY3JlYXRlSVBDSGFuZGxlciB9IGZyb20gJy4uL2luZGV4JztcclxuLy8gTm90ZTogVGhlc2Ugc2VydmljZXMgd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4vLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgcGxhY2Vob2xkZXIgaW1wbGVtZW50YXRpb25zXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJQbGF5bGlzdEhhbmRsZXJzKCk6IHZvaWQge1xyXG4gIC8vIFBsYXlsaXN0IG9wZXJhdGlvbnMgKHBsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9ucyBmb3IgZnV0dXJlIHRhc2tzKVxyXG4gIFxyXG4gIC8vIEdldCBhbGwgcGxheWxpc3RzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OmdldEFsbCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKG9wdGlvbnM/OiBhbnkpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gR2V0IHBsYXlsaXN0IGJ5IElEXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OmdldEJ5SWQnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChwbGF5bGlzdElkOiBudW1iZXIpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDcmVhdGUgYSBuZXcgcGxheWxpc3RcclxuICBpcGNNYWluLmhhbmRsZSgncGxheWxpc3Q6Y3JlYXRlJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoaW5wdXQ6IGFueSkgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBpZDogMSwgdGl0bGU6IGlucHV0LnRpdGxlLCBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24gfTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBhIHBsYXlsaXN0XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OnVwZGF0ZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHBsYXlsaXN0SWQ6IG51bWJlciwgdXBkYXRlczogYW55KSA9PiB7XHJcbiAgICAvLyBQbGFjZWhvbGRlciAtIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gbGF0ZXIgdGFza3NcclxuICAgIHJldHVybiB7IGlkOiBwbGF5bGlzdElkLCAuLi51cGRhdGVzIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBEZWxldGUgYSBwbGF5bGlzdFxyXG4gIGlwY01haW4uaGFuZGxlKCdwbGF5bGlzdDpkZWxldGUnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChwbGF5bGlzdElkOiBudW1iZXIpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gU2VhcmNoIHZpZGVvcyBpbiBhIHBsYXlsaXN0XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OnNlYXJjaFZpZGVvcycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKG9wdGlvbnM6IGFueSkgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4gW107XHJcbiAgfSkpO1xyXG5cclxuICAvLyBBZGQgdmlkZW8gdG8gcGxheWxpc3RcclxuICBpcGNNYWluLmhhbmRsZSgncGxheWxpc3Q6YWRkVmlkZW8nLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChwbGF5bGlzdElkOiBudW1iZXIsIHZpZGVvSWQ6IHN0cmluZykgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBSZW1vdmUgdmlkZW8gZnJvbSBwbGF5bGlzdFxyXG4gIGlwY01haW4uaGFuZGxlKCdwbGF5bGlzdDpyZW1vdmVWaWRlbycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHBsYXlsaXN0SWQ6IG51bWJlciwgdmlkZW9JZDogc3RyaW5nKSA9PiB7XHJcbiAgICAvLyBQbGFjZWhvbGRlciAtIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gbGF0ZXIgdGFza3NcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFJlb3JkZXIgdmlkZW9zIGluIHBsYXlsaXN0XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OnJlb3JkZXJWaWRlb3MnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChwbGF5bGlzdElkOiBudW1iZXIsIHZpZGVvT3JkZXJzOiBhbnlbXSkgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBHZXQgcGxheWxpc3Qgc3RhdGlzdGljc1xyXG4gIGlwY01haW4uaGFuZGxlKCdwbGF5bGlzdDpnZXRTdGF0cycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHBsYXlsaXN0SWQ6IG51bWJlcikgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyB2aWRlb0NvdW50OiAwLCB0b3RhbER1cmF0aW9uOiAwIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBZb3VUdWJlIG9wZXJhdGlvbnMgKHBsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9ucyBmb3IgZnV0dXJlIHRhc2tzKVxyXG5cclxuICAvLyBHZXQgWW91VHViZSBwbGF5bGlzdCBtZXRhZGF0YVxyXG4gIGlwY01haW4uaGFuZGxlKCd5b3V0dWJlOmdldFBsYXlsaXN0TWV0YWRhdGEnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICh1cmw6IHN0cmluZykgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyB0aXRsZTogJ1NhbXBsZSBQbGF5bGlzdCcsIGRlc2NyaXB0aW9uOiAnU2FtcGxlIERlc2NyaXB0aW9uJyB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gSW1wb3J0IFlvdVR1YmUgcGxheWxpc3RcclxuICBpcGNNYWluLmhhbmRsZSgneW91dHViZTppbXBvcnRQbGF5bGlzdCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XHJcbiAgICAvLyBQbGFjZWhvbGRlciAtIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gbGF0ZXIgdGFza3NcclxuICAgIHJldHVybiB7IHBsYXlsaXN0OiB7IGlkOiAxLCB0aXRsZTogJ0ltcG9ydGVkIFBsYXlsaXN0JyB9LCB2aWRlb0NvdW50OiAwIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBHZXQgdmlkZW8gcXVhbGl0aWVzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3lvdXR1YmU6Z2V0VmlkZW9RdWFsaXRpZXMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICh2aWRlb0lkOiBzdHJpbmcpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIFsnNzIwcCcsICc0ODBwJywgJzM2MHAnXTtcclxuICB9KSk7XHJcblxyXG4gIC8vIENoZWNrIHl0LWRscCBhdmFpbGFiaWxpdHlcclxuICBpcGNNYWluLmhhbmRsZSgneW91dHViZTpjaGVja0F2YWlsYWJpbGl0eScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBhdmFpbGFibGU6IGZhbHNlLCB2ZXJzaW9uOiBudWxsIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBVcGRhdGUgeXQtZGxwXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3lvdXR1YmU6dXBkYXRlWXREbHAnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdOb3QgaW1wbGVtZW50ZWQgeWV0JyB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gVmFsaWRhdGUgWW91VHViZSBVUkxcclxuICBpcGNNYWluLmhhbmRsZSgneW91dHViZTp2YWxpZGF0ZVVybCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XHJcbiAgICAvLyBQbGFjZWhvbGRlciAtIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gbGF0ZXIgdGFza3NcclxuICAgIGNvbnN0IGlzVmFsaWQgPSB1cmwuaW5jbHVkZXMoJ3lvdXR1YmUuY29tJykgfHwgdXJsLmluY2x1ZGVzKCd5b3V0dS5iZScpO1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZCwgcGxheWxpc3RJZDogbnVsbCwgc2FuaXRpemVkVXJsOiBpc1ZhbGlkID8gdXJsIDogbnVsbCB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gTGVnYWN5IGhhbmRsZXJzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ3BsYXlsaXN0OmdldE1ldGFkYXRhJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAodXJsOiBzdHJpbmcpID0+IHtcclxuICAgIC8vIFBsYWNlaG9sZGVyIC0gd2lsbCBiZSBpbXBsZW1lbnRlZCBpbiBsYXRlciB0YXNrc1xyXG4gICAgcmV0dXJuIHsgZXJyb3I6ICdOb3QgaW1wbGVtZW50ZWQgeWV0IC0gd2lsbCBiZSBhZGRlZCBpbiBsYXRlciB0YXNrcycgfTtcclxuICB9KSk7XHJcblxyXG4gIGlwY01haW4uaGFuZGxlKCdpbXBvcnQ6c3RhcnQnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICh1cmw6IHN0cmluZykgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBlcnJvcjogJ05vdCBpbXBsZW1lbnRlZCB5ZXQgLSB3aWxsIGJlIGFkZGVkIGluIGxhdGVyIHRhc2tzJyB9O1xyXG4gIH0pKTtcclxuXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2dldFBsYXlsaXN0RGV0YWlscycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4geyBlcnJvcjogJ05vdCBpbXBsZW1lbnRlZCB5ZXQgLSB3aWxsIGJlIGFkZGVkIGluIGxhdGVyIHRhc2tzJyB9O1xyXG4gIH0pKTtcclxuXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2dldFBsYXlsaXN0cycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgLSB3aWxsIGJlIGltcGxlbWVudGVkIGluIGxhdGVyIHRhc2tzXHJcbiAgICByZXR1cm4gW3sgaWQ6ICcxJywgdGl0bGU6ICdTYW1wbGUgUGxheWxpc3QnIH1dO1xyXG4gIH0pKTtcclxuXHJcbiAgY29uc29sZS5sb2coJ+KchSBQbGF5bGlzdCBJUEMgaGFuZGxlcnMgcmVnaXN0ZXJlZCAocGxhY2Vob2xkZXIgaW1wbGVtZW50YXRpb25zKScpO1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/handlers/app/playlist-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/dependency-handlers.ts":
/*!*****************************************************!*\
  !*** ./src/backend/handlers/dependency-handlers.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * IPC handlers for dependency management\n * Provides secure communication between main and renderer processes for dependency operations\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initializeDependencyHandlers = initializeDependencyHandlers;\nexports.getDependencyManager = getDependencyManager;\nexports.cleanupDependencyHandlers = cleanupDependencyHandlers;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst dependency_manager_service_1 = __webpack_require__(/*! ../services/dependency-manager-service */ \"./src/backend/services/dependency-manager-service.ts\");\nlet dependencyManager = null;\n/**\n * Initialize dependency IPC handlers\n */\nfunction initializeDependencyHandlers() {\n    // Create dependency manager instance\n    dependencyManager = new dependency_manager_service_1.DependencyManagerService();\n    // Set up event forwarding to renderer\n    dependencyManager.on('statusUpdated', (status) => {\n        broadcastToRenderers('dependency:statusUpdated', status);\n    });\n    dependencyManager.on('downloadProgress', (progress) => {\n        broadcastToRenderers('dependency:downloadProgress', progress);\n    });\n    dependencyManager.on('installStarted', (dependency) => {\n        broadcastToRenderers('dependency:installStarted', dependency);\n    });\n    dependencyManager.on('installCompleted', (dependency) => {\n        broadcastToRenderers('dependency:installCompleted', dependency);\n    });\n    dependencyManager.on('installFailed', (dependency, error) => {\n        broadcastToRenderers('dependency:installFailed', { dependency, error: error.message });\n    });\n    dependencyManager.on('dependenciesCleanedUp', () => {\n        broadcastToRenderers('dependency:cleanedUp');\n    });\n    // Initialize the dependency manager\n    dependencyManager.initialize().catch((error) => {\n        console.error('Failed to initialize dependency manager:', error);\n        broadcastToRenderers('dependency:initializationFailed', error.message);\n    });\n    // Register IPC handlers\n    registerHandlers();\n}\n/**\n * Register all dependency-related IPC handlers\n */\nfunction registerHandlers() {\n    if (!dependencyManager) {\n        throw new Error('Dependency manager not initialized');\n    }\n    // Check dependency status\n    electron_1.ipcMain.handle('dependency:checkStatus', async () => {\n        try {\n            return await dependencyManager.checkDependencies();\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Get cached dependency status\n    electron_1.ipcMain.handle('dependency:getStatus', () => {\n        return dependencyManager.getDependencyStatus();\n    });\n    // Install a specific dependency\n    electron_1.ipcMain.handle('dependency:install', async (_event, dependencyName) => {\n        try {\n            if (!['ytdlp', 'ffmpeg'].includes(dependencyName)) {\n                throw new Error(`Invalid dependency name: ${dependencyName}`);\n            }\n            await dependencyManager.installDependency(dependencyName);\n            return { success: true };\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Validate a specific dependency\n    electron_1.ipcMain.handle('dependency:validate', async (_event, dependencyName) => {\n        try {\n            if (!['ytdlp', 'ffmpeg'].includes(dependencyName)) {\n                throw new Error(`Invalid dependency name: ${dependencyName}`);\n            }\n            return await dependencyManager.validateDependency(dependencyName);\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Get dependency version\n    electron_1.ipcMain.handle('dependency:getVersion', async (_event, dependencyName) => {\n        try {\n            if (!['ytdlp', 'ffmpeg'].includes(dependencyName)) {\n                throw new Error(`Invalid dependency name: ${dependencyName}`);\n            }\n            return await dependencyManager.getDependencyVersion(dependencyName);\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Get dependency path\n    electron_1.ipcMain.handle('dependency:getPath', (_event, dependencyName) => {\n        try {\n            if (!['ytdlp', 'ffmpeg'].includes(dependencyName)) {\n                throw new Error(`Invalid dependency name: ${dependencyName}`);\n            }\n            return dependencyManager.getDependencyPath(dependencyName);\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Clean up all dependencies\n    electron_1.ipcMain.handle('dependency:cleanup', async () => {\n        try {\n            await dependencyManager.cleanupDependencies();\n            return { success: true };\n        }\n        catch (error) {\n            throw new Error(error instanceof Error ? error.message : 'Unknown error');\n        }\n    });\n    // Check if all dependencies are ready\n    electron_1.ipcMain.handle('dependency:areAllReady', () => {\n        return dependencyManager.areAllDependenciesReady();\n    });\n    // Check if dependency manager is initialized\n    electron_1.ipcMain.handle('dependency:isInitialized', () => {\n        return dependencyManager.isInitialized();\n    });\n}\n/**\n * Broadcast an event to all renderer processes\n */\nfunction broadcastToRenderers(channel, data) {\n    const windows = electron_1.BrowserWindow.getAllWindows();\n    windows.forEach(window => {\n        if (!window.isDestroyed()) {\n            window.webContents.send(channel, data);\n        }\n    });\n}\n/**\n * Get the dependency manager instance\n */\nfunction getDependencyManager() {\n    return dependencyManager;\n}\n/**\n * Cleanup dependency handlers\n */\nfunction cleanupDependencyHandlers() {\n    if (dependencyManager) {\n        dependencyManager.removeAllListeners();\n        dependencyManager = null;\n    }\n    // Remove IPC handlers\n    const handlers = [\n        'dependency:checkStatus',\n        'dependency:getStatus',\n        'dependency:install',\n        'dependency:validate',\n        'dependency:getVersion',\n        'dependency:getPath',\n        'dependency:cleanup',\n        'dependency:areAllReady',\n        'dependency:isInitialized',\n    ];\n    handlers.forEach(handler => {\n        electron_1.ipcMain.removeHandler(handler);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9oYW5kbGVycy9kZXBlbmRlbmN5LWhhbmRsZXJzLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBV0gsb0VBcUNDO0FBaUhELG9EQUVDO0FBS0QsOERBc0JDO0FBNUxELG1FQUFrRDtBQUNsRCwrSkFBa0Y7QUFHbEYsSUFBSSxpQkFBaUIsR0FBb0MsSUFBSSxDQUFDO0FBRTlEOztHQUVHO0FBQ0gsU0FBZ0IsNEJBQTRCO0lBQzFDLHFDQUFxQztJQUNyQyxpQkFBaUIsR0FBRyxJQUFJLHFEQUF3QixFQUFFLENBQUM7SUFFbkQsc0NBQXNDO0lBQ3RDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxNQUF3QixFQUFFLEVBQUU7UUFDakUsb0JBQW9CLENBQUMsMEJBQTBCLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDLENBQUM7SUFFSCxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxRQUFvQyxFQUFFLEVBQUU7UUFDaEYsb0JBQW9CLENBQUMsNkJBQTZCLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDaEUsQ0FBQyxDQUFDLENBQUM7SUFFSCxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxVQUFrQixFQUFFLEVBQUU7UUFDNUQsb0JBQW9CLENBQUMsMkJBQTJCLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDaEUsQ0FBQyxDQUFDLENBQUM7SUFFSCxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxVQUFrQixFQUFFLEVBQUU7UUFDOUQsb0JBQW9CLENBQUMsNkJBQTZCLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbEUsQ0FBQyxDQUFDLENBQUM7SUFFSCxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUMsVUFBa0IsRUFBRSxLQUFZLEVBQUUsRUFBRTtRQUN6RSxvQkFBb0IsQ0FBQywwQkFBMEIsRUFBRSxFQUFFLFVBQVUsRUFB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QUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isb0JBQW9CO0lBQ2xDLE9BQU8saUJBQWlCLENBQUM7QUFDM0IsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IseUJBQXlCO0lBQ3ZDLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUN0QixpQkFBaUIsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ3ZDLGlCQUFpQixHQUFHLElBQUksQ0FBQztJQUMzQixDQUFDO0lBRUQsc0JBQXNCO0lBQ3RCLE1BQU0sUUFBUSxHQUFHO1FBQ2Ysd0JBQXdCO1FBQ3hCLHNCQUFzQjtRQUN0QixvQkFBb0I7UUFDcEIscUJBQXFCO1FBQ3JCLHVCQUF1QjtRQUN2QixvQkFBb0I7UUFDcEIsb0JBQW9CO1FBQ3BCLHdCQUF3QjtRQUN4QiwwQkFBMEI7S0FDM0IsQ0FBQztJQUVGLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDekIsa0JBQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9oYW5kbGVycy9kZXBlbmRlbmN5LWhhbmRsZXJzLnRzPzdkNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIElQQyBoYW5kbGVycyBmb3IgZGVwZW5kZW5jeSBtYW5hZ2VtZW50XHJcbiAqIFByb3ZpZGVzIHNlY3VyZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gbWFpbiBhbmQgcmVuZGVyZXIgcHJvY2Vzc2VzIGZvciBkZXBlbmRlbmN5IG9wZXJhdGlvbnNcclxuICovXHJcblxyXG5pbXBvcnQgeyBpcGNNYWluLCBCcm93c2VyV2luZG93IH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQgeyBEZXBlbmRlbmN5TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9kZXBlbmRlbmN5LW1hbmFnZXItc2VydmljZSc7XHJcbmltcG9ydCB0eXBlIHsgRGVwZW5kZW5jeVN0YXR1cywgRGVwZW5kZW5jeURvd25sb2FkUHJvZ3Jlc3MgfSBmcm9tICdAL3NoYXJlZC9pbnRlcmZhY2VzL2RlcGVuZGVuY3ktbWFuYWdlcic7XHJcblxyXG5sZXQgZGVwZW5kZW5jeU1hbmFnZXI6IERlcGVuZGVuY3lNYW5hZ2VyU2VydmljZSB8IG51bGwgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgZGVwZW5kZW5jeSBJUEMgaGFuZGxlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRGVwZW5kZW5jeUhhbmRsZXJzKCk6IHZvaWQge1xyXG4gIC8vIENyZWF0ZSBkZXBlbmRlbmN5IG1hbmFnZXIgaW5zdGFuY2VcclxuICBkZXBlbmRlbmN5TWFuYWdlciA9IG5ldyBEZXBlbmRlbmN5TWFuYWdlclNlcnZpY2UoKTtcclxuXHJcbiAgLy8gU2V0IHVwIGV2ZW50IGZvcndhcmRpbmcgdG8gcmVuZGVyZXJcclxuICBkZXBlbmRlbmN5TWFuYWdlci5vbignc3RhdHVzVXBkYXRlZCcsIChzdGF0dXM6IERlcGVuZGVuY3lTdGF0dXMpID0+IHtcclxuICAgIGJyb2FkY2FzdFRvUmVuZGVyZXJzKCdkZXBlbmRlbmN5OnN0YXR1c1VwZGF0ZWQnLCBzdGF0dXMpO1xyXG4gIH0pO1xyXG5cclxuICBkZXBlbmRlbmN5TWFuYWdlci5vbignZG93bmxvYWRQcm9ncmVzcycsIChwcm9ncmVzczogRGVwZW5kZW5jeURvd25sb2FkUHJvZ3Jlc3MpID0+IHtcclxuICAgIGJyb2FkY2FzdFRvUmVuZGVyZXJzKCdkZXBlbmRlbmN5OmRvd25sb2FkUHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XHJcbiAgfSk7XHJcblxyXG4gIGRlcGVuZGVuY3lNYW5hZ2VyLm9uKCdpbnN0YWxsU3RhcnRlZCcsIChkZXBlbmRlbmN5OiBzdHJpbmcpID0+IHtcclxuICAgIGJyb2FkY2FzdFRvUmVuZGVyZXJzKCdkZXBlbmRlbmN5Omluc3RhbGxTdGFydGVkJywgZGVwZW5kZW5jeSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlcGVuZGVuY3lNYW5hZ2VyLm9uKCdpbnN0YWxsQ29tcGxldGVkJywgKGRlcGVuZGVuY3k6IHN0cmluZykgPT4ge1xyXG4gICAgYnJvYWRjYXN0VG9SZW5kZXJlcnMoJ2RlcGVuZGVuY3k6aW5zdGFsbENvbXBsZXRlZCcsIGRlcGVuZGVuY3kpO1xyXG4gIH0pO1xyXG5cclxuICBkZXBlbmRlbmN5TWFuYWdlci5vbignaW5zdGFsbEZhaWxlZCcsIChkZXBlbmRlbmN5OiBzdHJpbmcsIGVycm9yOiBFcnJvcikgPT4ge1xyXG4gICAgYnJvYWRjYXN0VG9SZW5kZXJlcnMoJ2RlcGVuZGVuY3k6aW5zdGFsbEZhaWxlZCcsIHsgZGVwZW5kZW5jeSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlcGVuZGVuY3lNYW5hZ2VyLm9uKCdkZXBlbmRlbmNpZXNDbGVhbmVkVXAnLCAoKSA9PiB7XHJcbiAgICBicm9hZGNhc3RUb1JlbmRlcmVycygnZGVwZW5kZW5jeTpjbGVhbmVkVXAnKTtcclxuICB9KTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVwZW5kZW5jeSBtYW5hZ2VyXHJcbiAgZGVwZW5kZW5jeU1hbmFnZXIuaW5pdGlhbGl6ZSgpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgZGVwZW5kZW5jeSBtYW5hZ2VyOicsIGVycm9yKTtcclxuICAgIGJyb2FkY2FzdFRvUmVuZGVyZXJzKCdkZXBlbmRlbmN5OmluaXRpYWxpemF0aW9uRmFpbGVkJywgZXJyb3IubWVzc2FnZSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFJlZ2lzdGVyIElQQyBoYW5kbGVyc1xyXG4gIHJlZ2lzdGVySGFuZGxlcnMoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGFsbCBkZXBlbmRlbmN5LXJlbGF0ZWQgSVBDIGhhbmRsZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckhhbmRsZXJzKCk6IHZvaWQge1xyXG4gIGlmICghZGVwZW5kZW5jeU1hbmFnZXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRGVwZW5kZW5jeSBtYW5hZ2VyIG5vdCBpbml0aWFsaXplZCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgZGVwZW5kZW5jeSBzdGF0dXNcclxuICBpcGNNYWluLmhhbmRsZSgnZGVwZW5kZW5jeTpjaGVja1N0YXR1cycsIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBkZXBlbmRlbmN5TWFuYWdlciEuY2hlY2tEZXBlbmRlbmNpZXMoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEdldCBjYWNoZWQgZGVwZW5kZW5jeSBzdGF0dXNcclxuICBpcGNNYWluLmhhbmRsZSgnZGVwZW5kZW5jeTpnZXRTdGF0dXMnLCAoKSA9PiB7XHJcbiAgICByZXR1cm4gZGVwZW5kZW5jeU1hbmFnZXIhLmdldERlcGVuZGVuY3lTdGF0dXMoKTtcclxuICB9KTtcclxuXHJcbiAgLy8gSW5zdGFsbCBhIHNwZWNpZmljIGRlcGVuZGVuY3lcclxuICBpcGNNYWluLmhhbmRsZSgnZGVwZW5kZW5jeTppbnN0YWxsJywgYXN5bmMgKF9ldmVudCwgZGVwZW5kZW5jeU5hbWU6ICd5dGRscCcgfCAnZmZtcGVnJykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFbJ3l0ZGxwJywgJ2ZmbXBlZyddLmluY2x1ZGVzKGRlcGVuZGVuY3lOYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IG5hbWU6ICR7ZGVwZW5kZW5jeU5hbWV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGF3YWl0IGRlcGVuZGVuY3lNYW5hZ2VyIS5pbnN0YWxsRGVwZW5kZW5jeShkZXBlbmRlbmN5TmFtZSk7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIFZhbGlkYXRlIGEgc3BlY2lmaWMgZGVwZW5kZW5jeVxyXG4gIGlwY01haW4uaGFuZGxlKCdkZXBlbmRlbmN5OnZhbGlkYXRlJywgYXN5bmMgKF9ldmVudCwgZGVwZW5kZW5jeU5hbWU6ICd5dGRscCcgfCAnZmZtcGVnJykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFbJ3l0ZGxwJywgJ2ZmbXBlZyddLmluY2x1ZGVzKGRlcGVuZGVuY3lOYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IG5hbWU6ICR7ZGVwZW5kZW5jeU5hbWV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhd2FpdCBkZXBlbmRlbmN5TWFuYWdlciEudmFsaWRhdGVEZXBlbmRlbmN5KGRlcGVuZGVuY3lOYW1lKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEdldCBkZXBlbmRlbmN5IHZlcnNpb25cclxuICBpcGNNYWluLmhhbmRsZSgnZGVwZW5kZW5jeTpnZXRWZXJzaW9uJywgYXN5bmMgKF9ldmVudCwgZGVwZW5kZW5jeU5hbWU6ICd5dGRscCcgfCAnZmZtcGVnJykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFbJ3l0ZGxwJywgJ2ZmbXBlZyddLmluY2x1ZGVzKGRlcGVuZGVuY3lOYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZXBlbmRlbmN5IG5hbWU6ICR7ZGVwZW5kZW5jeU5hbWV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhd2FpdCBkZXBlbmRlbmN5TWFuYWdlciEuZ2V0RGVwZW5kZW5jeVZlcnNpb24oZGVwZW5kZW5jeU5hbWUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gR2V0IGRlcGVuZGVuY3kgcGF0aFxyXG4gIGlwY01haW4uaGFuZGxlKCdkZXBlbmRlbmN5OmdldFBhdGgnLCAoX2V2ZW50LCBkZXBlbmRlbmN5TmFtZTogJ3l0ZGxwJyB8ICdmZm1wZWcnKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIVsneXRkbHAnLCAnZmZtcGVnJ10uaW5jbHVkZXMoZGVwZW5kZW5jeU5hbWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlcGVuZGVuY3kgbmFtZTogJHtkZXBlbmRlbmN5TmFtZX1gKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGRlcGVuZGVuY3lNYW5hZ2VyIS5nZXREZXBlbmRlbmN5UGF0aChkZXBlbmRlbmN5TmFtZSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBDbGVhbiB1cCBhbGwgZGVwZW5kZW5jaWVzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2RlcGVuZGVuY3k6Y2xlYW51cCcsIGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGRlcGVuZGVuY3lNYW5hZ2VyIS5jbGVhbnVwRGVwZW5kZW5jaWVzKCk7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIENoZWNrIGlmIGFsbCBkZXBlbmRlbmNpZXMgYXJlIHJlYWR5XHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2RlcGVuZGVuY3k6YXJlQWxsUmVhZHknLCAoKSA9PiB7XHJcbiAgICByZXR1cm4gZGVwZW5kZW5jeU1hbmFnZXIhLmFyZUFsbERlcGVuZGVuY2llc1JlYWR5KCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIENoZWNrIGlmIGRlcGVuZGVuY3kgbWFuYWdlciBpcyBpbml0aWFsaXplZFxyXG4gIGlwY01haW4uaGFuZGxlKCdkZXBlbmRlbmN5OmlzSW5pdGlhbGl6ZWQnLCAoKSA9PiB7XHJcbiAgICByZXR1cm4gZGVwZW5kZW5jeU1hbmFnZXIhLmlzSW5pdGlhbGl6ZWQoKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJyb2FkY2FzdCBhbiBldmVudCB0byBhbGwgcmVuZGVyZXIgcHJvY2Vzc2VzXHJcbiAqL1xyXG5mdW5jdGlvbiBicm9hZGNhc3RUb1JlbmRlcmVycyhjaGFubmVsOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcclxuICBjb25zdCB3aW5kb3dzID0gQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCk7XHJcbiAgd2luZG93cy5mb3JFYWNoKHdpbmRvdyA9PiB7XHJcbiAgICBpZiAoIXdpbmRvdy5pc0Rlc3Ryb3llZCgpKSB7XHJcbiAgICAgIHdpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBkZXBlbmRlbmN5IG1hbmFnZXIgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRlbmN5TWFuYWdlcigpOiBEZXBlbmRlbmN5TWFuYWdlclNlcnZpY2UgfCBudWxsIHtcclxuICByZXR1cm4gZGVwZW5kZW5jeU1hbmFnZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbnVwIGRlcGVuZGVuY3kgaGFuZGxlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwRGVwZW5kZW5jeUhhbmRsZXJzKCk6IHZvaWQge1xyXG4gIGlmIChkZXBlbmRlbmN5TWFuYWdlcikge1xyXG4gICAgZGVwZW5kZW5jeU1hbmFnZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICBkZXBlbmRlbmN5TWFuYWdlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgSVBDIGhhbmRsZXJzXHJcbiAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAnZGVwZW5kZW5jeTpjaGVja1N0YXR1cycsXHJcbiAgICAnZGVwZW5kZW5jeTpnZXRTdGF0dXMnLFxyXG4gICAgJ2RlcGVuZGVuY3k6aW5zdGFsbCcsXHJcbiAgICAnZGVwZW5kZW5jeTp2YWxpZGF0ZScsXHJcbiAgICAnZGVwZW5kZW5jeTpnZXRWZXJzaW9uJyxcclxuICAgICdkZXBlbmRlbmN5OmdldFBhdGgnLFxyXG4gICAgJ2RlcGVuZGVuY3k6Y2xlYW51cCcsXHJcbiAgICAnZGVwZW5kZW5jeTphcmVBbGxSZWFkeScsXHJcbiAgICAnZGVwZW5kZW5jeTppc0luaXRpYWxpemVkJyxcclxuICBdO1xyXG5cclxuICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xyXG4gICAgaXBjTWFpbi5yZW1vdmVIYW5kbGVyKGhhbmRsZXIpO1xyXG4gIH0pO1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/backend/handlers/dependency-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/error-handlers.ts":
/*!************************************************!*\
  !*** ./src/backend/handlers/error-handlers.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * IPC Error Handlers\n * Provides secure IPC communication for error handling and recovery operations\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initializeErrorHandlers = initializeErrorHandlers;\nexports.cleanupErrorHandlers = cleanupErrorHandlers;\nexports.handleIPCError = handleIPCError;\nexports.createErrorResponse = createErrorResponse;\nexports.validateErrorHandlerService = validateErrorHandlerService;\nexports.getErrorHandlerService = getErrorHandlerService;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst index_1 = __webpack_require__(/*! ./index */ \"./src/backend/handlers/index.ts\");\nconst logger_service_1 = __webpack_require__(/*! ../services/logger-service */ \"./src/backend/services/logger-service.ts\");\nlet errorHandlerService = null;\nconst logger = (0, logger_service_1.getLogger)();\n/**\n * Initialize error handler service and register IPC handlers\n */\nfunction initializeErrorHandlers(errorHandler) {\n    errorHandlerService = errorHandler;\n    registerErrorIPCHandlers();\n    logger.info('Error IPC handlers initialized', 'ErrorHandlers');\n}\n/**\n * Register all error-related IPC handlers\n */\nfunction registerErrorIPCHandlers() {\n    // Get error statistics\n    electron_1.ipcMain.handle('error:getStatistics', (0, index_1.createIPCHandler)(async () => {\n        if (!errorHandlerService) {\n            throw new Error('Error handler service not initialized');\n        }\n        return errorHandlerService.getErrorStatistics();\n    }));\n    // Get recent error reports\n    electron_1.ipcMain.handle('error:getRecentReports', (0, index_1.createIPCHandler)(async (limit = 10) => {\n        if (!errorHandlerService) {\n            throw new Error('Error handler service not initialized');\n        }\n        const stats = errorHandlerService.getErrorStatistics();\n        return stats.recentErrors.slice(0, limit);\n    }));\n    // Report an error from renderer process\n    electron_1.ipcMain.handle('error:report', (0, index_1.createIPCHandler)(async (error, context, options) => {\n        if (!errorHandlerService) {\n            throw new Error('Error handler service not initialized');\n        }\n        // Create Error object from serialized error\n        const errorObj = new Error(error.message);\n        errorObj.name = error.name || 'RendererError';\n        errorObj.stack = error.stack;\n        return await errorHandlerService.handleError(errorObj, context, options);\n    }));\n    // Clear old error reports\n    electron_1.ipcMain.handle('error:clearOldReports', (0, index_1.createIPCHandler)(async (maxAge) => {\n        if (!errorHandlerService) {\n            throw new Error('Error handler service not initialized');\n        }\n        errorHandlerService.clearOldReports(maxAge);\n    }));\n    // Trigger graceful shutdown\n    electron_1.ipcMain.handle('error:gracefulShutdown', (0, index_1.createIPCHandler)(async (reason = 'User requested') => {\n        if (!errorHandlerService) {\n            throw new Error('Error handler service not initialized');\n        }\n        await errorHandlerService.gracefulShutdown(reason);\n    }));\n    // Test error handling (development only)\n    if (process.env.NODE_ENV === 'development') {\n        electron_1.ipcMain.handle('error:test', (0, index_1.createIPCHandler)(async (errorType) => {\n            if (!errorHandlerService) {\n                throw new Error('Error handler service not initialized');\n            }\n            let testError;\n            switch (errorType) {\n                case 'network':\n                    testError = new Error('ENOTFOUND: Network connection failed');\n                    break;\n                case 'filesystem':\n                    testError = new Error('ENOENT: File not found');\n                    break;\n                case 'permission':\n                    testError = new Error('EACCES: Permission denied');\n                    break;\n                case 'validation':\n                    testError = new Error('Invalid input format');\n                    break;\n                default:\n                    testError = new Error('Test error for development');\n            }\n            return await errorHandlerService.handleError(testError, {\n                operation: 'test',\n                component: 'ErrorHandlers',\n                additionalData: { errorType },\n            });\n        }));\n    }\n    logger.debug('Error IPC handlers registered successfully', 'ErrorHandlers');\n}\n/**\n * Cleanup error IPC handlers\n */\nfunction cleanupErrorHandlers() {\n    // Remove specific error handlers\n    const errorChannels = [\n        'error:getStatistics',\n        'error:getRecentReports',\n        'error:report',\n        'error:clearOldReports',\n        'error:gracefulShutdown',\n    ];\n    if (process.env.NODE_ENV === 'development') {\n        errorChannels.push('error:test');\n    }\n    errorChannels.forEach(channel => {\n        electron_1.ipcMain.removeHandler(channel);\n    });\n    errorHandlerService = null;\n    logger.info('Error IPC handlers cleaned up', 'ErrorHandlers');\n}\n/**\n * Handle IPC errors with proper error response format\n */\nfunction handleIPCError(error, channel, args) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`IPC Error in channel: ${channel}`, 'ErrorHandlers', {\n        error: errorMessage,\n        args: args ? JSON.stringify(args) : undefined,\n    });\n    // If we have an error handler service, report the error\n    if (errorHandlerService) {\n        const errorObj = error instanceof Error ? error : new Error(errorMessage);\n        errorHandlerService.handleError(errorObj, {\n            operation: 'ipc',\n            component: 'ErrorHandlers',\n            additionalData: { channel, args },\n        }).catch(handlingError => {\n            logger.error('Failed to handle IPC error', 'ErrorHandlers', {\n                originalError: errorMessage,\n                handlingError: handlingError instanceof Error ? handlingError.message : handlingError,\n            });\n        });\n    }\n    return (0, index_1.createIPCResponse)(undefined, errorMessage);\n}\n/**\n * Create standardized error response for IPC\n */\nfunction createErrorResponse(error, context) {\n    return (0, index_1.createIPCResponse)(undefined, `${context ? `${context}: ` : ''}${error.message}`);\n}\n/**\n * Validate error handler service is available\n */\nfunction validateErrorHandlerService() {\n    if (!errorHandlerService) {\n        throw new Error('Error handler service not initialized. Call initializeErrorHandlers first.');\n    }\n}\n/**\n * Get error handler service instance (for internal use)\n */\nfunction getErrorHandlerService() {\n    return errorHandlerService;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDO0lBQ2hHLENBQUM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixzQkFBc0I7SUFDcEMsT0FBTyxtQkFBbUIsQ0FBQztBQUM3QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9oYW5kbGVycy9lcnJvci1oYW5kbGVycy50cz9kNDQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBJUEMgRXJyb3IgSGFuZGxlcnNcclxuICogUHJvdmlkZXMgc2VjdXJlIElQQyBjb21tdW5pY2F0aW9uIGZvciBlcnJvciBoYW5kbGluZyBhbmQgcmVjb3Zlcnkgb3BlcmF0aW9uc1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IGlwY01haW4gfSBmcm9tICdlbGVjdHJvbic7XHJcbmltcG9ydCB7IEVycm9ySGFuZGxlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9lcnJvci1oYW5kbGVyLXNlcnZpY2UnO1xyXG5pbXBvcnQgeyBjcmVhdGVJUENIYW5kbGVyLCBjcmVhdGVJUENSZXNwb25zZSB9IGZyb20gJy4vaW5kZXgnO1xyXG5pbXBvcnQgdHlwZSB7IFxyXG4gIEVycm9yU3RhdGlzdGljcywgXHJcbiAgRXJyb3JSZXBvcnQsIFxyXG4gIEVycm9yQ29udGV4dCwgXHJcbiAgUmVjb3ZlcnlPcHRpb25zLFxyXG4gIEVycm9ySGFuZGxlckNvbmZpZyBcclxufSBmcm9tICdAL3NoYXJlZC90eXBlcy9lcnJvci10eXBlcyc7XHJcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJy4uL3NlcnZpY2VzL2xvZ2dlci1zZXJ2aWNlJztcclxuXHJcbmxldCBlcnJvckhhbmRsZXJTZXJ2aWNlOiBFcnJvckhhbmRsZXJTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XHJcbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgZXJyb3IgaGFuZGxlciBzZXJ2aWNlIGFuZCByZWdpc3RlciBJUEMgaGFuZGxlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGVycyhlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlclNlcnZpY2UpOiB2b2lkIHtcclxuICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gZXJyb3JIYW5kbGVyO1xyXG4gIHJlZ2lzdGVyRXJyb3JJUENIYW5kbGVycygpO1xyXG4gIGxvZ2dlci5pbmZvKCdFcnJvciBJUEMgaGFuZGxlcnMgaW5pdGlhbGl6ZWQnLCAnRXJyb3JIYW5kbGVycycpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXIgYWxsIGVycm9yLXJlbGF0ZWQgSVBDIGhhbmRsZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckVycm9ySVBDSGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgLy8gR2V0IGVycm9yIHN0YXRpc3RpY3NcclxuICBpcGNNYWluLmhhbmRsZSgnZXJyb3I6Z2V0U3RhdGlzdGljcycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCk6IFByb21pc2U8RXJyb3JTdGF0aXN0aWNzPiA9PiB7XHJcbiAgICBpZiAoIWVycm9ySGFuZGxlclNlcnZpY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBoYW5kbGVyIHNlcnZpY2Ugbm90IGluaXRpYWxpemVkJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldEVycm9yU3RhdGlzdGljcygpO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gR2V0IHJlY2VudCBlcnJvciByZXBvcnRzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2Vycm9yOmdldFJlY2VudFJlcG9ydHMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChsaW1pdDogbnVtYmVyID0gMTApOiBQcm9taXNlPEVycm9yUmVwb3J0W10+ID0+IHtcclxuICAgIGlmICghZXJyb3JIYW5kbGVyU2VydmljZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGhhbmRsZXIgc2VydmljZSBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgc3RhdHMgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldEVycm9yU3RhdGlzdGljcygpO1xyXG4gICAgcmV0dXJuIHN0YXRzLnJlY2VudEVycm9ycy5zbGljZSgwLCBsaW1pdCk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBSZXBvcnQgYW4gZXJyb3IgZnJvbSByZW5kZXJlciBwcm9jZXNzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2Vycm9yOnJlcG9ydCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKFxyXG4gICAgZXJyb3I6IHsgbWVzc2FnZTogc3RyaW5nOyBzdGFjaz86IHN0cmluZzsgbmFtZT86IHN0cmluZyB9LFxyXG4gICAgY29udGV4dDogRXJyb3JDb250ZXh0LFxyXG4gICAgb3B0aW9ucz86IFJlY292ZXJ5T3B0aW9uc1xyXG4gICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gICAgaWYgKCFlcnJvckhhbmRsZXJTZXJ2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgaGFuZGxlciBzZXJ2aWNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgRXJyb3Igb2JqZWN0IGZyb20gc2VyaWFsaXplZCBlcnJvclxyXG4gICAgY29uc3QgZXJyb3JPYmogPSBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICBlcnJvck9iai5uYW1lID0gZXJyb3IubmFtZSB8fCAnUmVuZGVyZXJFcnJvcic7XHJcbiAgICBlcnJvck9iai5zdGFjayA9IGVycm9yLnN0YWNrO1xyXG4gICAgXHJcbiAgICByZXR1cm4gYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcihlcnJvck9iaiwgY29udGV4dCwgb3B0aW9ucyk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDbGVhciBvbGQgZXJyb3IgcmVwb3J0c1xyXG4gIGlwY01haW4uaGFuZGxlKCdlcnJvcjpjbGVhck9sZFJlcG9ydHMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChtYXhBZ2U/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGlmICghZXJyb3JIYW5kbGVyU2VydmljZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGhhbmRsZXIgc2VydmljZSBub3QgaW5pdGlhbGl6ZWQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZXJyb3JIYW5kbGVyU2VydmljZS5jbGVhck9sZFJlcG9ydHMobWF4QWdlKTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFRyaWdnZXIgZ3JhY2VmdWwgc2h1dGRvd25cclxuICBpcGNNYWluLmhhbmRsZSgnZXJyb3I6Z3JhY2VmdWxTaHV0ZG93bicsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHJlYXNvbjogc3RyaW5nID0gJ1VzZXIgcmVxdWVzdGVkJyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgaWYgKCFlcnJvckhhbmRsZXJTZXJ2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgaGFuZGxlciBzZXJ2aWNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmdyYWNlZnVsU2h1dGRvd24ocmVhc29uKTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFRlc3QgZXJyb3IgaGFuZGxpbmcgKGRldmVsb3BtZW50IG9ubHkpXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICBpcGNNYWluLmhhbmRsZSgnZXJyb3I6dGVzdCcsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGVycm9yVHlwZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XHJcbiAgICAgIGlmICghZXJyb3JIYW5kbGVyU2VydmljZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgaGFuZGxlciBzZXJ2aWNlIG5vdCBpbml0aWFsaXplZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBsZXQgdGVzdEVycm9yOiBFcnJvcjtcclxuICAgICAgXHJcbiAgICAgIHN3aXRjaCAoZXJyb3JUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbmV0d29yayc6XHJcbiAgICAgICAgICB0ZXN0RXJyb3IgPSBuZXcgRXJyb3IoJ0VOT1RGT1VORDogTmV0d29yayBjb25uZWN0aW9uIGZhaWxlZCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZmlsZXN5c3RlbSc6XHJcbiAgICAgICAgICB0ZXN0RXJyb3IgPSBuZXcgRXJyb3IoJ0VOT0VOVDogRmlsZSBub3QgZm91bmQnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3Blcm1pc3Npb24nOlxyXG4gICAgICAgICAgdGVzdEVycm9yID0gbmV3IEVycm9yKCdFQUNDRVM6IFBlcm1pc3Npb24gZGVuaWVkJyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd2YWxpZGF0aW9uJzpcclxuICAgICAgICAgIHRlc3RFcnJvciA9IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBmb3JtYXQnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0ZXN0RXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3IgZm9yIGRldmVsb3BtZW50Jyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKHRlc3RFcnJvciwge1xyXG4gICAgICAgIG9wZXJhdGlvbjogJ3Rlc3QnLFxyXG4gICAgICAgIGNvbXBvbmVudDogJ0Vycm9ySGFuZGxlcnMnLFxyXG4gICAgICAgIGFkZGl0aW9uYWxEYXRhOiB7IGVycm9yVHlwZSB9LFxyXG4gICAgICB9KTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIGxvZ2dlci5kZWJ1ZygnRXJyb3IgSVBDIGhhbmRsZXJzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5JywgJ0Vycm9ySGFuZGxlcnMnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFudXAgZXJyb3IgSVBDIGhhbmRsZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cEVycm9ySGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgLy8gUmVtb3ZlIHNwZWNpZmljIGVycm9yIGhhbmRsZXJzXHJcbiAgY29uc3QgZXJyb3JDaGFubmVscyA9IFtcclxuICAgICdlcnJvcjpnZXRTdGF0aXN0aWNzJyxcclxuICAgICdlcnJvcjpnZXRSZWNlbnRSZXBvcnRzJyxcclxuICAgICdlcnJvcjpyZXBvcnQnLFxyXG4gICAgJ2Vycm9yOmNsZWFyT2xkUmVwb3J0cycsXHJcbiAgICAnZXJyb3I6Z3JhY2VmdWxTaHV0ZG93bicsXHJcbiAgXTtcclxuXHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICBlcnJvckNoYW5uZWxzLnB1c2goJ2Vycm9yOnRlc3QnKTtcclxuICB9XHJcblxyXG4gIGVycm9yQ2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcclxuICAgIGlwY01haW4ucmVtb3ZlSGFuZGxlcihjaGFubmVsKTtcclxuICB9KTtcclxuXHJcbiAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG51bGw7XHJcbiAgbG9nZ2VyLmluZm8oJ0Vycm9yIElQQyBoYW5kbGVycyBjbGVhbmVkIHVwJywgJ0Vycm9ySGFuZGxlcnMnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBJUEMgZXJyb3JzIHdpdGggcHJvcGVyIGVycm9yIHJlc3BvbnNlIGZvcm1hdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUlQQ0Vycm9yKGVycm9yOiB1bmtub3duLCBjaGFubmVsOiBzdHJpbmcsIGFyZ3M/OiBhbnlbXSk6IGFueSB7XHJcbiAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gIFxyXG4gIGxvZ2dlci5lcnJvcihgSVBDIEVycm9yIGluIGNoYW5uZWw6ICR7Y2hhbm5lbH1gLCAnRXJyb3JIYW5kbGVycycsIHtcclxuICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXHJcbiAgICBhcmdzOiBhcmdzID8gSlNPTi5zdHJpbmdpZnkoYXJncykgOiB1bmRlZmluZWQsXHJcbiAgfSk7XHJcblxyXG4gIC8vIElmIHdlIGhhdmUgYW4gZXJyb3IgaGFuZGxlciBzZXJ2aWNlLCByZXBvcnQgdGhlIGVycm9yXHJcbiAgaWYgKGVycm9ySGFuZGxlclNlcnZpY2UpIHtcclxuICAgIGNvbnN0IGVycm9yT2JqID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICBcclxuICAgIGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoZXJyb3JPYmosIHtcclxuICAgICAgb3BlcmF0aW9uOiAnaXBjJyxcclxuICAgICAgY29tcG9uZW50OiAnRXJyb3JIYW5kbGVycycsXHJcbiAgICAgIGFkZGl0aW9uYWxEYXRhOiB7IGNoYW5uZWwsIGFyZ3MgfSxcclxuICAgIH0pLmNhdGNoKGhhbmRsaW5nRXJyb3IgPT4ge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBoYW5kbGUgSVBDIGVycm9yJywgJ0Vycm9ySGFuZGxlcnMnLCB7XHJcbiAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JNZXNzYWdlLFxyXG4gICAgICAgIGhhbmRsaW5nRXJyb3I6IGhhbmRsaW5nRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGhhbmRsaW5nRXJyb3IubWVzc2FnZSA6IGhhbmRsaW5nRXJyb3IsXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlSVBDUmVzcG9uc2UodW5kZWZpbmVkLCBlcnJvck1lc3NhZ2UpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIHN0YW5kYXJkaXplZCBlcnJvciByZXNwb25zZSBmb3IgSVBDXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3JSZXNwb25zZShlcnJvcjogRXJyb3IsIGNvbnRleHQ/OiBzdHJpbmcpOiBhbnkge1xyXG4gIHJldHVybiBjcmVhdGVJUENSZXNwb25zZSh1bmRlZmluZWQsIGAke2NvbnRleHQgPyBgJHtjb250ZXh0fTogYCA6ICcnfSR7ZXJyb3IubWVzc2FnZX1gKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIGVycm9yIGhhbmRsZXIgc2VydmljZSBpcyBhdmFpbGFibGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUVycm9ySGFuZGxlclNlcnZpY2UoKTogdm9pZCB7XHJcbiAgaWYgKCFlcnJvckhhbmRsZXJTZXJ2aWNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGhhbmRsZXIgc2VydmljZSBub3QgaW5pdGlhbGl6ZWQuIENhbGwgaW5pdGlhbGl6ZUVycm9ySGFuZGxlcnMgZmlyc3QuJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGVycm9yIGhhbmRsZXIgc2VydmljZSBpbnN0YW5jZSAoZm9yIGludGVybmFsIHVzZSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvckhhbmRsZXJTZXJ2aWNlKCk6IEVycm9ySGFuZGxlclNlcnZpY2UgfCBudWxsIHtcclxuICByZXR1cm4gZXJyb3JIYW5kbGVyU2VydmljZTtcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/handlers/error-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/files/file-handlers.ts":
/*!*****************************************************!*\
  !*** ./src/backend/handlers/files/file-handlers.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerFileHandlers = registerFileHandlers;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst index_1 = __webpack_require__(/*! ../index */ \"./src/backend/handlers/index.ts\");\nconst file_system_service_1 = __webpack_require__(/*! ../../services/file-system-service */ \"./src/backend/services/file-system-service.ts\");\n// Initialize file system service\nconst fileSystemService = new file_system_service_1.FileSystemService();\nfunction registerFileHandlers() {\n    // Check if file exists\n    electron_1.ipcMain.handle('fs:exists', (0, index_1.createIPCHandler)(async (filePath) => {\n        return await fileSystemService.exists(filePath);\n    }));\n    // Read JSON file\n    electron_1.ipcMain.handle('fs:readJson', (0, index_1.createIPCHandler)(async (filePath) => {\n        return await fileSystemService.readJson(filePath);\n    }));\n    // Write JSON file\n    electron_1.ipcMain.handle('fs:writeJson', (0, index_1.createIPCHandler)(async (filePath, data) => {\n        await fileSystemService.writeJson(filePath, data);\n        return { success: true };\n    }));\n    // Read text file\n    electron_1.ipcMain.handle('fs:readText', (0, index_1.createIPCHandler)(async (filePath, encoding) => {\n        return await fileSystemService.readFile(filePath, encoding);\n    }));\n    // Write text file\n    electron_1.ipcMain.handle('fs:writeText', (0, index_1.createIPCHandler)(async (filePath, content, encoding) => {\n        await fileSystemService.writeFile(filePath, content, encoding);\n        return { success: true };\n    }));\n    // Delete file\n    electron_1.ipcMain.handle('fs:delete', (0, index_1.createIPCHandler)(async (filePath) => {\n        await fileSystemService.deleteFile(filePath);\n        return { success: true };\n    }));\n    // Copy file\n    electron_1.ipcMain.handle('fs:copy', (0, index_1.createIPCHandler)(async (src, dest) => {\n        await fileSystemService.copyFile(src, dest);\n        return { success: true };\n    }));\n    // Move file\n    electron_1.ipcMain.handle('fs:move', (0, index_1.createIPCHandler)(async (src, dest) => {\n        await fileSystemService.moveFile(src, dest);\n        return { success: true };\n    }));\n    // Get file stats\n    electron_1.ipcMain.handle('fs:getStats', (0, index_1.createIPCHandler)(async (filePath) => {\n        const stats = await fileSystemService.getStats(filePath);\n        return {\n            size: stats.size,\n            isFile: stats.isFile,\n            isDirectory: stats.isDirectory,\n            mtime: stats.modifiedAt,\n            ctime: stats.createdAt,\n            atime: stats.accessedAt\n        };\n    }));\n    // List files in directory (using listDirectory method)\n    electron_1.ipcMain.handle('fs:listFiles', (0, index_1.createIPCHandler)(async (dirPath) => {\n        const dirStructure = await fileSystemService.listDirectory(dirPath);\n        return dirStructure.files;\n    }));\n    // List directories (using listDirectory method)\n    electron_1.ipcMain.handle('fs:listDirectories', (0, index_1.createIPCHandler)(async (dirPath) => {\n        const dirStructure = await fileSystemService.listDirectory(dirPath);\n        return dirStructure.directories;\n    }));\n    // Ensure directory exists\n    electron_1.ipcMain.handle('fs:ensureDirectory', (0, index_1.createIPCHandler)(async (dirPath) => {\n        await fileSystemService.ensureDirectory(dirPath);\n        return { success: true };\n    }));\n    // Get file size\n    electron_1.ipcMain.handle('fs:getSize', (0, index_1.createIPCHandler)(async (filePath) => {\n        return await fileSystemService.getSize(filePath);\n    }));\n    // Format file size (utility method - implement inline)\n    electron_1.ipcMain.handle('fs:formatSize', (0, index_1.createIPCHandler)(async (bytes) => {\n        const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n        let size = bytes;\n        let unitIndex = 0;\n        while (size >= 1024 && unitIndex < units.length - 1) {\n            size /= 1024;\n            unitIndex++;\n        }\n        return `${size.toFixed(2)} ${units[unitIndex]}`;\n    }));\n    // Sanitize filename (using sanitizePath method)\n    electron_1.ipcMain.handle('fs:sanitizeFilename', (0, index_1.createIPCHandler)(async (filename) => {\n        return fileSystemService.sanitizePath(filename);\n    }));\n    // Create unique filename (implement inline)\n    electron_1.ipcMain.handle('fs:createUniqueFilename', (0, index_1.createIPCHandler)(async (filePath) => {\n        let counter = 1;\n        let uniquePath = filePath;\n        while (await fileSystemService.exists(uniquePath)) {\n            const ext = path.extname(filePath);\n            const base = path.basename(filePath, ext);\n            const dir = path.dirname(filePath);\n            uniquePath = path.join(dir, `${base}_${counter}${ext}`);\n            counter++;\n        }\n        return uniquePath;\n    }));\n    // Get application paths\n    electron_1.ipcMain.handle('fs:getAppPaths', (0, index_1.createIPCHandler)(async () => {\n        return fileSystemService.getAppDirectories();\n    }));\n    // Initialize directories\n    electron_1.ipcMain.handle('fs:initializeDirectories', (0, index_1.createIPCHandler)(async () => {\n        await fileSystemService.initializeAppDirectories();\n        return { success: true };\n    }));\n    // Cleanup temp files\n    electron_1.ipcMain.handle('fs:cleanupTempFiles', (0, index_1.createIPCHandler)(async () => {\n        await fileSystemService.cleanupTempFiles();\n        return { success: true };\n    }));\n    // Select directory dialog\n    electron_1.ipcMain.handle('fs:selectDirectory', (0, index_1.createIPCHandler)(async () => {\n        const focusedWindow = electron_1.BrowserWindow.getFocusedWindow();\n        const result = await electron_1.dialog.showOpenDialog(focusedWindow || new electron_1.BrowserWindow(), {\n            properties: ['openDirectory'],\n        });\n        if (result.canceled || result.filePaths.length === 0) {\n            return null;\n        }\n        return result.filePaths[0];\n    }));\n    console.log(' File system IPC handlers registered');\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9oYW5kbGVycy9maWxlcy9maWxlLWhhbmRsZXJzLnRzIiwibWFwcGluZ3MiOiI7O0FBUUEsb0RBcUpDOztBQTdKRCxtRUFBMEQ7QUFDMUQsMkVBQTZCO0FBQzdCLHVGQUE0QztBQUM1Qyw2SUFBdUU7QUFFdkUsaUNBQWlDO0FBQ2pDLE1BQU0saUJBQWlCLEdBQUcsSUFBSSx1Q0FBaUIsRUFBRSxDQUFDO0FBRWxELFNBQWdCLG9CQUFvQjtJQUNsQyx1QkFBdUI7SUFDdkIsa0JBQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLDRCQUFnQixFQUFDLEtBQUssRUFBRSxRQUFnQixFQUFFLEVBQUU7UUFDdEUsT0FBTyxNQUFNLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsRCxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosaUJBQWlCO0lBQ2pCLGtCQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsUUFBZ0IsRUFBRSxFQUFFO1FBQ3hFLE9BQU8sTUFBTSxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLGtCQUFrQjtJQUNsQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFFBQWdCLEVBQUUsSUFBUyxFQUFFLEVBQUU7UUFDcEYsTUFBTSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xELE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLGlCQUFpQjtJQUNqQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFFBQWdCLEVBQUUsUUFBeUIsRUFBRSxFQUFFO1FBQ25HLE9BQU8sTUFBTSxpQkFBaUIs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M0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVKLHFCQUFxQjtJQUNyQixrQkFBTyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUNoRSxNQUFNLGlCQUFpQixDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosMEJBQTBCO0lBQzFCLGtCQUFPLENBQUMsTUFBTSxDQUFDLG9CQUFvQixFQUFFLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQy9ELE1BQU0sYUFBYSxHQUFHLHdCQUFhLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN2RCxNQUFNLE1BQU0sR0FBRyxNQUFNLGlCQUFNLENBQUMsY0FBYyxDQUFDLGFBQWEsSUFBSSxJQUFJLHdCQUFhLEVBQUUsRUFBRTtZQUMvRSxVQUFVLEVBQUUsQ0FBQyxlQUFlLENBQUM7U0FDOUIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxNQUFNLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ3JELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosT0FBTyxDQUFDLEdBQUcsQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFBQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9oYW5kbGVycy9maWxlcy9maWxlLWhhbmRsZXJzLnRzPzMyYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXBjTWFpbiwgZGlhbG9nLCBCcm93c2VyV2luZG93IH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgeyBjcmVhdGVJUENIYW5kbGVyIH0gZnJvbSAnLi4vaW5kZXgnO1xyXG5pbXBvcnQgeyBGaWxlU3lzdGVtU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZpbGUtc3lzdGVtLXNlcnZpY2UnO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBmaWxlIHN5c3RlbSBzZXJ2aWNlXHJcbmNvbnN0IGZpbGVTeXN0ZW1TZXJ2aWNlID0gbmV3IEZpbGVTeXN0ZW1TZXJ2aWNlKCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJGaWxlSGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgLy8gQ2hlY2sgaWYgZmlsZSBleGlzdHNcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6ZXhpc3RzJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgcmV0dXJuIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmV4aXN0cyhmaWxlUGF0aCk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBSZWFkIEpTT04gZmlsZVxyXG4gIGlwY01haW4uaGFuZGxlKCdmczpyZWFkSnNvbicsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIHJldHVybiBhd2FpdCBmaWxlU3lzdGVtU2VydmljZS5yZWFkSnNvbihmaWxlUGF0aCk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBXcml0ZSBKU09OIGZpbGVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6d3JpdGVKc29uJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoZmlsZVBhdGg6IHN0cmluZywgZGF0YTogYW55KSA9PiB7XHJcbiAgICBhd2FpdCBmaWxlU3lzdGVtU2VydmljZS53cml0ZUpzb24oZmlsZVBhdGgsIGRhdGEpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gUmVhZCB0ZXh0IGZpbGVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6cmVhZFRleHQnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChmaWxlUGF0aDogc3RyaW5nLCBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nKSA9PiB7XHJcbiAgICByZXR1cm4gYXdhaXQgZmlsZVN5c3RlbVNlcnZpY2UucmVhZEZpbGUoZmlsZVBhdGgsIGVuY29kaW5nKTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFdyaXRlIHRleHQgZmlsZVxyXG4gIGlwY01haW4uaGFuZGxlKCdmczp3cml0ZVRleHQnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChmaWxlUGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIGVuY29kaW5nPzogQnVmZmVyRW5jb2RpbmcpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLndyaXRlRmlsZShmaWxlUGF0aCwgY29udGVudCwgZW5jb2RpbmcpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gRGVsZXRlIGZpbGVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6ZGVsZXRlJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgYXdhaXQgZmlsZVN5c3RlbVNlcnZpY2UuZGVsZXRlRmlsZShmaWxlUGF0aCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDb3B5IGZpbGVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6Y29weScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHNyYzogc3RyaW5nLCBkZXN0OiBzdHJpbmcpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmNvcHlGaWxlKHNyYywgZGVzdCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBNb3ZlIGZpbGVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6bW92ZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHNyYzogc3RyaW5nLCBkZXN0OiBzdHJpbmcpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLm1vdmVGaWxlKHNyYywgZGVzdCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfSkpO1xyXG5cclxuICAvLyBHZXQgZmlsZSBzdGF0c1xyXG4gIGlwY01haW4uaGFuZGxlKCdmczpnZXRTdGF0cycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZmlsZVN5c3RlbVNlcnZpY2UuZ2V0U3RhdHMoZmlsZVBhdGgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcclxuICAgICAgaXNGaWxlOiBzdGF0cy5pc0ZpbGUsXHJcbiAgICAgIGlzRGlyZWN0b3J5OiBzdGF0cy5pc0RpcmVjdG9yeSxcclxuICAgICAgbXRpbWU6IHN0YXRzLm1vZGlmaWVkQXQsXHJcbiAgICAgIGN0aW1lOiBzdGF0cy5jcmVhdGVkQXQsXHJcbiAgICAgIGF0aW1lOiBzdGF0cy5hY2Nlc3NlZEF0XHJcbiAgICB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gTGlzdCBmaWxlcyBpbiBkaXJlY3RvcnkgKHVzaW5nIGxpc3REaXJlY3RvcnkgbWV0aG9kKVxyXG4gIGlwY01haW4uaGFuZGxlKCdmczpsaXN0RmlsZXMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChkaXJQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IGRpclN0cnVjdHVyZSA9IGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmxpc3REaXJlY3RvcnkoZGlyUGF0aCk7XHJcbiAgICByZXR1cm4gZGlyU3RydWN0dXJlLmZpbGVzO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gTGlzdCBkaXJlY3RvcmllcyAodXNpbmcgbGlzdERpcmVjdG9yeSBtZXRob2QpXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2ZzOmxpc3REaXJlY3RvcmllcycsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGRpclBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgZGlyU3RydWN0dXJlID0gYXdhaXQgZmlsZVN5c3RlbVNlcnZpY2UubGlzdERpcmVjdG9yeShkaXJQYXRoKTtcclxuICAgIHJldHVybiBkaXJTdHJ1Y3R1cmUuZGlyZWN0b3JpZXM7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBFbnN1cmUgZGlyZWN0b3J5IGV4aXN0c1xyXG4gIGlwY01haW4uaGFuZGxlKCdmczplbnN1cmVEaXJlY3RvcnknLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jIChkaXJQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmVuc3VyZURpcmVjdG9yeShkaXJQYXRoKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9KSk7XHJcblxyXG4gIC8vIEdldCBmaWxlIHNpemVcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6Z2V0U2l6ZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIHJldHVybiBhd2FpdCBmaWxlU3lzdGVtU2VydmljZS5nZXRTaXplKGZpbGVQYXRoKTtcclxuICB9KSk7XHJcblxyXG4gIC8vIEZvcm1hdCBmaWxlIHNpemUgKHV0aWxpdHkgbWV0aG9kIC0gaW1wbGVtZW50IGlubGluZSlcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6Zm9ybWF0U2l6ZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGJ5dGVzOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHVuaXRzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XHJcbiAgICBsZXQgc2l6ZSA9IGJ5dGVzO1xyXG4gICAgbGV0IHVuaXRJbmRleCA9IDA7XHJcbiAgICBcclxuICAgIHdoaWxlIChzaXplID49IDEwMjQgJiYgdW5pdEluZGV4IDwgdW5pdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICBzaXplIC89IDEwMjQ7XHJcbiAgICAgIHVuaXRJbmRleCsrO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gYCR7c2l6ZS50b0ZpeGVkKDIpfSAke3VuaXRzW3VuaXRJbmRleF19YDtcclxuICB9KSk7XHJcblxyXG4gIC8vIFNhbml0aXplIGZpbGVuYW1lICh1c2luZyBzYW5pdGl6ZVBhdGggbWV0aG9kKVxyXG4gIGlwY01haW4uaGFuZGxlKCdmczpzYW5pdGl6ZUZpbGVuYW1lJywgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoZmlsZW5hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgcmV0dXJuIGZpbGVTeXN0ZW1TZXJ2aWNlLnNhbml0aXplUGF0aChmaWxlbmFtZSk7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBDcmVhdGUgdW5pcXVlIGZpbGVuYW1lIChpbXBsZW1lbnQgaW5saW5lKVxyXG4gIGlwY01haW4uaGFuZGxlKCdmczpjcmVhdGVVbmlxdWVGaWxlbmFtZScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpID0+IHtcclxuICAgIGxldCBjb3VudGVyID0gMTtcclxuICAgIGxldCB1bmlxdWVQYXRoID0gZmlsZVBhdGg7XHJcbiAgICBcclxuICAgIHdoaWxlIChhd2FpdCBmaWxlU3lzdGVtU2VydmljZS5leGlzdHModW5pcXVlUGF0aCkpIHtcclxuICAgICAgY29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGVQYXRoKTtcclxuICAgICAgY29uc3QgYmFzZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgsIGV4dCk7XHJcbiAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XHJcbiAgICAgIHVuaXF1ZVBhdGggPSBwYXRoLmpvaW4oZGlyLCBgJHtiYXNlfV8ke2NvdW50ZXJ9JHtleHR9YCk7XHJcbiAgICAgIGNvdW50ZXIrKztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHVuaXF1ZVBhdGg7XHJcbiAgfSkpO1xyXG5cclxuICAvLyBHZXQgYXBwbGljYXRpb24gcGF0aHNcclxuICBpcGNNYWluLmhhbmRsZSgnZnM6Z2V0QXBwUGF0aHMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgIHJldHVybiBmaWxlU3lzdGVtU2VydmljZS5nZXRBcHBEaXJlY3RvcmllcygpO1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBkaXJlY3Rvcmllc1xyXG4gIGlwY01haW4uaGFuZGxlKCdmczppbml0aWFsaXplRGlyZWN0b3JpZXMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmluaXRpYWxpemVBcHBEaXJlY3RvcmllcygpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH0pKTtcclxuXHJcbiAgLy8gQ2xlYW51cCB0ZW1wIGZpbGVzXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2ZzOmNsZWFudXBUZW1wRmlsZXMnLCBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgIGF3YWl0IGZpbGVTeXN0ZW1TZXJ2aWNlLmNsZWFudXBUZW1wRmlsZXMoKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9KSk7XHJcblxyXG4gIC8vIFNlbGVjdCBkaXJlY3RvcnkgZGlhbG9nXHJcbiAgaXBjTWFpbi5oYW5kbGUoJ2ZzOnNlbGVjdERpcmVjdG9yeScsIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZm9jdXNlZFdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGlhbG9nLnNob3dPcGVuRGlhbG9nKGZvY3VzZWRXaW5kb3cgfHwgbmV3IEJyb3dzZXJXaW5kb3coKSwge1xyXG4gICAgICBwcm9wZXJ0aWVzOiBbJ29wZW5EaXJlY3RvcnknXSxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAocmVzdWx0LmNhbmNlbGVkIHx8IHJlc3VsdC5maWxlUGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0LmZpbGVQYXRoc1swXTtcclxuICB9KSk7XHJcblxyXG4gIGNvbnNvbGUubG9nKCfinIUgRmlsZSBzeXN0ZW0gSVBDIGhhbmRsZXJzIHJlZ2lzdGVyZWQnKTtcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/backend/handlers/files/file-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/index.ts":
/*!***************************************!*\
  !*** ./src/backend/handlers/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Central IPC handler registry for secure communication between main and renderer processes\n * This file organizes all IPC handlers by functional domains and provides proper error handling\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initializeIPCHandlers = initializeIPCHandlers;\nexports.cleanupIPCHandlers = cleanupIPCHandlers;\nexports.createIPCResponse = createIPCResponse;\nexports.handleIPCError = handleIPCError;\nexports.createIPCHandler = createIPCHandler;\nconst dependency_handlers_1 = __webpack_require__(/*! ./dependency-handlers */ \"./src/backend/handlers/dependency-handlers.ts\");\nconst settings_handlers_1 = __webpack_require__(/*! ./settings/settings-handlers */ \"./src/backend/handlers/settings/settings-handlers.ts\");\nconst playlist_handlers_1 = __webpack_require__(/*! ./app/playlist-handlers */ \"./src/backend/handlers/app/playlist-handlers.ts\");\nconst file_handlers_1 = __webpack_require__(/*! ./files/file-handlers */ \"./src/backend/handlers/files/file-handlers.ts\");\nconst app_handlers_1 = __webpack_require__(/*! ./app/app-handlers */ \"./src/backend/handlers/app/app-handlers.ts\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\n/**\n * Registry of all IPC handler domains\n */\nconst handlerRegistry = {\n    app: {\n        register: app_handlers_1.registerAppHandlers,\n    },\n    files: {\n        register: file_handlers_1.registerFileHandlers,\n    },\n    settings: {\n        register: settings_handlers_1.registerSettingsHandlers,\n    },\n    playlists: {\n        register: playlist_handlers_1.registerPlaylistHandlers,\n    },\n    dependencies: {\n        register: dependency_handlers_1.initializeDependencyHandlers,\n        cleanup: dependency_handlers_1.cleanupDependencyHandlers,\n    },\n};\n/**\n * Initialize all IPC handlers with proper error handling\n */\nfunction initializeIPCHandlers() {\n    try {\n        console.log(' Initializing IPC handlers...');\n        // Register all handler domains\n        Object.entries(handlerRegistry).forEach(([domain, handler]) => {\n            try {\n                handler.register();\n                console.log(` ${domain} handlers registered successfully`);\n            }\n            catch (error) {\n                console.error(` Failed to register ${domain} handlers:`, error);\n                throw error;\n            }\n        });\n        // Set up global error handling for IPC\n        setupGlobalIPCErrorHandling();\n        console.log(' All IPC handlers initialized successfully');\n    }\n    catch (error) {\n        console.error(' Critical error during IPC handler initialization:', error);\n        throw error;\n    }\n}\n/**\n * Cleanup all IPC handlers\n */\nfunction cleanupIPCHandlers() {\n    try {\n        console.log(' Cleaning up IPC handlers...');\n        // Cleanup handlers that have cleanup functions\n        Object.entries(handlerRegistry).forEach(([domain, handler]) => {\n            if (handler.cleanup) {\n                try {\n                    handler.cleanup();\n                    console.log(` ${domain} handlers cleaned up successfully`);\n                }\n                catch (error) {\n                    console.error(` Failed to cleanup ${domain} handlers:`, error);\n                }\n            }\n        });\n        // Remove all IPC handlers\n        electron_1.ipcMain.removeAllListeners();\n        console.log(' All IPC handlers cleaned up successfully');\n    }\n    catch (error) {\n        console.error(' Error during IPC handler cleanup:', error);\n    }\n}\n/**\n * Set up global error handling for IPC communication\n */\nfunction setupGlobalIPCErrorHandling() {\n    // Handle uncaught exceptions in IPC handlers\n    process.on('uncaughtException', error => {\n        console.error(' Uncaught exception in IPC handler:', error);\n        // In production, you might want to report this error\n    });\n    // Handle unhandled promise rejections in IPC handlers\n    process.on('unhandledRejection', (reason, promise) => {\n        console.error(' Unhandled rejection in IPC handler:', reason, 'at:', promise);\n        // In production, you might want to report this error\n    });\n}\n/**\n * Utility function to create standardized IPC response\n */\nfunction createIPCResponse(data, error) {\n    if (error) {\n        return {\n            success: false,\n            error,\n            timestamp: new Date().toISOString(),\n        };\n    }\n    return {\n        success: true,\n        data,\n        timestamp: new Date().toISOString(),\n    };\n}\n/**\n * Utility function to handle IPC errors consistently\n */\nfunction handleIPCError(error, context) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    console.error(`IPC Error in ${context}:`, error);\n    return createIPCResponse(undefined, errorMessage);\n}\n/**\n * Type-safe IPC handler wrapper\n */\nfunction createIPCHandler(handler) {\n    return async (_event, ...args) => {\n        try {\n            const result = await handler(...args);\n            return createIPCResponse(result);\n        }\n        catch (error) {\n            return handleIPCError(error, handler.name || 'anonymous handler');\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUIsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQVlEOztHQUVHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQzlCLE9BQXVEO0lBRXZELE9BQU8sS0FBSyxFQUNWLE1BQW1DLEVBQ25DLEdBQUcsSUFBVyxFQUNpQixFQUFFO1FBQ2pDLElBQUksQ0FBQztZQUNILE1BQU0sTUFBTSxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDdEMsT0FBTyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sY0FBYyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLG1CQUFtQixDQUFDLENBQUM7UUFDcEUsQ0FBQztJQUNILENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL2hhbmRsZXJzL2luZGV4LnRzPzBmNWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENlbnRyYWwgSVBDIGhhbmRsZXIgcmVnaXN0cnkgZm9yIHNlY3VyZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gbWFpbiBhbmQgcmVuZGVyZXIgcHJvY2Vzc2VzXHJcbiAqIFRoaXMgZmlsZSBvcmdhbml6ZXMgYWxsIElQQyBoYW5kbGVycyBieSBmdW5jdGlvbmFsIGRvbWFpbnMgYW5kIHByb3ZpZGVzIHByb3BlciBlcnJvciBoYW5kbGluZ1xyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgY2xlYW51cERlcGVuZGVuY3lIYW5kbGVycyxcclxuICBpbml0aWFsaXplRGVwZW5kZW5jeUhhbmRsZXJzLFxyXG59IGZyb20gJy4vZGVwZW5kZW5jeS1oYW5kbGVycyc7XHJcbmltcG9ydCB7IHJlZ2lzdGVyU2V0dGluZ3NIYW5kbGVycyB9IGZyb20gJy4vc2V0dGluZ3Mvc2V0dGluZ3MtaGFuZGxlcnMnO1xyXG5pbXBvcnQgeyByZWdpc3RlclBsYXlsaXN0SGFuZGxlcnMgfSBmcm9tICcuL2FwcC9wbGF5bGlzdC1oYW5kbGVycyc7XHJcbmltcG9ydCB7IHJlZ2lzdGVyRmlsZUhhbmRsZXJzIH0gZnJvbSAnLi9maWxlcy9maWxlLWhhbmRsZXJzJztcclxuaW1wb3J0IHsgcmVnaXN0ZXJBcHBIYW5kbGVycyB9IGZyb20gJy4vYXBwL2FwcC1oYW5kbGVycyc7XHJcbmltcG9ydCB7IGlwY01haW4gfSBmcm9tICdlbGVjdHJvbic7XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBJUEMgaGFuZGxlciByZWdpc3RyYXRpb24gZnVuY3Rpb25zXHJcbiAqL1xyXG5pbnRlcmZhY2UgSGFuZGxlclJlZ2lzdHJhdGlvbiB7XHJcbiAgcmVnaXN0ZXI6ICgpID0+IHZvaWQ7XHJcbiAgY2xlYW51cD86ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RyeSBvZiBhbGwgSVBDIGhhbmRsZXIgZG9tYWluc1xyXG4gKi9cclxuY29uc3QgaGFuZGxlclJlZ2lzdHJ5OiBSZWNvcmQ8c3RyaW5nLCBIYW5kbGVyUmVnaXN0cmF0aW9uPiA9IHtcclxuICBhcHA6IHtcclxuICAgIHJlZ2lzdGVyOiByZWdpc3RlckFwcEhhbmRsZXJzLFxyXG4gIH0sXHJcbiAgZmlsZXM6IHtcclxuICAgIHJlZ2lzdGVyOiByZWdpc3RlckZpbGVIYW5kbGVycyxcclxuICB9LFxyXG4gIHNldHRpbmdzOiB7XHJcbiAgICByZWdpc3RlcjogcmVnaXN0ZXJTZXR0aW5nc0hhbmRsZXJzLFxyXG4gIH0sXHJcbiAgcGxheWxpc3RzOiB7XHJcbiAgICByZWdpc3RlcjogcmVnaXN0ZXJQbGF5bGlzdEhhbmRsZXJzLFxyXG4gIH0sXHJcbiAgZGVwZW5kZW5jaWVzOiB7XHJcbiAgICByZWdpc3RlcjogaW5pdGlhbGl6ZURlcGVuZGVuY3lIYW5kbGVycyxcclxuICAgIGNsZWFudXA6IGNsZWFudXBEZXBlbmRlbmN5SGFuZGxlcnMsXHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGFsbCBJUEMgaGFuZGxlcnMgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplSVBDSGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIEluaXRpYWxpemluZyBJUEMgaGFuZGxlcnMuLi4nKTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciBhbGwgaGFuZGxlciBkb21haW5zXHJcbiAgICBPYmplY3QuZW50cmllcyhoYW5kbGVyUmVnaXN0cnkpLmZvckVhY2goKFtkb21haW4sIGhhbmRsZXJdKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaGFuZGxlci5yZWdpc3RlcigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgJHtkb21haW59IGhhbmRsZXJzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5YCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byByZWdpc3RlciAke2RvbWFpbn0gaGFuZGxlcnM6YCwgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZXQgdXAgZ2xvYmFsIGVycm9yIGhhbmRsaW5nIGZvciBJUENcclxuICAgIHNldHVwR2xvYmFsSVBDRXJyb3JIYW5kbGluZygpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn46JIEFsbCBJUEMgaGFuZGxlcnMgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICfwn5KlIENyaXRpY2FsIGVycm9yIGR1cmluZyBJUEMgaGFuZGxlciBpbml0aWFsaXphdGlvbjonLFxyXG4gICAgICBlcnJvcixcclxuICAgICk7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbnVwIGFsbCBJUEMgaGFuZGxlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwSVBDSGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFuaW5nIHVwIElQQyBoYW5kbGVycy4uLicpO1xyXG5cclxuICAgIC8vIENsZWFudXAgaGFuZGxlcnMgdGhhdCBoYXZlIGNsZWFudXAgZnVuY3Rpb25zXHJcbiAgICBPYmplY3QuZW50cmllcyhoYW5kbGVyUmVnaXN0cnkpLmZvckVhY2goKFtkb21haW4sIGhhbmRsZXJdKSA9PiB7XHJcbiAgICAgIGlmIChoYW5kbGVyLmNsZWFudXApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaGFuZGxlci5jbGVhbnVwKCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7ZG9tYWlufSBoYW5kbGVycyBjbGVhbmVkIHVwIHN1Y2Nlc3NmdWxseWApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGNsZWFudXAgJHtkb21haW59IGhhbmRsZXJzOmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBhbGwgSVBDIGhhbmRsZXJzXHJcbiAgICBpcGNNYWluLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn46JIEFsbCBJUEMgaGFuZGxlcnMgY2xlYW5lZCB1cCBzdWNjZXNzZnVsbHknKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign8J+SpSBFcnJvciBkdXJpbmcgSVBDIGhhbmRsZXIgY2xlYW51cDonLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0IHVwIGdsb2JhbCBlcnJvciBoYW5kbGluZyBmb3IgSVBDIGNvbW11bmljYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHNldHVwR2xvYmFsSVBDRXJyb3JIYW5kbGluZygpOiB2b2lkIHtcclxuICAvLyBIYW5kbGUgdW5jYXVnaHQgZXhjZXB0aW9ucyBpbiBJUEMgaGFuZGxlcnNcclxuICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ/CfmqggVW5jYXVnaHQgZXhjZXB0aW9uIGluIElQQyBoYW5kbGVyOicsIGVycm9yKTtcclxuICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSBtaWdodCB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yXHJcbiAgfSk7XHJcblxyXG4gIC8vIEhhbmRsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zIGluIElQQyBoYW5kbGVyc1xyXG4gIHByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIChyZWFzb24sIHByb21pc2UpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICfwn5qoIFVuaGFuZGxlZCByZWplY3Rpb24gaW4gSVBDIGhhbmRsZXI6JyxcclxuICAgICAgcmVhc29uLFxyXG4gICAgICAnYXQ6JyxcclxuICAgICAgcHJvbWlzZSxcclxuICAgICk7XHJcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3UgbWlnaHQgd2FudCB0byByZXBvcnQgdGhpcyBlcnJvclxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgc3RhbmRhcmRpemVkIElQQyByZXNwb25zZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUlQQ1Jlc3BvbnNlPFQ+KGRhdGE/OiBULCBlcnJvcj86IHN0cmluZyk6IElQQ1Jlc3BvbnNlPFQ+IHtcclxuICBpZiAoZXJyb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcixcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICBkYXRhLFxyXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIElQQyBlcnJvcnMgY29uc2lzdGVudGx5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlSVBDRXJyb3IoXHJcbiAgZXJyb3I6IHVua25vd24sXHJcbiAgY29udGV4dDogc3RyaW5nLFxyXG4pOiBJUENSZXNwb25zZTxhbnk+IHtcclxuICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcclxuICBjb25zb2xlLmVycm9yKGBJUEMgRXJyb3IgaW4gJHtjb250ZXh0fTpgLCBlcnJvcik7XHJcblxyXG4gIHJldHVybiBjcmVhdGVJUENSZXNwb25zZSh1bmRlZmluZWQsIGVycm9yTWVzc2FnZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFuZGFyZCBJUEMgcmVzcG9uc2UgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElQQ1Jlc3BvbnNlPFQgPSBhbnk+IHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIGRhdGE/OiBUO1xyXG4gIGVycm9yPzogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogVHlwZS1zYWZlIElQQyBoYW5kbGVyIHdyYXBwZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJUENIYW5kbGVyPFRBcmdzIGV4dGVuZHMgYW55W10sIFRSZXR1cm4+KFxyXG4gIGhhbmRsZXI6ICguLi5hcmdzOiBUQXJncykgPT4gUHJvbWlzZTxUUmV0dXJuPiB8IFRSZXR1cm4sXHJcbikge1xyXG4gIHJldHVybiBhc3luYyAoXHJcbiAgICBfZXZlbnQ6IEVsZWN0cm9uLklwY01haW5JbnZva2VFdmVudCxcclxuICAgIC4uLmFyZ3M6IFRBcmdzXHJcbiAgKTogUHJvbWlzZTxJUENSZXNwb25zZTxUUmV0dXJuPj4gPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlciguLi5hcmdzKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZUlQQ1Jlc3BvbnNlKHJlc3VsdCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gaGFuZGxlSVBDRXJyb3IoZXJyb3IsIGhhbmRsZXIubmFtZSB8fCAnYW5vbnltb3VzIGhhbmRsZXInKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/handlers/index.ts\n\n}");

/***/ }),

/***/ "./src/backend/handlers/settings/settings-handlers.ts":
/*!************************************************************!*\
  !*** ./src/backend/handlers/settings/settings-handlers.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerSettingsHandlers = registerSettingsHandlers;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst settingsService_1 = __webpack_require__(/*! ../../services/settingsService */ \"./src/backend/services/settingsService.ts\");\nconst index_1 = __webpack_require__(/*! ../index */ \"./src/backend/handlers/index.ts\");\n// Initialize settings service\nconst settingsService = new settingsService_1.SettingsService();\nfunction registerSettingsHandlers() {\n    // Get a setting value\n    electron_1.ipcMain.handle('settings:get', (0, index_1.createIPCHandler)(async (key) => {\n        return settingsService.get(key);\n    }));\n    // Set a setting value\n    electron_1.ipcMain.handle('settings:set', (0, index_1.createIPCHandler)(async (key, value) => {\n        settingsService.set(key, value);\n        return { success: true };\n    }));\n    // Get all settings\n    electron_1.ipcMain.handle('settings:getAll', (0, index_1.createIPCHandler)(async () => {\n        return settingsService.getAll();\n    }));\n    // Reset settings to defaults\n    electron_1.ipcMain.handle('settings:reset', (0, index_1.createIPCHandler)(async () => {\n        settingsService.reset();\n        return { success: true };\n    }));\n    // Check if a setting has been customized\n    electron_1.ipcMain.handle('settings:hasCustomValue', (0, index_1.createIPCHandler)(async (key) => {\n        return settingsService.has(key);\n    }));\n    // Get settings store path\n    electron_1.ipcMain.handle('settings:getStorePath', (0, index_1.createIPCHandler)(async () => {\n        return settingsService.getStorePath();\n    }));\n    // Validate settings\n    electron_1.ipcMain.handle('settings:validate', (0, index_1.createIPCHandler)(async () => {\n        const validation = settingsService.validate();\n        return validation.isValid;\n    }));\n    // Export settings\n    electron_1.ipcMain.handle('settings:export', (0, index_1.createIPCHandler)(async () => {\n        const exportData = settingsService.export();\n        return JSON.stringify(exportData);\n    }));\n    // Import settings\n    electron_1.ipcMain.handle('settings:import', (0, index_1.createIPCHandler)(async (jsonString) => {\n        const importData = JSON.parse(jsonString);\n        return settingsService.import(importData);\n    }));\n    // Initialize download location (placeholder - will be implemented in later tasks)\n    electron_1.ipcMain.handle('settings:initializeDownloadLocation', (0, index_1.createIPCHandler)(async () => {\n        // Placeholder implementation\n        return { success: true };\n    }));\n    // Sanitize settings\n    electron_1.ipcMain.handle('settings:sanitize', (0, index_1.createIPCHandler)(async () => {\n        settingsService.sanitize();\n        return { success: true };\n    }));\n    // Create backup\n    electron_1.ipcMain.handle('settings:createBackup', (0, index_1.createIPCHandler)(async () => {\n        const backupPath = await settingsService.createBackup();\n        return { backupPath };\n    }));\n    // Restore from backup\n    electron_1.ipcMain.handle('settings:restoreFromBackup', (0, index_1.createIPCHandler)(async (backupPath) => {\n        await settingsService.restoreFromBackup(backupPath);\n        return { success: true };\n    }));\n    // Get settings version\n    electron_1.ipcMain.handle('settings:getVersion', (0, index_1.createIPCHandler)(async () => {\n        return settingsService.getVersion();\n    }));\n    // Check if migration is needed\n    electron_1.ipcMain.handle('settings:needsMigration', (0, index_1.createIPCHandler)(async (targetVersion) => {\n        return settingsService.needsMigration(targetVersion);\n    }));\n    // Migrate settings\n    electron_1.ipcMain.handle('settings:migrate', (0, index_1.createIPCHandler)(async (targetVersion) => {\n        await settingsService.migrate(targetVersion);\n        return { success: true };\n    }));\n    // List available backups\n    electron_1.ipcMain.handle('settings:listBackups', (0, index_1.createIPCHandler)(async () => {\n        return await settingsService.listBackups();\n    }));\n    // Get detailed validation results\n    electron_1.ipcMain.handle('settings:getValidationDetails', (0, index_1.createIPCHandler)(async () => {\n        return settingsService.validate();\n    }));\n    console.log(' Settings IPC handlers registered');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9oYW5kbGVycy9zZXR0aW5ncy9zZXR0aW5ncy1oYW5kbGVycy50cyIsIm1hcHBpbmdzIjoiOztBQU9BLDREQTRKQztBQW5LRCxtRUFBbUM7QUFDbkMsaUlBQWlFO0FBQ2pFLHVGQUE0QztBQUU1Qyw4QkFBOEI7QUFDOUIsTUFBTSxlQUFlLEdBQUcsSUFBSSxpQ0FBZSxFQUFFLENBQUM7QUFFOUMsU0FBZ0Isd0JBQXdCO0lBQ3RDLHNCQUFzQjtJQUN0QixrQkFBTyxDQUFDLE1BQU0sQ0FDWixjQUFjLEVBQ2QsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLEdBQVcsRUFBRSxFQUFFO1FBQ3JDLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFVLENBQUMsQ0FBQztJQUN6QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsc0JBQXNCO0lBQ3RCLGtCQUFPLENBQUMsTUFBTSxDQUNaLGNBQWMsRUFDZCw0QkFBZ0IsRUFBQyxLQUFLLEVBQUUsR0FBVyxFQUFFLEtBQVUsRUFBRSxFQUFFO1FBQ2pELGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLG1CQUFtQjtJQUNuQixrQkFBTyxDQUFDLE1BQU0sQ0FDWixpQkFBaUIsRUFDakIsNEJBQWdCLEVBQUMsS0FBSyxJQUFJLEVBQUU7UUFDMUIsT0FBTyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbEMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLDZCQUE2QjtJQUM3QixrQkFBTyxDQUFDLE1BQU0sQ0FDWixnQkFBZ0IsRUFDaEIsNEJBQWdCLEVBQUMsS0FBSyxJQUFJLEVBQUU7UUFDMUIsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3hCLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLHlDQUF5QztJQUN6QyxrQkFBTyxDQUFDLE1BQU0sQ0FDWix5QkFBeUIsRUFDekIsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLEdBQVcsRUFBRSxFQUFFO1FBQ3JDLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFVLENBQUMsQ0FBQztJQUN6QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsMEJBQTBCO0lBQzFCLGtCQUFPLENBQUMsTUFBTSxDQUNaLHVCQUF1QixFQUN2Qiw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQixPQUFPLGVBQWUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsb0JBQW9CO0lBQ3BCLGtCQUFPLENBQUMsTUFBTSxDQUNaLG1CQUFtQixFQUNuQiw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQixNQUFNLFVBQVUsR0FBRyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUMsT0FBTyxVQUFVLENBQUMsT0FBTyxDQUFDO0lBQzVCLENBQUMsQ0FBQyxDQUNILENBQUM7SUFFRixrQkFBa0I7SUFDbEIsa0JBQU8sQ0FBQyxNQUFNLENBQ1osaUJBQWlCLEVBQ2pCLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQzFCLE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM1QyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDcEMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLGtCQUFrQjtJQUNsQixrQkFBTyxDQUFDLE1BQU0sQ0FDWixpQkFBaUIsRUFDakIsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFVBQWtCLEVBQUUsRUFBRTtRQUM1QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFDLE9BQU8sZUFBZSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM1QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsa0ZBQWtGO0lBQ2xGLGtCQUFPLENBQUMsTUFBTSxDQUNaLHFDQUFxQyxFQUNyQyw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQiw2QkFBNkI7UUFDN0IsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsb0JBQW9CO0lBQ3BCLGtCQUFPLENBQUMsTUFBTSxDQUNaLG1CQUFtQixFQUNuQiw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQixlQUFlLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDM0IsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsZ0JBQWdCO0lBQ2hCLGtCQUFPLENBQUMsTUFBTSxDQUNaLHVCQUF1QixFQUN2Qiw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQixNQUFNLFVBQVUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4RCxPQUFPLEVBQUUsVUFBVSxFQUFFLENBQUM7SUFDeEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLHNCQUFzQjtJQUN0QixrQkFBTyxDQUFDLE1BQU0sQ0FDWiw0QkFBNEIsRUFDNUIsNEJBQWdCLEVBQUMsS0FBSyxFQUFFLFVBQWtCLEVBQUUsRUFBRTtRQUM1QyxNQUFNLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNwRCxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUNILENBQUM7SUFFRix1QkFBdUI7SUFDdkIsa0JBQU8sQ0FBQyxNQUFNLENBQ1oscUJBQXFCLEVBQ3JCLDRCQUFnQixFQUFDLEtBQUssSUFBSSxFQUFFO1FBQzFCLE9BQU8sZUFBZSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3RDLENBQUMsQ0FBQyxDQUNILENBQUM7SUFFRiwrQkFBK0I7SUFDL0Isa0JBQU8sQ0FBQyxNQUFNLENBQ1oseUJBQXlCLEVBQ3pCLDRCQUFnQixFQUFDLEtBQUssRUFBRSxhQUFxQixFQUFFLEVBQUU7UUFDL0MsT0FBTyxlQUFlLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUMsQ0FBQyxDQUNILENBQUM7SUFFRixtQkFBbUI7SUFDbkIsa0JBQU8sQ0FBQyxNQUFNLENBQ1osa0JBQWtCLEVBQ2xCLDRCQUFnQixFQUFDLEtBQUssRUFBRSxhQUFxQixFQUFFLEVBQUU7UUFDL0MsTUFBTSxlQUFlLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUVGLHlCQUF5QjtJQUN6QixrQkFBTyxDQUFDLE1BQU0sQ0FDWixzQkFBc0IsRUFDdEIsNEJBQWdCLEVBQUMsS0FBSyxJQUFJLEVBQUU7UUFDMUIsT0FBTyxNQUFNLGVBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsa0NBQWtDO0lBQ2xDLGtCQUFPLENBQUMsTUFBTSxDQUNaLCtCQUErQixFQUMvQiw0QkFBZ0IsRUFBQyxLQUFLLElBQUksRUFBRTtRQUMxQixPQUFPLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNwQyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBRUYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0FBQ3BELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL2hhbmRsZXJzL3NldHRpbmdzL3NldHRpbmdzLWhhbmRsZXJzLnRzP2UyMDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXBjTWFpbiB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgU2V0dGluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvc2V0dGluZ3NTZXJ2aWNlJztcclxuaW1wb3J0IHsgY3JlYXRlSVBDSGFuZGxlciB9IGZyb20gJy4uL2luZGV4JztcclxuXHJcbi8vIEluaXRpYWxpemUgc2V0dGluZ3Mgc2VydmljZVxyXG5jb25zdCBzZXR0aW5nc1NlcnZpY2UgPSBuZXcgU2V0dGluZ3NTZXJ2aWNlKCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJTZXR0aW5nc0hhbmRsZXJzKCk6IHZvaWQge1xyXG4gIC8vIEdldCBhIHNldHRpbmcgdmFsdWVcclxuICBpcGNNYWluLmhhbmRsZShcclxuICAgICdzZXR0aW5nczpnZXQnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzU2VydmljZS5nZXQoa2V5IGFzIGFueSk7XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBTZXQgYSBzZXR0aW5nIHZhbHVlXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6c2V0JyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XHJcbiAgICAgIHNldHRpbmdzU2VydmljZS5zZXQoa2V5IGFzIGFueSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBHZXQgYWxsIHNldHRpbmdzXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6Z2V0QWxsJyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXR1cm4gc2V0dGluZ3NTZXJ2aWNlLmdldEFsbCgpO1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgLy8gUmVzZXQgc2V0dGluZ3MgdG8gZGVmYXVsdHNcclxuICBpcGNNYWluLmhhbmRsZShcclxuICAgICdzZXR0aW5nczpyZXNldCcsXHJcbiAgICBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgICAgc2V0dGluZ3NTZXJ2aWNlLnJlc2V0KCk7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIENoZWNrIGlmIGEgc2V0dGluZyBoYXMgYmVlbiBjdXN0b21pemVkXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6aGFzQ3VzdG9tVmFsdWUnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzU2VydmljZS5oYXMoa2V5IGFzIGFueSk7XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBHZXQgc2V0dGluZ3Mgc3RvcmUgcGF0aFxyXG4gIGlwY01haW4uaGFuZGxlKFxyXG4gICAgJ3NldHRpbmdzOmdldFN0b3JlUGF0aCcsXHJcbiAgICBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzU2VydmljZS5nZXRTdG9yZVBhdGgoKTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIFZhbGlkYXRlIHNldHRpbmdzXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6dmFsaWRhdGUnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBzZXR0aW5nc1NlcnZpY2UudmFsaWRhdGUoKTtcclxuICAgICAgcmV0dXJuIHZhbGlkYXRpb24uaXNWYWxpZDtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIEV4cG9ydCBzZXR0aW5nc1xyXG4gIGlwY01haW4uaGFuZGxlKFxyXG4gICAgJ3NldHRpbmdzOmV4cG9ydCcsXHJcbiAgICBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZXhwb3J0RGF0YSA9IHNldHRpbmdzU2VydmljZS5leHBvcnQoKTtcclxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4cG9ydERhdGEpO1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgLy8gSW1wb3J0IHNldHRpbmdzXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6aW1wb3J0JyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKGpzb25TdHJpbmc6IHN0cmluZykgPT4ge1xyXG4gICAgICBjb25zdCBpbXBvcnREYXRhID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzU2VydmljZS5pbXBvcnQoaW1wb3J0RGF0YSk7XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBJbml0aWFsaXplIGRvd25sb2FkIGxvY2F0aW9uIChwbGFjZWhvbGRlciAtIHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gbGF0ZXIgdGFza3MpXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6aW5pdGlhbGl6ZURvd25sb2FkTG9jYXRpb24nLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICAgIC8vIFBsYWNlaG9sZGVyIGltcGxlbWVudGF0aW9uXHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIFNhbml0aXplIHNldHRpbmdzXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6c2FuaXRpemUnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICAgIHNldHRpbmdzU2VydmljZS5zYW5pdGl6ZSgpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBDcmVhdGUgYmFja3VwXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6Y3JlYXRlQmFja3VwJyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBiYWNrdXBQYXRoID0gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLmNyZWF0ZUJhY2t1cCgpO1xyXG4gICAgICByZXR1cm4geyBiYWNrdXBQYXRoIH07XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBSZXN0b3JlIGZyb20gYmFja3VwXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6cmVzdG9yZUZyb21CYWNrdXAnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoYmFja3VwUGF0aDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGF3YWl0IHNldHRpbmdzU2VydmljZS5yZXN0b3JlRnJvbUJhY2t1cChiYWNrdXBQYXRoKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgLy8gR2V0IHNldHRpbmdzIHZlcnNpb25cclxuICBpcGNNYWluLmhhbmRsZShcclxuICAgICdzZXR0aW5nczpnZXRWZXJzaW9uJyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXR1cm4gc2V0dGluZ3NTZXJ2aWNlLmdldFZlcnNpb24oKTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIENoZWNrIGlmIG1pZ3JhdGlvbiBpcyBuZWVkZWRcclxuICBpcGNNYWluLmhhbmRsZShcclxuICAgICdzZXR0aW5nczpuZWVkc01pZ3JhdGlvbicsXHJcbiAgICBjcmVhdGVJUENIYW5kbGVyKGFzeW5jICh0YXJnZXRWZXJzaW9uOiBzdHJpbmcpID0+IHtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzU2VydmljZS5uZWVkc01pZ3JhdGlvbih0YXJnZXRWZXJzaW9uKTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIC8vIE1pZ3JhdGUgc2V0dGluZ3NcclxuICBpcGNNYWluLmhhbmRsZShcclxuICAgICdzZXR0aW5nczptaWdyYXRlJyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKHRhcmdldFZlcnNpb246IHN0cmluZykgPT4ge1xyXG4gICAgICBhd2FpdCBzZXR0aW5nc1NlcnZpY2UubWlncmF0ZSh0YXJnZXRWZXJzaW9uKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgLy8gTGlzdCBhdmFpbGFibGUgYmFja3Vwc1xyXG4gIGlwY01haW4uaGFuZGxlKFxyXG4gICAgJ3NldHRpbmdzOmxpc3RCYWNrdXBzJyxcclxuICAgIGNyZWF0ZUlQQ0hhbmRsZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXR1cm4gYXdhaXQgc2V0dGluZ3NTZXJ2aWNlLmxpc3RCYWNrdXBzKCk7XHJcbiAgICB9KSxcclxuICApO1xyXG5cclxuICAvLyBHZXQgZGV0YWlsZWQgdmFsaWRhdGlvbiByZXN1bHRzXHJcbiAgaXBjTWFpbi5oYW5kbGUoXHJcbiAgICAnc2V0dGluZ3M6Z2V0VmFsaWRhdGlvbkRldGFpbHMnLFxyXG4gICAgY3JlYXRlSVBDSGFuZGxlcihhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJldHVybiBzZXR0aW5nc1NlcnZpY2UudmFsaWRhdGUoKTtcclxuICAgIH0pLFxyXG4gICk7XHJcblxyXG4gIGNvbnNvbGUubG9nKCfinIUgU2V0dGluZ3MgSVBDIGhhbmRsZXJzIHJlZ2lzdGVyZWQnKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/backend/handlers/settings/settings-handlers.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/application-lifecycle-service.ts":
/*!***************************************************************!*\
  !*** ./src/backend/services/application-lifecycle-service.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Application Lifecycle Service\n * Manages application startup, shutdown, and lifecycle events\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ApplicationLifecycleService = void 0;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nclass ApplicationLifecycleService extends events_1.EventEmitter {\n    constructor(logger, windowManager, errorHandler) {\n        super();\n        this.startupProcedures = new Map();\n        this.state = {\n            isStarting: false,\n            isReady: false,\n            isShuttingDown: false,\n            startupTime: null,\n            readyTime: null,\n            shutdownTime: null,\n            lastError: null,\n            resourcesCleanedUp: false,\n            eventListenersRemoved: false,\n            windowsManaged: 0,\n            activeConnections: 0,\n        };\n        this.startupTimeout = 60000; // 60 seconds\n        this.quitPrevented = false;\n        this.resourceCleanupTasks = [];\n        this.eventListenerCleanupTasks = [];\n        this.activeTimers = new Set();\n        this.activeIntervals = new Set();\n        this.logger = logger;\n        this.windowManager = windowManager;\n        this.errorHandler = errorHandler;\n        this.setupEventHandlers();\n    }\n    /**\n     * Initialize the application lifecycle\n     */\n    async initialize() {\n        this.logger.info('Initializing application lifecycle', 'AppLifecycle');\n        // Register default startup procedures\n        this.registerDefaultStartupProcedures();\n        // Register shutdown procedures with error handler\n        await this.registerShutdownProcedures();\n        this.logger.info('Application lifecycle initialized', 'AppLifecycle');\n    }\n    /**\n     * Register a startup procedure\n     */\n    registerStartupProcedure(procedure) {\n        this.startupProcedures.set(procedure.name, procedure);\n        this.logger.debug(`Startup procedure registered: ${procedure.name}`, 'AppLifecycle');\n    }\n    /**\n     * Execute application startup sequence\n     */\n    async startup() {\n        if (this.state.isStarting || this.state.isReady) {\n            this.logger.warn('Startup already in progress or completed', 'AppLifecycle');\n            return;\n        }\n        this.state.isStarting = true;\n        this.state.startupTime = Date.now();\n        this.emit('startup-started');\n        this.logger.info('Starting application startup sequence', 'AppLifecycle');\n        try {\n            // Execute startup procedures in priority order\n            const procedures = Array.from(this.startupProcedures.values()).sort((a, b) => b.priority - a.priority);\n            for (const procedure of procedures) {\n                try {\n                    this.logger.info(`Executing startup procedure: ${procedure.name}`, 'AppLifecycle');\n                    await Promise.race([\n                        procedure.procedure(),\n                        this.createTimeoutPromise(procedure.timeout, `Startup procedure ${procedure.name} timed out`),\n                    ]);\n                    this.logger.info(`Startup procedure completed: ${procedure.name}`, 'AppLifecycle');\n                }\n                catch (error) {\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    this.logger.error(`Startup procedure failed: ${procedure.name}`, 'AppLifecycle', {\n                        error: errorMessage,\n                    });\n                    if (procedure.required) {\n                        throw new Error(`Required startup procedure failed: ${procedure.name} - ${errorMessage}`);\n                    }\n                }\n            }\n            this.state.isStarting = false;\n            this.state.isReady = true;\n            this.state.readyTime = Date.now();\n            const startupDuration = this.state.readyTime - this.state.startupTime;\n            this.logger.info(`Application startup completed in ${startupDuration}ms`, 'AppLifecycle');\n            this.emit('startup-completed');\n        }\n        catch (error) {\n            this.state.isStarting = false;\n            this.state.lastError =\n                error instanceof Error ? error : new Error(String(error));\n            this.logger.error('Application startup failed', 'AppLifecycle', {\n                error: this.state.lastError.message,\n            });\n            this.emit('startup-failed', { error: this.state.lastError });\n            throw this.state.lastError;\n        }\n    }\n    /**\n     * Execute application shutdown sequence\n     */\n    async shutdown(reason = 'Unknown') {\n        if (this.state.isShuttingDown) {\n            this.logger.warn('Shutdown already in progress', 'AppLifecycle');\n            return;\n        }\n        this.state.isShuttingDown = true;\n        this.state.shutdownTime = Date.now();\n        this.emit('shutdown-started', { reason });\n        this.logger.info(`Starting application shutdown: ${reason}`, 'AppLifecycle');\n        try {\n            // Use error handler's graceful shutdown\n            await this.errorHandler.gracefulShutdown(reason);\n            this.logger.info('Application shutdown completed', 'AppLifecycle');\n            this.emit('shutdown-completed');\n        }\n        catch (error) {\n            this.logger.error('Error during application shutdown', 'AppLifecycle', {\n                error: error instanceof Error ? error.message : error,\n                reason,\n            });\n        }\n    }\n    /**\n     * Get current application state\n     */\n    getState() {\n        return { ...this.state };\n    }\n    /**\n     * Check if application is ready\n     */\n    isReady() {\n        return this.state.isReady;\n    }\n    /**\n     * Check if application is shutting down\n     */\n    isShuttingDown() {\n        return this.state.isShuttingDown;\n    }\n    /**\n     * Register a resource cleanup task\n     */\n    registerResourceCleanup(cleanupTask) {\n        this.resourceCleanupTasks.push(cleanupTask);\n        this.logger.debug('Resource cleanup task registered', 'AppLifecycle');\n    }\n    /**\n     * Register an event listener cleanup task\n     */\n    registerEventListenerCleanup(cleanupTask) {\n        this.eventListenerCleanupTasks.push(cleanupTask);\n        this.logger.debug('Event listener cleanup task registered', 'AppLifecycle');\n    }\n    /**\n     * Register a timer for automatic cleanup\n     */\n    registerTimer(timer) {\n        this.activeTimers.add(timer);\n    }\n    /**\n     * Register an interval for automatic cleanup\n     */\n    registerInterval(interval) {\n        this.activeIntervals.add(interval);\n    }\n    /**\n     * Clean up all resources\n     */\n    async cleanupResources() {\n        if (this.state.resourcesCleanedUp) {\n            this.logger.debug('Resources already cleaned up', 'AppLifecycle');\n            return;\n        }\n        this.logger.info('Starting resource cleanup', 'AppLifecycle');\n        try {\n            // Clear all timers\n            for (const timer of this.activeTimers) {\n                clearTimeout(timer);\n            }\n            this.activeTimers.clear();\n            // Clear all intervals\n            for (const interval of this.activeIntervals) {\n                clearInterval(interval);\n            }\n            this.activeIntervals.clear();\n            // Execute resource cleanup tasks\n            const cleanupPromises = this.resourceCleanupTasks.map(async (task, index) => {\n                try {\n                    await task();\n                    this.logger.debug(`Resource cleanup task ${index} completed`, 'AppLifecycle');\n                }\n                catch (error) {\n                    this.logger.error(`Resource cleanup task ${index} failed`, 'AppLifecycle', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                }\n            });\n            await Promise.allSettled(cleanupPromises);\n            this.state.resourcesCleanedUp = true;\n            this.logger.info('Resource cleanup completed', 'AppLifecycle');\n        }\n        catch (error) {\n            this.logger.error('Error during resource cleanup', 'AppLifecycle', {\n                error: error instanceof Error ? error.message : error,\n            });\n        }\n    }\n    /**\n     * Clean up all event listeners\n     */\n    cleanupEventListeners() {\n        if (this.state.eventListenersRemoved) {\n            this.logger.debug('Event listeners already cleaned up', 'AppLifecycle');\n            return;\n        }\n        this.logger.info('Starting event listener cleanup', 'AppLifecycle');\n        try {\n            // Execute event listener cleanup tasks\n            this.eventListenerCleanupTasks.forEach((task, index) => {\n                try {\n                    task();\n                    this.logger.debug(`Event listener cleanup task ${index} completed`, 'AppLifecycle');\n                }\n                catch (error) {\n                    this.logger.error(`Event listener cleanup task ${index} failed`, 'AppLifecycle', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                }\n            });\n            // Remove all listeners from this EventEmitter\n            this.removeAllListeners();\n            this.state.eventListenersRemoved = true;\n            this.logger.info('Event listener cleanup completed', 'AppLifecycle');\n        }\n        catch (error) {\n            this.logger.error('Error during event listener cleanup', 'AppLifecycle', {\n                error: error instanceof Error ? error.message : error,\n            });\n        }\n    }\n    /**\n     * Update window management statistics\n     */\n    updateWindowStats(windowCount) {\n        this.state.windowsManaged = windowCount;\n        this.logger.debug(`Window count updated: ${windowCount}`, 'AppLifecycle');\n    }\n    /**\n     * Update active connections count\n     */\n    updateConnectionStats(connectionCount) {\n        this.state.activeConnections = connectionCount;\n        this.logger.debug(`Active connections updated: ${connectionCount}`, 'AppLifecycle');\n    }\n    /**\n     * Register default startup procedures\n     */\n    registerDefaultStartupProcedures() {\n        // Window manager initialization\n        this.registerStartupProcedure({\n            name: 'window-manager',\n            priority: 10,\n            timeout: 10000,\n            required: true,\n            procedure: async () => {\n                // Window manager should already be initialized\n                this.logger.debug('Window manager startup procedure', 'AppLifecycle');\n            },\n        });\n        // Main window creation\n        this.registerStartupProcedure({\n            name: 'main-window',\n            priority: 5,\n            timeout: 15000,\n            required: true,\n            procedure: async () => {\n                await this.createMainWindow();\n            },\n        });\n        // Post-startup cleanup\n        this.registerStartupProcedure({\n            name: 'post-startup-cleanup',\n            priority: 1,\n            timeout: 5000,\n            required: false,\n            procedure: async () => {\n                // Perform any post-startup cleanup tasks\n                this.logger.debug('Post-startup cleanup completed', 'AppLifecycle');\n            },\n        });\n    }\n    /**\n     * Register shutdown procedures with error handler\n     */\n    async registerShutdownProcedures() {\n        // Register resource cleanup\n        this.errorHandler.registerShutdownProcedure({\n            name: 'resource-cleanup',\n            priority: 15,\n            timeout: 10000,\n            procedure: async () => {\n                await this.cleanupResources();\n            },\n        });\n        // Register window manager shutdown\n        this.errorHandler.registerShutdownProcedure({\n            name: 'window-manager',\n            priority: 10,\n            timeout: 10000,\n            procedure: async () => {\n                await this.windowManager.shutdown();\n            },\n        });\n        // Register event listener cleanup\n        this.errorHandler.registerShutdownProcedure({\n            name: 'event-listener-cleanup',\n            priority: 5,\n            timeout: 5000,\n            procedure: async () => {\n                this.cleanupEventListeners();\n            },\n        });\n        // Register application lifecycle shutdown\n        this.errorHandler.registerShutdownProcedure({\n            name: 'application-lifecycle',\n            priority: 1,\n            timeout: 5000,\n            procedure: async () => {\n                await this.shutdownService();\n            },\n        });\n    }\n    /**\n     * Create the main application window\n     */\n    async createMainWindow() {\n        try {\n            const mainWindow = await this.windowManager.createWindow({\n                id: 'main',\n                width: 800,\n                height: 600,\n                minWidth: 600,\n                minHeight: 400,\n                center: true,\n                title: 'Playlistify',\n                webPreferences: {\n                    preload: 'F:\\\\My Github Repos\\\\Open Source Repos\\\\PlayListify\\\\.webpack\\\\renderer\\\\main_window\\\\preload.js',\n                },\n            }, 'http://localhost:3000/main_window/index.html');\n            // Open DevTools in development\n            if (process.env.NODE_ENV === 'development') {\n                mainWindow.webContents.openDevTools();\n            }\n            this.logger.info('Main window created successfully', 'AppLifecycle');\n        }\n        catch (error) {\n            this.logger.error('Failed to create main window', 'AppLifecycle', {\n                error: error instanceof Error ? error.message : error,\n            });\n            throw error;\n        }\n    }\n    /**\n     * Set up application event handlers\n     */\n    setupEventHandlers() {\n        // App ready event\n        electron_1.app.on('ready', async () => {\n            this.emit('ready');\n            try {\n                await this.startup();\n            }\n            catch (error) {\n                this.logger.error('Startup failed on app ready', 'AppLifecycle', {\n                    error: error instanceof Error ? error.message : error,\n                });\n                // Show error dialog and quit\n                const { dialog } = __webpack_require__(/*! electron */ \"electron\");\n                await dialog.showErrorBox('Startup Error', 'Failed to initialize the application. Please try again or contact support.');\n                electron_1.app.quit();\n            }\n        });\n        // Before quit event\n        electron_1.app.on('before-quit', event => {\n            this.emit('before-quit', { event });\n            if (!this.state.isShuttingDown && !this.quitPrevented) {\n                this.quitPrevented = true;\n                event.preventDefault();\n                this.shutdown('Application Quit')\n                    .then(() => {\n                    this.quitPrevented = false;\n                    electron_1.app.quit();\n                })\n                    .catch(error => {\n                    this.logger.error('Error during shutdown on before-quit', 'AppLifecycle', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                    this.quitPrevented = false;\n                    electron_1.app.quit();\n                });\n            }\n        });\n        // Will quit event\n        electron_1.app.on('will-quit', event => {\n            this.emit('will-quit', { event });\n            this.logger.info('Application will quit', 'AppLifecycle');\n        });\n        // Window all closed event\n        electron_1.app.on('window-all-closed', () => {\n            this.emit('window-all-closed');\n            // On macOS, applications typically stay active until explicitly quit\n            if (process.platform !== 'darwin') {\n                this.logger.debug('All windows closed, quitting application', 'AppLifecycle');\n                electron_1.app.quit();\n            }\n        });\n        // Activate event (macOS)\n        electron_1.app.on('activate', () => {\n            this.emit('activate');\n            // On macOS, re-create window when dock icon is clicked and no windows are open\n            if (electron_1.BrowserWindow.getAllWindows().length === 0 && this.state.isReady) {\n                this.createMainWindow().catch(error => {\n                    this.logger.error('Failed to recreate main window on activate', 'AppLifecycle', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                });\n            }\n        });\n        // Window manager events\n        this.windowManager.on('request-main-window', () => {\n            if (this.state.isReady && !this.state.isShuttingDown) {\n                this.createMainWindow().catch(error => {\n                    this.logger.error('Failed to create main window on request', 'AppLifecycle', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                });\n            }\n        });\n        this.windowManager.on('all-windows-closed', () => {\n            this.updateWindowStats(0);\n            if (process.platform !== 'darwin' && !this.state.isShuttingDown) {\n                electron_1.app.quit();\n            }\n        });\n        // Update window statistics when windows are created or closed\n        this.windowManager.on('window-created', () => {\n            const stats = this.windowManager.getWindowStats();\n            this.updateWindowStats(stats.activeWindows);\n        });\n        this.windowManager.on('window-closed', () => {\n            const stats = this.windowManager.getWindowStats();\n            this.updateWindowStats(stats.activeWindows);\n        });\n        // Register window manager cleanup tasks\n        this.registerEventListenerCleanup(() => {\n            this.windowManager.removeAllListeners();\n        });\n        this.registerResourceCleanup(async () => {\n            // Save all window states before shutdown\n            const windowIds = this.windowManager.getAllWindowIds();\n            this.logger.debug(`Saving state for ${windowIds.length} windows`, 'AppLifecycle');\n        });\n        // Certificate error handling\n        electron_1.app.on('certificate-error', (event, webContents, url, error, certificate, callback) => {\n            this.logger.warn('Certificate error', 'AppLifecycle', { error, url });\n            // In development, we might want to ignore certificate errors for localhost\n            if (process.env.NODE_ENV === 'development' &&\n                url.includes('localhost')) {\n                event.preventDefault();\n                callback(true);\n            }\n            else {\n                callback(false);\n            }\n        });\n        // Security: Prevent new window creation from renderer\n        electron_1.app.on('web-contents-created', (_event, contents) => {\n            // Handle external link attempts\n            contents.setWindowOpenHandler(({ url }) => {\n                this.logger.warn('Blocked new window creation', 'AppLifecycle', {\n                    url,\n                });\n                return { action: 'deny' };\n            });\n            contents.on('will-navigate', (navigationEvent, navigationUrl) => {\n                const parsedUrl = new URL(navigationUrl);\n                // Only allow navigation to the same origin or specific allowed domains\n                if (parsedUrl.origin !== 'http://localhost:3000' &&\n                    parsedUrl.origin !== 'https://www.youtube.com' &&\n                    parsedUrl.origin !== 'https://youtube.com') {\n                    navigationEvent.preventDefault();\n                    this.logger.warn('Blocked navigation', 'AppLifecycle', {\n                        url: navigationUrl,\n                    });\n                }\n            });\n        });\n    }\n    /**\n     * Create a timeout promise for procedure timeouts\n     */\n    createTimeoutPromise(timeout, message) {\n        return new Promise((_, reject) => {\n            setTimeout(() => reject(new Error(message)), timeout);\n        });\n    }\n    /**\n     * Shutdown the lifecycle service\n     */\n    async shutdownService() {\n        this.logger.info('Application lifecycle service shutting down', 'AppLifecycle');\n        this.removeAllListeners();\n        this.logger.info('Application lifecycle service shutdown complete', 'AppLifecycle');\n    }\n}\nexports.ApplicationLifecycleService = ApplicationLifecycleService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9hcHBsaWNhdGlvbi1saWZlY3ljbGUtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7QUFFSCxtRUFBOEM7QUFDOUMsNkRBQXNDO0FBd0N0QyxNQUFhLDJCQUE0QixTQUFRLHFCQUFZO0lBeUIzRCxZQUNFLE1BQXFCLEVBQ3JCLGFBQW1DLEVBQ25DLFlBQWlDO1FBRWpDLEtBQUssRUFBRSxDQUFDO1FBMUJGLHNCQUFpQixHQUFrQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzdELFVBQUssR0FBcUI7WUFDaEMsVUFBVSxFQUFFLEtBQUs7WUFDakIsT0FBTyxFQUFFLEtBQUs7WUFDZCxjQUFjLEVBQUUsS0FBSztZQUNyQixXQUFXLEVBQUUsSUFBSTtZQUNqQixTQUFTLEVBQUUsSUFBSTtZQUNmLFlBQVksRUFBRSxJQUFJO1lBQ2xCLFNBQVMsRUFBRSxJQUFJO1lBQ2Ysa0JBQWtCLEVBQUUsS0FBSztZQUN6QixxQkFBcUIsRUFBRSxLQUFLO1lBQzVCLGNBQWMsRUFBRSxDQUFDO1lBQ2pCLGlCQUFpQixFQUFFLENBQUM7U0FDckIsQ0FBQztRQUNNLG1CQUFjLEdBQUcsS0FBSyxDQUFDLENBQUMsYUFBYTtRQUNyQyxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUN0Qix5QkFBb0IsR0FBK0IsRUFBRSxDQUFDO1FBQ3RELDhCQUF5QixHQUFzQixFQUFFLENBQUM7UUFDbEQsaUJBQVksR0FBd0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUM5QyxvQkFBZSxHQUF3QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBUXZELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxV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Q0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLGVBQWU7UUFDbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2QsNkNBQTZDLEVBQzdDLGNBQWMsQ0FDZixDQUFDO1FBQ0YsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2QsaURBQWlELEVBQ2pELGNBQWMsQ0FDZixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBenFCRCxrRUF5cUJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9hcHBsaWNhdGlvbi1saWZlY3ljbGUtc2VydmljZS50cz9iZWYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBcHBsaWNhdGlvbiBMaWZlY3ljbGUgU2VydmljZVxyXG4gKiBNYW5hZ2VzIGFwcGxpY2F0aW9uIHN0YXJ0dXAsIHNodXRkb3duLCBhbmQgbGlmZWN5Y2xlIGV2ZW50c1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdyB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHR5cGUgeyBFcnJvckhhbmRsZXJTZXJ2aWNlIH0gZnJvbSAnLi9lcnJvci1oYW5kbGVyLXNlcnZpY2UnO1xyXG5pbXBvcnQgdHlwZSB7IExvZ2dlclNlcnZpY2UgfSBmcm9tICcuL2xvZ2dlci1zZXJ2aWNlJztcclxuaW1wb3J0IHR5cGUgeyBXaW5kb3dNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vd2luZG93LW1hbmFnZXItc2VydmljZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0dXBQcm9jZWR1cmUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBwcmlvcml0eTogbnVtYmVyO1xyXG4gIHRpbWVvdXQ6IG51bWJlcjtcclxuICBwcm9jZWR1cmU6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVxdWlyZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGlmZWN5Y2xlRXZlbnRzIHtcclxuICAnc3RhcnR1cC1zdGFydGVkJzogdm9pZDtcclxuICAnc3RhcnR1cC1jb21wbGV0ZWQnOiB2b2lkO1xyXG4gICdzdGFydHVwLWZhaWxlZCc6IHsgZXJyb3I6IEVycm9yIH07XHJcbiAgJ3NodXRkb3duLXN0YXJ0ZWQnOiB7IHJlYXNvbjogc3RyaW5nIH07XHJcbiAgJ3NodXRkb3duLWNvbXBsZXRlZCc6IHZvaWQ7XHJcbiAgJ2JlZm9yZS1xdWl0JzogeyBldmVudDogRWxlY3Ryb24uRXZlbnQgfTtcclxuICAnd2lsbC1xdWl0JzogeyBldmVudDogRWxlY3Ryb24uRXZlbnQgfTtcclxuICAnd2luZG93LWFsbC1jbG9zZWQnOiB2b2lkO1xyXG4gIGFjdGl2YXRlOiB2b2lkO1xyXG4gIHJlYWR5OiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFwcGxpY2F0aW9uU3RhdGUge1xyXG4gIGlzU3RhcnRpbmc6IGJvb2xlYW47XHJcbiAgaXNSZWFkeTogYm9vbGVhbjtcclxuICBpc1NodXR0aW5nRG93bjogYm9vbGVhbjtcclxuICBzdGFydHVwVGltZTogbnVtYmVyIHwgbnVsbDtcclxuICByZWFkeVRpbWU6IG51bWJlciB8IG51bGw7XHJcbiAgc2h1dGRvd25UaW1lOiBudW1iZXIgfCBudWxsO1xyXG4gIGxhc3RFcnJvcjogRXJyb3IgfCBudWxsO1xyXG4gIHJlc291cmNlc0NsZWFuZWRVcDogYm9vbGVhbjtcclxuICBldmVudExpc3RlbmVyc1JlbW92ZWQ6IGJvb2xlYW47XHJcbiAgd2luZG93c01hbmFnZWQ6IG51bWJlcjtcclxuICBhY3RpdmVDb25uZWN0aW9uczogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQXBwbGljYXRpb25MaWZlY3ljbGVTZXJ2aWNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyU2VydmljZTtcclxuICBwcml2YXRlIHdpbmRvd01hbmFnZXI6IFdpbmRvd01hbmFnZXJTZXJ2aWNlO1xyXG4gIHByaXZhdGUgZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXJTZXJ2aWNlO1xyXG4gIHByaXZhdGUgc3RhcnR1cFByb2NlZHVyZXM6IE1hcDxzdHJpbmcsIFN0YXJ0dXBQcm9jZWR1cmU+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgc3RhdGU6IEFwcGxpY2F0aW9uU3RhdGUgPSB7XHJcbiAgICBpc1N0YXJ0aW5nOiBmYWxzZSxcclxuICAgIGlzUmVhZHk6IGZhbHNlLFxyXG4gICAgaXNTaHV0dGluZ0Rvd246IGZhbHNlLFxyXG4gICAgc3RhcnR1cFRpbWU6IG51bGwsXHJcbiAgICByZWFkeVRpbWU6IG51bGwsXHJcbiAgICBzaHV0ZG93blRpbWU6IG51bGwsXHJcbiAgICBsYXN0RXJyb3I6IG51bGwsXHJcbiAgICByZXNvdXJjZXNDbGVhbmVkVXA6IGZhbHNlLFxyXG4gICAgZXZlbnRMaXN0ZW5lcnNSZW1vdmVkOiBmYWxzZSxcclxuICAgIHdpbmRvd3NNYW5hZ2VkOiAwLFxyXG4gICAgYWN0aXZlQ29ubmVjdGlvbnM6IDAsXHJcbiAgfTtcclxuICBwcml2YXRlIHN0YXJ0dXBUaW1lb3V0ID0gNjAwMDA7IC8vIDYwIHNlY29uZHNcclxuICBwcml2YXRlIHF1aXRQcmV2ZW50ZWQgPSBmYWxzZTtcclxuICBwcml2YXRlIHJlc291cmNlQ2xlYW51cFRhc2tzOiBBcnJheTwoKSA9PiBQcm9taXNlPHZvaWQ+PiA9IFtdO1xyXG4gIHByaXZhdGUgZXZlbnRMaXN0ZW5lckNsZWFudXBUYXNrczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcclxuICBwcml2YXRlIGFjdGl2ZVRpbWVyczogU2V0PE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBTZXQoKTtcclxuICBwcml2YXRlIGFjdGl2ZUludGVydmFsczogU2V0PE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBTZXQoKTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBsb2dnZXI6IExvZ2dlclNlcnZpY2UsXHJcbiAgICB3aW5kb3dNYW5hZ2VyOiBXaW5kb3dNYW5hZ2VyU2VydmljZSxcclxuICAgIGVycm9ySGFuZGxlcjogRXJyb3JIYW5kbGVyU2VydmljZSxcclxuICApIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcclxuICAgIHRoaXMud2luZG93TWFuYWdlciA9IHdpbmRvd01hbmFnZXI7XHJcbiAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcclxuICAgIHRoaXMuc2V0dXBFdmVudEhhbmRsZXJzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBhcHBsaWNhdGlvbiBsaWZlY3ljbGVcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnSW5pdGlhbGl6aW5nIGFwcGxpY2F0aW9uIGxpZmVjeWNsZScsICdBcHBMaWZlY3ljbGUnKTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciBkZWZhdWx0IHN0YXJ0dXAgcHJvY2VkdXJlc1xyXG4gICAgdGhpcy5yZWdpc3RlckRlZmF1bHRTdGFydHVwUHJvY2VkdXJlcygpO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHNodXRkb3duIHByb2NlZHVyZXMgd2l0aCBlcnJvciBoYW5kbGVyXHJcbiAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyU2h1dGRvd25Qcm9jZWR1cmVzKCk7XHJcblxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnQXBwbGljYXRpb24gbGlmZWN5Y2xlIGluaXRpYWxpemVkJywgJ0FwcExpZmVjeWNsZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSBzdGFydHVwIHByb2NlZHVyZVxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyU3RhcnR1cFByb2NlZHVyZShwcm9jZWR1cmU6IFN0YXJ0dXBQcm9jZWR1cmUpOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhcnR1cFByb2NlZHVyZXMuc2V0KHByb2NlZHVyZS5uYW1lLCBwcm9jZWR1cmUpO1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXHJcbiAgICAgIGBTdGFydHVwIHByb2NlZHVyZSByZWdpc3RlcmVkOiAke3Byb2NlZHVyZS5uYW1lfWAsXHJcbiAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGUgYXBwbGljYXRpb24gc3RhcnR1cCBzZXF1ZW5jZVxyXG4gICAqL1xyXG4gIGFzeW5jIHN0YXJ0dXAoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZS5pc1N0YXJ0aW5nIHx8IHRoaXMuc3RhdGUuaXNSZWFkeSkge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxyXG4gICAgICAgICdTdGFydHVwIGFscmVhZHkgaW4gcHJvZ3Jlc3Mgb3IgY29tcGxldGVkJyxcclxuICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3RhdGUuaXNTdGFydGluZyA9IHRydWU7XHJcbiAgICB0aGlzLnN0YXRlLnN0YXJ0dXBUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIHRoaXMuZW1pdCgnc3RhcnR1cC1zdGFydGVkJyk7XHJcblxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnU3RhcnRpbmcgYXBwbGljYXRpb24gc3RhcnR1cCBzZXF1ZW5jZScsICdBcHBMaWZlY3ljbGUnKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBFeGVjdXRlIHN0YXJ0dXAgcHJvY2VkdXJlcyBpbiBwcmlvcml0eSBvcmRlclxyXG4gICAgICBjb25zdCBwcm9jZWR1cmVzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXJ0dXBQcm9jZWR1cmVzLnZhbHVlcygpKS5zb3J0KFxyXG4gICAgICAgIChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcHJvY2VkdXJlIG9mIHByb2NlZHVyZXMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcclxuICAgICAgICAgICAgYEV4ZWN1dGluZyBzdGFydHVwIHByb2NlZHVyZTogJHtwcm9jZWR1cmUubmFtZX1gLFxyXG4gICAgICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgcHJvY2VkdXJlLnByb2NlZHVyZSgpLFxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbWVvdXRQcm9taXNlKFxyXG4gICAgICAgICAgICAgIHByb2NlZHVyZS50aW1lb3V0LFxyXG4gICAgICAgICAgICAgIGBTdGFydHVwIHByb2NlZHVyZSAke3Byb2NlZHVyZS5uYW1lfSB0aW1lZCBvdXRgLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcclxuICAgICAgICAgICAgYFN0YXJ0dXAgcHJvY2VkdXJlIGNvbXBsZXRlZDogJHtwcm9jZWR1cmUubmFtZX1gLFxyXG4gICAgICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XHJcbiAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICBgU3RhcnR1cCBwcm9jZWR1cmUgZmFpbGVkOiAke3Byb2NlZHVyZS5uYW1lfWAsXHJcbiAgICAgICAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKHByb2NlZHVyZS5yZXF1aXJlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgYFJlcXVpcmVkIHN0YXJ0dXAgcHJvY2VkdXJlIGZhaWxlZDogJHtwcm9jZWR1cmUubmFtZX0gLSAke2Vycm9yTWVzc2FnZX1gLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGF0ZS5pc1N0YXJ0aW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc3RhdGUuaXNSZWFkeSA9IHRydWU7XHJcbiAgICAgIHRoaXMuc3RhdGUucmVhZHlUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXJ0dXBEdXJhdGlvbiA9IHRoaXMuc3RhdGUucmVhZHlUaW1lIC0gdGhpcy5zdGF0ZS5zdGFydHVwVGltZSE7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXHJcbiAgICAgICAgYEFwcGxpY2F0aW9uIHN0YXJ0dXAgY29tcGxldGVkIGluICR7c3RhcnR1cER1cmF0aW9ufW1zYCxcclxuICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMuZW1pdCgnc3RhcnR1cC1jb21wbGV0ZWQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUuaXNTdGFydGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnN0YXRlLmxhc3RFcnJvciA9XHJcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xyXG5cclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0FwcGxpY2F0aW9uIHN0YXJ0dXAgZmFpbGVkJywgJ0FwcExpZmVjeWNsZScsIHtcclxuICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5sYXN0RXJyb3IubWVzc2FnZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmVtaXQoJ3N0YXJ0dXAtZmFpbGVkJywgeyBlcnJvcjogdGhpcy5zdGF0ZS5sYXN0RXJyb3IgfSk7XHJcbiAgICAgIHRocm93IHRoaXMuc3RhdGUubGFzdEVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZSBhcHBsaWNhdGlvbiBzaHV0ZG93biBzZXF1ZW5jZVxyXG4gICAqL1xyXG4gIGFzeW5jIHNodXRkb3duKHJlYXNvbjogc3RyaW5nID0gJ1Vua25vd24nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5zdGF0ZS5pc1NodXR0aW5nRG93bikge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdTaHV0ZG93biBhbHJlYWR5IGluIHByb2dyZXNzJywgJ0FwcExpZmVjeWNsZScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0ZS5pc1NodXR0aW5nRG93biA9IHRydWU7XHJcbiAgICB0aGlzLnN0YXRlLnNodXRkb3duVGltZSA9IERhdGUubm93KCk7XHJcbiAgICB0aGlzLmVtaXQoJ3NodXRkb3duLXN0YXJ0ZWQnLCB7IHJlYXNvbiB9KTtcclxuXHJcbiAgICB0aGlzLmxvZ2dlci5pbmZvKFxyXG4gICAgICBgU3RhcnRpbmcgYXBwbGljYXRpb24gc2h1dGRvd246ICR7cmVhc29ufWAsXHJcbiAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVc2UgZXJyb3IgaGFuZGxlcidzIGdyYWNlZnVsIHNodXRkb3duXHJcbiAgICAgIGF3YWl0IHRoaXMuZXJyb3JIYW5kbGVyLmdyYWNlZnVsU2h1dGRvd24ocmVhc29uKTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0FwcGxpY2F0aW9uIHNodXRkb3duIGNvbXBsZXRlZCcsICdBcHBMaWZlY3ljbGUnKTtcclxuICAgICAgdGhpcy5lbWl0KCdzaHV0ZG93bi1jb21wbGV0ZWQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBkdXJpbmcgYXBwbGljYXRpb24gc2h1dGRvd24nLCAnQXBwTGlmZWN5Y2xlJywge1xyXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgICAgIHJlYXNvbixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBhcHBsaWNhdGlvbiBzdGF0ZVxyXG4gICAqL1xyXG4gIGdldFN0YXRlKCk6IEFwcGxpY2F0aW9uU3RhdGUge1xyXG4gICAgcmV0dXJuIHsgLi4udGhpcy5zdGF0ZSB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYXBwbGljYXRpb24gaXMgcmVhZHlcclxuICAgKi9cclxuICBpc1JlYWR5KCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNSZWFkeTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFwcGxpY2F0aW9uIGlzIHNodXR0aW5nIGRvd25cclxuICAgKi9cclxuICBpc1NodXR0aW5nRG93bigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzU2h1dHRpbmdEb3duO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSByZXNvdXJjZSBjbGVhbnVwIHRhc2tcclxuICAgKi9cclxuICByZWdpc3RlclJlc291cmNlQ2xlYW51cChjbGVhbnVwVGFzazogKCkgPT4gUHJvbWlzZTx2b2lkPik6IHZvaWQge1xyXG4gICAgdGhpcy5yZXNvdXJjZUNsZWFudXBUYXNrcy5wdXNoKGNsZWFudXBUYXNrKTtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdSZXNvdXJjZSBjbGVhbnVwIHRhc2sgcmVnaXN0ZXJlZCcsICdBcHBMaWZlY3ljbGUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGNsZWFudXAgdGFza1xyXG4gICAqL1xyXG4gIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lckNsZWFudXAoY2xlYW51cFRhc2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIHRoaXMuZXZlbnRMaXN0ZW5lckNsZWFudXBUYXNrcy5wdXNoKGNsZWFudXBUYXNrKTtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdFdmVudCBsaXN0ZW5lciBjbGVhbnVwIHRhc2sgcmVnaXN0ZXJlZCcsICdBcHBMaWZlY3ljbGUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgdGltZXIgZm9yIGF1dG9tYXRpYyBjbGVhbnVwXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJUaW1lcih0aW1lcjogTm9kZUpTLlRpbWVvdXQpOiB2b2lkIHtcclxuICAgIHRoaXMuYWN0aXZlVGltZXJzLmFkZCh0aW1lcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBpbnRlcnZhbCBmb3IgYXV0b21hdGljIGNsZWFudXBcclxuICAgKi9cclxuICByZWdpc3RlckludGVydmFsKGludGVydmFsOiBOb2RlSlMuVGltZW91dCk6IHZvaWQge1xyXG4gICAgdGhpcy5hY3RpdmVJbnRlcnZhbHMuYWRkKGludGVydmFsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIGFsbCByZXNvdXJjZXNcclxuICAgKi9cclxuICBhc3luYyBjbGVhbnVwUmVzb3VyY2VzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUucmVzb3VyY2VzQ2xlYW5lZFVwKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdSZXNvdXJjZXMgYWxyZWFkeSBjbGVhbmVkIHVwJywgJ0FwcExpZmVjeWNsZScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnU3RhcnRpbmcgcmVzb3VyY2UgY2xlYW51cCcsICdBcHBMaWZlY3ljbGUnKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDbGVhciBhbGwgdGltZXJzXHJcbiAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy5hY3RpdmVUaW1lcnMpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYWN0aXZlVGltZXJzLmNsZWFyKCk7XHJcblxyXG4gICAgICAvLyBDbGVhciBhbGwgaW50ZXJ2YWxzXHJcbiAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5hY3RpdmVJbnRlcnZhbHMpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFjdGl2ZUludGVydmFscy5jbGVhcigpO1xyXG5cclxuICAgICAgLy8gRXhlY3V0ZSByZXNvdXJjZSBjbGVhbnVwIHRhc2tzXHJcbiAgICAgIGNvbnN0IGNsZWFudXBQcm9taXNlcyA9IHRoaXMucmVzb3VyY2VDbGVhbnVwVGFza3MubWFwKFxyXG4gICAgICAgIGFzeW5jICh0YXNrLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGFzaygpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgICAgICAgICBgUmVzb3VyY2UgY2xlYW51cCB0YXNrICR7aW5kZXh9IGNvbXBsZXRlZGAsXHJcbiAgICAgICAgICAgICAgJ0FwcExpZmVjeWNsZScsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcclxuICAgICAgICAgICAgICBgUmVzb3VyY2UgY2xlYW51cCB0YXNrICR7aW5kZXh9IGZhaWxlZGAsXHJcbiAgICAgICAgICAgICAgJ0FwcExpZmVjeWNsZScsXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNsZWFudXBQcm9taXNlcyk7XHJcblxyXG4gICAgICB0aGlzLnN0YXRlLnJlc291cmNlc0NsZWFuZWRVcCA9IHRydWU7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1Jlc291cmNlIGNsZWFudXAgY29tcGxldGVkJywgJ0FwcExpZmVjeWNsZScpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Vycm9yIGR1cmluZyByZXNvdXJjZSBjbGVhbnVwJywgJ0FwcExpZmVjeWNsZScsIHtcclxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcixcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBhbGwgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgY2xlYW51cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUuZXZlbnRMaXN0ZW5lcnNSZW1vdmVkKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdFdmVudCBsaXN0ZW5lcnMgYWxyZWFkeSBjbGVhbmVkIHVwJywgJ0FwcExpZmVjeWNsZScpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnU3RhcnRpbmcgZXZlbnQgbGlzdGVuZXIgY2xlYW51cCcsICdBcHBMaWZlY3ljbGUnKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBFeGVjdXRlIGV2ZW50IGxpc3RlbmVyIGNsZWFudXAgdGFza3NcclxuICAgICAgdGhpcy5ldmVudExpc3RlbmVyQ2xlYW51cFRhc2tzLmZvckVhY2goKHRhc2ssIGluZGV4KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRhc2soKTtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxyXG4gICAgICAgICAgICBgRXZlbnQgbGlzdGVuZXIgY2xlYW51cCB0YXNrICR7aW5kZXh9IGNvbXBsZXRlZGAsXHJcbiAgICAgICAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgIGBFdmVudCBsaXN0ZW5lciBjbGVhbnVwIHRhc2sgJHtpbmRleH0gZmFpbGVkYCxcclxuICAgICAgICAgICAgJ0FwcExpZmVjeWNsZScsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZyb20gdGhpcyBFdmVudEVtaXR0ZXJcclxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAgIHRoaXMuc3RhdGUuZXZlbnRMaXN0ZW5lcnNSZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnRXZlbnQgbGlzdGVuZXIgY2xlYW51cCBjb21wbGV0ZWQnLCAnQXBwTGlmZWN5Y2xlJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3IgZHVyaW5nIGV2ZW50IGxpc3RlbmVyIGNsZWFudXAnLCAnQXBwTGlmZWN5Y2xlJywge1xyXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB3aW5kb3cgbWFuYWdlbWVudCBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgdXBkYXRlV2luZG93U3RhdHMod2luZG93Q291bnQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5zdGF0ZS53aW5kb3dzTWFuYWdlZCA9IHdpbmRvd0NvdW50O1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFdpbmRvdyBjb3VudCB1cGRhdGVkOiAke3dpbmRvd0NvdW50fWAsICdBcHBMaWZlY3ljbGUnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhY3RpdmUgY29ubmVjdGlvbnMgY291bnRcclxuICAgKi9cclxuICB1cGRhdGVDb25uZWN0aW9uU3RhdHMoY29ubmVjdGlvbkNvdW50OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGUuYWN0aXZlQ29ubmVjdGlvbnMgPSBjb25uZWN0aW9uQ291bnQ7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgYEFjdGl2ZSBjb25uZWN0aW9ucyB1cGRhdGVkOiAke2Nvbm5lY3Rpb25Db3VudH1gLFxyXG4gICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBkZWZhdWx0IHN0YXJ0dXAgcHJvY2VkdXJlc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgcmVnaXN0ZXJEZWZhdWx0U3RhcnR1cFByb2NlZHVyZXMoKTogdm9pZCB7XHJcbiAgICAvLyBXaW5kb3cgbWFuYWdlciBpbml0aWFsaXphdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlclN0YXJ0dXBQcm9jZWR1cmUoe1xyXG4gICAgICBuYW1lOiAnd2luZG93LW1hbmFnZXInLFxyXG4gICAgICBwcmlvcml0eTogMTAsXHJcbiAgICAgIHRpbWVvdXQ6IDEwMDAwLFxyXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgcHJvY2VkdXJlOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgLy8gV2luZG93IG1hbmFnZXIgc2hvdWxkIGFscmVhZHkgYmUgaW5pdGlhbGl6ZWRcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnV2luZG93IG1hbmFnZXIgc3RhcnR1cCBwcm9jZWR1cmUnLCAnQXBwTGlmZWN5Y2xlJyk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBNYWluIHdpbmRvdyBjcmVhdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlclN0YXJ0dXBQcm9jZWR1cmUoe1xyXG4gICAgICBuYW1lOiAnbWFpbi13aW5kb3cnLFxyXG4gICAgICBwcmlvcml0eTogNSxcclxuICAgICAgdGltZW91dDogMTUwMDAsXHJcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICBwcm9jZWR1cmU6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZU1haW5XaW5kb3coKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFBvc3Qtc3RhcnR1cCBjbGVhbnVwXHJcbiAgICB0aGlzLnJlZ2lzdGVyU3RhcnR1cFByb2NlZHVyZSh7XHJcbiAgICAgIG5hbWU6ICdwb3N0LXN0YXJ0dXAtY2xlYW51cCcsXHJcbiAgICAgIHByaW9yaXR5OiAxLFxyXG4gICAgICB0aW1lb3V0OiA1MDAwLFxyXG4gICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgIHByb2NlZHVyZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIC8vIFBlcmZvcm0gYW55IHBvc3Qtc3RhcnR1cCBjbGVhbnVwIHRhc2tzXHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1Bvc3Qtc3RhcnR1cCBjbGVhbnVwIGNvbXBsZXRlZCcsICdBcHBMaWZlY3ljbGUnKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgc2h1dGRvd24gcHJvY2VkdXJlcyB3aXRoIGVycm9yIGhhbmRsZXJcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHJlZ2lzdGVyU2h1dGRvd25Qcm9jZWR1cmVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gUmVnaXN0ZXIgcmVzb3VyY2UgY2xlYW51cFxyXG4gICAgdGhpcy5lcnJvckhhbmRsZXIucmVnaXN0ZXJTaHV0ZG93blByb2NlZHVyZSh7XHJcbiAgICAgIG5hbWU6ICdyZXNvdXJjZS1jbGVhbnVwJyxcclxuICAgICAgcHJpb3JpdHk6IDE1LFxyXG4gICAgICB0aW1lb3V0OiAxMDAwMCxcclxuICAgICAgcHJvY2VkdXJlOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwUmVzb3VyY2VzKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB3aW5kb3cgbWFuYWdlciBzaHV0ZG93blxyXG4gICAgdGhpcy5lcnJvckhhbmRsZXIucmVnaXN0ZXJTaHV0ZG93blByb2NlZHVyZSh7XHJcbiAgICAgIG5hbWU6ICd3aW5kb3ctbWFuYWdlcicsXHJcbiAgICAgIHByaW9yaXR5OiAxMCxcclxuICAgICAgdGltZW91dDogMTAwMDAsXHJcbiAgICAgIHByb2NlZHVyZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMud2luZG93TWFuYWdlci5zaHV0ZG93bigpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgY2xlYW51cFxyXG4gICAgdGhpcy5lcnJvckhhbmRsZXIucmVnaXN0ZXJTaHV0ZG93blByb2NlZHVyZSh7XHJcbiAgICAgIG5hbWU6ICdldmVudC1saXN0ZW5lci1jbGVhbnVwJyxcclxuICAgICAgcHJpb3JpdHk6IDUsXHJcbiAgICAgIHRpbWVvdXQ6IDUwMDAsXHJcbiAgICAgIHByb2NlZHVyZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY2xlYW51cEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciBhcHBsaWNhdGlvbiBsaWZlY3ljbGUgc2h1dGRvd25cclxuICAgIHRoaXMuZXJyb3JIYW5kbGVyLnJlZ2lzdGVyU2h1dGRvd25Qcm9jZWR1cmUoe1xyXG4gICAgICBuYW1lOiAnYXBwbGljYXRpb24tbGlmZWN5Y2xlJyxcclxuICAgICAgcHJpb3JpdHk6IDEsXHJcbiAgICAgIHRpbWVvdXQ6IDUwMDAsXHJcbiAgICAgIHByb2NlZHVyZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2h1dGRvd25TZXJ2aWNlKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgbWFpbiBhcHBsaWNhdGlvbiB3aW5kb3dcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZU1haW5XaW5kb3coKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBtYWluV2luZG93ID0gYXdhaXQgdGhpcy53aW5kb3dNYW5hZ2VyLmNyZWF0ZVdpbmRvdyhcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJ21haW4nLFxyXG4gICAgICAgICAgd2lkdGg6IDgwMCxcclxuICAgICAgICAgIGhlaWdodDogNjAwLFxyXG4gICAgICAgICAgbWluV2lkdGg6IDYwMCxcclxuICAgICAgICAgIG1pbkhlaWdodDogNDAwLFxyXG4gICAgICAgICAgY2VudGVyOiB0cnVlLFxyXG4gICAgICAgICAgdGl0bGU6ICdQbGF5bGlzdGlmeScsXHJcbiAgICAgICAgICB3ZWJQcmVmZXJlbmNlczoge1xyXG4gICAgICAgICAgICBwcmVsb2FkOiBNQUlOX1dJTkRPV19QUkVMT0FEX1dFQlBBQ0tfRU5UUlksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTUFJTl9XSU5ET1dfV0VCUEFDS19FTlRSWSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIE9wZW4gRGV2VG9vbHMgaW4gZGV2ZWxvcG1lbnRcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnTWFpbiB3aW5kb3cgY3JlYXRlZCBzdWNjZXNzZnVsbHknLCAnQXBwTGlmZWN5Y2xlJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBtYWluIHdpbmRvdycsICdBcHBMaWZlY3ljbGUnLCB7XHJcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB1cCBhcHBsaWNhdGlvbiBldmVudCBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc2V0dXBFdmVudEhhbmRsZXJzKCk6IHZvaWQge1xyXG4gICAgLy8gQXBwIHJlYWR5IGV2ZW50XHJcbiAgICBhcHAub24oJ3JlYWR5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydHVwKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1N0YXJ0dXAgZmFpbGVkIG9uIGFwcCByZWFkeScsICdBcHBMaWZlY3ljbGUnLCB7XHJcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcixcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBlcnJvciBkaWFsb2cgYW5kIHF1aXRcclxuICAgICAgICBjb25zdCB7IGRpYWxvZyB9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuICAgICAgICBhd2FpdCBkaWFsb2cuc2hvd0Vycm9yQm94KFxyXG4gICAgICAgICAgJ1N0YXJ0dXAgRXJyb3InLFxyXG4gICAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIHRoZSBhcHBsaWNhdGlvbi4gUGxlYXNlIHRyeSBhZ2FpbiBvciBjb250YWN0IHN1cHBvcnQuJyxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBhcHAucXVpdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCZWZvcmUgcXVpdCBldmVudFxyXG4gICAgYXBwLm9uKCdiZWZvcmUtcXVpdCcsIGV2ZW50ID0+IHtcclxuICAgICAgdGhpcy5lbWl0KCdiZWZvcmUtcXVpdCcsIHsgZXZlbnQgfSk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaXNTaHV0dGluZ0Rvd24gJiYgIXRoaXMucXVpdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHRoaXMucXVpdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaHV0ZG93bignQXBwbGljYXRpb24gUXVpdCcpXHJcbiAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucXVpdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhcHAucXVpdCgpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAgICdFcnJvciBkdXJpbmcgc2h1dGRvd24gb24gYmVmb3JlLXF1aXQnLFxyXG4gICAgICAgICAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhcHAucXVpdCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdpbGwgcXVpdCBldmVudFxyXG4gICAgYXBwLm9uKCd3aWxsLXF1aXQnLCBldmVudCA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdCgnd2lsbC1xdWl0JywgeyBldmVudCB9KTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQXBwbGljYXRpb24gd2lsbCBxdWl0JywgJ0FwcExpZmVjeWNsZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2luZG93IGFsbCBjbG9zZWQgZXZlbnRcclxuICAgIGFwcC5vbignd2luZG93LWFsbC1jbG9zZWQnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdCgnd2luZG93LWFsbC1jbG9zZWQnKTtcclxuXHJcbiAgICAgIC8vIE9uIG1hY09TLCBhcHBsaWNhdGlvbnMgdHlwaWNhbGx5IHN0YXkgYWN0aXZlIHVudGlsIGV4cGxpY2l0bHkgcXVpdFxyXG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgICAgICdBbGwgd2luZG93cyBjbG9zZWQsIHF1aXR0aW5nIGFwcGxpY2F0aW9uJyxcclxuICAgICAgICAgICdBcHBMaWZlY3ljbGUnLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXBwLnF1aXQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0aXZhdGUgZXZlbnQgKG1hY09TKVxyXG4gICAgYXBwLm9uKCdhY3RpdmF0ZScsICgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KCdhY3RpdmF0ZScpO1xyXG5cclxuICAgICAgLy8gT24gbWFjT1MsIHJlLWNyZWF0ZSB3aW5kb3cgd2hlbiBkb2NrIGljb24gaXMgY2xpY2tlZCBhbmQgbm8gd2luZG93cyBhcmUgb3BlblxyXG4gICAgICBpZiAoQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkubGVuZ3RoID09PSAwICYmIHRoaXMuc3RhdGUuaXNSZWFkeSkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlTWFpbldpbmRvdygpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxyXG4gICAgICAgICAgICAnRmFpbGVkIHRvIHJlY3JlYXRlIG1haW4gd2luZG93IG9uIGFjdGl2YXRlJyxcclxuICAgICAgICAgICAgJ0FwcExpZmVjeWNsZScsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdpbmRvdyBtYW5hZ2VyIGV2ZW50c1xyXG4gICAgdGhpcy53aW5kb3dNYW5hZ2VyLm9uKCdyZXF1ZXN0LW1haW4td2luZG93JywgKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZS5pc1JlYWR5ICYmICF0aGlzLnN0YXRlLmlzU2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVNYWluV2luZG93KCkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgICAgICdGYWlsZWQgdG8gY3JlYXRlIG1haW4gd2luZG93IG9uIHJlcXVlc3QnLFxyXG4gICAgICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy53aW5kb3dNYW5hZ2VyLm9uKCdhbGwtd2luZG93cy1jbG9zZWQnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlV2luZG93U3RhdHMoMCk7XHJcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnZGFyd2luJyAmJiAhdGhpcy5zdGF0ZS5pc1NodXR0aW5nRG93bikge1xyXG4gICAgICAgIGFwcC5xdWl0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB3aW5kb3cgc3RhdGlzdGljcyB3aGVuIHdpbmRvd3MgYXJlIGNyZWF0ZWQgb3IgY2xvc2VkXHJcbiAgICB0aGlzLndpbmRvd01hbmFnZXIub24oJ3dpbmRvdy1jcmVhdGVkJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMud2luZG93TWFuYWdlci5nZXRXaW5kb3dTdGF0cygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVdpbmRvd1N0YXRzKHN0YXRzLmFjdGl2ZVdpbmRvd3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy53aW5kb3dNYW5hZ2VyLm9uKCd3aW5kb3ctY2xvc2VkJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMud2luZG93TWFuYWdlci5nZXRXaW5kb3dTdGF0cygpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVdpbmRvd1N0YXRzKHN0YXRzLmFjdGl2ZVdpbmRvd3MpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgd2luZG93IG1hbmFnZXIgY2xlYW51cCB0YXNrc1xyXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXJDbGVhbnVwKCgpID0+IHtcclxuICAgICAgdGhpcy53aW5kb3dNYW5hZ2VyLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5yZWdpc3RlclJlc291cmNlQ2xlYW51cChhc3luYyAoKSA9PiB7XHJcbiAgICAgIC8vIFNhdmUgYWxsIHdpbmRvdyBzdGF0ZXMgYmVmb3JlIHNodXRkb3duXHJcbiAgICAgIGNvbnN0IHdpbmRvd0lkcyA9IHRoaXMud2luZG93TWFuYWdlci5nZXRBbGxXaW5kb3dJZHMoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXHJcbiAgICAgICAgYFNhdmluZyBzdGF0ZSBmb3IgJHt3aW5kb3dJZHMubGVuZ3RofSB3aW5kb3dzYCxcclxuICAgICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENlcnRpZmljYXRlIGVycm9yIGhhbmRsaW5nXHJcbiAgICBhcHAub24oXHJcbiAgICAgICdjZXJ0aWZpY2F0ZS1lcnJvcicsXHJcbiAgICAgIChldmVudCwgd2ViQ29udGVudHMsIHVybCwgZXJyb3IsIGNlcnRpZmljYXRlLCBjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0NlcnRpZmljYXRlIGVycm9yJywgJ0FwcExpZmVjeWNsZScsIHsgZXJyb3IsIHVybCB9KTtcclxuXHJcbiAgICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIG1pZ2h0IHdhbnQgdG8gaWdub3JlIGNlcnRpZmljYXRlIGVycm9ycyBmb3IgbG9jYWxob3N0XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcclxuICAgICAgICAgIHVybC5pbmNsdWRlcygnbG9jYWxob3N0JylcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gU2VjdXJpdHk6IFByZXZlbnQgbmV3IHdpbmRvdyBjcmVhdGlvbiBmcm9tIHJlbmRlcmVyXHJcbiAgICBhcHAub24oJ3dlYi1jb250ZW50cy1jcmVhdGVkJywgKF9ldmVudCwgY29udGVudHMpID0+IHtcclxuICAgICAgLy8gSGFuZGxlIGV4dGVybmFsIGxpbmsgYXR0ZW1wdHNcclxuICAgICAgY29udGVudHMuc2V0V2luZG93T3BlbkhhbmRsZXIoKHsgdXJsIH0pID0+IHtcclxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdCbG9ja2VkIG5ldyB3aW5kb3cgY3JlYXRpb24nLCAnQXBwTGlmZWN5Y2xlJywge1xyXG4gICAgICAgICAgdXJsLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7IGFjdGlvbjogJ2RlbnknIH07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29udGVudHMub24oJ3dpbGwtbmF2aWdhdGUnLCAobmF2aWdhdGlvbkV2ZW50LCBuYXZpZ2F0aW9uVXJsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChuYXZpZ2F0aW9uVXJsKTtcclxuXHJcbiAgICAgICAgLy8gT25seSBhbGxvdyBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lIG9yaWdpbiBvciBzcGVjaWZpYyBhbGxvd2VkIGRvbWFpbnNcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBwYXJzZWRVcmwub3JpZ2luICE9PSAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyAmJlxyXG4gICAgICAgICAgcGFyc2VkVXJsLm9yaWdpbiAhPT0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tJyAmJlxyXG4gICAgICAgICAgcGFyc2VkVXJsLm9yaWdpbiAhPT0gJ2h0dHBzOi8veW91dHViZS5jb20nXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBuYXZpZ2F0aW9uRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0Jsb2NrZWQgbmF2aWdhdGlvbicsICdBcHBMaWZlY3ljbGUnLCB7XHJcbiAgICAgICAgICAgIHVybDogbmF2aWdhdGlvblVybCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHRpbWVvdXQgcHJvbWlzZSBmb3IgcHJvY2VkdXJlIHRpbWVvdXRzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcmVhdGVUaW1lb3V0UHJvbWlzZShcclxuICAgIHRpbWVvdXQ6IG51bWJlcixcclxuICAgIG1lc3NhZ2U6IHN0cmluZyxcclxuICApOiBQcm9taXNlPG5ldmVyPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IobWVzc2FnZSkpLCB0aW1lb3V0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2h1dGRvd24gdGhlIGxpZmVjeWNsZSBzZXJ2aWNlXHJcbiAgICovXHJcbiAgYXN5bmMgc2h1dGRvd25TZXJ2aWNlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcclxuICAgICAgJ0FwcGxpY2F0aW9uIGxpZmVjeWNsZSBzZXJ2aWNlIHNodXR0aW5nIGRvd24nLFxyXG4gICAgICAnQXBwTGlmZWN5Y2xlJyxcclxuICAgICk7XHJcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbyhcclxuICAgICAgJ0FwcGxpY2F0aW9uIGxpZmVjeWNsZSBzZXJ2aWNlIHNodXRkb3duIGNvbXBsZXRlJyxcclxuICAgICAgJ0FwcExpZmVjeWNsZScsXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/backend/services/application-lifecycle-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/dependency-manager-service.ts":
/*!************************************************************!*\
  !*** ./src/backend/services/dependency-manager-service.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Dependency Manager Service\n * Manages external dependencies like yt-dlp and FFmpeg\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DependencyManagerService = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst fs = tslib_1.__importStar(__webpack_require__(/*! fs-extra */ \"fs-extra\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst os = tslib_1.__importStar(__webpack_require__(/*! os */ \"os\"));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst errors_1 = __webpack_require__(/*! @/shared/errors */ \"./src/shared/errors.ts\");\nconst dependency_config_1 = __webpack_require__(/*! ../config/dependency-config */ \"./src/backend/config/dependency-config.ts\");\nconst dependency_utils_1 = __webpack_require__(/*! ../utils/dependency-utils */ \"./src/backend/utils/dependency-utils.ts\");\nclass DependencyManagerService extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.initialized = false;\n        this.dependencyStatus = null;\n    }\n    /**\n     * Initialize the dependency manager\n     */\n    async initialize() {\n        try {\n            if (!(0, dependency_config_1.isPlatformSupported)()) {\n                throw new errors_1.DependencyError(`Unsupported platform: ${os.platform()}`);\n            }\n            // Ensure dependencies directory exists\n            const depsDir = (0, dependency_config_1.getDependenciesDirectory)();\n            await fs.ensureDir(depsDir);\n            // Check initial dependency status\n            await this.checkDependencies();\n            this.initialized = true;\n            this.emit('initialized');\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            throw new errors_1.DependencyError(`Failed to initialize dependency manager: ${message}`);\n        }\n    }\n    /**\n     * Check the status of all required dependencies\n     */\n    async checkDependencies() {\n        try {\n            const [ytdlpStatus, ffmpegStatus] = await Promise.all([\n                this.checkSingleDependency('ytdlp'),\n                this.checkSingleDependency('ffmpeg'),\n            ]);\n            this.dependencyStatus = {\n                ytdlp: ytdlpStatus,\n                ffmpeg: ffmpegStatus,\n            };\n            this.emit('statusUpdated', this.dependencyStatus);\n            return this.dependencyStatus;\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            throw new errors_1.DependencyError(`Failed to check dependencies: ${message}`);\n        }\n    }\n    /**\n     * Check the status of a single dependency\n     */\n    async checkSingleDependency(name) {\n        try {\n            const executablePath = (0, dependency_config_1.getDependencyExecutablePath)(name);\n            const isValid = await (0, dependency_utils_1.validateBinary)(executablePath);\n            if (!isValid) {\n                return {\n                    name,\n                    path: executablePath,\n                    installed: false,\n                    isValid: false,\n                    error: 'Binary not found or not executable',\n                };\n            }\n            const version = await (0, dependency_utils_1.getBinaryVersion)(executablePath);\n            return {\n                name,\n                path: executablePath,\n                installed: true,\n                isValid: true,\n                version: version || 'Unknown',\n            };\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            return {\n                name,\n                path: (0, dependency_config_1.getDependencyExecutablePath)(name),\n                installed: false,\n                isValid: false,\n                error: message,\n            };\n        }\n    }\n    /**\n     * Install a specific dependency\n     */\n    async installDependency(name) {\n        try {\n            this.emit('installStarted', name);\n            const config = (0, dependency_config_1.getDependencyConfig)();\n            const dependencyConfig = name === 'ytdlp' ? config.ytdlp : config.ffmpeg;\n            const dependencyDir = (0, dependency_config_1.getDependencyDirectory)(name);\n            const tempDir = path.join(os.tmpdir(), `playlistify-${name}-${Date.now()}`);\n            // Clean up any existing installation\n            if (await fs.pathExists(dependencyDir)) {\n                await fs.remove(dependencyDir);\n            }\n            // Create directories\n            await fs.ensureDir(dependencyDir);\n            await fs.ensureDir(tempDir);\n            try {\n                // Check if download URL is accessible\n                const isAccessible = await (0, dependency_utils_1.checkUrlAccessibility)(dependencyConfig.downloadUrl);\n                if (!isAccessible) {\n                    throw new errors_1.DependencyDownloadError(`Download URL is not accessible: ${dependencyConfig.downloadUrl}`);\n                }\n                // Download the dependency\n                const downloadPath = path.join(tempDir, dependencyConfig.filename);\n                await (0, dependency_utils_1.retryWithBackoff)(async () => {\n                    await (0, dependency_utils_1.downloadFile)(dependencyConfig.downloadUrl, downloadPath, (progress) => {\n                        progress.dependency = name;\n                        this.emit('downloadProgress', progress);\n                    });\n                });\n                this.emit('downloadProgress', {\n                    dependency: name,\n                    progress: 100,\n                    status: 'extracting',\n                    message: 'Extracting files...',\n                });\n                // Extract and install\n                await this.extractAndInstall(name, downloadPath, dependencyDir);\n                // Validate installation\n                const isValid = await this.validateDependency(name);\n                if (!isValid) {\n                    throw new errors_1.DependencyValidationError(`Installation validation failed for ${name}`);\n                }\n                // Update status\n                await this.checkDependencies();\n                this.emit('installCompleted', name);\n            }\n            finally {\n                // Clean up temp files\n                await (0, dependency_utils_1.cleanupTempFiles)(tempDir);\n            }\n        }\n        catch (error) {\n            this.emit('installFailed', name, error);\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            throw new errors_1.DependencyInstallationError(`Failed to install ${name}: ${message}`);\n        }\n    }\n    /**\n     * Extract and install a dependency\n     */\n    async extractAndInstall(name, downloadPath, installDir) {\n        const binDir = path.join(installDir, 'bin');\n        await fs.ensureDir(binDir);\n        if (name === 'ytdlp') {\n            // yt-dlp is usually a single executable\n            if (downloadPath.endsWith('.exe') || !downloadPath.includes('.')) {\n                // Direct executable\n                const config = (0, dependency_config_1.getDependencyConfig)();\n                const targetPath = path.join(binDir, config.ytdlp.executable);\n                await fs.copy(downloadPath, targetPath);\n                await (0, dependency_utils_1.makeExecutable)(targetPath);\n            }\n            else {\n                throw new errors_1.DependencyInstallationError('Unexpected yt-dlp package format');\n            }\n        }\n        else if (name === 'ffmpeg') {\n            // FFmpeg comes in various archive formats\n            const tempExtractDir = path.join(path.dirname(downloadPath), 'extract');\n            await fs.ensureDir(tempExtractDir);\n            if (downloadPath.endsWith('.zip')) {\n                await (0, dependency_utils_1.extractZip)(downloadPath, tempExtractDir);\n            }\n            else if (downloadPath.endsWith('.tar.xz') || downloadPath.endsWith('.tar.gz')) {\n                await (0, dependency_utils_1.extractTar)(downloadPath, tempExtractDir);\n            }\n            else {\n                throw new errors_1.DependencyInstallationError('Unsupported FFmpeg archive format');\n            }\n            // Find and copy the ffmpeg executable\n            const ffmpegExecutable = await this.findExecutableInDirectory(tempExtractDir, 'ffmpeg');\n            if (!ffmpegExecutable) {\n                throw new errors_1.DependencyInstallationError('FFmpeg executable not found in archive');\n            }\n            const config = (0, dependency_config_1.getDependencyConfig)();\n            const targetPath = path.join(binDir, config.ffmpeg.executable);\n            await fs.copy(ffmpegExecutable, targetPath);\n            await (0, dependency_utils_1.makeExecutable)(targetPath);\n            // Clean up temp extraction\n            await (0, dependency_utils_1.cleanupTempFiles)(tempExtractDir);\n        }\n    }\n    /**\n     * Find an executable in a directory (recursively)\n     */\n    async findExecutableInDirectory(dir, executableName) {\n        try {\n            const items = await fs.readdir(dir, { withFileTypes: true });\n            for (const item of items) {\n                const fullPath = path.join(dir, item.name);\n                if (item.isFile()) {\n                    const baseName = path.basename(item.name, path.extname(item.name));\n                    if (baseName === executableName || item.name === executableName ||\n                        (process.platform === 'win32' && item.name === `${executableName}.exe`)) {\n                        return fullPath;\n                    }\n                }\n                else if (item.isDirectory()) {\n                    const found = await this.findExecutableInDirectory(fullPath, executableName);\n                    if (found) {\n                        return found;\n                    }\n                }\n            }\n            return null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Get the path to a dependency binary\n     */\n    getDependencyPath(name) {\n        return (0, dependency_config_1.getDependencyExecutablePath)(name);\n    }\n    /**\n     * Validate that a dependency is properly installed and functional\n     */\n    async validateDependency(name) {\n        try {\n            const executablePath = (0, dependency_config_1.getDependencyExecutablePath)(name);\n            // Check if binary exists and is executable\n            const isValid = await (0, dependency_utils_1.validateBinary)(executablePath);\n            if (!isValid) {\n                return false;\n            }\n            // Try to get version to ensure it's working\n            const version = await (0, dependency_utils_1.getBinaryVersion)(executablePath);\n            return version !== null;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Get version information for a dependency\n     */\n    async getDependencyVersion(name) {\n        try {\n            const executablePath = (0, dependency_config_1.getDependencyExecutablePath)(name);\n            return await (0, dependency_utils_1.getBinaryVersion)(executablePath);\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Clean up all managed dependencies\n     */\n    async cleanupDependencies() {\n        try {\n            const depsDir = (0, dependency_config_1.getDependenciesDirectory)();\n            if (await fs.pathExists(depsDir)) {\n                await fs.remove(depsDir);\n            }\n            // Reset status\n            this.dependencyStatus = null;\n            await this.checkDependencies();\n            this.emit('dependenciesCleanedUp');\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : 'Unknown error';\n            throw new errors_1.DependencyError(`Failed to cleanup dependencies: ${message}`);\n        }\n    }\n    /**\n     * Get current dependency status (cached)\n     */\n    getDependencyStatus() {\n        return this.dependencyStatus;\n    }\n    /**\n     * Check if the dependency manager is initialized\n     */\n    isInitialized() {\n        return this.initialized;\n    }\n    /**\n     * Check if all dependencies are installed and valid\n     */\n    areAllDependenciesReady() {\n        if (!this.dependencyStatus) {\n            return false;\n        }\n        return this.dependencyStatus.ytdlp.installed &&\n            this.dependencyStatus.ytdlp.isValid &&\n            this.dependencyStatus.ffmpeg.installed &&\n            this.dependencyStatus.ffmpeg.isValid;\n    }\n}\nexports.DependencyManagerService = DependencyManagerService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9kZXBlbmRlbmN5LW1hbmFnZXItc2VydmljZS50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7O0FBRUgsaUZBQStCO0FBQy9CLDJFQUE2QjtBQUM3QixxRUFBeUI7QUFDekIsNkRBQXNDO0FBQ3RDLHNGQUt5QjtBQU96QixnSUFPcUM7QUFDckMsMkhBVW1DO0FBRW5DLE1BQWEsd0JBQXlCLFNBQVEscUJBQVk7SUFJeEQ7UUFDRSxLQUFLLEVBQUUsQ0FBQztRQUpGLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLHFCQUFnQixHQUE0QixJQUFJLENBQUM7SUFJekQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFVBQVU7UUFDZCxJQUFJLENBQUM7WUFDSCxJQUFJLENBQUMsMkNBQW1CLEdBQUUsRUFBRSxDQUFDO2dCQUMzQixNQUFNLElBQUksd0JBQWUsQ0FBQyx5QkFBeUIsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN0RSxDQUFDO1lBRUQsdUNBQXVDO1lBQ3ZDLE1BQU0sT0FBTyxHQUFHLGdEQUF3QixHQUFFLENBQUM7WUFDM0MsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRTVCLGtDQUFrQztZQUNsQyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBRS9CLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixNQUFNLE9BQU8sR0FBRyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7WUFDekUsTUFBTSxJQUFJLHdCQUFlLENBQUMsNENBQTRDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDbkYsQ0FBQztJQUNILENB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QW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNILGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsdUJBQXVCO1FBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUMzQixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsU0FBUztZQUNyQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLE9BQU87WUFDbkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTO1lBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO0lBQzlDLENBQUM7Q0FDRjtBQWhWRCw0REFnVkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL3NlcnZpY2VzL2RlcGVuZGVuY3ktbWFuYWdlci1zZXJ2aWNlLnRzP2M1ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERlcGVuZGVuY3kgTWFuYWdlciBTZXJ2aWNlXHJcbiAqIE1hbmFnZXMgZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIGxpa2UgeXQtZGxwIGFuZCBGRm1wZWdcclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHtcclxuICBEZXBlbmRlbmN5RXJyb3IsXHJcbiAgRGVwZW5kZW5jeUluc3RhbGxhdGlvbkVycm9yLFxyXG4gIERlcGVuZGVuY3lWYWxpZGF0aW9uRXJyb3IsXHJcbiAgRGVwZW5kZW5jeURvd25sb2FkRXJyb3IsXHJcbn0gZnJvbSAnQC9zaGFyZWQvZXJyb3JzJztcclxuaW1wb3J0IHR5cGUge1xyXG4gIERlcGVuZGVuY3lNYW5hZ2VyU2VydmljZSBhcyBJRGVwZW5kZW5jeU1hbmFnZXJTZXJ2aWNlLFxyXG4gIERlcGVuZGVuY3lTdGF0dXMsXHJcbiAgRGVwZW5kZW5jeUluZm8sXHJcbiAgRGVwZW5kZW5jeURvd25sb2FkUHJvZ3Jlc3MsXHJcbn0gZnJvbSAnQC9zaGFyZWQvaW50ZXJmYWNlcy9kZXBlbmRlbmN5LW1hbmFnZXInO1xyXG5pbXBvcnQge1xyXG4gIGdldERlcGVuZGVuY3lDb25maWcsXHJcbiAgZ2V0RGVwZW5kZW5jaWVzRGlyZWN0b3J5LFxyXG4gIGdldERlcGVuZGVuY3lEaXJlY3RvcnksXHJcbiAgZ2V0RGVwZW5kZW5jeUV4ZWN1dGFibGVQYXRoLFxyXG4gIGlzUGxhdGZvcm1TdXBwb3J0ZWQsXHJcbiAgZ2V0RXhlY3V0YWJsZVBlcm1pc3Npb25zLFxyXG59IGZyb20gJy4uL2NvbmZpZy9kZXBlbmRlbmN5LWNvbmZpZyc7XHJcbmltcG9ydCB7XHJcbiAgZG93bmxvYWRGaWxlLFxyXG4gIGV4dHJhY3RaaXAsXHJcbiAgZXh0cmFjdFRhcixcclxuICBtYWtlRXhlY3V0YWJsZSxcclxuICB2YWxpZGF0ZUJpbmFyeSxcclxuICBnZXRCaW5hcnlWZXJzaW9uLFxyXG4gIGNsZWFudXBUZW1wRmlsZXMsXHJcbiAgcmV0cnlXaXRoQmFja29mZixcclxuICBjaGVja1VybEFjY2Vzc2liaWxpdHksXHJcbn0gZnJvbSAnLi4vdXRpbHMvZGVwZW5kZW5jeS11dGlscyc7XHJcblxyXG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeU1hbmFnZXJTZXJ2aWNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgSURlcGVuZGVuY3lNYW5hZ2VyU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gIHByaXZhdGUgZGVwZW5kZW5jeVN0YXR1czogRGVwZW5kZW5jeVN0YXR1cyB8IG51bGwgPSBudWxsO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBkZXBlbmRlbmN5IG1hbmFnZXJcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFpc1BsYXRmb3JtU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRGVwZW5kZW5jeUVycm9yKGBVbnN1cHBvcnRlZCBwbGF0Zm9ybTogJHtvcy5wbGF0Zm9ybSgpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgZGVwZW5kZW5jaWVzIGRpcmVjdG9yeSBleGlzdHNcclxuICAgICAgY29uc3QgZGVwc0RpciA9IGdldERlcGVuZGVuY2llc0RpcmVjdG9yeSgpO1xyXG4gICAgICBhd2FpdCBmcy5lbnN1cmVEaXIoZGVwc0Rpcik7XHJcblxyXG4gICAgICAvLyBDaGVjayBpbml0aWFsIGRlcGVuZGVuY3kgc3RhdHVzXHJcbiAgICAgIGF3YWl0IHRoaXMuY2hlY2tEZXBlbmRlbmNpZXMoKTtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XHJcbiAgICAgIHRocm93IG5ldyBEZXBlbmRlbmN5RXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIGRlcGVuZGVuY3kgbWFuYWdlcjogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgdGhlIHN0YXR1cyBvZiBhbGwgcmVxdWlyZWQgZGVwZW5kZW5jaWVzXHJcbiAgICovXHJcbiAgYXN5bmMgY2hlY2tEZXBlbmRlbmNpZXMoKTogUHJvbWlzZTxEZXBlbmRlbmN5U3RhdHVzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBbeXRkbHBTdGF0dXMsIGZmbXBlZ1N0YXR1c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgdGhpcy5jaGVja1NpbmdsZURlcGVuZGVuY3koJ3l0ZGxwJyksXHJcbiAgICAgICAgdGhpcy5jaGVja1NpbmdsZURlcGVuZGVuY3koJ2ZmbXBlZycpLFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVN0YXR1cyA9IHtcclxuICAgICAgICB5dGRscDogeXRkbHBTdGF0dXMsXHJcbiAgICAgICAgZmZtcGVnOiBmZm1wZWdTdGF0dXMsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmVtaXQoJ3N0YXR1c1VwZGF0ZWQnLCB0aGlzLmRlcGVuZGVuY3lTdGF0dXMpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5U3RhdHVzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xyXG4gICAgICB0aHJvdyBuZXcgRGVwZW5kZW5jeUVycm9yKGBGYWlsZWQgdG8gY2hlY2sgZGVwZW5kZW5jaWVzOiAke21lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB0aGUgc3RhdHVzIG9mIGEgc2luZ2xlIGRlcGVuZGVuY3lcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrU2luZ2xlRGVwZW5kZW5jeShuYW1lOiAneXRkbHAnIHwgJ2ZmbXBlZycpOiBQcm9taXNlPERlcGVuZGVuY3lJbmZvPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBleGVjdXRhYmxlUGF0aCA9IGdldERlcGVuZGVuY3lFeGVjdXRhYmxlUGF0aChuYW1lKTtcclxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHZhbGlkYXRlQmluYXJ5KGV4ZWN1dGFibGVQYXRoKTtcclxuXHJcbiAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgcGF0aDogZXhlY3V0YWJsZVBhdGgsXHJcbiAgICAgICAgICBpbnN0YWxsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcjogJ0JpbmFyeSBub3QgZm91bmQgb3Igbm90IGV4ZWN1dGFibGUnLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBnZXRCaW5hcnlWZXJzaW9uKGV4ZWN1dGFibGVQYXRoKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwYXRoOiBleGVjdXRhYmxlUGF0aCxcclxuICAgICAgICBpbnN0YWxsZWQ6IHRydWUsXHJcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uIHx8ICdVbmtub3duJyxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHBhdGg6IGdldERlcGVuZGVuY3lFeGVjdXRhYmxlUGF0aChuYW1lKSxcclxuICAgICAgICBpbnN0YWxsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBtZXNzYWdlLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFsbCBhIHNwZWNpZmljIGRlcGVuZGVuY3lcclxuICAgKi9cclxuICBhc3luYyBpbnN0YWxsRGVwZW5kZW5jeShuYW1lOiAneXRkbHAnIHwgJ2ZmbXBlZycpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZW1pdCgnaW5zdGFsbFN0YXJ0ZWQnLCBuYW1lKTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGdldERlcGVuZGVuY3lDb25maWcoKTtcclxuICAgICAgY29uc3QgZGVwZW5kZW5jeUNvbmZpZyA9IG5hbWUgPT09ICd5dGRscCcgPyBjb25maWcueXRkbHAgOiBjb25maWcuZmZtcGVnO1xyXG4gICAgICBjb25zdCBkZXBlbmRlbmN5RGlyID0gZ2V0RGVwZW5kZW5jeURpcmVjdG9yeShuYW1lKTtcclxuICAgICAgY29uc3QgdGVtcERpciA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgYHBsYXlsaXN0aWZ5LSR7bmFtZX0tJHtEYXRlLm5vdygpfWApO1xyXG5cclxuICAgICAgLy8gQ2xlYW4gdXAgYW55IGV4aXN0aW5nIGluc3RhbGxhdGlvblxyXG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhkZXBlbmRlbmN5RGlyKSkge1xyXG4gICAgICAgIGF3YWl0IGZzLnJlbW92ZShkZXBlbmRlbmN5RGlyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yaWVzXHJcbiAgICAgIGF3YWl0IGZzLmVuc3VyZURpcihkZXBlbmRlbmN5RGlyKTtcclxuICAgICAgYXdhaXQgZnMuZW5zdXJlRGlyKHRlbXBEaXIpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDaGVjayBpZiBkb3dubG9hZCBVUkwgaXMgYWNjZXNzaWJsZVxyXG4gICAgICAgIGNvbnN0IGlzQWNjZXNzaWJsZSA9IGF3YWl0IGNoZWNrVXJsQWNjZXNzaWJpbGl0eShkZXBlbmRlbmN5Q29uZmlnLmRvd25sb2FkVXJsKTtcclxuICAgICAgICBpZiAoIWlzQWNjZXNzaWJsZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IERlcGVuZGVuY3lEb3dubG9hZEVycm9yKGBEb3dubG9hZCBVUkwgaXMgbm90IGFjY2Vzc2libGU6ICR7ZGVwZW5kZW5jeUNvbmZpZy5kb3dubG9hZFVybH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvd25sb2FkIHRoZSBkZXBlbmRlbmN5XHJcbiAgICAgICAgY29uc3QgZG93bmxvYWRQYXRoID0gcGF0aC5qb2luKHRlbXBEaXIsIGRlcGVuZGVuY3lDb25maWcuZmlsZW5hbWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgYXdhaXQgZG93bmxvYWRGaWxlKFxyXG4gICAgICAgICAgICBkZXBlbmRlbmN5Q29uZmlnLmRvd25sb2FkVXJsLFxyXG4gICAgICAgICAgICBkb3dubG9hZFBhdGgsXHJcbiAgICAgICAgICAgIChwcm9ncmVzcykgPT4ge1xyXG4gICAgICAgICAgICAgIHByb2dyZXNzLmRlcGVuZGVuY3kgPSBuYW1lO1xyXG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnZG93bmxvYWRQcm9ncmVzcycsIHByb2dyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KCdkb3dubG9hZFByb2dyZXNzJywge1xyXG4gICAgICAgICAgZGVwZW5kZW5jeTogbmFtZSxcclxuICAgICAgICAgIHByb2dyZXNzOiAxMDAsXHJcbiAgICAgICAgICBzdGF0dXM6ICdleHRyYWN0aW5nJyxcclxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHRyYWN0aW5nIGZpbGVzLi4uJyxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBhbmQgaW5zdGFsbFxyXG4gICAgICAgIGF3YWl0IHRoaXMuZXh0cmFjdEFuZEluc3RhbGwobmFtZSwgZG93bmxvYWRQYXRoLCBkZXBlbmRlbmN5RGlyKTtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgaW5zdGFsbGF0aW9uXHJcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVEZXBlbmRlbmN5KG5hbWUpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IERlcGVuZGVuY3lWYWxpZGF0aW9uRXJyb3IoYEluc3RhbGxhdGlvbiB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1c1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tEZXBlbmRlbmNpZXMoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KCdpbnN0YWxsQ29tcGxldGVkJywgbmFtZSk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgdGVtcCBmaWxlc1xyXG4gICAgICAgIGF3YWl0IGNsZWFudXBUZW1wRmlsZXModGVtcERpcik7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZW1pdCgnaW5zdGFsbEZhaWxlZCcsIG5hbWUsIGVycm9yKTtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xyXG4gICAgICB0aHJvdyBuZXcgRGVwZW5kZW5jeUluc3RhbGxhdGlvbkVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCAke25hbWV9OiAke21lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IGFuZCBpbnN0YWxsIGEgZGVwZW5kZW5jeVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZXh0cmFjdEFuZEluc3RhbGwoXHJcbiAgICBuYW1lOiAneXRkbHAnIHwgJ2ZmbXBlZycsXHJcbiAgICBkb3dubG9hZFBhdGg6IHN0cmluZyxcclxuICAgIGluc3RhbGxEaXI6IHN0cmluZ1xyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgYmluRGlyID0gcGF0aC5qb2luKGluc3RhbGxEaXIsICdiaW4nKTtcclxuICAgIGF3YWl0IGZzLmVuc3VyZURpcihiaW5EaXIpO1xyXG5cclxuICAgIGlmIChuYW1lID09PSAneXRkbHAnKSB7XHJcbiAgICAgIC8vIHl0LWRscCBpcyB1c3VhbGx5IGEgc2luZ2xlIGV4ZWN1dGFibGVcclxuICAgICAgaWYgKGRvd25sb2FkUGF0aC5lbmRzV2l0aCgnLmV4ZScpIHx8ICFkb3dubG9hZFBhdGguaW5jbHVkZXMoJy4nKSkge1xyXG4gICAgICAgIC8vIERpcmVjdCBleGVjdXRhYmxlXHJcbiAgICAgICAgY29uc3QgY29uZmlnID0gZ2V0RGVwZW5kZW5jeUNvbmZpZygpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBwYXRoLmpvaW4oYmluRGlyLCBjb25maWcueXRkbHAuZXhlY3V0YWJsZSk7XHJcbiAgICAgICAgYXdhaXQgZnMuY29weShkb3dubG9hZFBhdGgsIHRhcmdldFBhdGgpO1xyXG4gICAgICAgIGF3YWl0IG1ha2VFeGVjdXRhYmxlKHRhcmdldFBhdGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBEZXBlbmRlbmN5SW5zdGFsbGF0aW9uRXJyb3IoJ1VuZXhwZWN0ZWQgeXQtZGxwIHBhY2thZ2UgZm9ybWF0Jyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2ZmbXBlZycpIHtcclxuICAgICAgLy8gRkZtcGVnIGNvbWVzIGluIHZhcmlvdXMgYXJjaGl2ZSBmb3JtYXRzXHJcbiAgICAgIGNvbnN0IHRlbXBFeHRyYWN0RGlyID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShkb3dubG9hZFBhdGgpLCAnZXh0cmFjdCcpO1xyXG4gICAgICBhd2FpdCBmcy5lbnN1cmVEaXIodGVtcEV4dHJhY3REaXIpO1xyXG5cclxuICAgICAgaWYgKGRvd25sb2FkUGF0aC5lbmRzV2l0aCgnLnppcCcpKSB7XHJcbiAgICAgICAgYXdhaXQgZXh0cmFjdFppcChkb3dubG9hZFBhdGgsIHRlbXBFeHRyYWN0RGlyKTtcclxuICAgICAgfSBlbHNlIGlmIChkb3dubG9hZFBhdGguZW5kc1dpdGgoJy50YXIueHonKSB8fCBkb3dubG9hZFBhdGguZW5kc1dpdGgoJy50YXIuZ3onKSkge1xyXG4gICAgICAgIGF3YWl0IGV4dHJhY3RUYXIoZG93bmxvYWRQYXRoLCB0ZW1wRXh0cmFjdERpcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvcignVW5zdXBwb3J0ZWQgRkZtcGVnIGFyY2hpdmUgZm9ybWF0Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZpbmQgYW5kIGNvcHkgdGhlIGZmbXBlZyBleGVjdXRhYmxlXHJcbiAgICAgIGNvbnN0IGZmbXBlZ0V4ZWN1dGFibGUgPSBhd2FpdCB0aGlzLmZpbmRFeGVjdXRhYmxlSW5EaXJlY3RvcnkodGVtcEV4dHJhY3REaXIsICdmZm1wZWcnKTtcclxuICAgICAgaWYgKCFmZm1wZWdFeGVjdXRhYmxlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvcignRkZtcGVnIGV4ZWN1dGFibGUgbm90IGZvdW5kIGluIGFyY2hpdmUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY29uZmlnID0gZ2V0RGVwZW5kZW5jeUNvbmZpZygpO1xyXG4gICAgICBjb25zdCB0YXJnZXRQYXRoID0gcGF0aC5qb2luKGJpbkRpciwgY29uZmlnLmZmbXBlZy5leGVjdXRhYmxlKTtcclxuICAgICAgYXdhaXQgZnMuY29weShmZm1wZWdFeGVjdXRhYmxlLCB0YXJnZXRQYXRoKTtcclxuICAgICAgYXdhaXQgbWFrZUV4ZWN1dGFibGUodGFyZ2V0UGF0aCk7XHJcblxyXG4gICAgICAvLyBDbGVhbiB1cCB0ZW1wIGV4dHJhY3Rpb25cclxuICAgICAgYXdhaXQgY2xlYW51cFRlbXBGaWxlcyh0ZW1wRXh0cmFjdERpcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIGFuIGV4ZWN1dGFibGUgaW4gYSBkaXJlY3RvcnkgKHJlY3Vyc2l2ZWx5KVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZmluZEV4ZWN1dGFibGVJbkRpcmVjdG9yeShkaXI6IHN0cmluZywgZXhlY3V0YWJsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBmcy5yZWFkZGlyKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XHJcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyLCBpdGVtLm5hbWUpO1xyXG5cclxuICAgICAgICBpZiAoaXRlbS5pc0ZpbGUoKSkge1xyXG4gICAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGl0ZW0ubmFtZSwgcGF0aC5leHRuYW1lKGl0ZW0ubmFtZSkpO1xyXG4gICAgICAgICAgaWYgKGJhc2VOYW1lID09PSBleGVjdXRhYmxlTmFtZSB8fCBpdGVtLm5hbWUgPT09IGV4ZWN1dGFibGVOYW1lIHx8IFxyXG4gICAgICAgICAgICAgIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGl0ZW0ubmFtZSA9PT0gYCR7ZXhlY3V0YWJsZU5hbWV9LmV4ZWApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdWxsUGF0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRFeGVjdXRhYmxlSW5EaXJlY3RvcnkoZnVsbFBhdGgsIGV4ZWN1dGFibGVOYW1lKTtcclxuICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGF0aCB0byBhIGRlcGVuZGVuY3kgYmluYXJ5XHJcbiAgICovXHJcbiAgZ2V0RGVwZW5kZW5jeVBhdGgobmFtZTogJ3l0ZGxwJyB8ICdmZm1wZWcnKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBnZXREZXBlbmRlbmN5RXhlY3V0YWJsZVBhdGgobmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSB0aGF0IGEgZGVwZW5kZW5jeSBpcyBwcm9wZXJseSBpbnN0YWxsZWQgYW5kIGZ1bmN0aW9uYWxcclxuICAgKi9cclxuICBhc3luYyB2YWxpZGF0ZURlcGVuZGVuY3kobmFtZTogJ3l0ZGxwJyB8ICdmZm1wZWcnKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBleGVjdXRhYmxlUGF0aCA9IGdldERlcGVuZGVuY3lFeGVjdXRhYmxlUGF0aChuYW1lKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIGJpbmFyeSBleGlzdHMgYW5kIGlzIGV4ZWN1dGFibGVcclxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHZhbGlkYXRlQmluYXJ5KGV4ZWN1dGFibGVQYXRoKTtcclxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUcnkgdG8gZ2V0IHZlcnNpb24gdG8gZW5zdXJlIGl0J3Mgd29ya2luZ1xyXG4gICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0QmluYXJ5VmVyc2lvbihleGVjdXRhYmxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB2ZXJzaW9uICE9PSBudWxsO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB2ZXJzaW9uIGluZm9ybWF0aW9uIGZvciBhIGRlcGVuZGVuY3lcclxuICAgKi9cclxuICBhc3luYyBnZXREZXBlbmRlbmN5VmVyc2lvbihuYW1lOiAneXRkbHAnIHwgJ2ZmbXBlZycpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGV4ZWN1dGFibGVQYXRoID0gZ2V0RGVwZW5kZW5jeUV4ZWN1dGFibGVQYXRoKG5hbWUpO1xyXG4gICAgICByZXR1cm4gYXdhaXQgZ2V0QmluYXJ5VmVyc2lvbihleGVjdXRhYmxlUGF0aCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBhbGwgbWFuYWdlZCBkZXBlbmRlbmNpZXNcclxuICAgKi9cclxuICBhc3luYyBjbGVhbnVwRGVwZW5kZW5jaWVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGVwc0RpciA9IGdldERlcGVuZGVuY2llc0RpcmVjdG9yeSgpO1xyXG4gICAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhkZXBzRGlyKSkge1xyXG4gICAgICAgIGF3YWl0IGZzLnJlbW92ZShkZXBzRGlyKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gUmVzZXQgc3RhdHVzXHJcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVN0YXR1cyA9IG51bGw7XHJcbiAgICAgIGF3YWl0IHRoaXMuY2hlY2tEZXBlbmRlbmNpZXMoKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuZW1pdCgnZGVwZW5kZW5jaWVzQ2xlYW5lZFVwJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XHJcbiAgICAgIHRocm93IG5ldyBEZXBlbmRlbmN5RXJyb3IoYEZhaWxlZCB0byBjbGVhbnVwIGRlcGVuZGVuY2llczogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgZGVwZW5kZW5jeSBzdGF0dXMgKGNhY2hlZClcclxuICAgKi9cclxuICBnZXREZXBlbmRlbmN5U3RhdHVzKCk6IERlcGVuZGVuY3lTdGF0dXMgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lTdGF0dXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZGVwZW5kZW5jeSBtYW5hZ2VyIGlzIGluaXRpYWxpemVkXHJcbiAgICovXHJcbiAgaXNJbml0aWFsaXplZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYWxsIGRlcGVuZGVuY2llcyBhcmUgaW5zdGFsbGVkIGFuZCB2YWxpZFxyXG4gICAqL1xyXG4gIGFyZUFsbERlcGVuZGVuY2llc1JlYWR5KCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKCF0aGlzLmRlcGVuZGVuY3lTdGF0dXMpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmRlcGVuZGVuY3lTdGF0dXMueXRkbHAuaW5zdGFsbGVkICYmIFxyXG4gICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVN0YXR1cy55dGRscC5pc1ZhbGlkICYmXHJcbiAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5U3RhdHVzLmZmbXBlZy5pbnN0YWxsZWQgJiYgXHJcbiAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5U3RhdHVzLmZmbXBlZy5pc1ZhbGlkO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/services/dependency-manager-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/development-service.ts":
/*!*****************************************************!*\
  !*** ./src/backend/services/development-service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DevelopmentService = void 0;\nexports.createDevelopmentService = createDevelopmentService;\nexports.getDevelopmentService = getDevelopmentService;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst logger_service_1 = __webpack_require__(/*! ./logger-service */ \"./src/backend/services/logger-service.ts\");\nconst fs = tslib_1.__importStar(__webpack_require__(/*! fs-extra */ \"fs-extra\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nclass DevelopmentService {\n    constructor(config) {\n        this.logger = (0, logger_service_1.getLogger)();\n        this.performanceMetrics = [];\n        this.startTime = Date.now();\n        this.config = {\n            enabled: process.env.NODE_ENV === 'development',\n            hotReload: process.env.NODE_ENV === 'development',\n            devTools: process.env.NODE_ENV === 'development',\n            debugLogging: process.env.NODE_ENV === 'development',\n            performanceMonitoring: process.env.NODE_ENV === 'development',\n            memoryTracking: process.env.NODE_ENV === 'development',\n            ...config\n        };\n        if (this.config.enabled) {\n            this.initialize();\n        }\n    }\n    initialize() {\n        this.logger.debug('Development service initialized', 'DevelopmentService', {\n            config: this.config\n        });\n        // Start performance monitoring\n        if (this.config.performanceMonitoring) {\n            this.startPerformanceMonitoring();\n        }\n        // Start memory tracking\n        if (this.config.memoryTracking) {\n            this.startMemoryTracking();\n        }\n        // Set up development event listeners\n        this.setupDevelopmentEventListeners();\n    }\n    startPerformanceMonitoring() {\n        const startupTime = Date.now() - this.startTime;\n        const metrics = {\n            startupTime,\n            memoryUsage: process.memoryUsage(),\n            cpuUsage: process.cpuUsage(),\n            timestamp: new Date().toISOString()\n        };\n        this.performanceMetrics.push(metrics);\n        this.logger.debug('Performance metrics collected', 'DevelopmentService', {\n            startupTime: `${startupTime}ms`,\n            memoryUsage: this.formatMemoryUsage(metrics.memoryUsage)\n        });\n    }\n    startMemoryTracking() {\n        // Track memory usage every 30 seconds in development\n        this.memoryTrackingInterval = setInterval(() => {\n            const memoryUsage = process.memoryUsage();\n            this.logger.debug('Memory usage', 'DevelopmentService', {\n                memory: this.formatMemoryUsage(memoryUsage)\n            });\n            // Warn if memory usage is high\n            const heapUsedMB = memoryUsage.heapUsed / 1024 / 1024;\n            if (heapUsedMB > 100) {\n                this.logger.warn('High memory usage detected', 'DevelopmentService', {\n                    heapUsedMB: Math.round(heapUsedMB),\n                    threshold: 100\n                });\n            }\n        }, 30000);\n    }\n    formatMemoryUsage(memoryUsage) {\n        return {\n            rss: `${Math.round(memoryUsage.rss / 1024 / 1024)}MB`,\n            heapTotal: `${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`,\n            heapUsed: `${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`,\n            external: `${Math.round(memoryUsage.external / 1024 / 1024)}MB`\n        };\n    }\n    setupDevelopmentEventListeners() {\n        // Listen for app events and log them for debugging\n        electron_1.app.on('browser-window-created', (event, window) => {\n            this.logger.debug('Browser window created', 'DevelopmentService', {\n                windowId: window.id,\n                title: window.getTitle()\n            });\n            // Set up window-specific development features\n            if (this.config.devTools) {\n                window.webContents.on('did-finish-load', () => {\n                    this.logger.debug('Window finished loading', 'DevelopmentService', {\n                        windowId: window.id,\n                        url: window.webContents.getURL()\n                    });\n                });\n                window.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {\n                    this.logger.error('Window failed to load', 'DevelopmentService', {\n                        windowId: window.id,\n                        errorCode,\n                        errorDescription,\n                        url: validatedURL\n                    });\n                });\n            }\n        });\n        electron_1.app.on('browser-window-focus', (event, window) => {\n            this.logger.debug('Window focused', 'DevelopmentService', {\n                windowId: window.id\n            });\n        });\n        electron_1.app.on('browser-window-blur', (event, window) => {\n            this.logger.debug('Window blurred', 'DevelopmentService', {\n                windowId: window.id\n            });\n        });\n    }\n    getPerformanceMetrics() {\n        return [...this.performanceMetrics];\n    }\n    getCurrentMemoryUsage() {\n        return process.memoryUsage();\n    }\n    getFormattedMemoryUsage() {\n        return this.formatMemoryUsage(this.getCurrentMemoryUsage());\n    }\n    logSystemInfo() {\n        if (!this.config.enabled)\n            return;\n        const systemInfo = {\n            platform: process.platform,\n            arch: process.arch,\n            nodeVersion: process.version,\n            electronVersion: process.versions.electron,\n            chromeVersion: process.versions.chrome,\n            v8Version: process.versions.v8,\n            appVersion: electron_1.app.getVersion(),\n            appName: electron_1.app.getName(),\n            userDataPath: electron_1.app.getPath('userData'),\n            tempPath: electron_1.app.getPath('temp'),\n            homePath: electron_1.app.getPath('home')\n        };\n        this.logger.info('System information', 'DevelopmentService', systemInfo);\n    }\n    async exportDevelopmentData() {\n        if (!this.config.enabled) {\n            throw new Error('Development service is not enabled');\n        }\n        const developmentData = {\n            config: this.config,\n            performanceMetrics: this.performanceMetrics,\n            currentMemoryUsage: this.getCurrentMemoryUsage(),\n            systemInfo: {\n                platform: process.platform,\n                arch: process.arch,\n                nodeVersion: process.version,\n                electronVersion: process.versions.electron,\n                chromeVersion: process.versions.chrome,\n                v8Version: process.versions.v8,\n                appVersion: electron_1.app.getVersion()\n            },\n            timestamp: new Date().toISOString()\n        };\n        try {\n            const userDataPath = electron_1.app.getPath('userData');\n            const exportPath = path.join(userDataPath, 'development-data.json');\n            await fs.writeJson(exportPath, developmentData, { spaces: 2 });\n            this.logger.info('Development data exported', 'DevelopmentService', {\n                exportPath\n            });\n            return exportPath;\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            this.logger.error('Failed to export development data', 'DevelopmentService', {\n                error: errorMessage\n            });\n            throw error;\n        }\n    }\n    enableDevTools(window) {\n        if (!this.config.enabled)\n            return;\n        const targetWindow = window || electron_1.BrowserWindow.getFocusedWindow();\n        if (targetWindow && !targetWindow.isDestroyed()) {\n            targetWindow.webContents.openDevTools();\n            this.logger.debug('DevTools opened', 'DevelopmentService', {\n                windowId: targetWindow.id\n            });\n        }\n    }\n    disableDevTools(window) {\n        if (!this.config.enabled)\n            return;\n        const targetWindow = window || electron_1.BrowserWindow.getFocusedWindow();\n        if (targetWindow && !targetWindow.isDestroyed()) {\n            targetWindow.webContents.closeDevTools();\n            this.logger.debug('DevTools closed', 'DevelopmentService', {\n                windowId: targetWindow.id\n            });\n        }\n    }\n    toggleDevTools(window) {\n        if (!this.config.enabled)\n            return;\n        const targetWindow = window || electron_1.BrowserWindow.getFocusedWindow();\n        if (targetWindow && !targetWindow.isDestroyed()) {\n            targetWindow.webContents.toggleDevTools();\n            this.logger.debug('DevTools toggled', 'DevelopmentService', {\n                windowId: targetWindow.id\n            });\n        }\n    }\n    forceGarbageCollection() {\n        if (!this.config.enabled)\n            return;\n        if (global.gc) {\n            const beforeMemory = process.memoryUsage();\n            global.gc();\n            const afterMemory = process.memoryUsage();\n            this.logger.debug('Garbage collection forced', 'DevelopmentService', {\n                before: this.formatMemoryUsage(beforeMemory),\n                after: this.formatMemoryUsage(afterMemory),\n                freed: `${Math.round((beforeMemory.heapUsed - afterMemory.heapUsed) / 1024 / 1024)}MB`\n            });\n        }\n        else {\n            this.logger.warn('Garbage collection not available', 'DevelopmentService', {\n                hint: 'Start with --expose-gc flag to enable manual garbage collection'\n            });\n        }\n    }\n    getConfig() {\n        return { ...this.config };\n    }\n    updateConfig(updates) {\n        this.config = { ...this.config, ...updates };\n        this.logger.debug('Development config updated', 'DevelopmentService', {\n            updates,\n            newConfig: this.config\n        });\n        // Restart services if needed\n        if (updates.memoryTracking !== undefined) {\n            if (this.memoryTrackingInterval) {\n                clearInterval(this.memoryTrackingInterval);\n                this.memoryTrackingInterval = undefined;\n            }\n            if (updates.memoryTracking && this.config.enabled) {\n                this.startMemoryTracking();\n            }\n        }\n    }\n    shutdown() {\n        this.logger.debug('Development service shutting down', 'DevelopmentService');\n        // Clear intervals\n        if (this.memoryTrackingInterval) {\n            clearInterval(this.memoryTrackingInterval);\n            this.memoryTrackingInterval = undefined;\n        }\n        // Log final performance metrics\n        if (this.config.performanceMonitoring) {\n            const totalRuntime = Date.now() - this.startTime;\n            const finalMemory = process.memoryUsage();\n            this.logger.info('Final development metrics', 'DevelopmentService', {\n                totalRuntime: `${totalRuntime}ms`,\n                finalMemory: this.formatMemoryUsage(finalMemory),\n                totalMetricsCollected: this.performanceMetrics.length\n            });\n        }\n    }\n}\nexports.DevelopmentService = DevelopmentService;\n// Create singleton instance\nlet developmentServiceInstance = null;\nfunction createDevelopmentService(config) {\n    if (!developmentServiceInstance) {\n        developmentServiceInstance = new DevelopmentService(config);\n    }\n    return developmentServiceInstance;\n}\nfunction getDevelopmentService() {\n    return developmentServiceInstance;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9kZXZlbG9wbWVudC1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQWdWQSw0REFLQztBQUVELHNEQUVDOztBQXpWRCxtRUFBOEM7QUFDOUMsaUhBQTZDO0FBQzdDLGlGQUErQjtBQUMvQiwyRUFBNkI7QUFrQjdCLE1BQU0sa0JBQWtCO0lBT3RCLFlBQVksTUFBbUM7UUFMdkMsV0FBTSxHQUFHLDhCQUFTLEdBQUUsQ0FBQztRQUVyQix1QkFBa0IsR0FBeUIsRUFBRSxDQUFDO1FBSXBELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTVCLElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixPQUFPLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssYUFBYTtZQUMvQyxTQUFTLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssYUFBYTtZQUNqRCxRQUFRLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssYUFBYTtZQUNoRCxZQUFZLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEtBQUssYUFBYTtZQUNwRCxxQkFBcUIsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxhQUFhO1lBQzdELGNBQWMsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxhQUFhO1lBQ3RELEdBQUcsTUFBTTtTQUNWLENBQUM7UUFFRixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3BCLENBQUM7SUFDSCxDQUFDO0lBRU8sVUFBVTtRQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxvQkFBb0IsRUFBRTtZQUN6RSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDcEIsQ0FBQyxDQUFDO1FBRUgsK0JBQStCO1FBQy9CLElB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LENBQUM7QUFDcEMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vc3JjL2JhY2tlbmQvc2VydmljZXMvZGV2ZWxvcG1lbnQtc2VydmljZS50cz8wMjFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdyB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXItc2VydmljZSc7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGV2ZWxvcG1lbnRDb25maWcge1xyXG4gIGVuYWJsZWQ6IGJvb2xlYW47XHJcbiAgaG90UmVsb2FkOiBib29sZWFuO1xyXG4gIGRldlRvb2xzOiBib29sZWFuO1xyXG4gIGRlYnVnTG9nZ2luZzogYm9vbGVhbjtcclxuICBwZXJmb3JtYW5jZU1vbml0b3Jpbmc6IGJvb2xlYW47XHJcbiAgbWVtb3J5VHJhY2tpbmc6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGVyZm9ybWFuY2VNZXRyaWNzIHtcclxuICBzdGFydHVwVGltZTogbnVtYmVyO1xyXG4gIG1lbW9yeVVzYWdlOiBOb2RlSlMuTWVtb3J5VXNhZ2U7XHJcbiAgY3B1VXNhZ2U6IE5vZGVKUy5DcHVVc2FnZTtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxufVxyXG5cclxuY2xhc3MgRGV2ZWxvcG1lbnRTZXJ2aWNlIHtcclxuICBwcml2YXRlIGNvbmZpZzogRGV2ZWxvcG1lbnRDb25maWc7XHJcbiAgcHJpdmF0ZSBsb2dnZXIgPSBnZXRMb2dnZXIoKTtcclxuICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xyXG4gIHByaXZhdGUgcGVyZm9ybWFuY2VNZXRyaWNzOiBQZXJmb3JtYW5jZU1ldHJpY3NbXSA9IFtdO1xyXG4gIHByaXZhdGUgbWVtb3J5VHJhY2tpbmdJbnRlcnZhbD86IE5vZGVKUy5UaW1lb3V0O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBQYXJ0aWFsPERldmVsb3BtZW50Q29uZmlnPikge1xyXG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgZW5hYmxlZDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXHJcbiAgICAgIGhvdFJlbG9hZDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXHJcbiAgICAgIGRldlRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICAgICAgZGVidWdMb2dnaW5nOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICAgICAgcGVyZm9ybWFuY2VNb25pdG9yaW5nOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICAgICAgbWVtb3J5VHJhY2tpbmc6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxyXG4gICAgICAuLi5jb25maWdcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRpYWxpemUoKTogdm9pZCB7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnRGV2ZWxvcG1lbnQgc2VydmljZSBpbml0aWFsaXplZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWdcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN0YXJ0IHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcclxuICAgIGlmICh0aGlzLmNvbmZpZy5wZXJmb3JtYW5jZU1vbml0b3JpbmcpIHtcclxuICAgICAgdGhpcy5zdGFydFBlcmZvcm1hbmNlTW9uaXRvcmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXJ0IG1lbW9yeSB0cmFja2luZ1xyXG4gICAgaWYgKHRoaXMuY29uZmlnLm1lbW9yeVRyYWNraW5nKSB7XHJcbiAgICAgIHRoaXMuc3RhcnRNZW1vcnlUcmFja2luZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB1cCBkZXZlbG9wbWVudCBldmVudCBsaXN0ZW5lcnNcclxuICAgIHRoaXMuc2V0dXBEZXZlbG9wbWVudEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3RhcnR1cFRpbWUgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XHJcbiAgICBcclxuICAgIGNvbnN0IG1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljcyA9IHtcclxuICAgICAgc3RhcnR1cFRpbWUsXHJcbiAgICAgIG1lbW9yeVVzYWdlOiBwcm9jZXNzLm1lbW9yeVVzYWdlKCksXHJcbiAgICAgIGNwdVVzYWdlOiBwcm9jZXNzLmNwdVVzYWdlKCksXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLnB1c2gobWV0cmljcyk7XHJcbiAgICBcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQZXJmb3JtYW5jZSBtZXRyaWNzIGNvbGxlY3RlZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgIHN0YXJ0dXBUaW1lOiBgJHtzdGFydHVwVGltZX1tc2AsXHJcbiAgICAgIG1lbW9yeVVzYWdlOiB0aGlzLmZvcm1hdE1lbW9yeVVzYWdlKG1ldHJpY3MubWVtb3J5VXNhZ2UpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnRNZW1vcnlUcmFja2luZygpOiB2b2lkIHtcclxuICAgIC8vIFRyYWNrIG1lbW9yeSB1c2FnZSBldmVyeSAzMCBzZWNvbmRzIGluIGRldmVsb3BtZW50XHJcbiAgICB0aGlzLm1lbW9yeVRyYWNraW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ01lbW9yeSB1c2FnZScsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgbWVtb3J5OiB0aGlzLmZvcm1hdE1lbW9yeVVzYWdlKG1lbW9yeVVzYWdlKVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFdhcm4gaWYgbWVtb3J5IHVzYWdlIGlzIGhpZ2hcclxuICAgICAgY29uc3QgaGVhcFVzZWRNQiA9IG1lbW9yeVVzYWdlLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQ7XHJcbiAgICAgIGlmIChoZWFwVXNlZE1CID4gMTAwKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignSGlnaCBtZW1vcnkgdXNhZ2UgZGV0ZWN0ZWQnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgICAgaGVhcFVzZWRNQjogTWF0aC5yb3VuZChoZWFwVXNlZE1CKSxcclxuICAgICAgICAgIHRocmVzaG9sZDogMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sIDMwMDAwKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZm9ybWF0TWVtb3J5VXNhZ2UobWVtb3J5VXNhZ2U6IE5vZGVKUy5NZW1vcnlVc2FnZSk6IGFueSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByc3M6IGAke01hdGgucm91bmQobWVtb3J5VXNhZ2UucnNzIC8gMTAyNCAvIDEwMjQpfU1CYCxcclxuICAgICAgaGVhcFRvdGFsOiBgJHtNYXRoLnJvdW5kKG1lbW9yeVVzYWdlLmhlYXBUb3RhbCAvIDEwMjQgLyAxMDI0KX1NQmAsXHJcbiAgICAgIGhlYXBVc2VkOiBgJHtNYXRoLnJvdW5kKG1lbW9yeVVzYWdlLmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpfU1CYCxcclxuICAgICAgZXh0ZXJuYWw6IGAke01hdGgucm91bmQobWVtb3J5VXNhZ2UuZXh0ZXJuYWwgLyAxMDI0IC8gMTAyNCl9TUJgXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXR1cERldmVsb3BtZW50RXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XHJcbiAgICAvLyBMaXN0ZW4gZm9yIGFwcCBldmVudHMgYW5kIGxvZyB0aGVtIGZvciBkZWJ1Z2dpbmdcclxuICAgIGFwcC5vbignYnJvd3Nlci13aW5kb3ctY3JlYXRlZCcsIChldmVudCwgd2luZG93KSA9PiB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdCcm93c2VyIHdpbmRvdyBjcmVhdGVkJywgJ0RldmVsb3BtZW50U2VydmljZScsIHtcclxuICAgICAgICB3aW5kb3dJZDogd2luZG93LmlkLFxyXG4gICAgICAgIHRpdGxlOiB3aW5kb3cuZ2V0VGl0bGUoKVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFNldCB1cCB3aW5kb3ctc3BlY2lmaWMgZGV2ZWxvcG1lbnQgZmVhdHVyZXNcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLmRldlRvb2xzKSB7XHJcbiAgICAgICAgd2luZG93LndlYkNvbnRlbnRzLm9uKCdkaWQtZmluaXNoLWxvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnV2luZG93IGZpbmlzaGVkIGxvYWRpbmcnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgICAgICB3aW5kb3dJZDogd2luZG93LmlkLFxyXG4gICAgICAgICAgICB1cmw6IHdpbmRvdy53ZWJDb250ZW50cy5nZXRVUkwoKVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy53ZWJDb250ZW50cy5vbignZGlkLWZhaWwtbG9hZCcsIChldmVudCwgZXJyb3JDb2RlLCBlcnJvckRlc2NyaXB0aW9uLCB2YWxpZGF0ZWRVUkwpID0+IHtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdXaW5kb3cgZmFpbGVkIHRvIGxvYWQnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgICAgICB3aW5kb3dJZDogd2luZG93LmlkLFxyXG4gICAgICAgICAgICBlcnJvckNvZGUsXHJcbiAgICAgICAgICAgIGVycm9yRGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgIHVybDogdmFsaWRhdGVkVVJMXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgYXBwLm9uKCdicm93c2VyLXdpbmRvdy1mb2N1cycsIChldmVudCwgd2luZG93KSA9PiB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdXaW5kb3cgZm9jdXNlZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgd2luZG93SWQ6IHdpbmRvdy5pZFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFwcC5vbignYnJvd3Nlci13aW5kb3ctYmx1cicsIChldmVudCwgd2luZG93KSA9PiB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdXaW5kb3cgYmx1cnJlZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgd2luZG93SWQ6IHdpbmRvdy5pZFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFBlcmZvcm1hbmNlTWV0cmljcygpOiBQZXJmb3JtYW5jZU1ldHJpY3NbXSB7XHJcbiAgICByZXR1cm4gWy4uLnRoaXMucGVyZm9ybWFuY2VNZXRyaWNzXTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRDdXJyZW50TWVtb3J5VXNhZ2UoKTogTm9kZUpTLk1lbW9yeVVzYWdlIHtcclxuICAgIHJldHVybiBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0Rm9ybWF0dGVkTWVtb3J5VXNhZ2UoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLmZvcm1hdE1lbW9yeVVzYWdlKHRoaXMuZ2V0Q3VycmVudE1lbW9yeVVzYWdlKCkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGxvZ1N5c3RlbUluZm8oKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBzeXN0ZW1JbmZvID0ge1xyXG4gICAgICBwbGF0Zm9ybTogcHJvY2Vzcy5wbGF0Zm9ybSxcclxuICAgICAgYXJjaDogcHJvY2Vzcy5hcmNoLFxyXG4gICAgICBub2RlVmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLFxyXG4gICAgICBlbGVjdHJvblZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24sXHJcbiAgICAgIGNocm9tZVZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMuY2hyb21lLFxyXG4gICAgICB2OFZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMudjgsXHJcbiAgICAgIGFwcFZlcnNpb246IGFwcC5nZXRWZXJzaW9uKCksXHJcbiAgICAgIGFwcE5hbWU6IGFwcC5nZXROYW1lKCksXHJcbiAgICAgIHVzZXJEYXRhUGF0aDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXHJcbiAgICAgIHRlbXBQYXRoOiBhcHAuZ2V0UGF0aCgndGVtcCcpLFxyXG4gICAgICBob21lUGF0aDogYXBwLmdldFBhdGgoJ2hvbWUnKVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdTeXN0ZW0gaW5mb3JtYXRpb24nLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywgc3lzdGVtSW5mbyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZXhwb3J0RGV2ZWxvcG1lbnREYXRhKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXZlbG9wbWVudCBzZXJ2aWNlIGlzIG5vdCBlbmFibGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGV2ZWxvcG1lbnREYXRhID0ge1xyXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxyXG4gICAgICBwZXJmb3JtYW5jZU1ldHJpY3M6IHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLFxyXG4gICAgICBjdXJyZW50TWVtb3J5VXNhZ2U6IHRoaXMuZ2V0Q3VycmVudE1lbW9yeVVzYWdlKCksXHJcbiAgICAgIHN5c3RlbUluZm86IHtcclxuICAgICAgICBwbGF0Zm9ybTogcHJvY2Vzcy5wbGF0Zm9ybSxcclxuICAgICAgICBhcmNoOiBwcm9jZXNzLmFyY2gsXHJcbiAgICAgICAgbm9kZVZlcnNpb246IHByb2Nlc3MudmVyc2lvbixcclxuICAgICAgICBlbGVjdHJvblZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24sXHJcbiAgICAgICAgY2hyb21lVmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9ucy5jaHJvbWUsXHJcbiAgICAgICAgdjhWZXJzaW9uOiBwcm9jZXNzLnZlcnNpb25zLnY4LFxyXG4gICAgICAgIGFwcFZlcnNpb246IGFwcC5nZXRWZXJzaW9uKClcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIH07XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXNlckRhdGFQYXRoID0gYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyk7XHJcbiAgICAgIGNvbnN0IGV4cG9ydFBhdGggPSBwYXRoLmpvaW4odXNlckRhdGFQYXRoLCAnZGV2ZWxvcG1lbnQtZGF0YS5qc29uJyk7XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24oZXhwb3J0UGF0aCwgZGV2ZWxvcG1lbnREYXRhLCB7IHNwYWNlczogMiB9KTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0RldmVsb3BtZW50IGRhdGEgZXhwb3J0ZWQnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgIGV4cG9ydFBhdGhcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gZXhwb3J0UGF0aDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBleHBvcnQgZGV2ZWxvcG1lbnQgZGF0YScsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxyXG4gICAgICB9KTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZW5hYmxlRGV2VG9vbHMod2luZG93PzogQnJvd3NlcldpbmRvdyk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0V2luZG93ID0gd2luZG93IHx8IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgXHJcbiAgICBpZiAodGFyZ2V0V2luZG93ICYmICF0YXJnZXRXaW5kb3cuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICB0YXJnZXRXaW5kb3cud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdEZXZUb29scyBvcGVuZWQnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgIHdpbmRvd0lkOiB0YXJnZXRXaW5kb3cuaWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZGlzYWJsZURldlRvb2xzKHdpbmRvdz86IEJyb3dzZXJXaW5kb3cpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldFdpbmRvdyA9IHdpbmRvdyB8fCBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKTtcclxuICAgIFxyXG4gICAgaWYgKHRhcmdldFdpbmRvdyAmJiAhdGFyZ2V0V2luZG93LmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgdGFyZ2V0V2luZG93LndlYkNvbnRlbnRzLmNsb3NlRGV2VG9vbHMoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0RldlRvb2xzIGNsb3NlZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgd2luZG93SWQ6IHRhcmdldFdpbmRvdy5pZFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyB0b2dnbGVEZXZUb29scyh3aW5kb3c/OiBCcm93c2VyV2luZG93KTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVuYWJsZWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCB0YXJnZXRXaW5kb3cgPSB3aW5kb3cgfHwgQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XHJcbiAgICBcclxuICAgIGlmICh0YXJnZXRXaW5kb3cgJiYgIXRhcmdldFdpbmRvdy5pc0Rlc3Ryb3llZCgpKSB7XHJcbiAgICAgIHRhcmdldFdpbmRvdy53ZWJDb250ZW50cy50b2dnbGVEZXZUb29scygpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnRGV2VG9vbHMgdG9nZ2xlZCcsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgd2luZG93SWQ6IHRhcmdldFdpbmRvdy5pZFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBmb3JjZUdhcmJhZ2VDb2xsZWN0aW9uKCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSByZXR1cm47XHJcblxyXG4gICAgaWYgKGdsb2JhbC5nYykge1xyXG4gICAgICBjb25zdCBiZWZvcmVNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIGdsb2JhbC5nYygpO1xyXG4gICAgICBjb25zdCBhZnRlck1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdHYXJiYWdlIGNvbGxlY3Rpb24gZm9yY2VkJywgJ0RldmVsb3BtZW50U2VydmljZScsIHtcclxuICAgICAgICBiZWZvcmU6IHRoaXMuZm9ybWF0TWVtb3J5VXNhZ2UoYmVmb3JlTWVtb3J5KSxcclxuICAgICAgICBhZnRlcjogdGhpcy5mb3JtYXRNZW1vcnlVc2FnZShhZnRlck1lbW9yeSksXHJcbiAgICAgICAgZnJlZWQ6IGAke01hdGgucm91bmQoKGJlZm9yZU1lbW9yeS5oZWFwVXNlZCAtIGFmdGVyTWVtb3J5LmhlYXBVc2VkKSAvIDEwMjQgLyAxMDI0KX1NQmBcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdHYXJiYWdlIGNvbGxlY3Rpb24gbm90IGF2YWlsYWJsZScsICdEZXZlbG9wbWVudFNlcnZpY2UnLCB7XHJcbiAgICAgICAgaGludDogJ1N0YXJ0IHdpdGggLS1leHBvc2UtZ2MgZmxhZyB0byBlbmFibGUgbWFudWFsIGdhcmJhZ2UgY29sbGVjdGlvbidcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0Q29uZmlnKCk6IERldmVsb3BtZW50Q29uZmlnIHtcclxuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlnIH07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBkYXRlQ29uZmlnKHVwZGF0ZXM6IFBhcnRpYWw8RGV2ZWxvcG1lbnRDb25maWc+KTogdm9pZCB7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLnVwZGF0ZXMgfTtcclxuICAgIFxyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoJ0RldmVsb3BtZW50IGNvbmZpZyB1cGRhdGVkJywgJ0RldmVsb3BtZW50U2VydmljZScsIHtcclxuICAgICAgdXBkYXRlcyxcclxuICAgICAgbmV3Q29uZmlnOiB0aGlzLmNvbmZpZ1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVzdGFydCBzZXJ2aWNlcyBpZiBuZWVkZWRcclxuICAgIGlmICh1cGRhdGVzLm1lbW9yeVRyYWNraW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKHRoaXMubWVtb3J5VHJhY2tpbmdJbnRlcnZhbCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tZW1vcnlUcmFja2luZ0ludGVydmFsKTtcclxuICAgICAgICB0aGlzLm1lbW9yeVRyYWNraW5nSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh1cGRhdGVzLm1lbW9yeVRyYWNraW5nICYmIHRoaXMuY29uZmlnLmVuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0TWVtb3J5VHJhY2tpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHNodXRkb3duKCk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoJ0RldmVsb3BtZW50IHNlcnZpY2Ugc2h1dHRpbmcgZG93bicsICdEZXZlbG9wbWVudFNlcnZpY2UnKTtcclxuXHJcbiAgICAvLyBDbGVhciBpbnRlcnZhbHNcclxuICAgIGlmICh0aGlzLm1lbW9yeVRyYWNraW5nSW50ZXJ2YWwpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1lbW9yeVRyYWNraW5nSW50ZXJ2YWwpO1xyXG4gICAgICB0aGlzLm1lbW9yeVRyYWNraW5nSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9nIGZpbmFsIHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgIGlmICh0aGlzLmNvbmZpZy5wZXJmb3JtYW5jZU1vbml0b3JpbmcpIHtcclxuICAgICAgY29uc3QgdG90YWxSdW50aW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xyXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0ZpbmFsIGRldmVsb3BtZW50IG1ldHJpY3MnLCAnRGV2ZWxvcG1lbnRTZXJ2aWNlJywge1xyXG4gICAgICAgIHRvdGFsUnVudGltZTogYCR7dG90YWxSdW50aW1lfW1zYCxcclxuICAgICAgICBmaW5hbE1lbW9yeTogdGhpcy5mb3JtYXRNZW1vcnlVc2FnZShmaW5hbE1lbW9yeSksXHJcbiAgICAgICAgdG90YWxNZXRyaWNzQ29sbGVjdGVkOiB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5sZW5ndGhcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDcmVhdGUgc2luZ2xldG9uIGluc3RhbmNlXHJcbmxldCBkZXZlbG9wbWVudFNlcnZpY2VJbnN0YW5jZTogRGV2ZWxvcG1lbnRTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRTZXJ2aWNlKGNvbmZpZz86IFBhcnRpYWw8RGV2ZWxvcG1lbnRDb25maWc+KTogRGV2ZWxvcG1lbnRTZXJ2aWNlIHtcclxuICBpZiAoIWRldmVsb3BtZW50U2VydmljZUluc3RhbmNlKSB7XHJcbiAgICBkZXZlbG9wbWVudFNlcnZpY2VJbnN0YW5jZSA9IG5ldyBEZXZlbG9wbWVudFNlcnZpY2UoY29uZmlnKTtcclxuICB9XHJcbiAgcmV0dXJuIGRldmVsb3BtZW50U2VydmljZUluc3RhbmNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGV2ZWxvcG1lbnRTZXJ2aWNlKCk6IERldmVsb3BtZW50U2VydmljZSB8IG51bGwge1xyXG4gIHJldHVybiBkZXZlbG9wbWVudFNlcnZpY2VJbnN0YW5jZTtcclxufVxyXG5cclxuZXhwb3J0IHsgRGV2ZWxvcG1lbnRTZXJ2aWNlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/backend/services/development-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/error-handler-service.ts":
/*!*******************************************************!*\
  !*** ./src/backend/services/error-handler-service.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Error Handler Service\n * Provides comprehensive error handling, recovery mechanisms, and graceful shutdown procedures\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorHandlerService = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst errors_1 = __webpack_require__(/*! @/shared/errors */ \"./src/shared/errors.ts\");\nclass ErrorHandlerService extends events_1.EventEmitter {\n    constructor(logger) {\n        super();\n        this.recoveryStrategies = new Map();\n        this.shutdownProcedures = new Map();\n        this.errorReports = new Map();\n        this.isShuttingDown = false;\n        this.shutdownTimeout = 30000; // 30 seconds\n        this.logger = logger;\n        this.sessionId = Date.now().toString();\n        this.setupDefaultRecoveryStrategies();\n        this.setupProcessHandlers();\n    }\n    /**\n     * Handle an error with automatic recovery attempts\n     */\n    async handleError(error, context, options = {}) {\n        const errorId = this.generateErrorId();\n        const baseError = error instanceof errors_1.BaseError ? error : this.wrapError(error, context);\n        // Create error report\n        const report = {\n            id: errorId,\n            timestamp: new Date(),\n            error: baseError,\n            context: { ...context, sessionId: this.sessionId },\n            recoveryAttempts: 0,\n            recovered: false,\n            userNotified: false,\n        };\n        this.errorReports.set(errorId, report);\n        // Log the error\n        this.logger.error('Error occurred', 'ErrorHandler', {\n            errorId,\n            error: baseError.toJSON ? baseError.toJSON() : this.errorToJSON(error),\n            context,\n        });\n        // Emit error event\n        this.emit('error', { error: baseError, context, report });\n        try {\n            // Attempt recovery\n            const recovered = await this.attemptRecovery(baseError, context, options);\n            report.recovered = recovered;\n            if (!recovered && options.userNotification !== false) {\n                await this.notifyUser(baseError, context);\n                report.userNotified = true;\n            }\n            // Update report\n            this.errorReports.set(errorId, report);\n            // Emit recovery result\n            this.emit('recoveryAttempt', { error: baseError, context, recovered, report });\n            return recovered;\n        }\n        catch (recoveryError) {\n            this.logger.error('Error during recovery attempt', 'ErrorHandler', {\n                originalError: baseError.toJSON ? baseError.toJSON() : this.errorToJSON(error),\n                recoveryError: recoveryError instanceof Error ? recoveryError.message : recoveryError,\n                context,\n            });\n            return false;\n        }\n    }\n    /**\n     * Attempt to recover from an error using registered strategies\n     */\n    async attemptRecovery(error, context, options) {\n        const maxRetries = options.maxRetries ?? 3;\n        const baseDelay = options.retryDelay ?? 1000;\n        const useExponentialBackoff = options.exponentialBackoff ?? true;\n        // Get applicable recovery strategies\n        const strategies = Array.from(this.recoveryStrategies.values())\n            .filter(strategy => strategy.canRecover(error))\n            .sort((a, b) => b.priority - a.priority);\n        if (strategies.length === 0) {\n            this.logger.warn('No recovery strategies available for error', 'ErrorHandler', {\n                errorType: error.constructor.name,\n                context,\n            });\n            // Try fallback action if provided\n            if (options.fallbackAction) {\n                try {\n                    await options.fallbackAction();\n                    return true;\n                }\n                catch (fallbackError) {\n                    this.logger.error('Fallback action failed', 'ErrorHandler', {\n                        fallbackError: fallbackError instanceof Error ? fallbackError.message : fallbackError,\n                    });\n                }\n            }\n            return false;\n        }\n        // Try each strategy with retries\n        for (const strategy of strategies) {\n            for (let attempt = 1; attempt <= maxRetries; attempt++) {\n                try {\n                    this.logger.info(`Attempting recovery with strategy: ${strategy.constructor.name}`, 'ErrorHandler', {\n                        attempt,\n                        maxRetries,\n                        context,\n                    });\n                    const recovered = await strategy.recover(error, context);\n                    if (recovered) {\n                        this.logger.info('Recovery successful', 'ErrorHandler', {\n                            strategy: strategy.constructor.name,\n                            attempt,\n                            context,\n                        });\n                        return true;\n                    }\n                    // Wait before retry\n                    if (attempt < maxRetries) {\n                        const delay = useExponentialBackoff\n                            ? baseDelay * Math.pow(2, attempt - 1)\n                            : baseDelay;\n                        await this.delay(delay);\n                    }\n                }\n                catch (strategyError) {\n                    this.logger.error('Recovery strategy failed', 'ErrorHandler', {\n                        strategy: strategy.constructor.name,\n                        attempt,\n                        error: strategyError instanceof Error ? strategyError.message : strategyError,\n                        context,\n                    });\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Register a recovery strategy\n     */\n    registerRecoveryStrategy(name, strategy) {\n        this.recoveryStrategies.set(name, strategy);\n        this.logger.debug(`Recovery strategy registered: ${name}`, 'ErrorHandler');\n    }\n    /**\n     * Register a shutdown procedure\n     */\n    registerShutdownProcedure(procedure) {\n        this.shutdownProcedures.set(procedure.name, procedure);\n        this.logger.debug(`Shutdown procedure registered: ${procedure.name}`, 'ErrorHandler');\n    }\n    /**\n     * Perform graceful shutdown\n     */\n    async gracefulShutdown(reason = 'Unknown') {\n        if (this.isShuttingDown) {\n            this.logger.warn('Shutdown already in progress', 'ErrorHandler');\n            return;\n        }\n        this.isShuttingDown = true;\n        this.logger.info(`Initiating graceful shutdown: ${reason}`, 'ErrorHandler');\n        this.emit('shutdownStarted', { reason });\n        try {\n            // Get procedures sorted by priority (higher priority first)\n            const procedures = Array.from(this.shutdownProcedures.values())\n                .sort((a, b) => b.priority - a.priority);\n            // Execute shutdown procedures\n            for (const procedure of procedures) {\n                try {\n                    this.logger.info(`Executing shutdown procedure: ${procedure.name}`, 'ErrorHandler');\n                    await Promise.race([\n                        procedure.procedure(),\n                        this.delay(procedure.timeout).then(() => {\n                            throw new Error(`Shutdown procedure ${procedure.name} timed out`);\n                        }),\n                    ]);\n                    this.logger.info(`Shutdown procedure completed: ${procedure.name}`, 'ErrorHandler');\n                }\n                catch (error) {\n                    this.logger.error(`Shutdown procedure failed: ${procedure.name}`, 'ErrorHandler', {\n                        error: error instanceof Error ? error.message : error,\n                    });\n                }\n            }\n            this.emit('shutdownCompleted', { reason });\n            this.logger.info('Graceful shutdown completed', 'ErrorHandler');\n        }\n        catch (error) {\n            this.logger.error('Error during graceful shutdown', 'ErrorHandler', {\n                error: error instanceof Error ? error.message : error,\n                reason,\n            });\n        }\n    }\n    /**\n     * Show user-friendly error notification\n     */\n    async notifyUser(error, context) {\n        try {\n            const mainWindow = electron_1.BrowserWindow.getFocusedWindow() || electron_1.BrowserWindow.getAllWindows()[0];\n            if (!mainWindow || mainWindow.isDestroyed()) {\n                // Fallback to system dialog\n                await this.showSystemErrorDialog(error, context);\n                return;\n            }\n            // Send error to renderer for user-friendly display\n            mainWindow.webContents.send('error-notification', {\n                error: error instanceof errors_1.BaseError ? error.toJSON() : this.errorToJSON(error),\n                context,\n                timestamp: new Date().toISOString(),\n            });\n        }\n        catch (notificationError) {\n            this.logger.error('Failed to notify user of error', 'ErrorHandler', {\n                notificationError: notificationError instanceof Error ? notificationError.message : notificationError,\n                originalError: error.message,\n            });\n            // Fallback to system dialog\n            await this.showSystemErrorDialog(error, context);\n        }\n    }\n    /**\n     * Show system error dialog as fallback\n     */\n    async showSystemErrorDialog(error, context) {\n        try {\n            const userMessage = error instanceof errors_1.BaseError && error.userMessage\n                ? error.userMessage\n                : 'An unexpected error occurred. Please try again.';\n            const suggestions = error instanceof errors_1.BaseError && error.suggestions\n                ? error.suggestions.join('\\n ')\n                : 'Restart the application if the problem persists.';\n            await electron_1.dialog.showErrorBox('Application Error', `${userMessage}\\n\\nSuggestions:\\n ${suggestions}\\n\\nOperation: ${context.operation}\\nComponent: ${context.component}`);\n        }\n        catch (dialogError) {\n            this.logger.error('Failed to show system error dialog', 'ErrorHandler', {\n                dialogError: dialogError instanceof Error ? dialogError.message : dialogError,\n            });\n        }\n    }\n    /**\n     * Setup default recovery strategies\n     */\n    setupDefaultRecoveryStrategies() {\n        // File system recovery strategy\n        this.registerRecoveryStrategy('filesystem', {\n            canRecover: (error) => error.message.includes('ENOENT') || error.message.includes('EACCES'),\n            recover: async (error, context) => {\n                this.logger.info('Attempting file system recovery', 'ErrorHandler', { context });\n                // Try to create missing directories or fix permissions\n                if (error.message.includes('ENOENT')) {\n                    // Directory creation logic would go here\n                    return true;\n                }\n                if (error.message.includes('EACCES')) {\n                    // Permission fix logic would go here\n                    return false; // Usually requires user intervention\n                }\n                return false;\n            },\n            priority: 5,\n        });\n        // Network recovery strategy\n        this.registerRecoveryStrategy('network', {\n            canRecover: (error) => error.message.includes('ENOTFOUND') ||\n                error.message.includes('ECONNREFUSED') ||\n                error.message.includes('timeout'),\n            recover: async (error, context) => {\n                this.logger.info('Attempting network recovery', 'ErrorHandler', { context });\n                // Wait and retry for network issues\n                await this.delay(2000);\n                return true; // Let the retry mechanism handle it\n            },\n            priority: 3,\n        });\n        // Database recovery strategy\n        this.registerRecoveryStrategy('database', {\n            canRecover: (error) => error.message.includes('database') ||\n                error.message.includes('SQLITE'),\n            recover: async (error, context) => {\n                this.logger.info('Attempting database recovery', 'ErrorHandler', { context });\n                // Database recovery logic would go here\n                // For now, just log and return false\n                return false;\n            },\n            priority: 4,\n        });\n    }\n    /**\n     * Setup process-level error handlers\n     */\n    setupProcessHandlers() {\n        // Handle uncaught exceptions\n        process.on('uncaughtException', async (error) => {\n            this.logger.error('Uncaught Exception', 'ErrorHandler', {\n                error: error.message,\n                stack: error.stack,\n            });\n            await this.handleError(error, {\n                operation: 'process',\n                component: 'uncaughtException',\n            });\n            // Graceful shutdown on critical errors\n            await this.gracefulShutdown('Uncaught Exception');\n            process.exit(1);\n        });\n        // Handle unhandled promise rejections\n        process.on('unhandledRejection', async (reason, promise) => {\n            const error = reason instanceof Error ? reason : new Error(String(reason));\n            this.logger.error('Unhandled Promise Rejection', 'ErrorHandler', {\n                reason: String(reason),\n                promise: promise.toString(),\n            });\n            await this.handleError(error, {\n                operation: 'process',\n                component: 'unhandledRejection',\n            });\n        });\n        // Handle app before-quit for graceful shutdown\n        electron_1.app.on('before-quit', async (event) => {\n            if (!this.isShuttingDown) {\n                event.preventDefault();\n                await this.gracefulShutdown('Application Quit');\n                electron_1.app.quit();\n            }\n        });\n    }\n    /**\n     * Wrap a regular Error in a BaseError\n     */\n    wrapError(error, context) {\n        // Determine error type based on context and message\n        if (context.component === 'IPC' || context.operation.includes('ipc')) {\n            return new errors_1.IPCError(error.message, 'IPC_ERROR', {\n                cause: error,\n                details: { context },\n            });\n        }\n        if (context.component === 'System' || error.message.includes('ENOENT') || error.message.includes('EACCES')) {\n            return new errors_1.SystemError(error.message, 'SYSTEM_ERROR', {\n                cause: error,\n                details: { context },\n            });\n        }\n        if (context.component === 'Configuration' || context.operation.includes('config')) {\n            return new errors_1.ConfigurationError(error.message, 'CONFIG_ERROR', {\n                cause: error,\n                details: { context },\n            });\n        }\n        // Default to ApplicationError\n        return new errors_1.ApplicationError(error.message, 'APPLICATION_ERROR', {\n            cause: error,\n            details: { context },\n        });\n    }\n    /**\n     * Convert regular Error to JSON\n     */\n    errorToJSON(error) {\n        return {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n            timestamp: new Date().toISOString(),\n        };\n    }\n    /**\n     * Generate unique error ID\n     */\n    generateErrorId() {\n        return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Utility delay function\n     */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    /**\n     * Get error statistics\n     */\n    getErrorStatistics() {\n        const reports = Array.from(this.errorReports.values());\n        const totalErrors = reports.length;\n        const recoveredErrors = reports.filter(r => r.recovered).length;\n        const recoveryRate = totalErrors > 0 ? (recoveredErrors / totalErrors) * 100 : 0;\n        const errorsByType = {};\n        reports.forEach(report => {\n            const errorType = report.error.constructor.name;\n            errorsByType[errorType] = (errorsByType[errorType] || 0) + 1;\n        });\n        const recentErrors = reports\n            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n            .slice(0, 10);\n        return {\n            totalErrors,\n            recoveredErrors,\n            recoveryRate,\n            errorsByType,\n            recentErrors,\n        };\n    }\n    /**\n     * Clear old error reports\n     */\n    clearOldReports(maxAge = 24 * 60 * 60 * 1000) {\n        const cutoff = new Date(Date.now() - maxAge);\n        for (const [id, report] of this.errorReports.entries()) {\n            if (report.timestamp < cutoff) {\n                this.errorReports.delete(id);\n            }\n        }\n    }\n    /**\n     * Shutdown the error handler service\n     */\n    async shutdown() {\n        this.logger.info('Error handler service shutting down', 'ErrorHandler');\n        // Clear old reports\n        this.clearOldReports();\n        // Remove all listeners\n        this.removeAllListeners();\n        this.logger.info('Error handler service shutdown complete', 'ErrorHandler');\n    }\n}\nexports.ErrorHandlerService = ErrorHandlerService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9lcnJvci1oYW5kbGVyLXNlcnZpY2UudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7O0FBRUgsNkRBQXNDO0FBQ3RDLG1FQUFzRDtBQUN0RCxzRkFBeUc7QUEwQ3pHLE1BQWEsbUJBQW9CLFNBQVEscUJBQVk7SUFTbkQsWUFBWSxNQUFxQjtRQUMvQixLQUFLLEVBQUUsQ0FBQztRQVJGLHVCQUFrQixHQUFrQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzlELHVCQUFrQixHQUFtQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQy9ELGlCQUFZLEdBQTZCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDbkQsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFDdkIsb0JBQWUsR0FBRyxLQUFLLENBQUMsQ0FBQyxhQUFhO1FBSzVDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyw4QkFBOEIsRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQ2YsS0FBWSxFQUNaLE9BQXFCLEVBQ3JCLFVBQWdDLEVBQUU7UUFFbEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sU0FBUyxHQUFHLEtBQUssWUFBWSxrQkFBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXRGLHNCQUFzQjtRQUN0QixNQUFNLE1BQU0sR0FBZ0I7WUFDMUIsRUFBRSxFQUFFLE9BQU87WUFDWCxTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUU7WUFDckIsS0FBSyxFQUFFLFNBQVM7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QUMsZUFBZSxFQUFFLENBQUM7UUFFdkIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRTFCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHlDQUF5QyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7Q0FDRjtBQXZmRCxrREF1ZkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL3NlcnZpY2VzL2Vycm9yLWhhbmRsZXItc2VydmljZS50cz81OWJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBFcnJvciBIYW5kbGVyIFNlcnZpY2VcclxuICogUHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBlcnJvciBoYW5kbGluZywgcmVjb3ZlcnkgbWVjaGFuaXNtcywgYW5kIGdyYWNlZnVsIHNodXRkb3duIHByb2NlZHVyZXNcclxuICovXHJcblxyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQgeyBhcHAsIGRpYWxvZywgQnJvd3NlcldpbmRvdyB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgQmFzZUVycm9yLCBTeXN0ZW1FcnJvciwgQXBwbGljYXRpb25FcnJvciwgSVBDRXJyb3IsIENvbmZpZ3VyYXRpb25FcnJvciB9IGZyb20gJ0Avc2hhcmVkL2Vycm9ycyc7XHJcbmltcG9ydCB0eXBlIHsgTG9nZ2VyU2VydmljZSB9IGZyb20gJy4vbG9nZ2VyLXNlcnZpY2UnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFcnJvclJlY292ZXJ5T3B0aW9ucyB7XHJcbiAgbWF4UmV0cmllcz86IG51bWJlcjtcclxuICByZXRyeURlbGF5PzogbnVtYmVyO1xyXG4gIGV4cG9uZW50aWFsQmFja29mZj86IGJvb2xlYW47XHJcbiAgZmFsbGJhY2tBY3Rpb24/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcclxuICB1c2VyTm90aWZpY2F0aW9uPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFcnJvckNvbnRleHQge1xyXG4gIG9wZXJhdGlvbjogc3RyaW5nO1xyXG4gIGNvbXBvbmVudDogc3RyaW5nO1xyXG4gIHVzZXJJZD86IHN0cmluZztcclxuICBzZXNzaW9uSWQ/OiBzdHJpbmc7XHJcbiAgYWRkaXRpb25hbERhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5U3RyYXRlZ3kge1xyXG4gIGNhblJlY292ZXI6IChlcnJvcjogRXJyb3IpID0+IGJvb2xlYW47XHJcbiAgcmVjb3ZlcjogKGVycm9yOiBFcnJvciwgY29udGV4dDogRXJyb3JDb250ZXh0KSA9PiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gIHByaW9yaXR5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2h1dGRvd25Qcm9jZWR1cmUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBwcmlvcml0eTogbnVtYmVyO1xyXG4gIHRpbWVvdXQ6IG51bWJlcjtcclxuICBwcm9jZWR1cmU6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JSZXBvcnQge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBEYXRlO1xyXG4gIGVycm9yOiBCYXNlRXJyb3IgfCBFcnJvcjtcclxuICBjb250ZXh0OiBFcnJvckNvbnRleHQ7XHJcbiAgcmVjb3ZlcnlBdHRlbXB0czogbnVtYmVyO1xyXG4gIHJlY292ZXJlZDogYm9vbGVhbjtcclxuICB1c2VyTm90aWZpZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBFcnJvckhhbmRsZXJTZXJ2aWNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyU2VydmljZTtcclxuICBwcml2YXRlIHJlY292ZXJ5U3RyYXRlZ2llczogTWFwPHN0cmluZywgUmVjb3ZlcnlTdHJhdGVneT4gPSBuZXcgTWFwKCk7XHJcbiAgcHJpdmF0ZSBzaHV0ZG93blByb2NlZHVyZXM6IE1hcDxzdHJpbmcsIFNodXRkb3duUHJvY2VkdXJlPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIGVycm9yUmVwb3J0czogTWFwPHN0cmluZywgRXJyb3JSZXBvcnQ+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgaXNTaHV0dGluZ0Rvd24gPSBmYWxzZTtcclxuICBwcml2YXRlIHNodXRkb3duVGltZW91dCA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXHJcbiAgcHJpdmF0ZSBzZXNzaW9uSWQ6IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXJTZXJ2aWNlKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICB0aGlzLnNlc3Npb25JZCA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcclxuICAgIHRoaXMuc2V0dXBEZWZhdWx0UmVjb3ZlcnlTdHJhdGVnaWVzKCk7XHJcbiAgICB0aGlzLnNldHVwUHJvY2Vzc0hhbmRsZXJzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYW4gZXJyb3Igd2l0aCBhdXRvbWF0aWMgcmVjb3ZlcnkgYXR0ZW1wdHNcclxuICAgKi9cclxuICBhc3luYyBoYW5kbGVFcnJvcihcclxuICAgIGVycm9yOiBFcnJvcixcclxuICAgIGNvbnRleHQ6IEVycm9yQ29udGV4dCxcclxuICAgIG9wdGlvbnM6IEVycm9yUmVjb3ZlcnlPcHRpb25zID0ge31cclxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIGNvbnN0IGVycm9ySWQgPSB0aGlzLmdlbmVyYXRlRXJyb3JJZCgpO1xyXG4gICAgY29uc3QgYmFzZUVycm9yID0gZXJyb3IgaW5zdGFuY2VvZiBCYXNlRXJyb3IgPyBlcnJvciA6IHRoaXMud3JhcEVycm9yKGVycm9yLCBjb250ZXh0KTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGVycm9yIHJlcG9ydFxyXG4gICAgY29uc3QgcmVwb3J0OiBFcnJvclJlcG9ydCA9IHtcclxuICAgICAgaWQ6IGVycm9ySWQsXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgZXJyb3I6IGJhc2VFcnJvcixcclxuICAgICAgY29udGV4dDogeyAuLi5jb250ZXh0LCBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkIH0sXHJcbiAgICAgIHJlY292ZXJ5QXR0ZW1wdHM6IDAsXHJcbiAgICAgIHJlY292ZXJlZDogZmFsc2UsXHJcbiAgICAgIHVzZXJOb3RpZmllZDogZmFsc2UsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZXJyb3JSZXBvcnRzLnNldChlcnJvcklkLCByZXBvcnQpO1xyXG5cclxuICAgIC8vIExvZyB0aGUgZXJyb3JcclxuICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBvY2N1cnJlZCcsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgIGVycm9ySWQsXHJcbiAgICAgIGVycm9yOiBiYXNlRXJyb3IudG9KU09OID8gYmFzZUVycm9yLnRvSlNPTigpIDogdGhpcy5lcnJvclRvSlNPTihlcnJvciksXHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFbWl0IGVycm9yIGV2ZW50XHJcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyBlcnJvcjogYmFzZUVycm9yLCBjb250ZXh0LCByZXBvcnQgfSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQXR0ZW1wdCByZWNvdmVyeVxyXG4gICAgICBjb25zdCByZWNvdmVyZWQgPSBhd2FpdCB0aGlzLmF0dGVtcHRSZWNvdmVyeShiYXNlRXJyb3IsIGNvbnRleHQsIG9wdGlvbnMpO1xyXG4gICAgICByZXBvcnQucmVjb3ZlcmVkID0gcmVjb3ZlcmVkO1xyXG5cclxuICAgICAgaWYgKCFyZWNvdmVyZWQgJiYgb3B0aW9ucy51c2VyTm90aWZpY2F0aW9uICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VXNlcihiYXNlRXJyb3IsIGNvbnRleHQpO1xyXG4gICAgICAgIHJlcG9ydC51c2VyTm90aWZpZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgcmVwb3J0XHJcbiAgICAgIHRoaXMuZXJyb3JSZXBvcnRzLnNldChlcnJvcklkLCByZXBvcnQpO1xyXG5cclxuICAgICAgLy8gRW1pdCByZWNvdmVyeSByZXN1bHRcclxuICAgICAgdGhpcy5lbWl0KCdyZWNvdmVyeUF0dGVtcHQnLCB7IGVycm9yOiBiYXNlRXJyb3IsIGNvbnRleHQsIHJlY292ZXJlZCwgcmVwb3J0IH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlY292ZXJlZDtcclxuICAgIH0gY2F0Y2ggKHJlY292ZXJ5RXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Vycm9yIGR1cmluZyByZWNvdmVyeSBhdHRlbXB0JywgJ0Vycm9ySGFuZGxlcicsIHtcclxuICAgICAgICBvcmlnaW5hbEVycm9yOiBiYXNlRXJyb3IudG9KU09OID8gYmFzZUVycm9yLnRvSlNPTigpIDogdGhpcy5lcnJvclRvSlNPTihlcnJvciksXHJcbiAgICAgICAgcmVjb3ZlcnlFcnJvcjogcmVjb3ZlcnlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcmVjb3ZlcnlFcnJvci5tZXNzYWdlIDogcmVjb3ZlcnlFcnJvcixcclxuICAgICAgICBjb250ZXh0LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGFuIGVycm9yIHVzaW5nIHJlZ2lzdGVyZWQgc3RyYXRlZ2llc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgYXR0ZW1wdFJlY292ZXJ5KFxyXG4gICAgZXJyb3I6IEJhc2VFcnJvciB8IEVycm9yLFxyXG4gICAgY29udGV4dDogRXJyb3JDb250ZXh0LFxyXG4gICAgb3B0aW9uczogRXJyb3JSZWNvdmVyeU9wdGlvbnNcclxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gMztcclxuICAgIGNvbnN0IGJhc2VEZWxheSA9IG9wdGlvbnMucmV0cnlEZWxheSA/PyAxMDAwO1xyXG4gICAgY29uc3QgdXNlRXhwb25lbnRpYWxCYWNrb2ZmID0gb3B0aW9ucy5leHBvbmVudGlhbEJhY2tvZmYgPz8gdHJ1ZTtcclxuXHJcbiAgICAvLyBHZXQgYXBwbGljYWJsZSByZWNvdmVyeSBzdHJhdGVnaWVzXHJcbiAgICBjb25zdCBzdHJhdGVnaWVzID0gQXJyYXkuZnJvbSh0aGlzLnJlY292ZXJ5U3RyYXRlZ2llcy52YWx1ZXMoKSlcclxuICAgICAgLmZpbHRlcihzdHJhdGVneSA9PiBzdHJhdGVneS5jYW5SZWNvdmVyKGVycm9yKSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcclxuXHJcbiAgICBpZiAoc3RyYXRlZ2llcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5sb2dnZXIud2FybignTm8gcmVjb3Zlcnkgc3RyYXRlZ2llcyBhdmFpbGFibGUgZm9yIGVycm9yJywgJ0Vycm9ySGFuZGxlcicsIHtcclxuICAgICAgICBlcnJvclR5cGU6IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBUcnkgZmFsbGJhY2sgYWN0aW9uIGlmIHByb3ZpZGVkXHJcbiAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrQWN0aW9uKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IG9wdGlvbnMuZmFsbGJhY2tBY3Rpb24oKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWxsYmFjayBhY3Rpb24gZmFpbGVkJywgJ0Vycm9ySGFuZGxlcicsIHtcclxuICAgICAgICAgICAgZmFsbGJhY2tFcnJvcjogZmFsbGJhY2tFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZmFsbGJhY2tFcnJvci5tZXNzYWdlIDogZmFsbGJhY2tFcnJvcixcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSBlYWNoIHN0cmF0ZWd5IHdpdGggcmV0cmllc1xyXG4gICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XHJcbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBBdHRlbXB0aW5nIHJlY292ZXJ5IHdpdGggc3RyYXRlZ3k6ICR7c3RyYXRlZ3kuY29uc3RydWN0b3IubmFtZX1gLCAnRXJyb3JIYW5kbGVyJywge1xyXG4gICAgICAgICAgICBhdHRlbXB0LFxyXG4gICAgICAgICAgICBtYXhSZXRyaWVzLFxyXG4gICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVjb3ZlcmVkID0gYXdhaXQgc3RyYXRlZ3kucmVjb3ZlcihlcnJvciwgY29udGV4dCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChyZWNvdmVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnUmVjb3Zlcnkgc3VjY2Vzc2Z1bCcsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5LmNvbnN0cnVjdG9yLm5hbWUsXHJcbiAgICAgICAgICAgICAgYXR0ZW1wdCxcclxuICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcclxuICAgICAgICAgIGlmIChhdHRlbXB0IDwgbWF4UmV0cmllcykge1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHVzZUV4cG9uZW50aWFsQmFja29mZiBcclxuICAgICAgICAgICAgICA/IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKVxyXG4gICAgICAgICAgICAgIDogYmFzZURlbGF5O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxheShkZWxheSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoc3RyYXRlZ3lFcnJvcikge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1JlY292ZXJ5IHN0cmF0ZWd5IGZhaWxlZCcsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneS5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgICAgICBhdHRlbXB0LFxyXG4gICAgICAgICAgICBlcnJvcjogc3RyYXRlZ3lFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc3RyYXRlZ3lFcnJvci5tZXNzYWdlIDogc3RyYXRlZ3lFcnJvcixcclxuICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgcmVjb3Zlcnkgc3RyYXRlZ3lcclxuICAgKi9cclxuICByZWdpc3RlclJlY292ZXJ5U3RyYXRlZ3kobmFtZTogc3RyaW5nLCBzdHJhdGVneTogUmVjb3ZlcnlTdHJhdGVneSk6IHZvaWQge1xyXG4gICAgdGhpcy5yZWNvdmVyeVN0cmF0ZWdpZXMuc2V0KG5hbWUsIHN0cmF0ZWd5KTtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBSZWNvdmVyeSBzdHJhdGVneSByZWdpc3RlcmVkOiAke25hbWV9YCwgJ0Vycm9ySGFuZGxlcicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSBzaHV0ZG93biBwcm9jZWR1cmVcclxuICAgKi9cclxuICByZWdpc3RlclNodXRkb3duUHJvY2VkdXJlKHByb2NlZHVyZTogU2h1dGRvd25Qcm9jZWR1cmUpOiB2b2lkIHtcclxuICAgIHRoaXMuc2h1dGRvd25Qcm9jZWR1cmVzLnNldChwcm9jZWR1cmUubmFtZSwgcHJvY2VkdXJlKTtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBTaHV0ZG93biBwcm9jZWR1cmUgcmVnaXN0ZXJlZDogJHtwcm9jZWR1cmUubmFtZX1gLCAnRXJyb3JIYW5kbGVyJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIGdyYWNlZnVsIHNodXRkb3duXHJcbiAgICovXHJcbiAgYXN5bmMgZ3JhY2VmdWxTaHV0ZG93bihyZWFzb246IHN0cmluZyA9ICdVbmtub3duJyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMuaXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgdGhpcy5sb2dnZXIud2FybignU2h1dGRvd24gYWxyZWFkeSBpbiBwcm9ncmVzcycsICdFcnJvckhhbmRsZXInKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbyhgSW5pdGlhdGluZyBncmFjZWZ1bCBzaHV0ZG93bjogJHtyZWFzb259YCwgJ0Vycm9ySGFuZGxlcicpO1xyXG5cclxuICAgIHRoaXMuZW1pdCgnc2h1dGRvd25TdGFydGVkJywgeyByZWFzb24gfSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHByb2NlZHVyZXMgc29ydGVkIGJ5IHByaW9yaXR5IChoaWdoZXIgcHJpb3JpdHkgZmlyc3QpXHJcbiAgICAgIGNvbnN0IHByb2NlZHVyZXMgPSBBcnJheS5mcm9tKHRoaXMuc2h1dGRvd25Qcm9jZWR1cmVzLnZhbHVlcygpKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XHJcblxyXG4gICAgICAvLyBFeGVjdXRlIHNodXRkb3duIHByb2NlZHVyZXNcclxuICAgICAgZm9yIChjb25zdCBwcm9jZWR1cmUgb2YgcHJvY2VkdXJlcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBFeGVjdXRpbmcgc2h1dGRvd24gcHJvY2VkdXJlOiAke3Byb2NlZHVyZS5uYW1lfWAsICdFcnJvckhhbmRsZXInKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgcHJvY2VkdXJlLnByb2NlZHVyZSgpLFxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5KHByb2NlZHVyZS50aW1lb3V0KS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNodXRkb3duIHByb2NlZHVyZSAke3Byb2NlZHVyZS5uYW1lfSB0aW1lZCBvdXRgKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBTaHV0ZG93biBwcm9jZWR1cmUgY29tcGxldGVkOiAke3Byb2NlZHVyZS5uYW1lfWAsICdFcnJvckhhbmRsZXInKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYFNodXRkb3duIHByb2NlZHVyZSBmYWlsZWQ6ICR7cHJvY2VkdXJlLm5hbWV9YCwgJ0Vycm9ySGFuZGxlcicsIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZW1pdCgnc2h1dGRvd25Db21wbGV0ZWQnLCB7IHJlYXNvbiB9KTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnR3JhY2VmdWwgc2h1dGRvd24gY29tcGxldGVkJywgJ0Vycm9ySGFuZGxlcicpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0Vycm9yIGR1cmluZyBncmFjZWZ1bCBzaHV0ZG93bicsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgdXNlci1mcmllbmRseSBlcnJvciBub3RpZmljYXRpb25cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIG5vdGlmeVVzZXIoZXJyb3I6IEJhc2VFcnJvciB8IEVycm9yLCBjb250ZXh0OiBFcnJvckNvbnRleHQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IG1haW5XaW5kb3cgPSBCcm93c2VyV2luZG93LmdldEZvY3VzZWRXaW5kb3coKSB8fCBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKVswXTtcclxuICAgICAgXHJcbiAgICAgIGlmICghbWFpbldpbmRvdyB8fCBtYWluV2luZG93LmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICAvLyBGYWxsYmFjayB0byBzeXN0ZW0gZGlhbG9nXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zaG93U3lzdGVtRXJyb3JEaWFsb2coZXJyb3IsIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2VuZCBlcnJvciB0byByZW5kZXJlciBmb3IgdXNlci1mcmllbmRseSBkaXNwbGF5XHJcbiAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnZXJyb3Itbm90aWZpY2F0aW9uJywge1xyXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEJhc2VFcnJvciA/IGVycm9yLnRvSlNPTigpIDogdGhpcy5lcnJvclRvSlNPTihlcnJvciksXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChub3RpZmljYXRpb25FcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIG5vdGlmeSB1c2VyIG9mIGVycm9yJywgJ0Vycm9ySGFuZGxlcicsIHtcclxuICAgICAgICBub3RpZmljYXRpb25FcnJvcjogbm90aWZpY2F0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IG5vdGlmaWNhdGlvbkVycm9yLm1lc3NhZ2UgOiBub3RpZmljYXRpb25FcnJvcixcclxuICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHN5c3RlbSBkaWFsb2dcclxuICAgICAgYXdhaXQgdGhpcy5zaG93U3lzdGVtRXJyb3JEaWFsb2coZXJyb3IsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvdyBzeXN0ZW0gZXJyb3IgZGlhbG9nIGFzIGZhbGxiYWNrXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBzaG93U3lzdGVtRXJyb3JEaWFsb2coZXJyb3I6IEJhc2VFcnJvciB8IEVycm9yLCBjb250ZXh0OiBFcnJvckNvbnRleHQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVzZXJNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBCYXNlRXJyb3IgJiYgZXJyb3IudXNlck1lc3NhZ2UgXHJcbiAgICAgICAgPyBlcnJvci51c2VyTWVzc2FnZSBcclxuICAgICAgICA6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgdHJ5IGFnYWluLic7XHJcblxyXG4gICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IGVycm9yIGluc3RhbmNlb2YgQmFzZUVycm9yICYmIGVycm9yLnN1Z2dlc3Rpb25zXHJcbiAgICAgICAgPyBlcnJvci5zdWdnZXN0aW9ucy5qb2luKCdcXG7igKIgJylcclxuICAgICAgICA6ICdSZXN0YXJ0IHRoZSBhcHBsaWNhdGlvbiBpZiB0aGUgcHJvYmxlbSBwZXJzaXN0cy4nO1xyXG5cclxuICAgICAgYXdhaXQgZGlhbG9nLnNob3dFcnJvckJveChcclxuICAgICAgICAnQXBwbGljYXRpb24gRXJyb3InLFxyXG4gICAgICAgIGAke3VzZXJNZXNzYWdlfVxcblxcblN1Z2dlc3Rpb25zOlxcbuKAoiAke3N1Z2dlc3Rpb25zfVxcblxcbk9wZXJhdGlvbjogJHtjb250ZXh0Lm9wZXJhdGlvbn1cXG5Db21wb25lbnQ6ICR7Y29udGV4dC5jb21wb25lbnR9YFxyXG4gICAgICApO1xyXG4gICAgfSBjYXRjaCAoZGlhbG9nRXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzaG93IHN5c3RlbSBlcnJvciBkaWFsb2cnLCAnRXJyb3JIYW5kbGVyJywge1xyXG4gICAgICAgIGRpYWxvZ0Vycm9yOiBkaWFsb2dFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGlhbG9nRXJyb3IubWVzc2FnZSA6IGRpYWxvZ0Vycm9yLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHVwIGRlZmF1bHQgcmVjb3Zlcnkgc3RyYXRlZ2llc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc2V0dXBEZWZhdWx0UmVjb3ZlcnlTdHJhdGVnaWVzKCk6IHZvaWQge1xyXG4gICAgLy8gRmlsZSBzeXN0ZW0gcmVjb3Zlcnkgc3RyYXRlZ3lcclxuICAgIHRoaXMucmVnaXN0ZXJSZWNvdmVyeVN0cmF0ZWd5KCdmaWxlc3lzdGVtJywge1xyXG4gICAgICBjYW5SZWNvdmVyOiAoZXJyb3IpID0+IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0VOT0VOVCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0VBQ0NFUycpLFxyXG4gICAgICByZWNvdmVyOiBhc3luYyAoZXJyb3IsIGNvbnRleHQpID0+IHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdBdHRlbXB0aW5nIGZpbGUgc3lzdGVtIHJlY292ZXJ5JywgJ0Vycm9ySGFuZGxlcicsIHsgY29udGV4dCB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIG1pc3NpbmcgZGlyZWN0b3JpZXMgb3IgZml4IHBlcm1pc3Npb25zXHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0VOT0VOVCcpKSB7XHJcbiAgICAgICAgICAvLyBEaXJlY3RvcnkgY3JlYXRpb24gbG9naWMgd291bGQgZ28gaGVyZVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdFQUNDRVMnKSkge1xyXG4gICAgICAgICAgLy8gUGVybWlzc2lvbiBmaXggbG9naWMgd291bGQgZ28gaGVyZVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBVc3VhbGx5IHJlcXVpcmVzIHVzZXIgaW50ZXJ2ZW50aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSxcclxuICAgICAgcHJpb3JpdHk6IDUsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBOZXR3b3JrIHJlY292ZXJ5IHN0cmF0ZWd5XHJcbiAgICB0aGlzLnJlZ2lzdGVyUmVjb3ZlcnlTdHJhdGVneSgnbmV0d29yaycsIHtcclxuICAgICAgY2FuUmVjb3ZlcjogKGVycm9yKSA9PiBcclxuICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdFTk9URk9VTkQnKSB8fCBcclxuICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdFQ09OTlJFRlVTRUQnKSB8fFxyXG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVvdXQnKSxcclxuICAgICAgcmVjb3ZlcjogYXN5bmMgKGVycm9yLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQXR0ZW1wdGluZyBuZXR3b3JrIHJlY292ZXJ5JywgJ0Vycm9ySGFuZGxlcicsIHsgY29udGV4dCB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBXYWl0IGFuZCByZXRyeSBmb3IgbmV0d29yayBpc3N1ZXNcclxuICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KDIwMDApO1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBMZXQgdGhlIHJldHJ5IG1lY2hhbmlzbSBoYW5kbGUgaXRcclxuICAgICAgfSxcclxuICAgICAgcHJpb3JpdHk6IDMsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEYXRhYmFzZSByZWNvdmVyeSBzdHJhdGVneVxyXG4gICAgdGhpcy5yZWdpc3RlclJlY292ZXJ5U3RyYXRlZ3koJ2RhdGFiYXNlJywge1xyXG4gICAgICBjYW5SZWNvdmVyOiAoZXJyb3IpID0+IFxyXG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RhdGFiYXNlJykgfHwgXHJcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnU1FMSVRFJyksXHJcbiAgICAgIHJlY292ZXI6IGFzeW5jIChlcnJvciwgY29udGV4dCkgPT4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0F0dGVtcHRpbmcgZGF0YWJhc2UgcmVjb3ZlcnknLCAnRXJyb3JIYW5kbGVyJywgeyBjb250ZXh0IH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERhdGFiYXNlIHJlY292ZXJ5IGxvZ2ljIHdvdWxkIGdvIGhlcmVcclxuICAgICAgICAvLyBGb3Igbm93LCBqdXN0IGxvZyBhbmQgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgICBwcmlvcml0eTogNCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dXAgcHJvY2Vzcy1sZXZlbCBlcnJvciBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc2V0dXBQcm9jZXNzSGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgICAvLyBIYW5kbGUgdW5jYXVnaHQgZXhjZXB0aW9uc1xyXG4gICAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBhc3luYyAoZXJyb3IpID0+IHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1VuY2F1Z2h0IEV4Y2VwdGlvbicsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIHtcclxuICAgICAgICBvcGVyYXRpb246ICdwcm9jZXNzJyxcclxuICAgICAgICBjb21wb25lbnQ6ICd1bmNhdWdodEV4Y2VwdGlvbicsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gR3JhY2VmdWwgc2h1dGRvd24gb24gY3JpdGljYWwgZXJyb3JzXHJcbiAgICAgIGF3YWl0IHRoaXMuZ3JhY2VmdWxTaHV0ZG93bignVW5jYXVnaHQgRXhjZXB0aW9uJyk7XHJcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhhbmRsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zXHJcbiAgICBwcm9jZXNzLm9uKCd1bmhhbmRsZWRSZWplY3Rpb24nLCBhc3luYyAocmVhc29uLCBwcm9taXNlKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiBuZXcgRXJyb3IoU3RyaW5nKHJlYXNvbikpO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1VuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbicsICdFcnJvckhhbmRsZXInLCB7XHJcbiAgICAgICAgcmVhc29uOiBTdHJpbmcocmVhc29uKSxcclxuICAgICAgICBwcm9taXNlOiBwcm9taXNlLnRvU3RyaW5nKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwge1xyXG4gICAgICAgIG9wZXJhdGlvbjogJ3Byb2Nlc3MnLFxyXG4gICAgICAgIGNvbXBvbmVudDogJ3VuaGFuZGxlZFJlamVjdGlvbicsXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGFwcCBiZWZvcmUtcXVpdCBmb3IgZ3JhY2VmdWwgc2h1dGRvd25cclxuICAgIGFwcC5vbignYmVmb3JlLXF1aXQnLCBhc3luYyAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmlzU2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmdyYWNlZnVsU2h1dGRvd24oJ0FwcGxpY2F0aW9uIFF1aXQnKTtcclxuICAgICAgICBhcHAucXVpdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdyYXAgYSByZWd1bGFyIEVycm9yIGluIGEgQmFzZUVycm9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB3cmFwRXJyb3IoZXJyb3I6IEVycm9yLCBjb250ZXh0OiBFcnJvckNvbnRleHQpOiBCYXNlRXJyb3Ige1xyXG4gICAgLy8gRGV0ZXJtaW5lIGVycm9yIHR5cGUgYmFzZWQgb24gY29udGV4dCBhbmQgbWVzc2FnZVxyXG4gICAgaWYgKGNvbnRleHQuY29tcG9uZW50ID09PSAnSVBDJyB8fCBjb250ZXh0Lm9wZXJhdGlvbi5pbmNsdWRlcygnaXBjJykpIHtcclxuICAgICAgcmV0dXJuIG5ldyBJUENFcnJvcihlcnJvci5tZXNzYWdlLCAnSVBDX0VSUk9SJywge1xyXG4gICAgICAgIGNhdXNlOiBlcnJvcixcclxuICAgICAgICBkZXRhaWxzOiB7IGNvbnRleHQgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnRleHQuY29tcG9uZW50ID09PSAnU3lzdGVtJyB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdFTk9FTlQnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdFQUNDRVMnKSkge1xyXG4gICAgICByZXR1cm4gbmV3IFN5c3RlbUVycm9yKGVycm9yLm1lc3NhZ2UsICdTWVNURU1fRVJST1InLCB7XHJcbiAgICAgICAgY2F1c2U6IGVycm9yLFxyXG4gICAgICAgIGRldGFpbHM6IHsgY29udGV4dCB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29udGV4dC5jb21wb25lbnQgPT09ICdDb25maWd1cmF0aW9uJyB8fCBjb250ZXh0Lm9wZXJhdGlvbi5pbmNsdWRlcygnY29uZmlnJykpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uRXJyb3IoZXJyb3IubWVzc2FnZSwgJ0NPTkZJR19FUlJPUicsIHtcclxuICAgICAgICBjYXVzZTogZXJyb3IsXHJcbiAgICAgICAgZGV0YWlsczogeyBjb250ZXh0IH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gQXBwbGljYXRpb25FcnJvclxyXG4gICAgcmV0dXJuIG5ldyBBcHBsaWNhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UsICdBUFBMSUNBVElPTl9FUlJPUicsIHtcclxuICAgICAgY2F1c2U6IGVycm9yLFxyXG4gICAgICBkZXRhaWxzOiB7IGNvbnRleHQgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCByZWd1bGFyIEVycm9yIHRvIEpTT05cclxuICAgKi9cclxuICBwcml2YXRlIGVycm9yVG9KU09OKGVycm9yOiBFcnJvcik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogZXJyb3IubmFtZSxcclxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSB1bmlxdWUgZXJyb3IgSURcclxuICAgKi9cclxuICBwcml2YXRlIGdlbmVyYXRlRXJyb3JJZCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBlcnJvcl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IGRlbGF5IGZ1bmN0aW9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkZWxheShtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZXJyb3Igc3RhdGlzdGljc1xyXG4gICAqL1xyXG4gIGdldEVycm9yU3RhdGlzdGljcygpOiB7XHJcbiAgICB0b3RhbEVycm9yczogbnVtYmVyO1xyXG4gICAgcmVjb3ZlcmVkRXJyb3JzOiBudW1iZXI7XHJcbiAgICByZWNvdmVyeVJhdGU6IG51bWJlcjtcclxuICAgIGVycm9yc0J5VHlwZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcclxuICAgIHJlY2VudEVycm9yczogRXJyb3JSZXBvcnRbXTtcclxuICB9IHtcclxuICAgIGNvbnN0IHJlcG9ydHMgPSBBcnJheS5mcm9tKHRoaXMuZXJyb3JSZXBvcnRzLnZhbHVlcygpKTtcclxuICAgIGNvbnN0IHRvdGFsRXJyb3JzID0gcmVwb3J0cy5sZW5ndGg7XHJcbiAgICBjb25zdCByZWNvdmVyZWRFcnJvcnMgPSByZXBvcnRzLmZpbHRlcihyID0+IHIucmVjb3ZlcmVkKS5sZW5ndGg7XHJcbiAgICBjb25zdCByZWNvdmVyeVJhdGUgPSB0b3RhbEVycm9ycyA+IDAgPyAocmVjb3ZlcmVkRXJyb3JzIC8gdG90YWxFcnJvcnMpICogMTAwIDogMDtcclxuXHJcbiAgICBjb25zdCBlcnJvcnNCeVR5cGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgIHJlcG9ydHMuZm9yRWFjaChyZXBvcnQgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvclR5cGUgPSByZXBvcnQuZXJyb3IuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgZXJyb3JzQnlUeXBlW2Vycm9yVHlwZV0gPSAoZXJyb3JzQnlUeXBlW2Vycm9yVHlwZV0gfHwgMCkgKyAxO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVjZW50RXJyb3JzID0gcmVwb3J0c1xyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKVxyXG4gICAgICAuc2xpY2UoMCwgMTApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsRXJyb3JzLFxyXG4gICAgICByZWNvdmVyZWRFcnJvcnMsXHJcbiAgICAgIHJlY292ZXJ5UmF0ZSxcclxuICAgICAgZXJyb3JzQnlUeXBlLFxyXG4gICAgICByZWNlbnRFcnJvcnMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgb2xkIGVycm9yIHJlcG9ydHNcclxuICAgKi9cclxuICBjbGVhck9sZFJlcG9ydHMobWF4QWdlOiBudW1iZXIgPSAyNCAqIDYwICogNjAgKiAxMDAwKTogdm9pZCB7XHJcbiAgICBjb25zdCBjdXRvZmYgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gbWF4QWdlKTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBbaWQsIHJlcG9ydF0gb2YgdGhpcy5lcnJvclJlcG9ydHMuZW50cmllcygpKSB7XHJcbiAgICAgIGlmIChyZXBvcnQudGltZXN0YW1wIDwgY3V0b2ZmKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvclJlcG9ydHMuZGVsZXRlKGlkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2h1dGRvd24gdGhlIGVycm9yIGhhbmRsZXIgc2VydmljZVxyXG4gICAqL1xyXG4gIGFzeW5jIHNodXRkb3duKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnRXJyb3IgaGFuZGxlciBzZXJ2aWNlIHNodXR0aW5nIGRvd24nLCAnRXJyb3JIYW5kbGVyJyk7XHJcbiAgICBcclxuICAgIC8vIENsZWFyIG9sZCByZXBvcnRzXHJcbiAgICB0aGlzLmNsZWFyT2xkUmVwb3J0cygpO1xyXG4gICAgXHJcbiAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIFxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnRXJyb3IgaGFuZGxlciBzZXJ2aWNlIHNodXRkb3duIGNvbXBsZXRlJywgJ0Vycm9ySGFuZGxlcicpO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/services/error-handler-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/file-system-service.ts":
/*!*****************************************************!*\
  !*** ./src/backend/services/file-system-service.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fileSystemService = exports.FileSystemService = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst fs = tslib_1.__importStar(__webpack_require__(/*! fs-extra */ \"fs-extra\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst settings_types_1 = __webpack_require__(/*! ../../shared/types/settings-types */ \"./src/shared/types/settings-types.ts\");\n// Simple console logger fallback\nconst consoleLogger = {\n    info: (message, meta) => console.log(`[INFO] ${message}`, meta || ''),\n    warn: (message, meta) => console.warn(`[WARN] ${message}`, meta || ''),\n    error: (message, meta) => console.error(`[ERROR] ${message}`, meta || ''),\n    debug: (message, meta) => console.debug(`[DEBUG] ${message}`, meta || ''),\n};\nclass FileSystemService {\n    constructor(logger) {\n        this.logger = logger || consoleLogger;\n        this.appDirectories = this.initializeAppDirectoriesPaths();\n        this.logger.info('FileSystemService initialized successfully', {\n            appDirectories: this.appDirectories,\n        });\n    }\n    /**\n     * Check if a file or directory exists\n     */\n    async exists(filePath) {\n        try {\n            const validation = this.validatePath(filePath);\n            if (!validation.isValid) {\n                this.logger.warn(`Path validation failed for exists check: ${filePath}`, {\n                    errors: validation.errors,\n                });\n                return false;\n            }\n            await fs.access(validation.sanitizedPath);\n            this.logger.debug(`Path exists: ${filePath}`);\n            return true;\n        }\n        catch (error) {\n            this.logger.debug(`Path does not exist: ${filePath}`);\n            return false;\n        }\n    }\n    /**\n     * Read a file with optional encoding\n     */\n    async readFile(filePath, encoding) {\n        try {\n            const validation = this.validatePath(filePath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid path for read operation: ${validation.errors.join(', ')}`, 'INVALID_PATH', filePath, { errors: validation.errors });\n            }\n            const content = encoding\n                ? await fs.readFile(validation.sanitizedPath, encoding)\n                : await fs.readFile(validation.sanitizedPath);\n            this.logger.debug(`File read successfully: ${filePath}`, {\n                size: Buffer.isBuffer(content) ? content.length : content.length,\n                encoding,\n            });\n            return content;\n        }\n        catch (error) {\n            this.logger.error(`Failed to read file: ${filePath}`, { error, encoding });\n            throw new settings_types_1.FileSystemError(`Failed to read file: ${filePath}`, 'READ_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Write content to a file\n     */\n    async writeFile(filePath, content, encoding) {\n        try {\n            const validation = this.validatePath(filePath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid path for write operation: ${validation.errors.join(', ')}`, 'INVALID_PATH', filePath, { errors: validation.errors });\n            }\n            // Ensure parent directory exists\n            const parentDir = path.dirname(validation.sanitizedPath);\n            await this.ensureDirectory(parentDir);\n            // Write the file\n            if (encoding && typeof content === 'string') {\n                await fs.writeFile(validation.sanitizedPath, content, encoding);\n            }\n            else {\n                await fs.writeFile(validation.sanitizedPath, content);\n            }\n            this.logger.info(`File written successfully: ${filePath}`, {\n                size: Buffer.isBuffer(content) ? content.length : content.length,\n                encoding,\n            });\n        }\n        catch (error) {\n            this.logger.error(`Failed to write file: ${filePath}`, { error, encoding });\n            throw new settings_types_1.FileSystemError(`Failed to write file: ${filePath}`, 'WRITE_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Delete a file\n     */\n    async deleteFile(filePath) {\n        try {\n            const validation = this.validatePath(filePath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid path for delete operation: ${validation.errors.join(', ')}`, 'INVALID_PATH', filePath, { errors: validation.errors });\n            }\n            if (!(await this.exists(validation.sanitizedPath))) {\n                this.logger.warn(`Attempted to delete non-existent file: ${filePath}`);\n                return;\n            }\n            await fs.remove(validation.sanitizedPath);\n            this.logger.info(`File deleted successfully: ${filePath}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to delete file: ${filePath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to delete file: ${filePath}`, 'DELETE_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Copy a file from source to destination\n     */\n    async copyFile(source, destination) {\n        try {\n            const sourceValidation = this.validatePath(source);\n            const destValidation = this.validatePath(destination);\n            if (!sourceValidation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid source path: ${sourceValidation.errors.join(', ')}`, 'INVALID_SOURCE_PATH', source, { errors: sourceValidation.errors });\n            }\n            if (!destValidation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid destination path: ${destValidation.errors.join(', ')}`, 'INVALID_DEST_PATH', destination, { errors: destValidation.errors });\n            }\n            // Ensure destination directory exists\n            const destDir = path.dirname(destValidation.sanitizedPath);\n            await this.ensureDirectory(destDir);\n            await fs.copy(sourceValidation.sanitizedPath, destValidation.sanitizedPath);\n            this.logger.info(`File copied successfully: ${source} -> ${destination}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to copy file: ${source} -> ${destination}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to copy file: ${source} -> ${destination}`, 'COPY_ERROR', source, error);\n        }\n    }\n    /**\n     * Move a file from source to destination\n     */\n    async moveFile(source, destination) {\n        try {\n            const sourceValidation = this.validatePath(source);\n            const destValidation = this.validatePath(destination);\n            if (!sourceValidation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid source path: ${sourceValidation.errors.join(', ')}`, 'INVALID_SOURCE_PATH', source, { errors: sourceValidation.errors });\n            }\n            if (!destValidation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid destination path: ${destValidation.errors.join(', ')}`, 'INVALID_DEST_PATH', destination, { errors: destValidation.errors });\n            }\n            // Ensure destination directory exists\n            const destDir = path.dirname(destValidation.sanitizedPath);\n            await this.ensureDirectory(destDir);\n            await fs.move(sourceValidation.sanitizedPath, destValidation.sanitizedPath);\n            this.logger.info(`File moved successfully: ${source} -> ${destination}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to move file: ${source} -> ${destination}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to move file: ${source} -> ${destination}`, 'MOVE_ERROR', source, error);\n        }\n    }\n    /**\n     * Ensure a directory exists, creating it if necessary\n     */\n    async ensureDirectory(dirPath) {\n        try {\n            const validation = this.validatePath(dirPath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid directory path: ${validation.errors.join(', ')}`, 'INVALID_PATH', dirPath, { errors: validation.errors });\n            }\n            await fs.ensureDir(validation.sanitizedPath);\n            this.logger.debug(`Directory ensured: ${dirPath}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to ensure directory: ${dirPath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to ensure directory: ${dirPath}`, 'ENSURE_DIR_ERROR', dirPath, error);\n        }\n    }\n    /**\n     * List directory contents with detailed information\n     */\n    async listDirectory(dirPath) {\n        try {\n            const validation = this.validatePath(dirPath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid directory path: ${validation.errors.join(', ')}`, 'INVALID_PATH', dirPath, { errors: validation.errors });\n            }\n            const exists = await this.exists(validation.sanitizedPath);\n            if (!exists) {\n                return {\n                    path: dirPath,\n                    exists: false,\n                    files: [],\n                    directories: [],\n                    totalItems: 0,\n                };\n            }\n            const items = await fs.readdir(validation.sanitizedPath);\n            const files = [];\n            const directories = [];\n            for (const item of items) {\n                const itemPath = path.join(validation.sanitizedPath, item);\n                const stats = await fs.stat(itemPath);\n                if (stats.isFile()) {\n                    files.push(item);\n                }\n                else if (stats.isDirectory()) {\n                    directories.push(item);\n                }\n            }\n            const result = {\n                path: dirPath,\n                exists: true,\n                files,\n                directories,\n                totalItems: files.length + directories.length,\n            };\n            this.logger.debug(`Directory listed: ${dirPath}`, {\n                fileCount: files.length,\n                dirCount: directories.length,\n            });\n            return result;\n        }\n        catch (error) {\n            this.logger.error(`Failed to list directory: ${dirPath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to list directory: ${dirPath}`, 'LIST_DIR_ERROR', dirPath, error);\n        }\n    }\n    /**\n     * Delete a directory and all its contents\n     */\n    async deleteDirectory(dirPath) {\n        try {\n            const validation = this.validatePath(dirPath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid directory path: ${validation.errors.join(', ')}`, 'INVALID_PATH', dirPath, { errors: validation.errors });\n            }\n            if (!(await this.exists(validation.sanitizedPath))) {\n                this.logger.warn(`Attempted to delete non-existent directory: ${dirPath}`);\n                return;\n            }\n            await fs.remove(validation.sanitizedPath);\n            this.logger.info(`Directory deleted successfully: ${dirPath}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to delete directory: ${dirPath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to delete directory: ${dirPath}`, 'DELETE_DIR_ERROR', dirPath, error);\n        }\n    }\n    /**\n     * Read a JSON file with type safety\n     */\n    async readJson(filePath) {\n        try {\n            const content = await this.readFile(filePath, 'utf8');\n            const data = JSON.parse(content);\n            this.logger.debug(`JSON file read successfully: ${filePath}`);\n            return data;\n        }\n        catch (error) {\n            this.logger.error(`Failed to read JSON file: ${filePath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to read JSON file: ${filePath}`, 'READ_JSON_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Write data to a JSON file with formatting\n     */\n    async writeJson(filePath, data) {\n        try {\n            const content = JSON.stringify(data, null, 2);\n            await this.writeFile(filePath, content, 'utf8');\n            this.logger.debug(`JSON file written successfully: ${filePath}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to write JSON file: ${filePath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to write JSON file: ${filePath}`, 'WRITE_JSON_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Validate and sanitize a file path\n     */\n    validatePath(inputPath, basePath) {\n        const result = {\n            isValid: true,\n            isSecure: true,\n            sanitizedPath: inputPath,\n            errors: [],\n        };\n        try {\n            // Basic validation\n            if (!inputPath || typeof inputPath !== 'string') {\n                result.isValid = false;\n                result.errors.push('Path must be a non-empty string');\n                return result;\n            }\n            // Sanitize the path\n            result.sanitizedPath = this.sanitizePath(inputPath);\n            // Check for directory traversal attempts\n            if (inputPath.includes('..') || inputPath.includes('~')) {\n                result.isSecure = false;\n                result.errors.push('Path contains potentially unsafe characters');\n            }\n            // Validate against base path if provided\n            if (basePath) {\n                const resolvedPath = path.resolve(basePath, result.sanitizedPath);\n                const resolvedBasePath = path.resolve(basePath);\n                if (!resolvedPath.startsWith(resolvedBasePath)) {\n                    result.isValid = false;\n                    result.isSecure = false;\n                    result.errors.push('Path attempts to escape base directory');\n                }\n            }\n            // Check for invalid characters (Windows-specific)\n            const invalidChars = /[<>:\"|?*]/;\n            if (invalidChars.test(path.basename(result.sanitizedPath))) {\n                result.errors.push('Path contains invalid characters');\n            }\n            // Update validity based on security\n            if (!result.isSecure) {\n                result.isValid = false;\n            }\n        }\n        catch (error) {\n            result.isValid = false;\n            result.isSecure = false;\n            result.errors.push(`Path validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n        return result;\n    }\n    /**\n     * Sanitize a path for safe file system operations\n     */\n    sanitizePath(inputPath) {\n        if (!inputPath || typeof inputPath !== 'string') {\n            return '';\n        }\n        // Normalize the path\n        let sanitized = path.normalize(inputPath);\n        // Remove or replace dangerous characters\n        sanitized = sanitized.replace(/[<>:\"|?*]/g, '_');\n        // Remove leading/trailing whitespace\n        sanitized = sanitized.trim();\n        // Handle multiple consecutive separators\n        sanitized = sanitized.replace(/[/\\\\]+/g, path.sep);\n        return sanitized;\n    }\n    /**\n     * Resolve multiple path segments safely\n     */\n    resolvePath(...paths) {\n        try {\n            const resolved = path.resolve(...paths);\n            return this.sanitizePath(resolved);\n        }\n        catch (error) {\n            this.logger.error('Failed to resolve path', { paths, error });\n            throw new settings_types_1.FileSystemError('Failed to resolve path', 'RESOLVE_PATH_ERROR', paths.join(' -> '), error);\n        }\n    }\n    /**\n     * Get detailed file/directory statistics\n     */\n    async getStats(filePath) {\n        try {\n            const validation = this.validatePath(filePath);\n            if (!validation.isValid) {\n                throw new settings_types_1.FileSystemError(`Invalid path for stats operation: ${validation.errors.join(', ')}`, 'INVALID_PATH', filePath, { errors: validation.errors });\n            }\n            const stats = await fs.stat(validation.sanitizedPath);\n            const result = {\n                size: stats.size,\n                isFile: stats.isFile(),\n                isDirectory: stats.isDirectory(),\n                createdAt: stats.birthtime,\n                modifiedAt: stats.mtime,\n                accessedAt: stats.atime,\n            };\n            this.logger.debug(`Stats retrieved for: ${filePath}`, result);\n            return result;\n        }\n        catch (error) {\n            this.logger.error(`Failed to get stats for: ${filePath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to get stats for: ${filePath}`, 'STATS_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Get file size in bytes\n     */\n    async getSize(filePath) {\n        try {\n            const stats = await this.getStats(filePath);\n            return stats.size;\n        }\n        catch (error) {\n            this.logger.error(`Failed to get size for: ${filePath}`, { error });\n            throw new settings_types_1.FileSystemError(`Failed to get size for: ${filePath}`, 'SIZE_ERROR', filePath, error);\n        }\n    }\n    /**\n     * Get application directory structure\n     */\n    getAppDirectories() {\n        return { ...this.appDirectories };\n    }\n    /**\n     * Initialize all application directories\n     */\n    async initializeAppDirectories() {\n        try {\n            const directories = Object.values(this.appDirectories);\n            for (const dir of directories) {\n                await this.ensureDirectory(dir);\n            }\n            this.logger.info('Application directories initialized successfully', {\n                directories: this.appDirectories,\n            });\n        }\n        catch (error) {\n            this.logger.error('Failed to initialize application directories', { error });\n            throw new settings_types_1.FileSystemError('Failed to initialize application directories', 'INIT_DIRS_ERROR', undefined, error);\n        }\n    }\n    /**\n     * Clean up temporary files\n     */\n    async cleanupTempFiles() {\n        try {\n            const tempDir = this.appDirectories.temp;\n            if (await this.exists(tempDir)) {\n                // Remove all contents but keep the directory\n                const contents = await this.listDirectory(tempDir);\n                for (const file of contents.files) {\n                    await this.deleteFile(path.join(tempDir, file));\n                }\n                for (const dir of contents.directories) {\n                    await this.deleteDirectory(path.join(tempDir, dir));\n                }\n                this.logger.info('Temporary files cleaned up successfully', {\n                    filesRemoved: contents.files.length,\n                    dirsRemoved: contents.directories.length,\n                });\n            }\n        }\n        catch (error) {\n            this.logger.error('Failed to cleanup temporary files', { error });\n            // Don't throw here - cleanup failures shouldn't break the app\n        }\n    }\n    /**\n     * Clean up old log files\n     */\n    async cleanupOldLogs(maxAge) {\n        try {\n            const logsDir = this.appDirectories.logs;\n            if (!(await this.exists(logsDir))) {\n                return;\n            }\n            const contents = await this.listDirectory(logsDir);\n            const cutoffDate = new Date(Date.now() - maxAge);\n            let removedCount = 0;\n            for (const file of contents.files) {\n                const filePath = path.join(logsDir, file);\n                const stats = await this.getStats(filePath);\n                if (stats.modifiedAt < cutoffDate) {\n                    await this.deleteFile(filePath);\n                    removedCount++;\n                }\n            }\n            this.logger.info('Old log files cleaned up successfully', {\n                removedCount,\n                maxAge,\n            });\n        }\n        catch (error) {\n            this.logger.error('Failed to cleanup old logs', { error, maxAge });\n            // Don't throw here - cleanup failures shouldn't break the app\n        }\n    }\n    /**\n     * Initialize application directory paths\n     */\n    initializeAppDirectoriesPaths() {\n        const userData = electron_1.app.getPath('userData');\n        return {\n            userData,\n            downloads: path.join(electron_1.app.getPath('downloads'), 'Playlistify'),\n            temp: path.join(userData, 'temp'),\n            logs: path.join(userData, 'logs'),\n            cache: path.join(userData, 'cache'),\n            dependencies: path.join(userData, 'dependencies'),\n            config: path.join(userData, 'config'),\n        };\n    }\n}\nexports.FileSystemService = FileSystemService;\n// Export a singleton instance\nexports.fileSystemService = new FileSystemService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9maWxlLXN5c3RlbS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRkFBK0I7QUFDL0IsMkVBQTZCO0FBQzdCLG1FQUErQjtBQUMvQiw4SEFRMkM7QUFVM0MsaUNBQWlDO0FBQ2pDLE1BQU0sYUFBYSxHQUFXO0lBQzVCLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxPQUFPLEVBQUUsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3JFLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxPQUFPLEVBQUUsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3RFLEtBQUssRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxPQUFPLEVBQUUsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3pFLEtBQUssRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxPQUFPLEVBQUUsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0NBQzFFLENBQUM7QUFFRixNQUFhLGlCQUFpQjtJQUk1QixZQUFZLE1BQWU7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLElBQUksYUFBYSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLDZCQUE2QixFQUFFLENBQUM7UUFFM0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsNENBQTRDLEVBQUU7WUFDN0QsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO1NBQ3BDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsUUFB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QUFjLENBQUM7WUFDakQsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQztTQUN0QyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBNXBCRCw4Q0E0cEJDO0FBRUQsOEJBQThCO0FBQ2pCLHlCQUFpQixHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vc3JjL2JhY2tlbmQvc2VydmljZXMvZmlsZS1zeXN0ZW0tc2VydmljZS50cz8xZTUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHsgYXBwIH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQge1xyXG4gIElGaWxlU3lzdGVtU2VydmljZSxcclxuICBGaWxlU3lzdGVtU3RhdHMsXHJcbiAgRGlyZWN0b3J5U3RydWN0dXJlLFxyXG4gIEZpbGVPcGVyYXRpb25SZXN1bHQsXHJcbiAgUGF0aFZhbGlkYXRpb25SZXN1bHQsXHJcbiAgQXBwRGlyZWN0b3JpZXMsXHJcbiAgRmlsZVN5c3RlbUVycm9yLFxyXG59IGZyb20gJy4uLy4uL3NoYXJlZC90eXBlcy9zZXR0aW5ncy10eXBlcyc7XHJcblxyXG4vLyBMb2dnZXIgaW50ZXJmYWNlICh3aWxsIGJlIGltcGxlbWVudGVkIGluIHRhc2sgMTApXHJcbmludGVyZmFjZSBMb2dnZXIge1xyXG4gIGluZm8obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogYW55KTogdm9pZDtcclxuICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IGFueSk6IHZvaWQ7XHJcbiAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBtZXRhPzogYW55KTogdm9pZDtcclxuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBhbnkpOiB2b2lkO1xyXG59XHJcblxyXG4vLyBTaW1wbGUgY29uc29sZSBsb2dnZXIgZmFsbGJhY2tcclxuY29uc3QgY29uc29sZUxvZ2dlcjogTG9nZ2VyID0ge1xyXG4gIGluZm86IChtZXNzYWdlLCBtZXRhKSA9PiBjb25zb2xlLmxvZyhgW0lORk9dICR7bWVzc2FnZX1gLCBtZXRhIHx8ICcnKSxcclxuICB3YXJuOiAobWVzc2FnZSwgbWV0YSkgPT4gY29uc29sZS53YXJuKGBbV0FSTl0gJHttZXNzYWdlfWAsIG1ldGEgfHwgJycpLFxyXG4gIGVycm9yOiAobWVzc2FnZSwgbWV0YSkgPT4gY29uc29sZS5lcnJvcihgW0VSUk9SXSAke21lc3NhZ2V9YCwgbWV0YSB8fCAnJyksXHJcbiAgZGVidWc6IChtZXNzYWdlLCBtZXRhKSA9PiBjb25zb2xlLmRlYnVnKGBbREVCVUddICR7bWVzc2FnZX1gLCBtZXRhIHx8ICcnKSxcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlU3lzdGVtU2VydmljZSBpbXBsZW1lbnRzIElGaWxlU3lzdGVtU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcclxuICBwcml2YXRlIGFwcERpcmVjdG9yaWVzOiBBcHBEaXJlY3RvcmllcztcclxuXHJcbiAgY29uc3RydWN0b3IobG9nZ2VyPzogTG9nZ2VyKSB7XHJcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlciB8fCBjb25zb2xlTG9nZ2VyO1xyXG4gICAgdGhpcy5hcHBEaXJlY3RvcmllcyA9IHRoaXMuaW5pdGlhbGl6ZUFwcERpcmVjdG9yaWVzUGF0aHMoKTtcclxuICAgIFxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnRmlsZVN5c3RlbVNlcnZpY2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jywge1xyXG4gICAgICBhcHBEaXJlY3RvcmllczogdGhpcy5hcHBEaXJlY3RvcmllcyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBmaWxlIG9yIGRpcmVjdG9yeSBleGlzdHNcclxuICAgKi9cclxuICBhc3luYyBleGlzdHMoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQYXRoKGZpbGVQYXRoKTtcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBQYXRoIHZhbGlkYXRpb24gZmFpbGVkIGZvciBleGlzdHMgY2hlY2s6ICR7ZmlsZVBhdGh9YCwge1xyXG4gICAgICAgICAgZXJyb3JzOiB2YWxpZGF0aW9uLmVycm9ycyxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF3YWl0IGZzLmFjY2Vzcyh2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgUGF0aCBleGlzdHM6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFBhdGggZG9lcyBub3QgZXhpc3Q6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBmaWxlIHdpdGggb3B0aW9uYWwgZW5jb2RpbmdcclxuICAgKi9cclxuICBhc3luYyByZWFkRmlsZShmaWxlUGF0aDogc3RyaW5nLCBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBCdWZmZXI+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUGF0aChmaWxlUGF0aCk7XHJcbiAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIHBhdGggZm9yIHJlYWQgb3BlcmF0aW9uOiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCxcclxuICAgICAgICAgICdJTlZBTElEX1BBVEgnLFxyXG4gICAgICAgICAgZmlsZVBhdGgsXHJcbiAgICAgICAgICB7IGVycm9yczogdmFsaWRhdGlvbi5lcnJvcnMgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbmNvZGluZyBcclxuICAgICAgICA/IGF3YWl0IGZzLnJlYWRGaWxlKHZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCwgZW5jb2RpbmcpXHJcbiAgICAgICAgOiBhd2FpdCBmcy5yZWFkRmlsZSh2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgpO1xyXG5cclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEZpbGUgcmVhZCBzdWNjZXNzZnVsbHk6ICR7ZmlsZVBhdGh9YCwge1xyXG4gICAgICAgIHNpemU6IEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSA/IGNvbnRlbnQubGVuZ3RoIDogY29udGVudC5sZW5ndGgsXHJcbiAgICAgICAgZW5jb2RpbmcsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJlYWQgZmlsZTogJHtmaWxlUGF0aH1gLCB7IGVycm9yLCBlbmNvZGluZyB9KTtcclxuICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICBgRmFpbGVkIHRvIHJlYWQgZmlsZTogJHtmaWxlUGF0aH1gLFxyXG4gICAgICAgICdSRUFEX0VSUk9SJyxcclxuICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV3JpdGUgY29udGVudCB0byBhIGZpbGVcclxuICAgKi9cclxuICBhc3luYyB3cml0ZUZpbGUoZmlsZVBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nIHwgQnVmZmVyLCBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVBhdGgoZmlsZVBhdGgpO1xyXG4gICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBwYXRoIGZvciB3cml0ZSBvcGVyYXRpb246ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gLFxyXG4gICAgICAgICAgJ0lOVkFMSURfUEFUSCcsXHJcbiAgICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICAgIHsgZXJyb3JzOiB2YWxpZGF0aW9uLmVycm9ycyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5zdXJlIHBhcmVudCBkaXJlY3RvcnkgZXhpc3RzXHJcbiAgICAgIGNvbnN0IHBhcmVudERpciA9IHBhdGguZGlybmFtZSh2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgpO1xyXG4gICAgICBhd2FpdCB0aGlzLmVuc3VyZURpcmVjdG9yeShwYXJlbnREaXIpO1xyXG5cclxuICAgICAgLy8gV3JpdGUgdGhlIGZpbGVcclxuICAgICAgaWYgKGVuY29kaW5nICYmIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZSh2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgsIGNvbnRlbnQsIGVuY29kaW5nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUodmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoLCBjb250ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRmlsZSB3cml0dGVuIHN1Y2Nlc3NmdWxseTogJHtmaWxlUGF0aH1gLCB7XHJcbiAgICAgICAgc2l6ZTogQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpID8gY29udGVudC5sZW5ndGggOiBjb250ZW50Lmxlbmd0aCxcclxuICAgICAgICBlbmNvZGluZyxcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGU6ICR7ZmlsZVBhdGh9YCwgeyBlcnJvciwgZW5jb2RpbmcgfSk7XHJcbiAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byB3cml0ZSBmaWxlOiAke2ZpbGVQYXRofWAsXHJcbiAgICAgICAgJ1dSSVRFX0VSUk9SJyxcclxuICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZmlsZVxyXG4gICAqL1xyXG4gIGFzeW5jIGRlbGV0ZUZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQYXRoKGZpbGVQYXRoKTtcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgcGF0aCBmb3IgZGVsZXRlIG9wZXJhdGlvbjogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKCcsICcpfWAsXHJcbiAgICAgICAgICAnSU5WQUxJRF9QQVRIJyxcclxuICAgICAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAgICAgeyBlcnJvcnM6IHZhbGlkYXRpb24uZXJyb3JzIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShhd2FpdCB0aGlzLmV4aXN0cyh2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgpKSkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEF0dGVtcHRlZCB0byBkZWxldGUgbm9uLWV4aXN0ZW50IGZpbGU6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCBmcy5yZW1vdmUodmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRmlsZSBkZWxldGVkIHN1Y2Nlc3NmdWxseTogJHtmaWxlUGF0aH1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIGZpbGU6ICR7ZmlsZVBhdGh9YCwgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICBgRmFpbGVkIHRvIGRlbGV0ZSBmaWxlOiAke2ZpbGVQYXRofWAsXHJcbiAgICAgICAgJ0RFTEVURV9FUlJPUicsXHJcbiAgICAgICAgZmlsZVBhdGgsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcHkgYSBmaWxlIGZyb20gc291cmNlIHRvIGRlc3RpbmF0aW9uXHJcbiAgICovXHJcbiAgYXN5bmMgY29weUZpbGUoc291cmNlOiBzdHJpbmcsIGRlc3RpbmF0aW9uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHNvdXJjZVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUGF0aChzb3VyY2UpO1xyXG4gICAgICBjb25zdCBkZXN0VmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQYXRoKGRlc3RpbmF0aW9uKTtcclxuXHJcbiAgICAgIGlmICghc291cmNlVmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIHNvdXJjZSBwYXRoOiAke3NvdXJjZVZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCxcclxuICAgICAgICAgICdJTlZBTElEX1NPVVJDRV9QQVRIJyxcclxuICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgIHsgZXJyb3JzOiBzb3VyY2VWYWxpZGF0aW9uLmVycm9ycyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkZXN0VmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIGRlc3RpbmF0aW9uIHBhdGg6ICR7ZGVzdFZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCxcclxuICAgICAgICAgICdJTlZBTElEX0RFU1RfUEFUSCcsXHJcbiAgICAgICAgICBkZXN0aW5hdGlvbixcclxuICAgICAgICAgIHsgZXJyb3JzOiBkZXN0VmFsaWRhdGlvbi5lcnJvcnMgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEVuc3VyZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgZXhpc3RzXHJcbiAgICAgIGNvbnN0IGRlc3REaXIgPSBwYXRoLmRpcm5hbWUoZGVzdFZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KGRlc3REaXIpO1xyXG5cclxuICAgICAgYXdhaXQgZnMuY29weShzb3VyY2VWYWxpZGF0aW9uLnNhbml0aXplZFBhdGgsIGRlc3RWYWxpZGF0aW9uLnNhbml0aXplZFBhdGgpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBGaWxlIGNvcGllZCBzdWNjZXNzZnVsbHk6ICR7c291cmNlfSAtPiAke2Rlc3RpbmF0aW9ufWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBjb3B5IGZpbGU6ICR7c291cmNlfSAtPiAke2Rlc3RpbmF0aW9ufWAsIHsgZXJyb3IgfSk7XHJcbiAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBjb3B5IGZpbGU6ICR7c291cmNlfSAtPiAke2Rlc3RpbmF0aW9ufWAsXHJcbiAgICAgICAgJ0NPUFlfRVJST1InLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSBhIGZpbGUgZnJvbSBzb3VyY2UgdG8gZGVzdGluYXRpb25cclxuICAgKi9cclxuICBhc3luYyBtb3ZlRmlsZShzb3VyY2U6IHN0cmluZywgZGVzdGluYXRpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc291cmNlVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQYXRoKHNvdXJjZSk7XHJcbiAgICAgIGNvbnN0IGRlc3RWYWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVBhdGgoZGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgaWYgKCFzb3VyY2VWYWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgc291cmNlIHBhdGg6ICR7c291cmNlVmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gLFxyXG4gICAgICAgICAgJ0lOVkFMSURfU09VUkNFX1BBVEgnLFxyXG4gICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgeyBlcnJvcnM6IHNvdXJjZVZhbGlkYXRpb24uZXJyb3JzIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWRlc3RWYWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgZGVzdGluYXRpb24gcGF0aDogJHtkZXN0VmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gLFxyXG4gICAgICAgICAgJ0lOVkFMSURfREVTVF9QQVRIJyxcclxuICAgICAgICAgIGRlc3RpbmF0aW9uLFxyXG4gICAgICAgICAgeyBlcnJvcnM6IGRlc3RWYWxpZGF0aW9uLmVycm9ycyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5zdXJlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBleGlzdHNcclxuICAgICAgY29uc3QgZGVzdERpciA9IHBhdGguZGlybmFtZShkZXN0VmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoKTtcclxuICAgICAgYXdhaXQgdGhpcy5lbnN1cmVEaXJlY3RvcnkoZGVzdERpcik7XHJcblxyXG4gICAgICBhd2FpdCBmcy5tb3ZlKHNvdXJjZVZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCwgZGVzdFZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYEZpbGUgbW92ZWQgc3VjY2Vzc2Z1bGx5OiAke3NvdXJjZX0gLT4gJHtkZXN0aW5hdGlvbn1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbW92ZSBmaWxlOiAke3NvdXJjZX0gLT4gJHtkZXN0aW5hdGlvbn1gLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gbW92ZSBmaWxlOiAke3NvdXJjZX0gLT4gJHtkZXN0aW5hdGlvbn1gLFxyXG4gICAgICAgICdNT1ZFX0VSUk9SJyxcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuc3VyZSBhIGRpcmVjdG9yeSBleGlzdHMsIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAqL1xyXG4gIGFzeW5jIGVuc3VyZURpcmVjdG9yeShkaXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUGF0aChkaXJQYXRoKTtcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICAgYEludmFsaWQgZGlyZWN0b3J5IHBhdGg6ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gLFxyXG4gICAgICAgICAgJ0lOVkFMSURfUEFUSCcsXHJcbiAgICAgICAgICBkaXJQYXRoLFxyXG4gICAgICAgICAgeyBlcnJvcnM6IHZhbGlkYXRpb24uZXJyb3JzIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCBmcy5lbnN1cmVEaXIodmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYERpcmVjdG9yeSBlbnN1cmVkOiAke2RpclBhdGh9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGVuc3VyZSBkaXJlY3Rvcnk6ICR7ZGlyUGF0aH1gLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gZW5zdXJlIGRpcmVjdG9yeTogJHtkaXJQYXRofWAsXHJcbiAgICAgICAgJ0VOU1VSRV9ESVJfRVJST1InLFxyXG4gICAgICAgIGRpclBhdGgsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3QgZGlyZWN0b3J5IGNvbnRlbnRzIHdpdGggZGV0YWlsZWQgaW5mb3JtYXRpb25cclxuICAgKi9cclxuICBhc3luYyBsaXN0RGlyZWN0b3J5KGRpclBhdGg6IHN0cmluZyk6IFByb21pc2U8RGlyZWN0b3J5U3RydWN0dXJlPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVBhdGgoZGlyUGF0aCk7XHJcbiAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIGRpcmVjdG9yeSBwYXRoOiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCxcclxuICAgICAgICAgICdJTlZBTElEX1BBVEgnLFxyXG4gICAgICAgICAgZGlyUGF0aCxcclxuICAgICAgICAgIHsgZXJyb3JzOiB2YWxpZGF0aW9uLmVycm9ycyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZXhpc3RzID0gYXdhaXQgdGhpcy5leGlzdHModmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoKTtcclxuICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcGF0aDogZGlyUGF0aCxcclxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXHJcbiAgICAgICAgICBmaWxlczogW10sXHJcbiAgICAgICAgICBkaXJlY3RvcmllczogW10sXHJcbiAgICAgICAgICB0b3RhbEl0ZW1zOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgZnMucmVhZGRpcih2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgpO1xyXG4gICAgICBjb25zdCBmaWxlczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgY29uc3QgZGlyZWN0b3JpZXM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuICAgICAgICBjb25zdCBpdGVtUGF0aCA9IHBhdGguam9pbih2YWxpZGF0aW9uLnNhbml0aXplZFBhdGgsIGl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMuc3RhdChpdGVtUGF0aCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XHJcbiAgICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICAgICAgZGlyZWN0b3JpZXMucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdDogRGlyZWN0b3J5U3RydWN0dXJlID0ge1xyXG4gICAgICAgIHBhdGg6IGRpclBhdGgsXHJcbiAgICAgICAgZXhpc3RzOiB0cnVlLFxyXG4gICAgICAgIGZpbGVzLFxyXG4gICAgICAgIGRpcmVjdG9yaWVzLFxyXG4gICAgICAgIHRvdGFsSXRlbXM6IGZpbGVzLmxlbmd0aCArIGRpcmVjdG9yaWVzLmxlbmd0aCxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBEaXJlY3RvcnkgbGlzdGVkOiAke2RpclBhdGh9YCwge1xyXG4gICAgICAgIGZpbGVDb3VudDogZmlsZXMubGVuZ3RoLFxyXG4gICAgICAgIGRpckNvdW50OiBkaXJlY3Rvcmllcy5sZW5ndGgsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gbGlzdCBkaXJlY3Rvcnk6ICR7ZGlyUGF0aH1gLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gbGlzdCBkaXJlY3Rvcnk6ICR7ZGlyUGF0aH1gLFxyXG4gICAgICAgICdMSVNUX0RJUl9FUlJPUicsXHJcbiAgICAgICAgZGlyUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZGlyZWN0b3J5IGFuZCBhbGwgaXRzIGNvbnRlbnRzXHJcbiAgICovXHJcbiAgYXN5bmMgZGVsZXRlRGlyZWN0b3J5KGRpclBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVQYXRoKGRpclBhdGgpO1xyXG4gICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBkaXJlY3RvcnkgcGF0aDogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKCcsICcpfWAsXHJcbiAgICAgICAgICAnSU5WQUxJRF9QQVRIJyxcclxuICAgICAgICAgIGRpclBhdGgsXHJcbiAgICAgICAgICB7IGVycm9yczogdmFsaWRhdGlvbi5lcnJvcnMgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGF3YWl0IHRoaXMuZXhpc3RzKHZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCkpKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgQXR0ZW1wdGVkIHRvIGRlbGV0ZSBub24tZXhpc3RlbnQgZGlyZWN0b3J5OiAke2RpclBhdGh9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCBmcy5yZW1vdmUodmFsaWRhdGlvbi5zYW5pdGl6ZWRQYXRoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRGlyZWN0b3J5IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5OiAke2RpclBhdGh9YCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBkaXJlY3Rvcnk6ICR7ZGlyUGF0aH1gLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gZGVsZXRlIGRpcmVjdG9yeTogJHtkaXJQYXRofWAsXHJcbiAgICAgICAgJ0RFTEVURV9ESVJfRVJST1InLFxyXG4gICAgICAgIGRpclBhdGgsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBKU09OIGZpbGUgd2l0aCB0eXBlIHNhZmV0eVxyXG4gICAqL1xyXG4gIGFzeW5jIHJlYWRKc29uPFQgPSBhbnk+KGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpIGFzIHN0cmluZztcclxuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBKU09OIGZpbGUgcmVhZCBzdWNjZXNzZnVsbHk6ICR7ZmlsZVBhdGh9YCk7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byByZWFkIEpTT04gZmlsZTogJHtmaWxlUGF0aH1gLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gcmVhZCBKU09OIGZpbGU6ICR7ZmlsZVBhdGh9YCxcclxuICAgICAgICAnUkVBRF9KU09OX0VSUk9SJyxcclxuICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV3JpdGUgZGF0YSB0byBhIEpTT04gZmlsZSB3aXRoIGZvcm1hdHRpbmdcclxuICAgKi9cclxuICBhc3luYyB3cml0ZUpzb24oZmlsZVBhdGg6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XHJcbiAgICAgIGF3YWl0IHRoaXMud3JpdGVGaWxlKGZpbGVQYXRoLCBjb250ZW50LCAndXRmOCcpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgSlNPTiBmaWxlIHdyaXR0ZW4gc3VjY2Vzc2Z1bGx5OiAke2ZpbGVQYXRofWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byB3cml0ZSBKU09OIGZpbGU6ICR7ZmlsZVBhdGh9YCwgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IEZpbGVTeXN0ZW1FcnJvcihcclxuICAgICAgICBgRmFpbGVkIHRvIHdyaXRlIEpTT04gZmlsZTogJHtmaWxlUGF0aH1gLFxyXG4gICAgICAgICdXUklURV9KU09OX0VSUk9SJyxcclxuICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYW5kIHNhbml0aXplIGEgZmlsZSBwYXRoXHJcbiAgICovXHJcbiAgdmFsaWRhdGVQYXRoKGlucHV0UGF0aDogc3RyaW5nLCBiYXNlUGF0aD86IHN0cmluZyk6IFBhdGhWYWxpZGF0aW9uUmVzdWx0IHtcclxuICAgIGNvbnN0IHJlc3VsdDogUGF0aFZhbGlkYXRpb25SZXN1bHQgPSB7XHJcbiAgICAgIGlzVmFsaWQ6IHRydWUsXHJcbiAgICAgIGlzU2VjdXJlOiB0cnVlLFxyXG4gICAgICBzYW5pdGl6ZWRQYXRoOiBpbnB1dFBhdGgsXHJcbiAgICAgIGVycm9yczogW10sXHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cclxuICAgICAgaWYgKCFpbnB1dFBhdGggfHwgdHlwZW9mIGlucHV0UGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaCgnUGF0aCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNhbml0aXplIHRoZSBwYXRoXHJcbiAgICAgIHJlc3VsdC5zYW5pdGl6ZWRQYXRoID0gdGhpcy5zYW5pdGl6ZVBhdGgoaW5wdXRQYXRoKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBkaXJlY3RvcnkgdHJhdmVyc2FsIGF0dGVtcHRzXHJcbiAgICAgIGlmIChpbnB1dFBhdGguaW5jbHVkZXMoJy4uJykgfHwgaW5wdXRQYXRoLmluY2x1ZGVzKCd+JykpIHtcclxuICAgICAgICByZXN1bHQuaXNTZWN1cmUgPSBmYWxzZTtcclxuICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goJ1BhdGggY29udGFpbnMgcG90ZW50aWFsbHkgdW5zYWZlIGNoYXJhY3RlcnMnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgYWdhaW5zdCBiYXNlIHBhdGggaWYgcHJvdmlkZWRcclxuICAgICAgaWYgKGJhc2VQYXRoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCByZXN1bHQuc2FuaXRpemVkUGF0aCk7XHJcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRCYXNlUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFyZXNvbHZlZFBhdGguc3RhcnRzV2l0aChyZXNvbHZlZEJhc2VQYXRoKSkge1xyXG4gICAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgIHJlc3VsdC5pc1NlY3VyZSA9IGZhbHNlO1xyXG4gICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKCdQYXRoIGF0dGVtcHRzIHRvIGVzY2FwZSBiYXNlIGRpcmVjdG9yeScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgY2hhcmFjdGVycyAoV2luZG93cy1zcGVjaWZpYylcclxuICAgICAgY29uc3QgaW52YWxpZENoYXJzID0gL1s8PjpcInw/Kl0vO1xyXG4gICAgICBpZiAoaW52YWxpZENoYXJzLnRlc3QocGF0aC5iYXNlbmFtZShyZXN1bHQuc2FuaXRpemVkUGF0aCkpKSB7XHJcbiAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKCdQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdmFsaWRpdHkgYmFzZWQgb24gc2VjdXJpdHlcclxuICAgICAgaWYgKCFyZXN1bHQuaXNTZWN1cmUpIHtcclxuICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgcmVzdWx0LmlzU2VjdXJlID0gZmFsc2U7XHJcbiAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChgUGF0aCB2YWxpZGF0aW9uIGVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYW5pdGl6ZSBhIHBhdGggZm9yIHNhZmUgZmlsZSBzeXN0ZW0gb3BlcmF0aW9uc1xyXG4gICAqL1xyXG4gIHNhbml0aXplUGF0aChpbnB1dFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBpZiAoIWlucHV0UGF0aCB8fCB0eXBlb2YgaW5wdXRQYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXHJcbiAgICBsZXQgc2FuaXRpemVkID0gcGF0aC5ub3JtYWxpemUoaW5wdXRQYXRoKTtcclxuICAgIFxyXG4gICAgLy8gUmVtb3ZlIG9yIHJlcGxhY2UgZGFuZ2Vyb3VzIGNoYXJhY3RlcnNcclxuICAgIHNhbml0aXplZCA9IHNhbml0aXplZC5yZXBsYWNlKC9bPD46XCJ8PypdL2csICdfJyk7XHJcbiAgICBcclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcclxuICAgIHNhbml0aXplZCA9IHNhbml0aXplZC50cmltKCk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBzZXBhcmF0b3JzXHJcbiAgICBzYW5pdGl6ZWQgPSBzYW5pdGl6ZWQucmVwbGFjZSgvWy9cXFxcXSsvZywgcGF0aC5zZXApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gc2FuaXRpemVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzb2x2ZSBtdWx0aXBsZSBwYXRoIHNlZ21lbnRzIHNhZmVseVxyXG4gICAqL1xyXG4gIHJlc29sdmVQYXRoKC4uLnBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNvbHZlZCA9IHBhdGgucmVzb2x2ZSguLi5wYXRocyk7XHJcbiAgICAgIHJldHVybiB0aGlzLnNhbml0aXplUGF0aChyZXNvbHZlZCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJlc29sdmUgcGF0aCcsIHsgcGF0aHMsIGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSBwYXRoJyxcclxuICAgICAgICAnUkVTT0xWRV9QQVRIX0VSUk9SJyxcclxuICAgICAgICBwYXRocy5qb2luKCcgLT4gJyksXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBkZXRhaWxlZCBmaWxlL2RpcmVjdG9yeSBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U3RhdHMoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8RmlsZVN5c3RlbVN0YXRzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVBhdGgoZmlsZVBhdGgpO1xyXG4gICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBwYXRoIGZvciBzdGF0cyBvcGVyYXRpb246ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gLFxyXG4gICAgICAgICAgJ0lOVkFMSURfUEFUSCcsXHJcbiAgICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICAgIHsgZXJyb3JzOiB2YWxpZGF0aW9uLmVycm9ycyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KHZhbGlkYXRpb24uc2FuaXRpemVkUGF0aCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXN1bHQ6IEZpbGVTeXN0ZW1TdGF0cyA9IHtcclxuICAgICAgICBzaXplOiBzdGF0cy5zaXplLFxyXG4gICAgICAgIGlzRmlsZTogc3RhdHMuaXNGaWxlKCksXHJcbiAgICAgICAgaXNEaXJlY3Rvcnk6IHN0YXRzLmlzRGlyZWN0b3J5KCksXHJcbiAgICAgICAgY3JlYXRlZEF0OiBzdGF0cy5iaXJ0aHRpbWUsXHJcbiAgICAgICAgbW9kaWZpZWRBdDogc3RhdHMubXRpbWUsXHJcbiAgICAgICAgYWNjZXNzZWRBdDogc3RhdHMuYXRpbWUsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3RhdHMgcmV0cmlldmVkIGZvcjogJHtmaWxlUGF0aH1gLCByZXN1bHQpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBnZXQgc3RhdHMgZm9yOiAke2ZpbGVQYXRofWAsIHsgZXJyb3IgfSk7XHJcbiAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgc3RhdHMgZm9yOiAke2ZpbGVQYXRofWAsXHJcbiAgICAgICAgJ1NUQVRTX0VSUk9SJyxcclxuICAgICAgICBmaWxlUGF0aCxcclxuICAgICAgICBlcnJvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGZpbGUgc2l6ZSBpbiBieXRlc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldFNpemUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuZ2V0U3RhdHMoZmlsZVBhdGgpO1xyXG4gICAgICByZXR1cm4gc3RhdHMuc2l6ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IHNpemUgZm9yOiAke2ZpbGVQYXRofWAsIHsgZXJyb3IgfSk7XHJcbiAgICAgIHRocm93IG5ldyBGaWxlU3lzdGVtRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgc2l6ZSBmb3I6ICR7ZmlsZVBhdGh9YCxcclxuICAgICAgICAnU0laRV9FUlJPUicsXHJcbiAgICAgICAgZmlsZVBhdGgsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhcHBsaWNhdGlvbiBkaXJlY3Rvcnkgc3RydWN0dXJlXHJcbiAgICovXHJcbiAgZ2V0QXBwRGlyZWN0b3JpZXMoKTogQXBwRGlyZWN0b3JpZXMge1xyXG4gICAgcmV0dXJuIHsgLi4udGhpcy5hcHBEaXJlY3RvcmllcyB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhbGwgYXBwbGljYXRpb24gZGlyZWN0b3JpZXNcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplQXBwRGlyZWN0b3JpZXMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkaXJlY3RvcmllcyA9IE9iamVjdC52YWx1ZXModGhpcy5hcHBEaXJlY3Rvcmllcyk7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJlY3Rvcmllcykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KGRpcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0FwcGxpY2F0aW9uIGRpcmVjdG9yaWVzIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScsIHtcclxuICAgICAgICBkaXJlY3RvcmllczogdGhpcy5hcHBEaXJlY3RvcmllcyxcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgYXBwbGljYXRpb24gZGlyZWN0b3JpZXMnLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRmlsZVN5c3RlbUVycm9yKFxyXG4gICAgICAgICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHBsaWNhdGlvbiBkaXJlY3RvcmllcycsXHJcbiAgICAgICAgJ0lOSVRfRElSU19FUlJPUicsXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIGVycm9yXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCB0ZW1wb3JhcnkgZmlsZXNcclxuICAgKi9cclxuICBhc3luYyBjbGVhbnVwVGVtcEZpbGVzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdGVtcERpciA9IHRoaXMuYXBwRGlyZWN0b3JpZXMudGVtcDtcclxuICAgICAgXHJcbiAgICAgIGlmIChhd2FpdCB0aGlzLmV4aXN0cyh0ZW1wRGlyKSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgY29udGVudHMgYnV0IGtlZXAgdGhlIGRpcmVjdG9yeVxyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5saXN0RGlyZWN0b3J5KHRlbXBEaXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBjb250ZW50cy5maWxlcykge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVGaWxlKHBhdGguam9pbih0ZW1wRGlyLCBmaWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIGNvbnRlbnRzLmRpcmVjdG9yaWVzKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZURpcmVjdG9yeShwYXRoLmpvaW4odGVtcERpciwgZGlyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdUZW1wb3JhcnkgZmlsZXMgY2xlYW5lZCB1cCBzdWNjZXNzZnVsbHknLCB7XHJcbiAgICAgICAgICBmaWxlc1JlbW92ZWQ6IGNvbnRlbnRzLmZpbGVzLmxlbmd0aCxcclxuICAgICAgICAgIGRpcnNSZW1vdmVkOiBjb250ZW50cy5kaXJlY3Rvcmllcy5sZW5ndGgsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY2xlYW51cCB0ZW1wb3JhcnkgZmlsZXMnLCB7IGVycm9yIH0pO1xyXG4gICAgICAvLyBEb24ndCB0aHJvdyBoZXJlIC0gY2xlYW51cCBmYWlsdXJlcyBzaG91bGRuJ3QgYnJlYWsgdGhlIGFwcFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYW4gdXAgb2xkIGxvZyBmaWxlc1xyXG4gICAqL1xyXG4gIGFzeW5jIGNsZWFudXBPbGRMb2dzKG1heEFnZTogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBsb2dzRGlyID0gdGhpcy5hcHBEaXJlY3Rvcmllcy5sb2dzO1xyXG4gICAgICBcclxuICAgICAgaWYgKCEoYXdhaXQgdGhpcy5leGlzdHMobG9nc0RpcikpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHRoaXMubGlzdERpcmVjdG9yeShsb2dzRGlyKTtcclxuICAgICAgY29uc3QgY3V0b2ZmRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSBtYXhBZ2UpO1xyXG4gICAgICBsZXQgcmVtb3ZlZENvdW50ID0gMDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBjb250ZW50cy5maWxlcykge1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGxvZ3NEaXIsIGZpbGUpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5nZXRTdGF0cyhmaWxlUGF0aCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXRzLm1vZGlmaWVkQXQgPCBjdXRvZmZEYXRlKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZUZpbGUoZmlsZVBhdGgpO1xyXG4gICAgICAgICAgcmVtb3ZlZENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdPbGQgbG9nIGZpbGVzIGNsZWFuZWQgdXAgc3VjY2Vzc2Z1bGx5Jywge1xyXG4gICAgICAgIHJlbW92ZWRDb3VudCxcclxuICAgICAgICBtYXhBZ2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjbGVhbnVwIG9sZCBsb2dzJywgeyBlcnJvciwgbWF4QWdlIH0pO1xyXG4gICAgICAvLyBEb24ndCB0aHJvdyBoZXJlIC0gY2xlYW51cCBmYWlsdXJlcyBzaG91bGRuJ3QgYnJlYWsgdGhlIGFwcFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhcHBsaWNhdGlvbiBkaXJlY3RvcnkgcGF0aHNcclxuICAgKi9cclxuICBwcml2YXRlIGluaXRpYWxpemVBcHBEaXJlY3Rvcmllc1BhdGhzKCk6IEFwcERpcmVjdG9yaWVzIHtcclxuICAgIGNvbnN0IHVzZXJEYXRhID0gYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVzZXJEYXRhLFxyXG4gICAgICBkb3dubG9hZHM6IHBhdGguam9pbihhcHAuZ2V0UGF0aCgnZG93bmxvYWRzJyksICdQbGF5bGlzdGlmeScpLFxyXG4gICAgICB0ZW1wOiBwYXRoLmpvaW4odXNlckRhdGEsICd0ZW1wJyksXHJcbiAgICAgIGxvZ3M6IHBhdGguam9pbih1c2VyRGF0YSwgJ2xvZ3MnKSxcclxuICAgICAgY2FjaGU6IHBhdGguam9pbih1c2VyRGF0YSwgJ2NhY2hlJyksXHJcbiAgICAgIGRlcGVuZGVuY2llczogcGF0aC5qb2luKHVzZXJEYXRhLCAnZGVwZW5kZW5jaWVzJyksXHJcbiAgICAgIGNvbmZpZzogcGF0aC5qb2luKHVzZXJEYXRhLCAnY29uZmlnJyksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBmaWxlU3lzdGVtU2VydmljZSA9IG5ldyBGaWxlU3lzdGVtU2VydmljZSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/services/file-system-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/logger-service.ts":
/*!************************************************!*\
  !*** ./src/backend/services/logger-service.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoggerService = void 0;\nexports.createLogger = createLogger;\nexports.getLogger = getLogger;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst fs = tslib_1.__importStar(__webpack_require__(/*! fs-extra */ \"fs-extra\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nclass LoggerService {\n    constructor(config) {\n        this.logDirectory = '';\n        this.currentLogFile = '';\n        this.fileLoggingEnabled = true;\n        this.sessionId = new Date().toISOString().replace(/[:.]/g, '-');\n        // Default configuration\n        this.config = {\n            level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',\n            file: {\n                enabled: true,\n                path: '',\n                maxSize: 10 * 1024 * 1024, // 10MB\n                maxFiles: 5\n            },\n            console: {\n                enabled: true,\n                colorize: process.env.NODE_ENV === 'development'\n            },\n            development: {\n                enhanced: process.env.NODE_ENV === 'development',\n                stackTrace: process.env.NODE_ENV === 'development'\n            },\n            ...config\n        };\n        this.initializeLogDirectory();\n    }\n    async initializeLogDirectory() {\n        try {\n            // Create Console Logs directory in app data\n            const userDataPath = electron_1.app.getPath('userData');\n            this.logDirectory = path.join(userDataPath, 'Console Logs');\n            // Ensure directory exists\n            await fs.ensureDir(this.logDirectory);\n            // Clean up old log files from previous sessions\n            await this.cleanupOldLogs();\n            // Set current log file path\n            this.currentLogFile = path.join(this.logDirectory, `app-${this.sessionId}.log`);\n            this.config.file.path = this.currentLogFile;\n            // Log initialization success\n            this.info('Logger initialized successfully', 'LoggerService', {\n                logDirectory: this.logDirectory,\n                logFile: this.currentLogFile,\n                sessionId: this.sessionId\n            });\n        }\n        catch (error) {\n            // Fallback to console-only logging\n            this.fileLoggingEnabled = false;\n            this.config.file.enabled = false;\n            console.warn('Failed to initialize file logging, falling back to console-only:', error);\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            this.warn('File logging disabled due to initialization error', 'LoggerService', { error: errorMessage });\n        }\n    }\n    async cleanupOldLogs() {\n        try {\n            const files = await fs.readdir(this.logDirectory);\n            const logFiles = files\n                .filter(file => file.startsWith('app-') && file.endsWith('.log'))\n                .map(file => ({\n                name: file,\n                path: path.join(this.logDirectory, file),\n                stat: fs.statSync(path.join(this.logDirectory, file))\n            }))\n                .sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());\n            // Keep only the most recent files (based on maxFiles config)\n            const filesToDelete = logFiles.slice(this.config.file.maxFiles - 1);\n            for (const file of filesToDelete) {\n                await fs.remove(file.path);\n            }\n            if (filesToDelete.length > 0) {\n                console.log(`Cleaned up ${filesToDelete.length} old log files`);\n            }\n        }\n        catch (error) {\n            console.warn('Failed to cleanup old log files:', error);\n        }\n    }\n    shouldLog(level) {\n        const levels = ['error', 'warn', 'info', 'debug'];\n        const currentLevelIndex = levels.indexOf(this.config.level);\n        const messageLevelIndex = levels.indexOf(level);\n        return messageLevelIndex <= currentLevelIndex;\n    }\n    formatTimestamp() {\n        return new Date().toISOString();\n    }\n    formatLogEntry(entry) {\n        let formatted = `[${entry.timestamp}] [${entry.level.toUpperCase()}]`;\n        if (entry.context) {\n            formatted += ` [${entry.context}]`;\n        }\n        formatted += ` ${entry.message}`;\n        if (entry.data && Object.keys(entry.data).length > 0) {\n            formatted += `\\n  Data: ${JSON.stringify(entry.data, null, 2)}`;\n        }\n        return formatted;\n    }\n    getConsoleColor(level) {\n        if (!this.config.console.colorize)\n            return '';\n        const colors = {\n            error: '\\x1b[31m', // Red\n            warn: '\\x1b[33m', // Yellow\n            info: '\\x1b[36m', // Cyan\n            debug: '\\x1b[90m' // Gray\n        };\n        return colors[level] || '';\n    }\n    resetConsoleColor() {\n        return this.config.console.colorize ? '\\x1b[0m' : '';\n    }\n    async writeToFile(entry) {\n        if (!this.config.file.enabled || !this.fileLoggingEnabled) {\n            return;\n        }\n        try {\n            const logLine = this.formatLogEntry(entry) + '\\n';\n            await fs.appendFile(this.currentLogFile, logLine, 'utf8');\n            // Check file size and rotate if necessary\n            await this.checkAndRotateLog();\n        }\n        catch (error) {\n            // Disable file logging on persistent errors\n            this.fileLoggingEnabled = false;\n            console.error('File logging disabled due to write error:', error);\n        }\n    }\n    async checkAndRotateLog() {\n        try {\n            const stats = await fs.stat(this.currentLogFile);\n            if (stats.size > this.config.file.maxSize) {\n                // Create new log file with timestamp\n                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n                this.currentLogFile = path.join(this.logDirectory, `app-${this.sessionId}-${timestamp}.log`);\n                this.info('Log file rotated', 'LoggerService', {\n                    newFile: this.currentLogFile,\n                    previousSize: stats.size\n                });\n            }\n        }\n        catch (error) {\n            console.warn('Failed to check log file size:', error);\n        }\n    }\n    writeToConsole(entry) {\n        if (!this.config.console.enabled) {\n            return;\n        }\n        const color = this.getConsoleColor(entry.level);\n        const reset = this.resetConsoleColor();\n        const formatted = this.formatLogEntry(entry);\n        const consoleMethod = entry.level === 'error' ? console.error :\n            entry.level === 'warn' ? console.warn :\n                entry.level === 'debug' ? console.debug :\n                    console.log;\n        consoleMethod(`${color}${formatted}${reset}`);\n        // Enhanced debugging in development mode\n        if (this.config.development.enhanced && entry.level === 'error' && this.config.development.stackTrace) {\n            const stack = new Error().stack;\n            if (stack) {\n                console.error(`${color}Stack trace:\\n${stack}${reset}`);\n            }\n        }\n    }\n    log(level, message, context, data) {\n        if (!this.shouldLog(level)) {\n            return;\n        }\n        const entry = {\n            timestamp: this.formatTimestamp(),\n            level,\n            message,\n            context,\n            data\n        };\n        // Write to console\n        this.writeToConsole(entry);\n        // Write to file (async, don't wait)\n        this.writeToFile(entry).catch(error => {\n            console.error('Failed to write log to file:', error);\n        });\n    }\n    error(message, context, data) {\n        this.log('error', message, context, data);\n    }\n    warn(message, context, data) {\n        this.log('warn', message, context, data);\n    }\n    info(message, context, data) {\n        this.log('info', message, context, data);\n    }\n    debug(message, context, data) {\n        this.log('debug', message, context, data);\n    }\n    setLevel(level) {\n        this.config.level = level;\n        this.info(`Log level changed to ${level}`, 'LoggerService');\n    }\n    getConfig() {\n        return { ...this.config };\n    }\n    getLogDirectory() {\n        return this.logDirectory;\n    }\n    getCurrentLogFile() {\n        return this.currentLogFile;\n    }\n    isFileLoggingEnabled() {\n        return this.fileLoggingEnabled && this.config.file.enabled;\n    }\n    async flush() {\n        // Ensure all pending file writes are completed\n        // This is useful during application shutdown\n        try {\n            if (this.fileLoggingEnabled && this.currentLogFile) {\n                // Force a final write to ensure everything is flushed\n                await fs.appendFile(this.currentLogFile, '', 'utf8');\n            }\n        }\n        catch (error) {\n            console.error('Failed to flush logs:', error);\n        }\n    }\n    async shutdown() {\n        this.info('Logger shutting down', 'LoggerService');\n        await this.flush();\n    }\n}\nexports.LoggerService = LoggerService;\n// Create singleton instance\nlet loggerInstance = null;\nfunction createLogger(config) {\n    if (!loggerInstance) {\n        loggerInstance = new LoggerService(config);\n    }\n    return loggerInstance;\n}\nfunction getLogger() {\n    if (!loggerInstance) {\n        loggerInstance = new LoggerService();\n    }\n    return loggerInstance;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9sb2dnZXItc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7QUFpVUEsb0NBS0M7QUFFRCw4QkFLQzs7QUE3VUQsbUVBQStCO0FBQy9CLGlGQUErQjtBQUMvQiwyRUFBNkI7QUE4QjdCLE1BQU0sYUFBYTtJQU9qQixZQUFZLE1BQThCO1FBTGxDLGlCQUFZLEdBQVcsRUFBRSxDQUFDO1FBQzFCLG1CQUFjLEdBQVcsRUFBRSxDQUFDO1FBQzVCLHVCQUFrQixHQUFZLElBQUksQ0FBQztRQUl6QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVoRSx3QkFBd0I7UUFDeEIsSUFBSSxDQUFDLE1BQU0sR0FBRztZQUNaLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxhQUFhLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTTtZQUNoRSxJQUFJLEVBQUU7Z0JBQ0osT0FBTyxFQUFFLElBQUk7Z0JBQ2IsSUFBSSxFQUFFLEVBQUU7Z0JBQ1IsT0FBTyxFQUFFLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUFFLE9BQU87Z0JBQ2xDLFFBQVEsRUFBRSxDQUFDO2FBQ1o7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsT0FBTyxFQUFFLElBQUk7Z0JBQ2IsUUFBUSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLGFBQWE7YUFDakQ7WUFDRCxXQUFXLEVBQUU7Z0JBQ1gsUUFBUSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLGFBQWE7Z0JBQ2hELFVBQVUsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxhQUFhO2FBQ25EO1lBQ0QsR0FBRyxNQUFNO1NBQ1YsQ0FBQztRQUVGLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ2hDLENB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QUFLLEVBQUUsQ0FBQztJQUNyQixDQUFDO0NBQ0Y7QUFtQlEsc0NBQWE7QUFqQnRCLDRCQUE0QjtBQUM1QixJQUFJLGNBQWMsR0FBeUIsSUFBSSxDQUFDO0FBRWhELFNBQWdCLFlBQVksQ0FBQyxNQUE4QjtJQUN6RCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDcEIsY0FBYyxHQUFHLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFDRCxPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDO0FBRUQsU0FBZ0IsU0FBUztJQUN2QixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDcEIsY0FBYyxHQUFHLElBQUksYUFBYSxFQUFFLENBQUM7SUFDdkMsQ0FBQztJQUNELE9BQU8sY0FBYyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9iYWNrZW5kL3NlcnZpY2VzL2xvZ2dlci1zZXJ2aWNlLnRzPzY3NDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwIH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5leHBvcnQgdHlwZSBMb2dMZXZlbCA9ICdlcnJvcicgfCAnd2FybicgfCAnaW5mbycgfCAnZGVidWcnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2dFbnRyeSB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgbGV2ZWw6IExvZ0xldmVsO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICBjb250ZXh0Pzogc3RyaW5nO1xyXG4gIGRhdGE/OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyQ29uZmlnIHtcclxuICBsZXZlbDogTG9nTGV2ZWw7XHJcbiAgZmlsZToge1xyXG4gICAgZW5hYmxlZDogYm9vbGVhbjtcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIG1heFNpemU6IG51bWJlcjtcclxuICAgIG1heEZpbGVzOiBudW1iZXI7XHJcbiAgfTtcclxuICBjb25zb2xlOiB7XHJcbiAgICBlbmFibGVkOiBib29sZWFuO1xyXG4gICAgY29sb3JpemU6IGJvb2xlYW47XHJcbiAgfTtcclxuICBkZXZlbG9wbWVudDoge1xyXG4gICAgZW5oYW5jZWQ6IGJvb2xlYW47XHJcbiAgICBzdGFja1RyYWNlOiBib29sZWFuO1xyXG4gIH07XHJcbn1cclxuXHJcbmNsYXNzIExvZ2dlclNlcnZpY2Uge1xyXG4gIHByaXZhdGUgY29uZmlnOiBMb2dnZXJDb25maWc7XHJcbiAgcHJpdmF0ZSBsb2dEaXJlY3Rvcnk6IHN0cmluZyA9ICcnO1xyXG4gIHByaXZhdGUgY3VycmVudExvZ0ZpbGU6IHN0cmluZyA9ICcnO1xyXG4gIHByaXZhdGUgZmlsZUxvZ2dpbmdFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcclxuICBwcml2YXRlIHNlc3Npb25JZDogc3RyaW5nO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBQYXJ0aWFsPExvZ2dlckNvbmZpZz4pIHtcclxuICAgIHRoaXMuc2Vzc2lvbklkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6Ll0vZywgJy0nKTtcclxuICAgIFxyXG4gICAgLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uXHJcbiAgICB0aGlzLmNvbmZpZyA9IHtcclxuICAgICAgbGV2ZWw6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gJ2RlYnVnJyA6ICdpbmZvJyxcclxuICAgICAgZmlsZToge1xyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgcGF0aDogJycsXHJcbiAgICAgICAgbWF4U2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgLy8gMTBNQlxyXG4gICAgICAgIG1heEZpbGVzOiA1XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbnNvbGU6IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGNvbG9yaXplOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xyXG4gICAgICB9LFxyXG4gICAgICBkZXZlbG9wbWVudDoge1xyXG4gICAgICAgIGVuaGFuY2VkOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICAgICAgICBzdGFja1RyYWNlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xyXG4gICAgICB9LFxyXG4gICAgICAuLi5jb25maWdcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplTG9nRGlyZWN0b3J5KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVMb2dEaXJlY3RvcnkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDcmVhdGUgQ29uc29sZSBMb2dzIGRpcmVjdG9yeSBpbiBhcHAgZGF0YVxyXG4gICAgICBjb25zdCB1c2VyRGF0YVBhdGggPSBhcHAuZ2V0UGF0aCgndXNlckRhdGEnKTtcclxuICAgICAgdGhpcy5sb2dEaXJlY3RvcnkgPSBwYXRoLmpvaW4odXNlckRhdGFQYXRoLCAnQ29uc29sZSBMb2dzJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbnN1cmUgZGlyZWN0b3J5IGV4aXN0c1xyXG4gICAgICBhd2FpdCBmcy5lbnN1cmVEaXIodGhpcy5sb2dEaXJlY3RvcnkpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYW4gdXAgb2xkIGxvZyBmaWxlcyBmcm9tIHByZXZpb3VzIHNlc3Npb25zXHJcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cE9sZExvZ3MoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFNldCBjdXJyZW50IGxvZyBmaWxlIHBhdGhcclxuICAgICAgdGhpcy5jdXJyZW50TG9nRmlsZSA9IHBhdGguam9pbihcclxuICAgICAgICB0aGlzLmxvZ0RpcmVjdG9yeSwgXHJcbiAgICAgICAgYGFwcC0ke3RoaXMuc2Vzc2lvbklkfS5sb2dgXHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLmNvbmZpZy5maWxlLnBhdGggPSB0aGlzLmN1cnJlbnRMb2dGaWxlO1xyXG4gICAgICBcclxuICAgICAgLy8gTG9nIGluaXRpYWxpemF0aW9uIHN1Y2Nlc3NcclxuICAgICAgdGhpcy5pbmZvKCdMb2dnZXIgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5JywgJ0xvZ2dlclNlcnZpY2UnLCB7XHJcbiAgICAgICAgbG9nRGlyZWN0b3J5OiB0aGlzLmxvZ0RpcmVjdG9yeSxcclxuICAgICAgICBsb2dGaWxlOiB0aGlzLmN1cnJlbnRMb2dGaWxlLFxyXG4gICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWRcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gRmFsbGJhY2sgdG8gY29uc29sZS1vbmx5IGxvZ2dpbmdcclxuICAgICAgdGhpcy5maWxlTG9nZ2luZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5jb25maWcuZmlsZS5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbml0aWFsaXplIGZpbGUgbG9nZ2luZywgZmFsbGluZyBiYWNrIHRvIGNvbnNvbGUtb25seTonLCBlcnJvcik7XHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuICAgICAgdGhpcy53YXJuKCdGaWxlIGxvZ2dpbmcgZGlzYWJsZWQgZHVlIHRvIGluaXRpYWxpemF0aW9uIGVycm9yJywgJ0xvZ2dlclNlcnZpY2UnLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNsZWFudXBPbGRMb2dzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHRoaXMubG9nRGlyZWN0b3J5KTtcclxuICAgICAgY29uc3QgbG9nRmlsZXMgPSBmaWxlc1xyXG4gICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLnN0YXJ0c1dpdGgoJ2FwcC0nKSAmJiBmaWxlLmVuZHNXaXRoKCcubG9nJykpXHJcbiAgICAgICAgLm1hcChmaWxlID0+ICh7XHJcbiAgICAgICAgICBuYW1lOiBmaWxlLFxyXG4gICAgICAgICAgcGF0aDogcGF0aC5qb2luKHRoaXMubG9nRGlyZWN0b3J5LCBmaWxlKSxcclxuICAgICAgICAgIHN0YXQ6IGZzLnN0YXRTeW5jKHBhdGguam9pbih0aGlzLmxvZ0RpcmVjdG9yeSwgZmlsZSkpXHJcbiAgICAgICAgfSkpXHJcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc3RhdC5tdGltZS5nZXRUaW1lKCkgLSBhLnN0YXQubXRpbWUuZ2V0VGltZSgpKTtcclxuXHJcbiAgICAgIC8vIEtlZXAgb25seSB0aGUgbW9zdCByZWNlbnQgZmlsZXMgKGJhc2VkIG9uIG1heEZpbGVzIGNvbmZpZylcclxuICAgICAgY29uc3QgZmlsZXNUb0RlbGV0ZSA9IGxvZ0ZpbGVzLnNsaWNlKHRoaXMuY29uZmlnLmZpbGUubWF4RmlsZXMgLSAxKTtcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgYXdhaXQgZnMucmVtb3ZlKGZpbGUucGF0aCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChmaWxlc1RvRGVsZXRlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ2xlYW5lZCB1cCAke2ZpbGVzVG9EZWxldGUubGVuZ3RofSBvbGQgbG9nIGZpbGVzYCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNsZWFudXAgb2xkIGxvZyBmaWxlczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNob3VsZExvZyhsZXZlbDogTG9nTGV2ZWwpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGxldmVsczogTG9nTGV2ZWxbXSA9IFsnZXJyb3InLCAnd2FybicsICdpbmZvJywgJ2RlYnVnJ107XHJcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IGxldmVscy5pbmRleE9mKHRoaXMuY29uZmlnLmxldmVsKTtcclxuICAgIGNvbnN0IG1lc3NhZ2VMZXZlbEluZGV4ID0gbGV2ZWxzLmluZGV4T2YobGV2ZWwpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gbWVzc2FnZUxldmVsSW5kZXggPD0gY3VycmVudExldmVsSW5kZXg7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZvcm1hdFRpbWVzdGFtcCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZm9ybWF0TG9nRW50cnkoZW50cnk6IExvZ0VudHJ5KTogc3RyaW5nIHtcclxuICAgIGxldCBmb3JtYXR0ZWQgPSBgWyR7ZW50cnkudGltZXN0YW1wfV0gWyR7ZW50cnkubGV2ZWwudG9VcHBlckNhc2UoKX1dYDtcclxuICAgIFxyXG4gICAgaWYgKGVudHJ5LmNvbnRleHQpIHtcclxuICAgICAgZm9ybWF0dGVkICs9IGAgWyR7ZW50cnkuY29udGV4dH1dYDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZm9ybWF0dGVkICs9IGAgJHtlbnRyeS5tZXNzYWdlfWA7XHJcbiAgICBcclxuICAgIGlmIChlbnRyeS5kYXRhICYmIE9iamVjdC5rZXlzKGVudHJ5LmRhdGEpLmxlbmd0aCA+IDApIHtcclxuICAgICAgZm9ybWF0dGVkICs9IGBcXG4gIERhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZW50cnkuZGF0YSwgbnVsbCwgMil9YDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0Q29uc29sZUNvbG9yKGxldmVsOiBMb2dMZXZlbCk6IHN0cmluZyB7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmNvbnNvbGUuY29sb3JpemUpIHJldHVybiAnJztcclxuICAgIFxyXG4gICAgY29uc3QgY29sb3JzID0ge1xyXG4gICAgICBlcnJvcjogJ1xceDFiWzMxbScsIC8vIFJlZFxyXG4gICAgICB3YXJuOiAnXFx4MWJbMzNtJywgIC8vIFllbGxvd1xyXG4gICAgICBpbmZvOiAnXFx4MWJbMzZtJywgIC8vIEN5YW5cclxuICAgICAgZGVidWc6ICdcXHgxYls5MG0nICAvLyBHcmF5XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gY29sb3JzW2xldmVsXSB8fCAnJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVzZXRDb25zb2xlQ29sb3IoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5jb25zb2xlLmNvbG9yaXplID8gJ1xceDFiWzBtJyA6ICcnO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB3cml0ZVRvRmlsZShlbnRyeTogTG9nRW50cnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5jb25maWcuZmlsZS5lbmFibGVkIHx8ICF0aGlzLmZpbGVMb2dnaW5nRW5hYmxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbG9nTGluZSA9IHRoaXMuZm9ybWF0TG9nRW50cnkoZW50cnkpICsgJ1xcbic7XHJcbiAgICAgIGF3YWl0IGZzLmFwcGVuZEZpbGUodGhpcy5jdXJyZW50TG9nRmlsZSwgbG9nTGluZSwgJ3V0ZjgnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZSBhbmQgcm90YXRlIGlmIG5lY2Vzc2FyeVxyXG4gICAgICBhd2FpdCB0aGlzLmNoZWNrQW5kUm90YXRlTG9nKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBEaXNhYmxlIGZpbGUgbG9nZ2luZyBvbiBwZXJzaXN0ZW50IGVycm9yc1xyXG4gICAgICB0aGlzLmZpbGVMb2dnaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGaWxlIGxvZ2dpbmcgZGlzYWJsZWQgZHVlIHRvIHdyaXRlIGVycm9yOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY2hlY2tBbmRSb3RhdGVMb2coKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQodGhpcy5jdXJyZW50TG9nRmlsZSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoc3RhdHMuc2l6ZSA+IHRoaXMuY29uZmlnLmZpbGUubWF4U2l6ZSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgbG9nIGZpbGUgd2l0aCB0aW1lc3RhbXBcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWzouXS9nLCAnLScpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudExvZ0ZpbGUgPSBwYXRoLmpvaW4oXHJcbiAgICAgICAgICB0aGlzLmxvZ0RpcmVjdG9yeSxcclxuICAgICAgICAgIGBhcHAtJHt0aGlzLnNlc3Npb25JZH0tJHt0aW1lc3RhbXB9LmxvZ2BcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaW5mbygnTG9nIGZpbGUgcm90YXRlZCcsICdMb2dnZXJTZXJ2aWNlJywge1xyXG4gICAgICAgICAgbmV3RmlsZTogdGhpcy5jdXJyZW50TG9nRmlsZSxcclxuICAgICAgICAgIHByZXZpb3VzU2l6ZTogc3RhdHMuc2l6ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjaGVjayBsb2cgZmlsZSBzaXplOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgd3JpdGVUb0NvbnNvbGUoZW50cnk6IExvZ0VudHJ5KTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29uZmlnLmNvbnNvbGUuZW5hYmxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbnNvbGVDb2xvcihlbnRyeS5sZXZlbCk7XHJcbiAgICBjb25zdCByZXNldCA9IHRoaXMucmVzZXRDb25zb2xlQ29sb3IoKTtcclxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0TG9nRW50cnkoZW50cnkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBjb25zb2xlTWV0aG9kID0gZW50cnkubGV2ZWwgPT09ICdlcnJvcicgPyBjb25zb2xlLmVycm9yIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmxldmVsID09PSAnd2FybicgPyBjb25zb2xlLndhcm4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGV2ZWwgPT09ICdkZWJ1ZycgPyBjb25zb2xlLmRlYnVnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nO1xyXG4gICAgXHJcbiAgICBjb25zb2xlTWV0aG9kKGAke2NvbG9yfSR7Zm9ybWF0dGVkfSR7cmVzZXR9YCk7XHJcbiAgICBcclxuICAgIC8vIEVuaGFuY2VkIGRlYnVnZ2luZyBpbiBkZXZlbG9wbWVudCBtb2RlXHJcbiAgICBpZiAodGhpcy5jb25maWcuZGV2ZWxvcG1lbnQuZW5oYW5jZWQgJiYgZW50cnkubGV2ZWwgPT09ICdlcnJvcicgJiYgdGhpcy5jb25maWcuZGV2ZWxvcG1lbnQuc3RhY2tUcmFjZSkge1xyXG4gICAgICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gICAgICBpZiAoc3RhY2spIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGAke2NvbG9yfVN0YWNrIHRyYWNlOlxcbiR7c3RhY2t9JHtyZXNldH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBsb2cobGV2ZWw6IExvZ0xldmVsLCBtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5zaG91bGRMb2cobGV2ZWwpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlbnRyeTogTG9nRW50cnkgPSB7XHJcbiAgICAgIHRpbWVzdGFtcDogdGhpcy5mb3JtYXRUaW1lc3RhbXAoKSxcclxuICAgICAgbGV2ZWwsXHJcbiAgICAgIG1lc3NhZ2UsXHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIGRhdGFcclxuICAgIH07XHJcblxyXG4gICAgLy8gV3JpdGUgdG8gY29uc29sZVxyXG4gICAgdGhpcy53cml0ZVRvQ29uc29sZShlbnRyeSk7XHJcbiAgICBcclxuICAgIC8vIFdyaXRlIHRvIGZpbGUgKGFzeW5jLCBkb24ndCB3YWl0KVxyXG4gICAgdGhpcy53cml0ZVRvRmlsZShlbnRyeSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gd3JpdGUgbG9nIHRvIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBjb250ZXh0Pzogc3RyaW5nLCBkYXRhPzogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLmxvZygnZXJyb3InLCBtZXNzYWdlLCBjb250ZXh0LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB3YXJuKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IHN0cmluZywgZGF0YT86IGFueSk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2coJ3dhcm4nLCBtZXNzYWdlLCBjb250ZXh0LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpbmZvKG1lc3NhZ2U6IHN0cmluZywgY29udGV4dD86IHN0cmluZywgZGF0YT86IGFueSk6IHZvaWQge1xyXG4gICAgdGhpcy5sb2coJ2luZm8nLCBtZXNzYWdlLCBjb250ZXh0LCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMubG9nKCdkZWJ1ZycsIG1lc3NhZ2UsIGNvbnRleHQsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldExldmVsKGxldmVsOiBMb2dMZXZlbCk6IHZvaWQge1xyXG4gICAgdGhpcy5jb25maWcubGV2ZWwgPSBsZXZlbDtcclxuICAgIHRoaXMuaW5mbyhgTG9nIGxldmVsIGNoYW5nZWQgdG8gJHtsZXZlbH1gLCAnTG9nZ2VyU2VydmljZScpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldENvbmZpZygpOiBMb2dnZXJDb25maWcge1xyXG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRMb2dEaXJlY3RvcnkoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmxvZ0RpcmVjdG9yeTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRDdXJyZW50TG9nRmlsZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExvZ0ZpbGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgaXNGaWxlTG9nZ2luZ0VuYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5maWxlTG9nZ2luZ0VuYWJsZWQgJiYgdGhpcy5jb25maWcuZmlsZS5lbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGZsdXNoKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gRW5zdXJlIGFsbCBwZW5kaW5nIGZpbGUgd3JpdGVzIGFyZSBjb21wbGV0ZWRcclxuICAgIC8vIFRoaXMgaXMgdXNlZnVsIGR1cmluZyBhcHBsaWNhdGlvbiBzaHV0ZG93blxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHRoaXMuZmlsZUxvZ2dpbmdFbmFibGVkICYmIHRoaXMuY3VycmVudExvZ0ZpbGUpIHtcclxuICAgICAgICAvLyBGb3JjZSBhIGZpbmFsIHdyaXRlIHRvIGVuc3VyZSBldmVyeXRoaW5nIGlzIGZsdXNoZWRcclxuICAgICAgICBhd2FpdCBmcy5hcHBlbmRGaWxlKHRoaXMuY3VycmVudExvZ0ZpbGUsICcnLCAndXRmOCcpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmx1c2ggbG9nczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgc2h1dGRvd24oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmluZm8oJ0xvZ2dlciBzaHV0dGluZyBkb3duJywgJ0xvZ2dlclNlcnZpY2UnKTtcclxuICAgIGF3YWl0IHRoaXMuZmx1c2goKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBzaW5nbGV0b24gaW5zdGFuY2VcclxubGV0IGxvZ2dlckluc3RhbmNlOiBMb2dnZXJTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKGNvbmZpZz86IFBhcnRpYWw8TG9nZ2VyQ29uZmlnPik6IExvZ2dlclNlcnZpY2Uge1xyXG4gIGlmICghbG9nZ2VySW5zdGFuY2UpIHtcclxuICAgIGxvZ2dlckluc3RhbmNlID0gbmV3IExvZ2dlclNlcnZpY2UoY29uZmlnKTtcclxuICB9XHJcbiAgcmV0dXJuIGxvZ2dlckluc3RhbmNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9nZ2VyKCk6IExvZ2dlclNlcnZpY2Uge1xyXG4gIGlmICghbG9nZ2VySW5zdGFuY2UpIHtcclxuICAgIGxvZ2dlckluc3RhbmNlID0gbmV3IExvZ2dlclNlcnZpY2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGxvZ2dlckluc3RhbmNlO1xyXG59XHJcblxyXG5leHBvcnQgeyBMb2dnZXJTZXJ2aWNlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/backend/services/logger-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/settingsService.ts":
/*!*************************************************!*\
  !*** ./src/backend/services/settingsService.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.settingsService = exports.SettingsService = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst electron_store_1 = tslib_1.__importDefault(__webpack_require__(/*! electron-store */ \"./node_modules/electron-store/index.js\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst settings_types_1 = __webpack_require__(/*! ../../shared/types/settings-types */ \"./src/shared/types/settings-types.ts\");\n// Simple console logger fallback\nconst consoleLogger = {\n    info: (message, meta) => console.log(`[INFO] ${message}`, meta || ''),\n    warn: (message, meta) => console.warn(`[WARN] ${message}`, meta || ''),\n    error: (message, meta) => console.error(`[ERROR] ${message}`, meta || ''),\n    debug: (message, meta) => console.debug(`[DEBUG] ${message}`, meta || ''),\n};\nclass SettingsService {\n    constructor(logger) {\n        this.logger = logger || consoleLogger;\n        try {\n            this.store = new electron_store_1.default({\n                defaults: settings_types_1.DEFAULT_USER_SETTINGS,\n                schema: settings_types_1.SETTINGS_SCHEMA,\n                name: 'user-settings',\n                cwd: path.join(electron_1.app.getPath('userData'), 'config'),\n                fileExtension: 'json',\n                serialize: (value) => JSON.stringify(value, null, 2),\n                deserialize: JSON.parse,\n                clearInvalidConfig: true,\n            });\n            this.logger.info('SettingsService initialized successfully', {\n                storePath: this.store.path,\n                storeSize: this.store.size,\n            });\n        }\n        catch (error) {\n            this.logger.error('Failed to initialize SettingsService', { error });\n            throw new settings_types_1.SettingsError('Failed to initialize settings store', 'INIT_ERROR', error);\n        }\n    }\n    /**\n     * Get a setting value by key with type safety\n     */\n    get(key) {\n        try {\n            const value = this.store.get(key);\n            this.logger.debug(`Retrieved setting: ${String(key)}`, { value });\n            return value;\n        }\n        catch (error) {\n            this.logger.error(`Failed to get setting: ${String(key)}`, { error });\n            throw new settings_types_1.SettingsError(`Failed to get setting: ${String(key)}`, 'GET_ERROR', error);\n        }\n    }\n    /**\n     * Set a setting value by key with validation\n     */\n    set(key, value) {\n        try {\n            // Validate the value before setting\n            const validationResult = this.validateSingleSetting(key, value);\n            if (!validationResult.isValid) {\n                throw new settings_types_1.SettingsError(`Invalid value for setting ${String(key)}: ${validationResult.errors.join(', ')}`, 'VALIDATION_ERROR', { key, value, errors: validationResult.errors });\n            }\n            this.store.set(key, value);\n            this.logger.info(`Updated setting: ${String(key)}`, { value });\n        }\n        catch (error) {\n            this.logger.error(`Failed to set setting: ${String(key)}`, {\n                error,\n                value,\n            });\n            if (error instanceof settings_types_1.SettingsError) {\n                throw error;\n            }\n            throw new settings_types_1.SettingsError(`Failed to set setting: ${String(key)}`, 'SET_ERROR', error);\n        }\n    }\n    /**\n     * Get all settings\n     */\n    getAll() {\n        try {\n            const settings = this.store.store;\n            this.logger.debug('Retrieved all settings');\n            return settings;\n        }\n        catch (error) {\n            this.logger.error('Failed to get all settings', { error });\n            throw new settings_types_1.SettingsError('Failed to get all settings', 'GET_ALL_ERROR', error);\n        }\n    }\n    /**\n     * Reset all settings to defaults\n     */\n    reset() {\n        try {\n            this.store.clear();\n            this.logger.info('Reset all settings to defaults');\n        }\n        catch (error) {\n            this.logger.error('Failed to reset settings', { error });\n            throw new settings_types_1.SettingsError('Failed to reset settings', 'RESET_ERROR', error);\n        }\n    }\n    /**\n     * Check if a setting exists (has been set)\n     */\n    has(key) {\n        try {\n            return this.store.has(key);\n        }\n        catch (error) {\n            this.logger.error(`Failed to check setting existence: ${String(key)}`, {\n                error,\n            });\n            return false;\n        }\n    }\n    /**\n     * Delete a specific setting (revert to default)\n     */\n    delete(key) {\n        try {\n            this.store.delete(key);\n            this.logger.info(`Deleted setting: ${String(key)}`);\n        }\n        catch (error) {\n            this.logger.error(`Failed to delete setting: ${String(key)}`, { error });\n            throw new settings_types_1.SettingsError(`Failed to delete setting: ${String(key)}`, 'DELETE_ERROR', error);\n        }\n    }\n    /**\n     * Validate all settings and return detailed results\n     */\n    validate() {\n        const result = {\n            isValid: true,\n            errors: [],\n            warnings: [],\n        };\n        try {\n            const settings = this.getAll();\n            // Validate each setting\n            Object.entries(settings).forEach(([key, value]) => {\n                const settingKey = key;\n                const validation = this.validateSingleSetting(settingKey, value);\n                if (!validation.isValid) {\n                    result.isValid = false;\n                    result.errors.push(...validation.errors.map(err => `${key}: ${err}`));\n                }\n                if (validation.warnings) {\n                    result.warnings.push(...validation.warnings.map(warn => `${key}: ${warn}`));\n                }\n            });\n            this.logger.debug('Settings validation completed', result);\n        }\n        catch (error) {\n            result.isValid = false;\n            result.errors.push(`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            this.logger.error('Settings validation failed', { error });\n        }\n        return result;\n    }\n    /**\n     * Sanitize settings by fixing invalid values\n     */\n    sanitize() {\n        try {\n            const settings = this.getAll();\n            let changesMade = false;\n            // Sanitize theme\n            if (!['light', 'dark', 'system'].includes(settings.theme)) {\n                this.store.set('theme', 'light');\n                changesMade = true;\n            }\n            // Sanitize video quality\n            if (!['best', 'worst', '720p', '1080p'].includes(settings.videoQuality)) {\n                this.store.set('videoQuality', 'best');\n                changesMade = true;\n            }\n            // Sanitize concurrent downloads\n            if (settings.maxConcurrentDownloads < 1 ||\n                settings.maxConcurrentDownloads > 10) {\n                this.store.set('maxConcurrentDownloads', 3);\n                changesMade = true;\n            }\n            // Sanitize window size\n            if (settings.windowSize.width < 800 || settings.windowSize.height < 600) {\n                this.store.set('windowSize', { width: 1200, height: 800 });\n                changesMade = true;\n            }\n            // Sanitize paths\n            if (settings.downloadLocation &&\n                !path.isAbsolute(settings.downloadLocation)) {\n                this.store.set('downloadLocation', path.join(electron_1.app.getPath('downloads'), 'Playlistify'));\n                changesMade = true;\n            }\n            if (changesMade) {\n                this.logger.info('Settings sanitized - invalid values corrected');\n            }\n        }\n        catch (error) {\n            this.logger.error('Failed to sanitize settings', { error });\n            throw new settings_types_1.SettingsError('Failed to sanitize settings', 'SANITIZE_ERROR', error);\n        }\n    }\n    /**\n     * Export settings with metadata\n     */\n    export() {\n        try {\n            const exportData = {\n                version: '1.0.0',\n                exportDate: new Date(),\n                settings: this.getAll(),\n            };\n            this.logger.info('Settings exported');\n            return exportData;\n        }\n        catch (error) {\n            this.logger.error('Failed to export settings', { error });\n            throw new settings_types_1.SettingsError('Failed to export settings', 'EXPORT_ERROR', error);\n        }\n    }\n    /**\n     * Import settings with validation\n     */\n    import(data) {\n        try {\n            // Validate import data structure\n            if (!data.settings || typeof data.settings !== 'object') {\n                throw new settings_types_1.SettingsError('Invalid import data structure', 'IMPORT_VALIDATION_ERROR');\n            }\n            // Import each valid setting\n            let importedCount = 0;\n            Object.entries(data.settings).forEach(([key, value]) => {\n                if (key in settings_types_1.DEFAULT_USER_SETTINGS) {\n                    try {\n                        this.set(key, value);\n                        importedCount++;\n                    }\n                    catch (error) {\n                        this.logger.warn(`Failed to import setting: ${key}`, {\n                            error,\n                            value,\n                        });\n                    }\n                }\n            });\n            // Validate and sanitize after import\n            this.sanitize();\n            const validation = this.validate();\n            if (!validation.isValid) {\n                this.logger.warn('Settings import completed with validation errors', {\n                    importedCount,\n                    errors: validation.errors,\n                });\n            }\n            else {\n                this.logger.info('Settings imported successfully', { importedCount });\n            }\n            return validation.isValid;\n        }\n        catch (error) {\n            this.logger.error('Failed to import settings', { error });\n            throw new settings_types_1.SettingsError('Failed to import settings', 'IMPORT_ERROR', error);\n        }\n    }\n    /**\n     * Get the file path where settings are stored\n     */\n    getStorePath() {\n        return this.store.path;\n    }\n    /**\n     * Initialize default settings and directories\n     */\n    async initializeDefaults() {\n        try {\n            // Initialize download location if not set\n            if (!this.get('downloadLocation')) {\n                const defaultPath = path.join(electron_1.app.getPath('downloads'), 'Playlistify');\n                this.set('downloadLocation', defaultPath);\n            }\n            // Initialize temp directory if not set\n            if (!this.get('tempDirectory')) {\n                const tempPath = path.join(electron_1.app.getPath('userData'), 'temp');\n                this.set('tempDirectory', tempPath);\n            }\n            // Validate and sanitize all settings\n            this.sanitize();\n            this.logger.info('Default settings initialized');\n        }\n        catch (error) {\n            this.logger.error('Failed to initialize default settings', { error });\n            throw new settings_types_1.SettingsError('Failed to initialize default settings', 'INIT_DEFAULTS_ERROR', error);\n        }\n    }\n    /**\n     * Create a backup of current settings\n     */\n    async createBackup() {\n        try {\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const backupData = this.export();\n            const backupPath = path.join(electron_1.app.getPath('userData'), 'config', `settings-backup-${timestamp}.json`);\n            // Ensure backup directory exists\n            const fs = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n            await fs.ensureDir(path.dirname(backupPath));\n            await fs.writeJson(backupPath, backupData, { spaces: 2 });\n            this.logger.info('Settings backup created', { backupPath });\n            return backupPath;\n        }\n        catch (error) {\n            this.logger.error('Failed to create settings backup', { error });\n            throw new settings_types_1.SettingsError('Failed to create settings backup', 'BACKUP_ERROR', error);\n        }\n    }\n    /**\n     * Restore settings from backup\n     */\n    async restoreFromBackup(backupPath) {\n        try {\n            const fs = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n            const backupData = await fs.readJson(backupPath);\n            if (!this.import(backupData)) {\n                throw new settings_types_1.SettingsError('Backup data validation failed', 'RESTORE_VALIDATION_ERROR');\n            }\n            this.logger.info('Settings restored from backup', { backupPath });\n        }\n        catch (error) {\n            this.logger.error('Failed to restore settings from backup', {\n                error,\n                backupPath,\n            });\n            throw new settings_types_1.SettingsError('Failed to restore settings from backup', 'RESTORE_ERROR', error);\n        }\n    }\n    /**\n     * Get current settings version\n     */\n    getVersion() {\n        try {\n            return this.get('version') || '1.0.0';\n        }\n        catch {\n            return '1.0.0';\n        }\n    }\n    /**\n     * Set settings version\n     */\n    setVersion(version) {\n        try {\n            this.store.set('version', version);\n            this.logger.info('Settings version updated', { version });\n        }\n        catch (error) {\n            this.logger.error('Failed to set settings version', { error, version });\n        }\n    }\n    /**\n     * Check if migration is needed\n     */\n    needsMigration(targetVersion) {\n        const currentVersion = this.getVersion();\n        return currentVersion !== targetVersion;\n    }\n    /**\n     * Migrate settings to new version\n     */\n    async migrate(targetVersion) {\n        const currentVersion = this.getVersion();\n        try {\n            this.logger.info('Starting settings migration', {\n                currentVersion,\n                targetVersion,\n            });\n            // Create backup before migration\n            const backupPath = await this.createBackup();\n            // Apply version-specific migrations\n            await this.applyMigrations(currentVersion, targetVersion);\n            // Update version\n            this.setVersion(targetVersion);\n            // Validate after migration\n            const validation = this.validate();\n            if (!validation.isValid) {\n                this.logger.warn('Settings validation failed after migration', validation);\n                this.sanitize();\n            }\n            this.logger.info('Settings migration completed successfully', {\n                currentVersion,\n                targetVersion,\n                backupPath,\n            });\n        }\n        catch (error) {\n            this.logger.error('Settings migration failed', {\n                error,\n                currentVersion,\n                targetVersion,\n            });\n            throw new settings_types_1.SettingsError('Settings migration failed', 'MIGRATION_ERROR', error);\n        }\n    }\n    /**\n     * Apply version-specific migration logic\n     */\n    async applyMigrations(fromVersion, toVersion) {\n        // Migration logic for different version transitions\n        // This is where you would add specific migration steps for each version\n        if (fromVersion === '1.0.0' && toVersion === '1.1.0') {\n            // Example migration: Add new settings with defaults\n            if (!this.has('notificationsEnabled')) {\n                this.set('notificationsEnabled', true);\n            }\n        }\n        // Add more migration logic as needed for future versions\n        this.logger.debug('Applied migrations', { fromVersion, toVersion });\n    }\n    /**\n     * List available backups\n     */\n    async listBackups() {\n        try {\n            const fs = __webpack_require__(/*! fs-extra */ \"fs-extra\");\n            const backupDir = path.join(electron_1.app.getPath('userData'), 'config');\n            if (!(await fs.pathExists(backupDir))) {\n                return [];\n            }\n            const files = await fs.readdir(backupDir);\n            const backupFiles = files.filter((file) => file.startsWith('settings-backup-'));\n            const backups = await Promise.all(backupFiles.map(async (file) => {\n                const filePath = path.join(backupDir, file);\n                const stats = await fs.stat(filePath);\n                try {\n                    const data = await fs.readJson(filePath);\n                    return {\n                        path: filePath,\n                        date: stats.mtime,\n                        version: data.version,\n                    };\n                }\n                catch {\n                    return {\n                        path: filePath,\n                        date: stats.mtime,\n                    };\n                }\n            }));\n            return backups.sort((a, b) => b.date.getTime() - a.date.getTime());\n        }\n        catch (error) {\n            this.logger.error('Failed to list backups', { error });\n            return [];\n        }\n    }\n    /**\n     * Validate a single setting value\n     */\n    validateSingleSetting(key, value) {\n        const result = {\n            isValid: true,\n            errors: [],\n            warnings: [],\n        };\n        try {\n            switch (key) {\n                case 'theme':\n                    if (!['light', 'dark', 'system'].includes(value)) {\n                        result.isValid = false;\n                        result.errors.push('Theme must be \"light\", \"dark\", or \"system\"');\n                    }\n                    break;\n                case 'language':\n                    if (typeof value !== 'string' || value.length === 0) {\n                        result.isValid = false;\n                        result.errors.push('Language must be a non-empty string');\n                    }\n                    break;\n                case 'videoQuality':\n                    if (!['best', 'worst', '720p', '1080p'].includes(value)) {\n                        result.isValid = false;\n                        result.errors.push('Video quality must be \"best\", \"worst\", \"720p\", or \"1080p\"');\n                    }\n                    break;\n                case 'maxConcurrentDownloads':\n                    if (typeof value !== 'number' || value < 1 || value > 10) {\n                        result.isValid = false;\n                        result.errors.push('Max concurrent downloads must be a number between 1 and 10');\n                    }\n                    break;\n                case 'windowSize':\n                    if (!value ||\n                        typeof value !== 'object' ||\n                        typeof value.width !== 'number' ||\n                        typeof value.height !== 'number' ||\n                        value.width < 800 ||\n                        value.height < 600) {\n                        result.isValid = false;\n                        result.errors.push('Window size must have width >= 800 and height >= 600');\n                    }\n                    break;\n                case 'windowPosition':\n                    if (!value ||\n                        typeof value !== 'object' ||\n                        typeof value.x !== 'number' ||\n                        typeof value.y !== 'number') {\n                        result.isValid = false;\n                        result.errors.push('Window position must have numeric x and y coordinates');\n                    }\n                    break;\n                case 'downloadLocation':\n                case 'tempDirectory':\n                    if (value && typeof value === 'string' && !path.isAbsolute(value)) {\n                        result.warnings?.push('Path should be absolute');\n                    }\n                    break;\n            }\n        }\n        catch (error) {\n            result.isValid = false;\n            result.errors.push(`Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n        return result;\n    }\n}\nexports.SettingsService = SettingsService;\n// Export a singleton instance\nexports.settingsService = new SettingsService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9zZXR0aW5nc1NlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG1FQUErQjtBQUMvQixzSUFBbUM7QUFDbkMsMkVBQTZCO0FBQzdCLDhIQVEyQztBQVUzQyxpQ0FBaUM7QUFDakMsTUFBTSxhQUFhLEdBQVc7SUFDNUIsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLE9BQU8sRUFBRSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7SUFDckUsSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLE9BQU8sRUFBRSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7SUFDdEUsS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLE9BQU8sRUFBRSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7SUFDekUsS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLE9BQU8sRUFBRSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7Q0FDMUUsQ0FBQztBQUVGLE1BQWEsZUFBZTtJQUkxQixZQUFZLE1BQWU7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLElBQUksYUFBYSxDQUFDO1FBRXRDLElBQUksQ0FBQztZQUNILElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSx3QkFBSyxDQUFlO2dCQUNuQyxRQUFRLEVBQUUsc0NBQXFCO2dCQUMvQixNQUFNLEVBQUUsZ0NBQWU7Z0JBQ3ZCLElBQUksRUFBRSxlQUFlO2dCQUNyQixHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFHLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLFFBQVEsQ0FBQztnQkFDakQsYUFBYSxFQUFFLE1BQU07Z0JBQ3JCLFNBQVMsRUFBRSxDQUFDLEtBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztnQkFDekQsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLO2dCQUN2QixrQkFBa0IsRUFBRSxJQUFJO2FBQ3pCLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDBDQUEwQyxFQUFFO2dCQUMzRCxTQUFTLEVBQUcsSUFBSSxDQUFDLEtBQWEsQ0FBQyxJQUFJO2dCQUNuQyxTQUFTLEVBQUcsSUFBSSxDQUFDLEtBQWEsQ0FBQyxJQUFJO2FBQ3BDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0NBQXNDLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sSUFBSSw4QkFBYSxDQUNyQixxQ0FBcUMsRUFDckMsWUFBWSxFQUNaLEtBQUssQ0FDTixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILEdBQUcsQ0FBK0IsR0FBTTtRQUN0QyxJQUFJLENBQUM7WUFDSCxNQUFNLEtBQUssR0FBSSxJQUFJLENBQUMsS0FBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ2xFLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLE1BQU0sSUFBSSw4QkFBYSxDQUNyQiwwQkFBMEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQ3ZDLFdBQVcsRUFDWCxLQUFLLENBQ04sQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxHQUFHLENBQStCLEdBQU0sRUFBRSxLQUFzQjtRQUM5RCxJQUFJLENBQUM7WUFDSCxvQ0FBb0M7WUFDcEMsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2hFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDOUIsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLDZCQUE2QixNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUNqRixrQkFBa0IsRUFDbEIsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FDaEQsQ0FBQztZQUNKLENBQUM7WUFFQSxJQUFJLENBQUMsS0FBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsb0JBQW9CLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNqRSxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDBCQUEwQixNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRTtnQkFDekQsS0FBSztnQkFDTCxLQUFLO2FBQ04sQ0FBQyxDQUFDO1lBQ0gsSUFBSSxLQUFLLFlBQVksOEJBQWEsRUFBRSxDQUFDO2dCQUNuQyxNQUFNLEtBQUssQ0FBQztZQUNkLENBQUM7WUFDRCxNQUFNLElBQUksOEJBQWEsQ0FDckIsMEJBQTBCLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUN2QyxXQUFXLEVBQ1gsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTTtRQUNKLElBQUksQ0FBQztZQUNILE1BQU0sUUFBUSxHQUFJLElBQUksQ0FBQyxLQUFhLENBQUMsS0FBSyxDQUFDO1lBQzNDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7WUFDNUMsT0FBTyxRQUFRLENBQUM7UUFDbEIsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDM0QsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLDRCQUE0QixFQUM1QixlQUFlLEVBQ2YsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSztRQUNILElBQUksQ0FBQztZQUNGLElBQUksQ0FBQyxLQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDNUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUNyRCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDBCQUEwQixFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN6RCxNQUFNLElBQUksOEJBQWEsQ0FBQywwQkFBMEIsRUFBRSxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDNUUsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILEdBQUcsQ0FBQyxHQUF1QjtRQUN6QixJQUFJLENBQUM7WUFDSCxPQUFRLElBQUksQ0FBQyxLQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsc0NBQXNDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFO2dCQUNyRSxLQUFLO2FBQ04sQ0FBQyxDQUFDO1lBQ0gsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLEdBQXVCO1FBQzVCLElBQUksQ0FBQztZQUNGLElBQUksQ0FBQyxLQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsNkJBQTZCLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN6RSxNQUFNLElBQUksOEJBQWEsQ0FDckIsNkJBQTZCLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUMxQyxjQUFjLEVBQ2QsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsUUFBUTtRQUNOLE1BQU0sTUFBTSxHQUE2QjtZQUN2QyxPQUFPLEVBQUUsSUFBSTtZQUNiLE1BQU0sRUFBRSxFQUFFO1lBQ1YsUUFBUSxFQUFFLEVBQUU7U0FDYixDQUFDO1FBRUYsSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRS9CLHdCQUF3QjtZQUN4QixNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hELE1BQU0sVUFBVSxHQUFHLEdBQXlCLENBQUM7Z0JBQzdDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBRWpFLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ3hCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29CQUN2QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUN4RSxDQUFDO2dCQUVELElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUN4QixNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FDbEIsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDLENBQ3RELENBQUM7Z0JBQ0osQ0FBQztZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDN0QsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztZQUN2QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDaEIsc0JBQXNCLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUNqRixDQUFDO1lBQ0YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRO1FBQ04sSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQy9CLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQztZQUV4QixpQkFBaUI7WUFDakIsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ3pELElBQUksQ0FBQyxLQUFhLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDMUMsV0FBVyxHQUFHLElBQUksQ0FBQztZQUNyQixDQUFDO1lBRUQseUJBQXlCO1lBQ3pCLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztnQkFDdkUsSUFBSSxDQUFDLEtBQWEsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNoRCxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLENBQUM7WUFFRCxnQ0FBZ0M7WUFDaEMsSUFDRSxRQUFRLENBQUMsc0JBQXNCLEdBQUcsQ0FBQztnQkFDbkMsUUFBUSxDQUFDLHNCQUFzQixHQUFHLEVBQUUsRUFDcEMsQ0FBQztnQkFDQSxJQUFJLENBQUMsS0FBYSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDckQsV0FBVyxHQUFHLElBQUksQ0FBQztZQUNyQixDQUFDO1lBRUQsdUJBQXVCO1lBQ3ZCLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO2dCQUN2RSxJQUFJLENBQUMsS0FBYSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLENBQUM7WUFFRCxpQkFBaUI7WUFDakIsSUFDRSxRQUFRLENBQUMsZ0JBQWdCO2dCQUN6QixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQzNDLENBQUM7Z0JBQ0EsSUFBSSxDQUFDLEtBQWEsQ0FBQyxHQUFHLENBQ3JCLGtCQUFrQixFQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQ25ELENBQUM7Z0JBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQztZQUNyQixDQUFDO1lBRUQsSUFBSSxXQUFXLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsK0NBQStDLENBQUMsQ0FBQztZQUNwRSxDQUFDO1FBQ0gsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDNUQsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLDZCQUE2QixFQUM3QixnQkFBZ0IsRUFDaEIsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTTtRQUNKLElBQUksQ0FBQztZQUNILE1BQU0sVUFBVSxHQUF1QjtnQkFDckMsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLFVBQVUsRUFBRSxJQUFJLElBQUksRUFBRTtnQkFDdEIsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUU7YUFDeEIsQ0FBQztZQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDdEMsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDMUQsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLDJCQUEyQixFQUMzQixjQUFjLEVBQ2QsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLElBQXdCO1FBQzdCLElBQUksQ0FBQztZQUNILGlDQUFpQztZQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxPQUFPLElBQUksQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFLENBQUM7Z0JBQ3hELE1BQU0sSUFBSSw4QkFBYSxDQUNyQiwrQkFBK0IsRUFDL0IseUJBQXlCLENBQzFCLENBQUM7WUFDSixDQUFDO1lBRUQsNEJBQTRCO1lBQzVCLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztZQUN0QixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFO2dCQUNyRCxJQUFJLEdBQUcsSUFBSSxzQ0FBcUIsRUFBRSxDQUFDO29CQUNqQyxJQUFJLENBQUM7d0JBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUF5QixFQUFFLEtBQVksQ0FBQyxDQUFDO3dCQUNsRCxhQUFhLEVBQUUsQ0FBQztvQkFDbEIsQ0FBQztvQkFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO3dCQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDZCQUE2QixHQUFHLEVBQUUsRUFBRTs0QkFDbkQsS0FBSzs0QkFDTCxLQUFLO3lCQUNOLENBQUMsQ0FBQztvQkFDTCxDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILHFDQUFxQztZQUNyQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDaEIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBRW5DLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGtEQUFrRCxFQUFFO29CQUNuRSxhQUFhO29CQUNiLE1BQU0sRUFBRSxVQUFVLENBQUMsTUFBTTtpQkFDMUIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdDQUFnQyxFQUFFLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztZQUN4RSxDQUFDO1lBRUQsT0FBTyxVQUFVLENBQUMsT0FBTyxDQUFDO1FBQzVCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsMkJBQTJCLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQzFELE1BQU0sSUFBSSw4QkFBYSxDQUNyQiwyQkFBMkIsRUFDM0IsY0FBYyxFQUNkLEtBQUssQ0FDTixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILFlBQVk7UUFDVixPQUFRLElBQUksQ0FBQyxLQUFhLENBQUMsSUFBSSxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxrQkFBa0I7UUFDdEIsSUFBSSxDQUFDO1lBQ0gsMENBQTBDO1lBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQztnQkFDbEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUN2RSxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQzVDLENBQUM7WUFFRCx1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztnQkFDL0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFHLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM1RCxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0QyxDQUFDO1lBRUQscUNBQXFDO1lBQ3JDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUVoQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1FBQ25ELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsdUNBQXVDLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ3RFLE1BQU0sSUFBSSw4QkFBYSxDQUNyQix1Q0FBdUMsRUFDdkMscUJBQXFCLEVBQ3JCLEtBQUssQ0FDTixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxZQUFZO1FBQ2hCLElBQUksQ0FBQztZQUNILE1BQU0sU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNqRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDakMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FDMUIsY0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFDdkIsUUFBUSxFQUNSLG1CQUFtQixTQUFTLE9BQU8sQ0FDcEMsQ0FBQztZQUVGLGlDQUFpQztZQUNqQyxNQUFNLEVBQUUsR0FBRyxtQkFBTyxDQUFDLDBCQUFVLENBQUMsQ0FBQztZQUMvQixNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQzdDLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1lBQzVELE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsa0NBQWtDLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ2pFLE1BQU0sSUFBSSw4QkFBYSxDQUNyQixrQ0FBa0MsRUFDbEMsY0FBYyxFQUNkLEtBQUssQ0FDTixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxVQUFrQjtRQUN4QyxJQUFJLENBQUM7WUFDSCxNQUFNLEVBQUUsR0FBRyxtQkFBTyxDQUFDLDBCQUFVLENBQUMsQ0FBQztZQUMvQixNQUFNLFVBQVUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFakQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztnQkFDN0IsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLCtCQUErQixFQUMvQiwwQkFBMEIsQ0FDM0IsQ0FBQztZQUNKLENBQUM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywrQkFBK0IsRUFBRSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7UUFDcEUsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx3Q0FBd0MsRUFBRTtnQkFDMUQsS0FBSztnQkFDTCxVQUFVO2FBQ1gsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxJQUFJLDhCQUFhLENBQ3JCLHdDQUF3QyxFQUN4QyxlQUFlLEVBQ2YsS0FBSyxDQUNOLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLElBQUksQ0FBQztZQUNILE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFnQixDQUFDLElBQUksT0FBTyxDQUFDO1FBQy9DLENBQUM7UUFBQyxNQUFNLENBQUM7WUFDUCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVSxDQUFDLE9BQWU7UUFDeEIsSUFBSSxDQUFDO1lBQ0YsSUFBSSxDQUFDLEtBQWEsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDBCQUEwQixFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUM1RCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDMUUsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILGNBQWMsQ0FBQyxhQUFxQjtRQUNsQyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDekMsT0FBTyxjQUFjLEtBQUssYUFBYSxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxPQUFPLENBQUMsYUFBcUI7UUFDakMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRXpDLElBQUksQ0FBQztZQUNILElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDZCQUE2QixFQUFFO2dCQUM5QyxjQUFjO2dCQUNkLGFBQWE7YUFDZCxDQUFDLENBQUM7WUFFSCxpQ0FBaUM7WUFDakMsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFN0Msb0NBQW9DO1lBQ3BDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFMUQsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFL0IsMkJBQTJCO1lBQzNCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDZCw0Q0FBNEMsRUFDNUMsVUFBVSxDQUNYLENBQUM7Z0JBQ0YsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2xCLENBQUM7WUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywyQ0FBMkMsRUFBRTtnQkFDNUQsY0FBYztnQkFDZCxhQUFhO2dCQUNiLFVBQVU7YUFDWCxDQUFDLENBQUM7UUFDTCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFO2dCQUM3QyxLQUFLO2dCQUNMLGNBQWM7Z0JBQ2QsYUFBYTthQUNkLENBQUMsQ0FBQztZQUNILE1BQU0sSUFBSSw4QkFBYSxDQUNyQiwyQkFBMkIsRUFDM0IsaUJBQWlCLEVBQ2pCLEtBQUssQ0FDTixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNLLEtBQUssQ0FBQyxlQUFlLENBQzNCLFdBQW1CLEVBQ25CLFNBQWlCO1FBRWpCLG9EQUFvRDtRQUNwRCx3RUFBd0U7UUFFeEUsSUFBSSxXQUFXLEtBQUssT0FBTyxJQUFJLFNBQVMsS0FBSyxPQUFPLEVBQUUsQ0FBQztZQUNyRCxvREFBb0Q7WUFDcEQsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDO2dCQUN0QyxJQUFJLENBQUMsR0FBRyxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3pDLENBQUM7UUFDSCxDQUFDO1FBRUQseURBQXlEO1FBQ3pELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLG9CQUFvQixFQUFFLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsS0FBSyxDQUFDLFdBQVc7UUFHZixJQUFJLENBQUM7WUFDSCxNQUFNLEVBQUUsR0FBRyxtQkFBTyxDQUFDLDBCQUFVLENBQUMsQ0FBQztZQUMvQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQUcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFFL0QsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDdEMsT0FBTyxFQUFFLENBQUM7WUFDWixDQUFDO1lBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzFDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUNoRCxJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLENBQ3BDLENBQUM7WUFFRixNQUFNLE9BQU8sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQy9CLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQVksRUFBRSxFQUFFO2dCQUNyQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDNUMsTUFBTSxLQUFLLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUV0QyxJQUFJLENBQUM7b0JBQ0gsTUFBTSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUN6QyxPQUFPO3dCQUNMLElBQUksRUFBRSxRQUFRO3dCQUNkLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSzt3QkFDakIsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO3FCQUN0QixDQUFDO2dCQUNKLENBQUM7Z0JBQUMsTUFBTSxDQUFDO29CQUNQLE9BQU87d0JBQ0wsSUFBSSxFQUFFLFFBQVE7d0JBQ2QsSUFBSSxFQUFFLEtBQUssQ0FBQyxLQUFLO3FCQUNsQixDQUFDO2dCQUNKLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO1lBRUYsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDdkQsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0sscUJBQXFCLENBQzNCLEdBQXVCLEVBQ3ZCLEtBQVU7UUFFVixNQUFNLE1BQU0sR0FBRztZQUNiLE9BQU8sRUFBRSxJQUFJO1lBQ2IsTUFBTSxFQUFFLEVBQWM7WUFDdEIsUUFBUSxFQUFFLEVBQWM7U0FDekIsQ0FBQztRQUVGLElBQUksQ0FBQztZQUNILFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ1osS0FBSyxPQUFPO29CQUNWLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQ2pELE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO29CQUNuRSxDQUFDO29CQUNELE1BQU07Z0JBRVIsS0FBSyxVQUFVO29CQUNiLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQ3BELE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO29CQUM1RCxDQUFDO29CQUNELE1BQU07Z0JBRVIsS0FBSyxjQUFjO29CQUNqQixJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDeEQsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7d0JBQ3ZCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNoQiwyREFBMkQsQ0FDNUQsQ0FBQztvQkFDSixDQUFDO29CQUNELE1BQU07Z0JBRVIsS0FBSyx3QkFBd0I7b0JBQzNCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksS0FBSyxHQUFHLEVBQUUsRUFBRSxDQUFDO3dCQUN6RCxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzt3QkFDdkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLDREQUE0RCxDQUM3RCxDQUFDO29CQUNKLENBQUM7b0JBQ0QsTUFBTTtnQkFFUixLQUFLLFlBQVk7b0JBQ2YsSUFDRSxDQUFDLEtBQUs7d0JBQ04sT0FBTyxLQUFLLEtBQUssUUFBUTt3QkFDekIsT0FBTyxLQUFLLENBQUMsS0FBSyxLQUFLLFFBQVE7d0JBQy9CLE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxRQUFRO3dCQUNoQyxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUc7d0JBQ2pCLEtBQUssQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUNsQixDQUFDO3dCQUNELE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDaEIsc0RBQXNELENBQ3ZELENBQUM7b0JBQ0osQ0FBQztvQkFDRCxNQUFNO2dCQUVSLEtBQUssZ0JBQWdCO29CQUNuQixJQUNFLENBQUMsS0FBSzt3QkFDTixPQUFPLEtBQUssS0FBSyxRQUFRO3dCQUN6QixPQUFPLEtBQUssQ0FBQyxDQUFDLEtBQUssUUFBUTt3QkFDM0IsT0FBTyxLQUFLLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFDM0IsQ0FBQzt3QkFDRCxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzt3QkFDdkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLHVEQUF1RCxDQUN4RCxDQUFDO29CQUNKLENBQUM7b0JBQ0QsTUFBTTtnQkFFUixLQUFLLGtCQUFrQixDQUFDO2dCQUN4QixLQUFLLGVBQWU7b0JBQ2xCLElBQUksS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDbEUsTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQztvQkFDbkQsQ0FBQztvQkFDRCxNQUFNO1lBQ1YsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7WUFDdkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLHFCQUFxQixLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FDaEYsQ0FBQztRQUNKLENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUF2cEJELDBDQXVwQkM7QUFFRCw4QkFBOEI7QUFDakIsdUJBQWUsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy9zZXR0aW5nc1NlcnZpY2UudHM/MmZmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XHJcbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7XHJcbiAgREVGQVVMVF9VU0VSX1NFVFRJTkdTLFxyXG4gIElTZXR0aW5nc1NlcnZpY2UsXHJcbiAgU0VUVElOR1NfU0NIRU1BLFxyXG4gIFNldHRpbmdzRXJyb3IsXHJcbiAgU2V0dGluZ3NFeHBvcnREYXRhLFxyXG4gIFNldHRpbmdzVmFsaWRhdGlvblJlc3VsdCxcclxuICBVc2VyU2V0dGluZ3MsXHJcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL3R5cGVzL3NldHRpbmdzLXR5cGVzJztcclxuXHJcbi8vIExvZ2dlciBpbnRlcmZhY2UgKHdpbGwgYmUgaW1wbGVtZW50ZWQgaW4gdGFzayAxMClcclxuaW50ZXJmYWNlIExvZ2dlciB7XHJcbiAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBhbnkpOiB2b2lkO1xyXG4gIHdhcm4obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogYW55KTogdm9pZDtcclxuICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBhbnkpOiB2b2lkO1xyXG4gIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IGFueSk6IHZvaWQ7XHJcbn1cclxuXHJcbi8vIFNpbXBsZSBjb25zb2xlIGxvZ2dlciBmYWxsYmFja1xyXG5jb25zdCBjb25zb2xlTG9nZ2VyOiBMb2dnZXIgPSB7XHJcbiAgaW5mbzogKG1lc3NhZ2UsIG1ldGEpID0+IGNvbnNvbGUubG9nKGBbSU5GT10gJHttZXNzYWdlfWAsIG1ldGEgfHwgJycpLFxyXG4gIHdhcm46IChtZXNzYWdlLCBtZXRhKSA9PiBjb25zb2xlLndhcm4oYFtXQVJOXSAke21lc3NhZ2V9YCwgbWV0YSB8fCAnJyksXHJcbiAgZXJyb3I6IChtZXNzYWdlLCBtZXRhKSA9PiBjb25zb2xlLmVycm9yKGBbRVJST1JdICR7bWVzc2FnZX1gLCBtZXRhIHx8ICcnKSxcclxuICBkZWJ1ZzogKG1lc3NhZ2UsIG1ldGEpID0+IGNvbnNvbGUuZGVidWcoYFtERUJVR10gJHttZXNzYWdlfWAsIG1ldGEgfHwgJycpLFxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFNldHRpbmdzU2VydmljZSBpbXBsZW1lbnRzIElTZXR0aW5nc1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgc3RvcmU6IFN0b3JlPFVzZXJTZXR0aW5ncz47XHJcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcclxuXHJcbiAgY29uc3RydWN0b3IobG9nZ2VyPzogTG9nZ2VyKSB7XHJcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlciB8fCBjb25zb2xlTG9nZ2VyO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RvcmU8VXNlclNldHRpbmdzPih7XHJcbiAgICAgICAgZGVmYXVsdHM6IERFRkFVTFRfVVNFUl9TRVRUSU5HUyxcclxuICAgICAgICBzY2hlbWE6IFNFVFRJTkdTX1NDSEVNQSxcclxuICAgICAgICBuYW1lOiAndXNlci1zZXR0aW5ncycsXHJcbiAgICAgICAgY3dkOiBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdjb25maWcnKSxcclxuICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXHJcbiAgICAgICAgc2VyaWFsaXplOiAodmFsdWU6IGFueSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpLFxyXG4gICAgICAgIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlLFxyXG4gICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXR0aW5nc1NlcnZpY2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jywge1xyXG4gICAgICAgIHN0b3JlUGF0aDogKHRoaXMuc3RvcmUgYXMgYW55KS5wYXRoLFxyXG4gICAgICAgIHN0b3JlU2l6ZTogKHRoaXMuc3RvcmUgYXMgYW55KS5zaXplLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTZXR0aW5nc1NlcnZpY2UnLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgU2V0dGluZ3NFcnJvcihcclxuICAgICAgICAnRmFpbGVkIHRvIGluaXRpYWxpemUgc2V0dGluZ3Mgc3RvcmUnLFxyXG4gICAgICAgICdJTklUX0VSUk9SJyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHNldHRpbmcgdmFsdWUgYnkga2V5IHdpdGggdHlwZSBzYWZldHlcclxuICAgKi9cclxuICBnZXQ8SyBleHRlbmRzIGtleW9mIFVzZXJTZXR0aW5ncz4oa2V5OiBLKTogVXNlclNldHRpbmdzW0tdIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gKHRoaXMuc3RvcmUgYXMgYW55KS5nZXQoa2V5KTtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFJldHJpZXZlZCBzZXR0aW5nOiAke1N0cmluZyhrZXkpfWAsIHsgdmFsdWUgfSk7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZ2V0IHNldHRpbmc6ICR7U3RyaW5nKGtleSl9YCwgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgc2V0dGluZzogJHtTdHJpbmcoa2V5KX1gLFxyXG4gICAgICAgICdHRVRfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGEgc2V0dGluZyB2YWx1ZSBieSBrZXkgd2l0aCB2YWxpZGF0aW9uXHJcbiAgICovXHJcbiAgc2V0PEsgZXh0ZW5kcyBrZXlvZiBVc2VyU2V0dGluZ3M+KGtleTogSywgdmFsdWU6IFVzZXJTZXR0aW5nc1tLXSk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdGhlIHZhbHVlIGJlZm9yZSBzZXR0aW5nXHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlU2luZ2xlU2V0dGluZyhrZXksIHZhbHVlKTtcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LmlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgU2V0dGluZ3NFcnJvcihcclxuICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBzZXR0aW5nICR7U3RyaW5nKGtleSl9OiAke3ZhbGlkYXRpb25SZXN1bHQuZXJyb3JzLmpvaW4oJywgJyl9YCxcclxuICAgICAgICAgICdWQUxJREFUSU9OX0VSUk9SJyxcclxuICAgICAgICAgIHsga2V5LCB2YWx1ZSwgZXJyb3JzOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9ycyB9LFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBVcGRhdGVkIHNldHRpbmc6ICR7U3RyaW5nKGtleSl9YCwgeyB2YWx1ZSB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gc2V0IHNldHRpbmc6ICR7U3RyaW5nKGtleSl9YCwge1xyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2V0dGluZ3NFcnJvcikge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBTZXR0aW5nc0Vycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gc2V0IHNldHRpbmc6ICR7U3RyaW5nKGtleSl9YCxcclxuICAgICAgICAnU0VUX0VSUk9SJyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgc2V0dGluZ3NcclxuICAgKi9cclxuICBnZXRBbGwoKTogVXNlclNldHRpbmdzIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gKHRoaXMuc3RvcmUgYXMgYW55KS5zdG9yZTtcclxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1JldHJpZXZlZCBhbGwgc2V0dGluZ3MnKTtcclxuICAgICAgcmV0dXJuIHNldHRpbmdzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWxsIHNldHRpbmdzJywgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgJ0ZhaWxlZCB0byBnZXQgYWxsIHNldHRpbmdzJyxcclxuICAgICAgICAnR0VUX0FMTF9FUlJPUicsXHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCBhbGwgc2V0dGluZ3MgdG8gZGVmYXVsdHNcclxuICAgKi9cclxuICByZXNldCgpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuY2xlYXIoKTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnUmVzZXQgYWxsIHNldHRpbmdzIHRvIGRlZmF1bHRzJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJlc2V0IHNldHRpbmdzJywgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoJ0ZhaWxlZCB0byByZXNldCBzZXR0aW5ncycsICdSRVNFVF9FUlJPUicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgc2V0dGluZyBleGlzdHMgKGhhcyBiZWVuIHNldClcclxuICAgKi9cclxuICBoYXMoa2V5OiBrZXlvZiBVc2VyU2V0dGluZ3MpOiBib29sZWFuIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5zdG9yZSBhcyBhbnkpLmhhcyhrZXkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBjaGVjayBzZXR0aW5nIGV4aXN0ZW5jZTogJHtTdHJpbmcoa2V5KX1gLCB7XHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYSBzcGVjaWZpYyBzZXR0aW5nIChyZXZlcnQgdG8gZGVmYXVsdClcclxuICAgKi9cclxuICBkZWxldGUoa2V5OiBrZXlvZiBVc2VyU2V0dGluZ3MpOiB2b2lkIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuZGVsZXRlKGtleSk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYERlbGV0ZWQgc2V0dGluZzogJHtTdHJpbmcoa2V5KX1gKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIHNldHRpbmc6ICR7U3RyaW5nKGtleSl9YCwgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBkZWxldGUgc2V0dGluZzogJHtTdHJpbmcoa2V5KX1gLFxyXG4gICAgICAgICdERUxFVEVfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYWxsIHNldHRpbmdzIGFuZCByZXR1cm4gZGV0YWlsZWQgcmVzdWx0c1xyXG4gICAqL1xyXG4gIHZhbGlkYXRlKCk6IFNldHRpbmdzVmFsaWRhdGlvblJlc3VsdCB7XHJcbiAgICBjb25zdCByZXN1bHQ6IFNldHRpbmdzVmFsaWRhdGlvblJlc3VsdCA9IHtcclxuICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgZXJyb3JzOiBbXSxcclxuICAgICAgd2FybmluZ3M6IFtdLFxyXG4gICAgfTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMuZ2V0QWxsKCk7XHJcblxyXG4gICAgICAvLyBWYWxpZGF0ZSBlYWNoIHNldHRpbmdcclxuICAgICAgT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNldHRpbmdLZXkgPSBrZXkgYXMga2V5b2YgVXNlclNldHRpbmdzO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlU2luZ2xlU2V0dGluZyhzZXR0aW5nS2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKC4uLnZhbGlkYXRpb24uZXJyb3JzLm1hcChlcnIgPT4gYCR7a2V5fTogJHtlcnJ9YCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbGlkYXRpb24ud2FybmluZ3MpIHtcclxuICAgICAgICAgIHJlc3VsdC53YXJuaW5ncy5wdXNoKFxyXG4gICAgICAgICAgICAuLi52YWxpZGF0aW9uLndhcm5pbmdzLm1hcCh3YXJuID0+IGAke2tleX06ICR7d2Fybn1gKSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXR0aW5ncyB2YWxpZGF0aW9uIGNvbXBsZXRlZCcsIHJlc3VsdCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICByZXN1bHQuZXJyb3JzLnB1c2goXHJcbiAgICAgICAgYFZhbGlkYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdTZXR0aW5ncyB2YWxpZGF0aW9uIGZhaWxlZCcsIHsgZXJyb3IgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhbml0aXplIHNldHRpbmdzIGJ5IGZpeGluZyBpbnZhbGlkIHZhbHVlc1xyXG4gICAqL1xyXG4gIHNhbml0aXplKCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLmdldEFsbCgpO1xyXG4gICAgICBsZXQgY2hhbmdlc01hZGUgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFNhbml0aXplIHRoZW1lXHJcbiAgICAgIGlmICghWydsaWdodCcsICdkYXJrJywgJ3N5c3RlbSddLmluY2x1ZGVzKHNldHRpbmdzLnRoZW1lKSkge1xyXG4gICAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuc2V0KCd0aGVtZScsICdsaWdodCcpO1xyXG4gICAgICAgIGNoYW5nZXNNYWRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2FuaXRpemUgdmlkZW8gcXVhbGl0eVxyXG4gICAgICBpZiAoIVsnYmVzdCcsICd3b3JzdCcsICc3MjBwJywgJzEwODBwJ10uaW5jbHVkZXMoc2V0dGluZ3MudmlkZW9RdWFsaXR5KSkge1xyXG4gICAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuc2V0KCd2aWRlb1F1YWxpdHknLCAnYmVzdCcpO1xyXG4gICAgICAgIGNoYW5nZXNNYWRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2FuaXRpemUgY29uY3VycmVudCBkb3dubG9hZHNcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHNldHRpbmdzLm1heENvbmN1cnJlbnREb3dubG9hZHMgPCAxIHx8XHJcbiAgICAgICAgc2V0dGluZ3MubWF4Q29uY3VycmVudERvd25sb2FkcyA+IDEwXHJcbiAgICAgICkge1xyXG4gICAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuc2V0KCdtYXhDb25jdXJyZW50RG93bmxvYWRzJywgMyk7XHJcbiAgICAgICAgY2hhbmdlc01hZGUgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTYW5pdGl6ZSB3aW5kb3cgc2l6ZVxyXG4gICAgICBpZiAoc2V0dGluZ3Mud2luZG93U2l6ZS53aWR0aCA8IDgwMCB8fCBzZXR0aW5ncy53aW5kb3dTaXplLmhlaWdodCA8IDYwMCkge1xyXG4gICAgICAgICh0aGlzLnN0b3JlIGFzIGFueSkuc2V0KCd3aW5kb3dTaXplJywgeyB3aWR0aDogMTIwMCwgaGVpZ2h0OiA4MDAgfSk7XHJcbiAgICAgICAgY2hhbmdlc01hZGUgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTYW5pdGl6ZSBwYXRoc1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgc2V0dGluZ3MuZG93bmxvYWRMb2NhdGlvbiAmJlxyXG4gICAgICAgICFwYXRoLmlzQWJzb2x1dGUoc2V0dGluZ3MuZG93bmxvYWRMb2NhdGlvbilcclxuICAgICAgKSB7XHJcbiAgICAgICAgKHRoaXMuc3RvcmUgYXMgYW55KS5zZXQoXHJcbiAgICAgICAgICAnZG93bmxvYWRMb2NhdGlvbicsXHJcbiAgICAgICAgICBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ2Rvd25sb2FkcycpLCAnUGxheWxpc3RpZnknKSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNoYW5nZXNNYWRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNoYW5nZXNNYWRlKSB7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2V0dGluZ3Mgc2FuaXRpemVkIC0gaW52YWxpZCB2YWx1ZXMgY29ycmVjdGVkJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc2FuaXRpemUgc2V0dGluZ3MnLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgU2V0dGluZ3NFcnJvcihcclxuICAgICAgICAnRmFpbGVkIHRvIHNhbml0aXplIHNldHRpbmdzJyxcclxuICAgICAgICAnU0FOSVRJWkVfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhwb3J0IHNldHRpbmdzIHdpdGggbWV0YWRhdGFcclxuICAgKi9cclxuICBleHBvcnQoKTogU2V0dGluZ3NFeHBvcnREYXRhIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGV4cG9ydERhdGE6IFNldHRpbmdzRXhwb3J0RGF0YSA9IHtcclxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxyXG4gICAgICAgIGV4cG9ydERhdGU6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgc2V0dGluZ3M6IHRoaXMuZ2V0QWxsKCksXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXR0aW5ncyBleHBvcnRlZCcpO1xyXG4gICAgICByZXR1cm4gZXhwb3J0RGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZXhwb3J0IHNldHRpbmdzJywgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgJ0ZhaWxlZCB0byBleHBvcnQgc2V0dGluZ3MnLFxyXG4gICAgICAgICdFWFBPUlRfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wb3J0IHNldHRpbmdzIHdpdGggdmFsaWRhdGlvblxyXG4gICAqL1xyXG4gIGltcG9ydChkYXRhOiBTZXR0aW5nc0V4cG9ydERhdGEpOiBib29sZWFuIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIGltcG9ydCBkYXRhIHN0cnVjdHVyZVxyXG4gICAgICBpZiAoIWRhdGEuc2V0dGluZ3MgfHwgdHlwZW9mIGRhdGEuc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgICAnSW52YWxpZCBpbXBvcnQgZGF0YSBzdHJ1Y3R1cmUnLFxyXG4gICAgICAgICAgJ0lNUE9SVF9WQUxJREFUSU9OX0VSUk9SJyxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbXBvcnQgZWFjaCB2YWxpZCBzZXR0aW5nXHJcbiAgICAgIGxldCBpbXBvcnRlZENvdW50ID0gMDtcclxuICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YS5zZXR0aW5ncykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBERUZBVUxUX1VTRVJfU0VUVElOR1MpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSBhcyBrZXlvZiBVc2VyU2V0dGluZ3MsIHZhbHVlIGFzIGFueSk7XHJcbiAgICAgICAgICAgIGltcG9ydGVkQ291bnQrKztcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEZhaWxlZCB0byBpbXBvcnQgc2V0dGluZzogJHtrZXl9YCwge1xyXG4gICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgYW5kIHNhbml0aXplIGFmdGVyIGltcG9ydFxyXG4gICAgICB0aGlzLnNhbml0aXplKCk7XHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKCk7XHJcblxyXG4gICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1NldHRpbmdzIGltcG9ydCBjb21wbGV0ZWQgd2l0aCB2YWxpZGF0aW9uIGVycm9ycycsIHtcclxuICAgICAgICAgIGltcG9ydGVkQ291bnQsXHJcbiAgICAgICAgICBlcnJvcnM6IHZhbGlkYXRpb24uZXJyb3JzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1NldHRpbmdzIGltcG9ydGVkIHN1Y2Nlc3NmdWxseScsIHsgaW1wb3J0ZWRDb3VudCB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZhbGlkYXRpb24uaXNWYWxpZDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IHNldHRpbmdzJywgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgJ0ZhaWxlZCB0byBpbXBvcnQgc2V0dGluZ3MnLFxyXG4gICAgICAgICdJTVBPUlRfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaWxlIHBhdGggd2hlcmUgc2V0dGluZ3MgYXJlIHN0b3JlZFxyXG4gICAqL1xyXG4gIGdldFN0b3JlUGF0aCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICh0aGlzLnN0b3JlIGFzIGFueSkucGF0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgZGVmYXVsdCBzZXR0aW5ncyBhbmQgZGlyZWN0b3JpZXNcclxuICAgKi9cclxuICBhc3luYyBpbml0aWFsaXplRGVmYXVsdHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJbml0aWFsaXplIGRvd25sb2FkIGxvY2F0aW9uIGlmIG5vdCBzZXRcclxuICAgICAgaWYgKCF0aGlzLmdldCgnZG93bmxvYWRMb2NhdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFBhdGggPSBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ2Rvd25sb2FkcycpLCAnUGxheWxpc3RpZnknKTtcclxuICAgICAgICB0aGlzLnNldCgnZG93bmxvYWRMb2NhdGlvbicsIGRlZmF1bHRQYXRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGl6ZSB0ZW1wIGRpcmVjdG9yeSBpZiBub3Qgc2V0XHJcbiAgICAgIGlmICghdGhpcy5nZXQoJ3RlbXBEaXJlY3RvcnknKSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXBQYXRoID0gcGF0aC5qb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCAndGVtcCcpO1xyXG4gICAgICAgIHRoaXMuc2V0KCd0ZW1wRGlyZWN0b3J5JywgdGVtcFBhdGgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWYWxpZGF0ZSBhbmQgc2FuaXRpemUgYWxsIHNldHRpbmdzXHJcbiAgICAgIHRoaXMuc2FuaXRpemUoKTtcclxuXHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0RlZmF1bHQgc2V0dGluZ3MgaW5pdGlhbGl6ZWQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBkZWZhdWx0IHNldHRpbmdzJywgeyBlcnJvciB9KTtcclxuICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgJ0ZhaWxlZCB0byBpbml0aWFsaXplIGRlZmF1bHQgc2V0dGluZ3MnLFxyXG4gICAgICAgICdJTklUX0RFRkFVTFRTX0VSUk9SJyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGJhY2t1cCBvZiBjdXJyZW50IHNldHRpbmdzXHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlQmFja3VwKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWzouXS9nLCAnLScpO1xyXG4gICAgICBjb25zdCBiYWNrdXBEYXRhID0gdGhpcy5leHBvcnQoKTtcclxuICAgICAgY29uc3QgYmFja3VwUGF0aCA9IHBhdGguam9pbihcclxuICAgICAgICBhcHAuZ2V0UGF0aCgndXNlckRhdGEnKSxcclxuICAgICAgICAnY29uZmlnJyxcclxuICAgICAgICBgc2V0dGluZ3MtYmFja3VwLSR7dGltZXN0YW1wfS5qc29uYCxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSBiYWNrdXAgZGlyZWN0b3J5IGV4aXN0c1xyXG4gICAgICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzLWV4dHJhJyk7XHJcbiAgICAgIGF3YWl0IGZzLmVuc3VyZURpcihwYXRoLmRpcm5hbWUoYmFja3VwUGF0aCkpO1xyXG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24oYmFja3VwUGF0aCwgYmFja3VwRGF0YSwgeyBzcGFjZXM6IDIgfSk7XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXR0aW5ncyBiYWNrdXAgY3JlYXRlZCcsIHsgYmFja3VwUGF0aCB9KTtcclxuICAgICAgcmV0dXJuIGJhY2t1cFBhdGg7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXR0aW5ncyBiYWNrdXAnLCB7IGVycm9yIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgU2V0dGluZ3NFcnJvcihcclxuICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBzZXR0aW5ncyBiYWNrdXAnLFxyXG4gICAgICAgICdCQUNLVVBfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdG9yZSBzZXR0aW5ncyBmcm9tIGJhY2t1cFxyXG4gICAqL1xyXG4gIGFzeW5jIHJlc3RvcmVGcm9tQmFja3VwKGJhY2t1cFBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xyXG4gICAgICBjb25zdCBiYWNrdXBEYXRhID0gYXdhaXQgZnMucmVhZEpzb24oYmFja3VwUGF0aCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuaW1wb3J0KGJhY2t1cERhdGEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFNldHRpbmdzRXJyb3IoXHJcbiAgICAgICAgICAnQmFja3VwIGRhdGEgdmFsaWRhdGlvbiBmYWlsZWQnLFxyXG4gICAgICAgICAgJ1JFU1RPUkVfVkFMSURBVElPTl9FUlJPUicsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2V0dGluZ3MgcmVzdG9yZWQgZnJvbSBiYWNrdXAnLCB7IGJhY2t1cFBhdGggfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHJlc3RvcmUgc2V0dGluZ3MgZnJvbSBiYWNrdXAnLCB7XHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgYmFja3VwUGF0aCxcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IG5ldyBTZXR0aW5nc0Vycm9yKFxyXG4gICAgICAgICdGYWlsZWQgdG8gcmVzdG9yZSBzZXR0aW5ncyBmcm9tIGJhY2t1cCcsXHJcbiAgICAgICAgJ1JFU1RPUkVfRVJST1InLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgc2V0dGluZ3MgdmVyc2lvblxyXG4gICAqL1xyXG4gIGdldFZlcnNpb24oKTogc3RyaW5nIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldCgndmVyc2lvbicgYXMgYW55KSB8fCAnMS4wLjAnO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiAnMS4wLjAnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHNldHRpbmdzIHZlcnNpb25cclxuICAgKi9cclxuICBzZXRWZXJzaW9uKHZlcnNpb246IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgKHRoaXMuc3RvcmUgYXMgYW55KS5zZXQoJ3ZlcnNpb24nLCB2ZXJzaW9uKTtcclxuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2V0dGluZ3MgdmVyc2lvbiB1cGRhdGVkJywgeyB2ZXJzaW9uIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzZXQgc2V0dGluZ3MgdmVyc2lvbicsIHsgZXJyb3IsIHZlcnNpb24gfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBtaWdyYXRpb24gaXMgbmVlZGVkXHJcbiAgICovXHJcbiAgbmVlZHNNaWdyYXRpb24odGFyZ2V0VmVyc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9IHRoaXMuZ2V0VmVyc2lvbigpO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRWZXJzaW9uICE9PSB0YXJnZXRWZXJzaW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlncmF0ZSBzZXR0aW5ncyB0byBuZXcgdmVyc2lvblxyXG4gICAqL1xyXG4gIGFzeW5jIG1pZ3JhdGUodGFyZ2V0VmVyc2lvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9IHRoaXMuZ2V0VmVyc2lvbigpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIHNldHRpbmdzIG1pZ3JhdGlvbicsIHtcclxuICAgICAgICBjdXJyZW50VmVyc2lvbixcclxuICAgICAgICB0YXJnZXRWZXJzaW9uLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBiYWNrdXAgYmVmb3JlIG1pZ3JhdGlvblxyXG4gICAgICBjb25zdCBiYWNrdXBQYXRoID0gYXdhaXQgdGhpcy5jcmVhdGVCYWNrdXAoKTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IHZlcnNpb24tc3BlY2lmaWMgbWlncmF0aW9uc1xyXG4gICAgICBhd2FpdCB0aGlzLmFwcGx5TWlncmF0aW9ucyhjdXJyZW50VmVyc2lvbiwgdGFyZ2V0VmVyc2lvbik7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdmVyc2lvblxyXG4gICAgICB0aGlzLnNldFZlcnNpb24odGFyZ2V0VmVyc2lvbik7XHJcblxyXG4gICAgICAvLyBWYWxpZGF0ZSBhZnRlciBtaWdyYXRpb25cclxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxyXG4gICAgICAgICAgJ1NldHRpbmdzIHZhbGlkYXRpb24gZmFpbGVkIGFmdGVyIG1pZ3JhdGlvbicsXHJcbiAgICAgICAgICB2YWxpZGF0aW9uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5zYW5pdGl6ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXR0aW5ncyBtaWdyYXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseScsIHtcclxuICAgICAgICBjdXJyZW50VmVyc2lvbixcclxuICAgICAgICB0YXJnZXRWZXJzaW9uLFxyXG4gICAgICAgIGJhY2t1cFBhdGgsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1NldHRpbmdzIG1pZ3JhdGlvbiBmYWlsZWQnLCB7XHJcbiAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgY3VycmVudFZlcnNpb24sXHJcbiAgICAgICAgdGFyZ2V0VmVyc2lvbixcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IG5ldyBTZXR0aW5nc0Vycm9yKFxyXG4gICAgICAgICdTZXR0aW5ncyBtaWdyYXRpb24gZmFpbGVkJyxcclxuICAgICAgICAnTUlHUkFUSU9OX0VSUk9SJyxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHZlcnNpb24tc3BlY2lmaWMgbWlncmF0aW9uIGxvZ2ljXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBhcHBseU1pZ3JhdGlvbnMoXHJcbiAgICBmcm9tVmVyc2lvbjogc3RyaW5nLFxyXG4gICAgdG9WZXJzaW9uOiBzdHJpbmcsXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBNaWdyYXRpb24gbG9naWMgZm9yIGRpZmZlcmVudCB2ZXJzaW9uIHRyYW5zaXRpb25zXHJcbiAgICAvLyBUaGlzIGlzIHdoZXJlIHlvdSB3b3VsZCBhZGQgc3BlY2lmaWMgbWlncmF0aW9uIHN0ZXBzIGZvciBlYWNoIHZlcnNpb25cclxuXHJcbiAgICBpZiAoZnJvbVZlcnNpb24gPT09ICcxLjAuMCcgJiYgdG9WZXJzaW9uID09PSAnMS4xLjAnKSB7XHJcbiAgICAgIC8vIEV4YW1wbGUgbWlncmF0aW9uOiBBZGQgbmV3IHNldHRpbmdzIHdpdGggZGVmYXVsdHNcclxuICAgICAgaWYgKCF0aGlzLmhhcygnbm90aWZpY2F0aW9uc0VuYWJsZWQnKSkge1xyXG4gICAgICAgIHRoaXMuc2V0KCdub3RpZmljYXRpb25zRW5hYmxlZCcsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIG1vcmUgbWlncmF0aW9uIGxvZ2ljIGFzIG5lZWRlZCBmb3IgZnV0dXJlIHZlcnNpb25zXHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQXBwbGllZCBtaWdyYXRpb25zJywgeyBmcm9tVmVyc2lvbiwgdG9WZXJzaW9uIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdCBhdmFpbGFibGUgYmFja3Vwc1xyXG4gICAqL1xyXG4gIGFzeW5jIGxpc3RCYWNrdXBzKCk6IFByb21pc2U8XHJcbiAgICBBcnJheTx7IHBhdGg6IHN0cmluZzsgZGF0ZTogRGF0ZTsgdmVyc2lvbj86IHN0cmluZyB9PlxyXG4gID4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xyXG4gICAgICBjb25zdCBiYWNrdXBEaXIgPSBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdjb25maWcnKTtcclxuXHJcbiAgICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHMoYmFja3VwRGlyKSkpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcihiYWNrdXBEaXIpO1xyXG4gICAgICBjb25zdCBiYWNrdXBGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZTogc3RyaW5nKSA9PlxyXG4gICAgICAgIGZpbGUuc3RhcnRzV2l0aCgnc2V0dGluZ3MtYmFja3VwLScpLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgYmFja3VwcyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgIGJhY2t1cEZpbGVzLm1hcChhc3luYyAoZmlsZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihiYWNrdXBEaXIsIGZpbGUpO1xyXG4gICAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KGZpbGVQYXRoKTtcclxuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucmVhZEpzb24oZmlsZVBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgIGRhdGU6IHN0YXRzLm10aW1lLFxyXG4gICAgICAgICAgICAgIHZlcnNpb246IGRhdGEudmVyc2lvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgIGRhdGU6IHN0YXRzLm10aW1lLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIGJhY2t1cHMuc29ydCgoYSwgYikgPT4gYi5kYXRlLmdldFRpbWUoKSAtIGEuZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBsaXN0IGJhY2t1cHMnLCB7IGVycm9yIH0pO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSBhIHNpbmdsZSBzZXR0aW5nIHZhbHVlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB2YWxpZGF0ZVNpbmdsZVNldHRpbmcoXHJcbiAgICBrZXk6IGtleW9mIFVzZXJTZXR0aW5ncyxcclxuICAgIHZhbHVlOiBhbnksXHJcbiAgKTogeyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcnM6IHN0cmluZ1tdOyB3YXJuaW5ncz86IHN0cmluZ1tdIH0ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICBlcnJvcnM6IFtdIGFzIHN0cmluZ1tdLFxyXG4gICAgICB3YXJuaW5nczogW10gYXMgc3RyaW5nW10sXHJcbiAgICB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAndGhlbWUnOlxyXG4gICAgICAgICAgaWYgKCFbJ2xpZ2h0JywgJ2RhcmsnLCAnc3lzdGVtJ10uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaCgnVGhlbWUgbXVzdCBiZSBcImxpZ2h0XCIsIFwiZGFya1wiLCBvciBcInN5c3RlbVwiJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnbGFuZ3VhZ2UnOlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaCgnTGFuZ3VhZ2UgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICd2aWRlb1F1YWxpdHknOlxyXG4gICAgICAgICAgaWYgKCFbJ2Jlc3QnLCAnd29yc3QnLCAnNzIwcCcsICcxMDgwcCddLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goXHJcbiAgICAgICAgICAgICAgJ1ZpZGVvIHF1YWxpdHkgbXVzdCBiZSBcImJlc3RcIiwgXCJ3b3JzdFwiLCBcIjcyMHBcIiwgb3IgXCIxMDgwcFwiJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdtYXhDb25jdXJyZW50RG93bmxvYWRzJzpcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMSB8fCB2YWx1ZSA+IDEwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChcclxuICAgICAgICAgICAgICAnTWF4IGNvbmN1cnJlbnQgZG93bmxvYWRzIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAxMCcsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnd2luZG93U2l6ZSc6XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF2YWx1ZSB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS53aWR0aCAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmhlaWdodCAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICAgICAgdmFsdWUud2lkdGggPCA4MDAgfHxcclxuICAgICAgICAgICAgdmFsdWUuaGVpZ2h0IDwgNjAwXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKFxyXG4gICAgICAgICAgICAgICdXaW5kb3cgc2l6ZSBtdXN0IGhhdmUgd2lkdGggPj0gODAwIGFuZCBoZWlnaHQgPj0gNjAwJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICd3aW5kb3dQb3NpdGlvbic6XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF2YWx1ZSB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS54ICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUueSAhPT0gJ251bWJlcidcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2goXHJcbiAgICAgICAgICAgICAgJ1dpbmRvdyBwb3NpdGlvbiBtdXN0IGhhdmUgbnVtZXJpYyB4IGFuZCB5IGNvb3JkaW5hdGVzJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlICdkb3dubG9hZExvY2F0aW9uJzpcclxuICAgICAgICBjYXNlICd0ZW1wRGlyZWN0b3J5JzpcclxuICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFwYXRoLmlzQWJzb2x1dGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC53YXJuaW5ncz8ucHVzaCgnUGF0aCBzaG91bGQgYmUgYWJzb2x1dGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXN1bHQuaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICByZXN1bHQuZXJyb3JzLnB1c2goXHJcbiAgICAgICAgYFZhbGlkYXRpb24gZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBzZXR0aW5nc1NlcnZpY2UgPSBuZXcgU2V0dGluZ3NTZXJ2aWNlKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/services/settingsService.ts\n\n}");

/***/ }),

/***/ "./src/backend/services/window-manager-service.ts":
/*!********************************************************!*\
  !*** ./src/backend/services/window-manager-service.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Window Manager Service\n * Handles window lifecycle, state management, and multi-window support\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WindowManagerService = void 0;\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nclass WindowManagerService extends events_1.EventEmitter {\n    constructor(logger, settings) {\n        super();\n        this.windows = new Map();\n        this.windowConfigs = new Map();\n        this.windowStates = new Map();\n        this.isShuttingDown = false;\n        this.stateUpdateTimeout = null;\n        this.logger = logger;\n        this.settings = settings;\n        this.setupAppEventHandlers();\n    }\n    /**\n     * Create a new window with the specified configuration\n     */\n    async createWindow(config, url) {\n        try {\n            this.logger.info(`Creating window: ${config.id}`, 'WindowManager');\n            // Check if window already exists\n            if (this.windows.has(config.id)) {\n                const existingWindow = this.windows.get(config.id);\n                if (!existingWindow.isDestroyed()) {\n                    existingWindow.focus();\n                    return existingWindow;\n                }\n                else {\n                    // Clean up destroyed window reference\n                    this.windows.delete(config.id);\n                    this.windowConfigs.delete(config.id);\n                    this.windowStates.delete(config.id);\n                }\n            }\n            // Restore window state if available\n            const savedState = await this.loadWindowState(config.id);\n            const windowBounds = this.calculateWindowBounds(config, savedState || undefined);\n            // Create browser window\n            const window = new electron_1.BrowserWindow({\n                ...windowBounds,\n                minWidth: config.minWidth,\n                minHeight: config.minHeight,\n                resizable: config.resizable ?? true,\n                minimizable: config.minimizable ?? true,\n                maximizable: config.maximizable ?? true,\n                closable: config.closable ?? true,\n                alwaysOnTop: config.alwaysOnTop ?? false,\n                skipTaskbar: config.skipTaskbar ?? false,\n                title: config.title ?? 'Playlistify',\n                show: config.show ?? false,\n                frame: config.frame ?? true,\n                transparent: config.transparent ?? false,\n                webPreferences: {\n                    nodeIntegration: false,\n                    contextIsolation: true,\n                    webSecurity: true,\n                    ...config.webPreferences,\n                },\n            });\n            // Store window references\n            this.windows.set(config.id, window);\n            this.windowConfigs.set(config.id, config);\n            // Initialize window state\n            const initialState = {\n                id: config.id,\n                bounds: window.getBounds(),\n                isMaximized: window.isMaximized(),\n                isMinimized: window.isMinimized(),\n                isFullScreen: window.isFullScreen(),\n                isVisible: window.isVisible(),\n                isFocused: window.isFocused(),\n                lastFocused: Date.now(),\n            };\n            this.windowStates.set(config.id, initialState);\n            // Set up window event handlers\n            this.setupWindowEventHandlers(window, config.id);\n            // Restore maximized state if needed\n            if (savedState?.isMaximized) {\n                window.maximize();\n            }\n            // Load URL if provided\n            if (url) {\n                await window.loadURL(url);\n            }\n            // Show window when ready\n            window.once('ready-to-show', () => {\n                if (!window.isDestroyed()) {\n                    window.show();\n                    if (config.center || (!config.x && !config.y)) {\n                        window.center();\n                    }\n                    this.logger.debug(`Window ready and shown: ${config.id}`, 'WindowManager');\n                }\n            });\n            this.emit('window-created', { window, config });\n            this.logger.info(`Window created successfully: ${config.id}`, 'WindowManager');\n            return window;\n        }\n        catch (error) {\n            this.logger.error(`Failed to create window: ${config.id}`, 'WindowManager', {\n                error: error instanceof Error ? error.message : error,\n            });\n            throw error;\n        }\n    }\n    /**\n     * Get a window by ID\n     */\n    getWindow(windowId) {\n        const window = this.windows.get(windowId);\n        return window && !window.isDestroyed() ? window : null;\n    }\n    /**\n     * Get all active windows\n     */\n    getAllWindows() {\n        return Array.from(this.windows.values()).filter(window => !window.isDestroyed());\n    }\n    /**\n     * Get window state by ID\n     */\n    getWindowState(windowId) {\n        return this.windowStates.get(windowId) || null;\n    }\n    /**\n     * Close a specific window\n     */\n    async closeWindow(windowId) {\n        try {\n            const window = this.windows.get(windowId);\n            if (!window || window.isDestroyed()) {\n                return false;\n            }\n            // Save window state before closing\n            await this.saveWindowState(windowId);\n            window.close();\n            return true;\n        }\n        catch (error) {\n            this.logger.error(`Failed to close window: ${windowId}`, 'WindowManager', {\n                error: error instanceof Error ? error.message : error,\n            });\n            return false;\n        }\n    }\n    /**\n     * Close all windows\n     */\n    async closeAllWindows() {\n        this.logger.info('Closing all windows', 'WindowManager');\n        this.isShuttingDown = true;\n        const windowIds = Array.from(this.windows.keys());\n        const closePromises = windowIds.map(id => this.closeWindow(id));\n        await Promise.allSettled(closePromises);\n        this.logger.info('All windows closed', 'WindowManager');\n    }\n    /**\n     * Focus a specific window\n     */\n    focusWindow(windowId) {\n        const window = this.windows.get(windowId);\n        if (!window || window.isDestroyed()) {\n            return false;\n        }\n        if (window.isMinimized()) {\n            window.restore();\n        }\n        window.focus();\n        return true;\n    }\n    /**\n     * Send message to a specific window\n     */\n    sendToWindow(windowId, channel, ...args) {\n        const window = this.windows.get(windowId);\n        if (!window || window.isDestroyed()) {\n            return false;\n        }\n        window.webContents.send(channel, ...args);\n        return true;\n    }\n    /**\n     * Send message to all windows\n     */\n    sendToAllWindows(channel, ...args) {\n        this.getAllWindows().forEach(window => {\n            window.webContents.send(channel, ...args);\n        });\n    }\n    /**\n     * Get the focused window\n     */\n    getFocusedWindow() {\n        return electron_1.BrowserWindow.getFocusedWindow();\n    }\n    /**\n     * Get the main window (first created window)\n     */\n    getMainWindow() {\n        const mainWindowId = Array.from(this.windows.keys())[0];\n        return mainWindowId ? this.getWindow(mainWindowId) : null;\n    }\n    /**\n     * Send message between specific windows\n     */\n    sendWindowToWindow(fromWindowId, toWindowId, channel, message) {\n        const fromWindow = this.getWindow(fromWindowId);\n        const toWindow = this.getWindow(toWindowId);\n        if (!fromWindow || !toWindow) {\n            this.logger.warn(`Failed to send message between windows: ${fromWindowId} -> ${toWindowId}`, 'WindowManager');\n            return false;\n        }\n        // Send message to target window\n        toWindow.webContents.send(channel, {\n            fromWindowId,\n            toWindowId,\n            message,\n            timestamp: Date.now(),\n        });\n        // Emit communication event\n        this.emit('window-communication', { fromWindowId, toWindowId, message });\n        this.logger.debug(`Message sent between windows: ${fromWindowId} -> ${toWindowId}`, 'WindowManager');\n        return true;\n    }\n    /**\n     * Broadcast message from one window to all others\n     */\n    broadcastFromWindow(fromWindowId, channel, message) {\n        const fromWindow = this.getWindow(fromWindowId);\n        if (!fromWindow) {\n            this.logger.warn(`Failed to broadcast from window: ${fromWindowId}`, 'WindowManager');\n            return;\n        }\n        const otherWindows = this.getAllWindows().filter(window => {\n            const windowId = this.getWindowIdByWindow(window);\n            return windowId !== fromWindowId;\n        });\n        otherWindows.forEach(window => {\n            window.webContents.send(channel, {\n                fromWindowId,\n                message,\n                timestamp: Date.now(),\n            });\n        });\n        // Emit broadcast event\n        this.emit('broadcast-message', { fromWindowId, message });\n        this.logger.debug(`Message broadcast from window: ${fromWindowId} to ${otherWindows.length} windows`, 'WindowManager');\n    }\n    /**\n     * Get window ID by BrowserWindow instance\n     */\n    getWindowIdByWindow(window) {\n        for (const [id, win] of this.windows.entries()) {\n            if (win === window && !win.isDestroyed()) {\n                return id;\n            }\n        }\n        return null;\n    }\n    /**\n     * Get all window IDs\n     */\n    getAllWindowIds() {\n        return Array.from(this.windows.keys()).filter(id => {\n            const window = this.windows.get(id);\n            return window && !window.isDestroyed();\n        });\n    }\n    /**\n     * Get window statistics\n     */\n    getWindowStats() {\n        const activeWindows = this.getAllWindows();\n        const focusedWindow = this.getFocusedWindow();\n        const focusedWindowId = focusedWindow\n            ? this.getWindowIdByWindow(focusedWindow)\n            : null;\n        const mainWindowId = Array.from(this.windows.keys())[0] || null;\n        const windowStates = {};\n        for (const [id, state] of this.windowStates.entries()) {\n            windowStates[id] = {\n                isMaximized: state.isMaximized,\n                isMinimized: state.isMinimized,\n                isVisible: state.isVisible,\n                isFocused: state.isFocused,\n                lastFocused: state.lastFocused,\n            };\n        }\n        return {\n            totalWindows: this.windows.size,\n            activeWindows: activeWindows.length,\n            focusedWindow: focusedWindowId,\n            mainWindow: mainWindowId,\n            windowStates,\n        };\n    }\n    /**\n     * Calculate window bounds considering screen constraints\n     */\n    calculateWindowBounds(config, savedState) {\n        const primaryDisplay = electron_1.screen.getPrimaryDisplay();\n        const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;\n        let bounds = {\n            width: config.width,\n            height: config.height,\n            x: config.x ?? 0,\n            y: config.y ?? 0,\n        };\n        // Use saved state if available and valid\n        if (savedState &&\n            this.isValidBounds(savedState.bounds, screenWidth, screenHeight)) {\n            bounds = { ...savedState.bounds };\n        }\n        else if (config.center || (!config.x && !config.y)) {\n            // Center the window\n            bounds.x = Math.floor((screenWidth - bounds.width) / 2);\n            bounds.y = Math.floor((screenHeight - bounds.height) / 2);\n        }\n        // Ensure window fits on screen\n        bounds.width = Math.min(bounds.width, screenWidth);\n        bounds.height = Math.min(bounds.height, screenHeight);\n        bounds.x = Math.max(0, Math.min(bounds.x, screenWidth - bounds.width));\n        bounds.y = Math.max(0, Math.min(bounds.y, screenHeight - bounds.height));\n        return bounds;\n    }\n    /**\n     * Check if bounds are valid for the current screen\n     */\n    isValidBounds(bounds, screenWidth, screenHeight) {\n        return (bounds.x >= 0 &&\n            bounds.y >= 0 &&\n            bounds.x + bounds.width <= screenWidth &&\n            bounds.y + bounds.height <= screenHeight &&\n            bounds.width > 0 &&\n            bounds.height > 0);\n    }\n    /**\n     * Set up event handlers for a specific window\n     */\n    setupWindowEventHandlers(window, windowId) {\n        // Window closed\n        window.on('closed', () => {\n            this.handleWindowClosed(windowId);\n        });\n        // Window focus/blur\n        window.on('focus', () => {\n            this.updateWindowState(windowId, {\n                isFocused: true,\n                lastFocused: Date.now(),\n            });\n            this.emit('window-focused', { windowId });\n        });\n        window.on('blur', () => {\n            this.updateWindowState(windowId, { isFocused: false });\n            this.emit('window-blurred', { windowId });\n        });\n        // Window minimize/maximize\n        window.on('minimize', () => {\n            this.updateWindowState(windowId, { isMinimized: true });\n            this.emit('window-minimized', { windowId });\n        });\n        window.on('maximize', () => {\n            this.updateWindowState(windowId, { isMaximized: true });\n            this.emit('window-maximized', { windowId });\n        });\n        window.on('unmaximize', () => {\n            this.updateWindowState(windowId, { isMaximized: false });\n            this.emit('window-unmaximized', { windowId });\n        });\n        // Window move/resize with debouncing\n        const debouncedStateUpdate = this.debounce(() => {\n            if (!window.isDestroyed()) {\n                const bounds = window.getBounds();\n                this.updateWindowState(windowId, { bounds });\n                this.saveWindowStateDebounced(windowId);\n            }\n        }, 500);\n        window.on('moved', () => {\n            const bounds = window.getBounds();\n            this.emit('window-moved', { windowId, bounds });\n            debouncedStateUpdate();\n        });\n        window.on('resized', () => {\n            const bounds = window.getBounds();\n            this.emit('window-resized', { windowId, bounds });\n            debouncedStateUpdate();\n        });\n        // Window show/hide\n        window.on('show', () => {\n            this.updateWindowState(windowId, { isVisible: true });\n        });\n        window.on('hide', () => {\n            this.updateWindowState(windowId, { isVisible: false });\n        });\n        // Handle window restore\n        window.on('restore', () => {\n            this.updateWindowState(windowId, { isMinimized: false });\n        });\n        // Handle fullscreen changes\n        window.on('enter-full-screen', () => {\n            this.updateWindowState(windowId, { isFullScreen: true });\n        });\n        window.on('leave-full-screen', () => {\n            this.updateWindowState(windowId, { isFullScreen: false });\n        });\n    }\n    /**\n     * Handle window closed event\n     */\n    handleWindowClosed(windowId) {\n        this.logger.debug(`Window closed: ${windowId}`, 'WindowManager');\n        // Clean up references\n        this.windows.delete(windowId);\n        this.windowConfigs.delete(windowId);\n        this.windowStates.delete(windowId);\n        this.emit('window-closed', { windowId });\n        // Check if all windows are closed\n        if (this.windows.size === 0) {\n            this.emit('all-windows-closed');\n        }\n    }\n    /**\n     * Update window state\n     */\n    updateWindowState(windowId, updates) {\n        const currentState = this.windowStates.get(windowId);\n        if (currentState) {\n            this.windowStates.set(windowId, { ...currentState, ...updates });\n        }\n    }\n    /**\n     * Load window state from settings\n     */\n    async loadWindowState(windowId) {\n        if (!this.settings) {\n            return null;\n        }\n        try {\n            const stateKey = `windowState.${windowId}`;\n            const savedState = await this.settings.get(stateKey);\n            return savedState || null;\n        }\n        catch (error) {\n            this.logger.warn(`Failed to load window state: ${windowId}`, 'WindowManager', {\n                error: error instanceof Error ? error.message : error,\n            });\n            return null;\n        }\n    }\n    /**\n     * Save window state to settings\n     */\n    async saveWindowState(windowId) {\n        if (!this.settings) {\n            return;\n        }\n        try {\n            const state = this.windowStates.get(windowId);\n            if (state) {\n                const stateKey = `windowState.${windowId}`;\n                await this.settings.set(stateKey, state);\n                this.logger.debug(`Window state saved: ${windowId}`, 'WindowManager');\n            }\n        }\n        catch (error) {\n            this.logger.warn(`Failed to save window state: ${windowId}`, 'WindowManager', {\n                error: error instanceof Error ? error.message : error,\n            });\n        }\n    }\n    /**\n     * Debounced window state saving\n     */\n    saveWindowStateDebounced(windowId) {\n        if (this.stateUpdateTimeout) {\n            clearTimeout(this.stateUpdateTimeout);\n        }\n        this.stateUpdateTimeout = setTimeout(() => {\n            this.saveWindowState(windowId);\n        }, 1000);\n    }\n    /**\n     * Set up application-level event handlers\n     */\n    setupAppEventHandlers() {\n        // Handle app activation (macOS)\n        electron_1.app.on('activate', async () => {\n            if (this.windows.size === 0 && !this.isShuttingDown) {\n                this.logger.debug('App activated with no windows, requesting main window creation', 'WindowManager');\n                this.emit('request-main-window');\n            }\n        });\n        // Handle all windows closed\n        electron_1.app.on('window-all-closed', () => {\n            this.emit('all-windows-closed');\n        });\n    }\n    /**\n     * Utility debounce function\n     */\n    debounce(func, wait) {\n        let timeout;\n        return ((...args) => {\n            clearTimeout(timeout);\n            timeout = setTimeout(() => func.apply(this, args), wait);\n        });\n    }\n    /**\n     * Cleanup and shutdown\n     */\n    async shutdown() {\n        this.logger.info('Window manager shutting down', 'WindowManager');\n        this.isShuttingDown = true;\n        // Clear any pending timeouts\n        if (this.stateUpdateTimeout) {\n            clearTimeout(this.stateUpdateTimeout);\n        }\n        // Save all window states\n        const savePromises = Array.from(this.windows.keys()).map(id => this.saveWindowState(id));\n        await Promise.allSettled(savePromises);\n        // Close all windows\n        await this.closeAllWindows();\n        // Remove all listeners\n        this.removeAllListeners();\n        this.logger.info('Window manager shutdown complete', 'WindowManager');\n    }\n}\nexports.WindowManagerService = WindowManagerService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy93aW5kb3ctbWFuYWdlci1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7OztBQUVILG1FQUFzRDtBQUN0RCw2REFBc0M7QUE4RHRDLE1BQWEsb0JBQXFCLFNBQVEscUJBQVk7SUFTcEQsWUFBWSxNQUFxQixFQUFFLFFBQTBCO1FBQzNELEtBQUssRUFBRSxDQUFDO1FBVEYsWUFBTyxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2hELGtCQUFhLEdBQThCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDckQsaUJBQVksR0FBNkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUduRCxtQkFBYyxHQUFHLEtBQUssQ0FBQztRQUN2Qix1QkFBa0IsR0FBMEIsSUFBSSxDQUFDO1FBSXZELElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQ2hCLE1BQW9CLEVBQ3BCLEdBQVk7UUFFWixJQUFJLENBQUM7WUFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBRW5FLGlDQUFpQztZQUNqQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNoQyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFFLENBQUM7Z0JBQ3BELElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQztvQkFDbEMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN2QixPQUFPLGNBQWMsQ0FBQztn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QUFLLENBQUMsUUFBUTtRQUNaLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDhCQUE4QixFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBRTNCLDZCQUE2QjtRQUM3QixJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQzVCLFlBQVksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUN4QyxDQUFDO1FBRUQseUJBQXlCO1FBQ3pCLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUM1RCxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUN6QixDQUFDO1FBQ0YsTUFBTSxPQUFPLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXZDLG9CQUFvQjtRQUNwQixNQUFNLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUU3Qix1QkFBdUI7UUFDdkIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDeEUsQ0FBQztDQUNGO0FBaHJCRCxvREFnckJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvYmFja2VuZC9zZXJ2aWNlcy93aW5kb3ctbWFuYWdlci1zZXJ2aWNlLnRzP2RjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFdpbmRvdyBNYW5hZ2VyIFNlcnZpY2VcclxuICogSGFuZGxlcyB3aW5kb3cgbGlmZWN5Y2xlLCBzdGF0ZSBtYW5hZ2VtZW50LCBhbmQgbXVsdGktd2luZG93IHN1cHBvcnRcclxuICovXHJcblxyXG5pbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIHNjcmVlbiB9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHR5cGUgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi9sb2dnZXItc2VydmljZSc7XHJcbi8vIFNldHRpbmdzIHNlcnZpY2UgaW50ZXJmYWNlIGZvciBvcHRpb25hbCBkZXBlbmRlbmN5XHJcbmludGVyZmFjZSBTZXR0aW5nc1NlcnZpY2Uge1xyXG4gIGdldDxUPihrZXk6IHN0cmluZyk6IFByb21pc2U8VD47XHJcbiAgc2V0PFQ+KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2luZG93Q29uZmlnIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgbWluV2lkdGg6IG51bWJlcjtcclxuICBtaW5IZWlnaHQ6IG51bWJlcjtcclxuICB4PzogbnVtYmVyO1xyXG4gIHk/OiBudW1iZXI7XHJcbiAgY2VudGVyPzogYm9vbGVhbjtcclxuICByZXNpemFibGU/OiBib29sZWFuO1xyXG4gIG1pbmltaXphYmxlPzogYm9vbGVhbjtcclxuICBtYXhpbWl6YWJsZT86IGJvb2xlYW47XHJcbiAgY2xvc2FibGU/OiBib29sZWFuO1xyXG4gIGFsd2F5c09uVG9wPzogYm9vbGVhbjtcclxuICBza2lwVGFza2Jhcj86IGJvb2xlYW47XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgaWNvbj86IHN0cmluZztcclxuICBzaG93PzogYm9vbGVhbjtcclxuICBmcmFtZT86IGJvb2xlYW47XHJcbiAgdHJhbnNwYXJlbnQ/OiBib29sZWFuO1xyXG4gIHdlYlByZWZlcmVuY2VzPzogRWxlY3Ryb24uV2ViUHJlZmVyZW5jZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2luZG93U3RhdGUge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgYm91bmRzOiBFbGVjdHJvbi5SZWN0YW5nbGU7XHJcbiAgaXNNYXhpbWl6ZWQ6IGJvb2xlYW47XHJcbiAgaXNNaW5pbWl6ZWQ6IGJvb2xlYW47XHJcbiAgaXNGdWxsU2NyZWVuOiBib29sZWFuO1xyXG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcclxuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgbGFzdEZvY3VzZWQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXaW5kb3dNYW5hZ2VyRXZlbnRzIHtcclxuICAnd2luZG93LWNyZWF0ZWQnOiB7IHdpbmRvdzogQnJvd3NlcldpbmRvdzsgY29uZmlnOiBXaW5kb3dDb25maWcgfTtcclxuICAnd2luZG93LWNsb3NlZCc6IHsgd2luZG93SWQ6IHN0cmluZyB9O1xyXG4gICd3aW5kb3ctZm9jdXNlZCc6IHsgd2luZG93SWQ6IHN0cmluZyB9O1xyXG4gICd3aW5kb3ctYmx1cnJlZCc6IHsgd2luZG93SWQ6IHN0cmluZyB9O1xyXG4gICd3aW5kb3ctbWluaW1pemVkJzogeyB3aW5kb3dJZDogc3RyaW5nIH07XHJcbiAgJ3dpbmRvdy1tYXhpbWl6ZWQnOiB7IHdpbmRvd0lkOiBzdHJpbmcgfTtcclxuICAnd2luZG93LXVubWF4aW1pemVkJzogeyB3aW5kb3dJZDogc3RyaW5nIH07XHJcbiAgJ3dpbmRvdy1tb3ZlZCc6IHsgd2luZG93SWQ6IHN0cmluZzsgYm91bmRzOiBFbGVjdHJvbi5SZWN0YW5nbGUgfTtcclxuICAnd2luZG93LXJlc2l6ZWQnOiB7IHdpbmRvd0lkOiBzdHJpbmc7IGJvdW5kczogRWxlY3Ryb24uUmVjdGFuZ2xlIH07XHJcbiAgJ2FsbC13aW5kb3dzLWNsb3NlZCc6IHZvaWQ7XHJcbiAgJ3JlcXVlc3QtbWFpbi13aW5kb3cnOiB2b2lkO1xyXG4gICd3aW5kb3ctY29tbXVuaWNhdGlvbic6IHtcclxuICAgIGZyb21XaW5kb3dJZDogc3RyaW5nO1xyXG4gICAgdG9XaW5kb3dJZDogc3RyaW5nO1xyXG4gICAgbWVzc2FnZTogYW55O1xyXG4gIH07XHJcbiAgJ2Jyb2FkY2FzdC1tZXNzYWdlJzogeyBmcm9tV2luZG93SWQ6IHN0cmluZzsgbWVzc2FnZTogYW55IH07XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBXaW5kb3dNYW5hZ2VyU2VydmljZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgcHJpdmF0ZSB3aW5kb3dzOiBNYXA8c3RyaW5nLCBCcm93c2VyV2luZG93PiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIHdpbmRvd0NvbmZpZ3M6IE1hcDxzdHJpbmcsIFdpbmRvd0NvbmZpZz4gPSBuZXcgTWFwKCk7XHJcbiAgcHJpdmF0ZSB3aW5kb3dTdGF0ZXM6IE1hcDxzdHJpbmcsIFdpbmRvd1N0YXRlPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyU2VydmljZTtcclxuICBwcml2YXRlIHNldHRpbmdzPzogU2V0dGluZ3NTZXJ2aWNlO1xyXG4gIHByaXZhdGUgaXNTaHV0dGluZ0Rvd24gPSBmYWxzZTtcclxuICBwcml2YXRlIHN0YXRlVXBkYXRlVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXJTZXJ2aWNlLCBzZXR0aW5ncz86IFNldHRpbmdzU2VydmljZSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgdGhpcy5zZXR1cEFwcEV2ZW50SGFuZGxlcnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyB3aW5kb3cgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBhc3luYyBjcmVhdGVXaW5kb3coXHJcbiAgICBjb25maWc6IFdpbmRvd0NvbmZpZyxcclxuICAgIHVybD86IHN0cmluZyxcclxuICApOiBQcm9taXNlPEJyb3dzZXJXaW5kb3c+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oYENyZWF0aW5nIHdpbmRvdzogJHtjb25maWcuaWR9YCwgJ1dpbmRvd01hbmFnZXInKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHdpbmRvdyBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICBpZiAodGhpcy53aW5kb3dzLmhhcyhjb25maWcuaWQpKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdXaW5kb3cgPSB0aGlzLndpbmRvd3MuZ2V0KGNvbmZpZy5pZCkhO1xyXG4gICAgICAgIGlmICghZXhpc3RpbmdXaW5kb3cuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgICAgZXhpc3RpbmdXaW5kb3cuZm9jdXMoKTtcclxuICAgICAgICAgIHJldHVybiBleGlzdGluZ1dpbmRvdztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgZGVzdHJveWVkIHdpbmRvdyByZWZlcmVuY2VcclxuICAgICAgICAgIHRoaXMud2luZG93cy5kZWxldGUoY29uZmlnLmlkKTtcclxuICAgICAgICAgIHRoaXMud2luZG93Q29uZmlncy5kZWxldGUoY29uZmlnLmlkKTtcclxuICAgICAgICAgIHRoaXMud2luZG93U3RhdGVzLmRlbGV0ZShjb25maWcuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzdG9yZSB3aW5kb3cgc3RhdGUgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBhd2FpdCB0aGlzLmxvYWRXaW5kb3dTdGF0ZShjb25maWcuaWQpO1xyXG4gICAgICBjb25zdCB3aW5kb3dCb3VuZHMgPSB0aGlzLmNhbGN1bGF0ZVdpbmRvd0JvdW5kcyhcclxuICAgICAgICBjb25maWcsXHJcbiAgICAgICAgc2F2ZWRTdGF0ZSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYnJvd3NlciB3aW5kb3dcclxuICAgICAgY29uc3Qgd2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xyXG4gICAgICAgIC4uLndpbmRvd0JvdW5kcyxcclxuICAgICAgICBtaW5XaWR0aDogY29uZmlnLm1pbldpZHRoLFxyXG4gICAgICAgIG1pbkhlaWdodDogY29uZmlnLm1pbkhlaWdodCxcclxuICAgICAgICByZXNpemFibGU6IGNvbmZpZy5yZXNpemFibGUgPz8gdHJ1ZSxcclxuICAgICAgICBtaW5pbWl6YWJsZTogY29uZmlnLm1pbmltaXphYmxlID8/IHRydWUsXHJcbiAgICAgICAgbWF4aW1pemFibGU6IGNvbmZpZy5tYXhpbWl6YWJsZSA/PyB0cnVlLFxyXG4gICAgICAgIGNsb3NhYmxlOiBjb25maWcuY2xvc2FibGUgPz8gdHJ1ZSxcclxuICAgICAgICBhbHdheXNPblRvcDogY29uZmlnLmFsd2F5c09uVG9wID8/IGZhbHNlLFxyXG4gICAgICAgIHNraXBUYXNrYmFyOiBjb25maWcuc2tpcFRhc2tiYXIgPz8gZmFsc2UsXHJcbiAgICAgICAgdGl0bGU6IGNvbmZpZy50aXRsZSA/PyAnUGxheWxpc3RpZnknLFxyXG4gICAgICAgIHNob3c6IGNvbmZpZy5zaG93ID8/IGZhbHNlLFxyXG4gICAgICAgIGZyYW1lOiBjb25maWcuZnJhbWUgPz8gdHJ1ZSxcclxuICAgICAgICB0cmFuc3BhcmVudDogY29uZmlnLnRyYW5zcGFyZW50ID8/IGZhbHNlLFxyXG4gICAgICAgIHdlYlByZWZlcmVuY2VzOiB7XHJcbiAgICAgICAgICBub2RlSW50ZWdyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgY29udGV4dElzb2xhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgIHdlYlNlY3VyaXR5OiB0cnVlLFxyXG4gICAgICAgICAgLi4uY29uZmlnLndlYlByZWZlcmVuY2VzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gU3RvcmUgd2luZG93IHJlZmVyZW5jZXNcclxuICAgICAgdGhpcy53aW5kb3dzLnNldChjb25maWcuaWQsIHdpbmRvdyk7XHJcbiAgICAgIHRoaXMud2luZG93Q29uZmlncy5zZXQoY29uZmlnLmlkLCBjb25maWcpO1xyXG5cclxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aW5kb3cgc3RhdGVcclxuICAgICAgY29uc3QgaW5pdGlhbFN0YXRlOiBXaW5kb3dTdGF0ZSA9IHtcclxuICAgICAgICBpZDogY29uZmlnLmlkLFxyXG4gICAgICAgIGJvdW5kczogd2luZG93LmdldEJvdW5kcygpLFxyXG4gICAgICAgIGlzTWF4aW1pemVkOiB3aW5kb3cuaXNNYXhpbWl6ZWQoKSxcclxuICAgICAgICBpc01pbmltaXplZDogd2luZG93LmlzTWluaW1pemVkKCksXHJcbiAgICAgICAgaXNGdWxsU2NyZWVuOiB3aW5kb3cuaXNGdWxsU2NyZWVuKCksXHJcbiAgICAgICAgaXNWaXNpYmxlOiB3aW5kb3cuaXNWaXNpYmxlKCksXHJcbiAgICAgICAgaXNGb2N1c2VkOiB3aW5kb3cuaXNGb2N1c2VkKCksXHJcbiAgICAgICAgbGFzdEZvY3VzZWQ6IERhdGUubm93KCksXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMud2luZG93U3RhdGVzLnNldChjb25maWcuaWQsIGluaXRpYWxTdGF0ZSk7XHJcblxyXG4gICAgICAvLyBTZXQgdXAgd2luZG93IGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgIHRoaXMuc2V0dXBXaW5kb3dFdmVudEhhbmRsZXJzKHdpbmRvdywgY29uZmlnLmlkKTtcclxuXHJcbiAgICAgIC8vIFJlc3RvcmUgbWF4aW1pemVkIHN0YXRlIGlmIG5lZWRlZFxyXG4gICAgICBpZiAoc2F2ZWRTdGF0ZT8uaXNNYXhpbWl6ZWQpIHtcclxuICAgICAgICB3aW5kb3cubWF4aW1pemUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTG9hZCBVUkwgaWYgcHJvdmlkZWRcclxuICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgIGF3YWl0IHdpbmRvdy5sb2FkVVJMKHVybCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNob3cgd2luZG93IHdoZW4gcmVhZHlcclxuICAgICAgd2luZG93Lm9uY2UoJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgICAgd2luZG93LnNob3coKTtcclxuICAgICAgICAgIGlmIChjb25maWcuY2VudGVyIHx8ICghY29uZmlnLnggJiYgIWNvbmZpZy55KSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2VudGVyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgICAgICAgYFdpbmRvdyByZWFkeSBhbmQgc2hvd246ICR7Y29uZmlnLmlkfWAsXHJcbiAgICAgICAgICAgICdXaW5kb3dNYW5hZ2VyJyxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuZW1pdCgnd2luZG93LWNyZWF0ZWQnLCB7IHdpbmRvdywgY29uZmlnIH0pO1xyXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFxyXG4gICAgICAgIGBXaW5kb3cgY3JlYXRlZCBzdWNjZXNzZnVsbHk6ICR7Y29uZmlnLmlkfWAsXHJcbiAgICAgICAgJ1dpbmRvd01hbmFnZXInLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIHdpbmRvdzogJHtjb25maWcuaWR9YCxcclxuICAgICAgICAnV2luZG93TWFuYWdlcicsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSB3aW5kb3cgYnkgSURcclxuICAgKi9cclxuICBnZXRXaW5kb3cod2luZG93SWQ6IHN0cmluZyk6IEJyb3dzZXJXaW5kb3cgfCBudWxsIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMud2luZG93cy5nZXQod2luZG93SWQpO1xyXG4gICAgcmV0dXJuIHdpbmRvdyAmJiAhd2luZG93LmlzRGVzdHJveWVkKCkgPyB3aW5kb3cgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCBhY3RpdmUgd2luZG93c1xyXG4gICAqL1xyXG4gIGdldEFsbFdpbmRvd3MoKTogQnJvd3NlcldpbmRvd1tdIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMud2luZG93cy52YWx1ZXMoKSkuZmlsdGVyKFxyXG4gICAgICB3aW5kb3cgPT4gIXdpbmRvdy5pc0Rlc3Ryb3llZCgpLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB3aW5kb3cgc3RhdGUgYnkgSURcclxuICAgKi9cclxuICBnZXRXaW5kb3dTdGF0ZSh3aW5kb3dJZDogc3RyaW5nKTogV2luZG93U3RhdGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLndpbmRvd1N0YXRlcy5nZXQod2luZG93SWQpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9zZSBhIHNwZWNpZmljIHdpbmRvd1xyXG4gICAqL1xyXG4gIGFzeW5jIGNsb3NlV2luZG93KHdpbmRvd0lkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMud2luZG93cy5nZXQod2luZG93SWQpO1xyXG4gICAgICBpZiAoIXdpbmRvdyB8fCB3aW5kb3cuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2F2ZSB3aW5kb3cgc3RhdGUgYmVmb3JlIGNsb3NpbmdcclxuICAgICAgYXdhaXQgdGhpcy5zYXZlV2luZG93U3RhdGUod2luZG93SWQpO1xyXG5cclxuICAgICAgd2luZG93LmNsb3NlKCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXHJcbiAgICAgICAgYEZhaWxlZCB0byBjbG9zZSB3aW5kb3c6ICR7d2luZG93SWR9YCxcclxuICAgICAgICAnV2luZG93TWFuYWdlcicsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvc2UgYWxsIHdpbmRvd3NcclxuICAgKi9cclxuICBhc3luYyBjbG9zZUFsbFdpbmRvd3MoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdDbG9zaW5nIGFsbCB3aW5kb3dzJywgJ1dpbmRvd01hbmFnZXInKTtcclxuICAgIHRoaXMuaXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IHdpbmRvd0lkcyA9IEFycmF5LmZyb20odGhpcy53aW5kb3dzLmtleXMoKSk7XHJcbiAgICBjb25zdCBjbG9zZVByb21pc2VzID0gd2luZG93SWRzLm1hcChpZCA9PiB0aGlzLmNsb3NlV2luZG93KGlkKSk7XHJcblxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNsb3NlUHJvbWlzZXMpO1xyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnQWxsIHdpbmRvd3MgY2xvc2VkJywgJ1dpbmRvd01hbmFnZXInKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvY3VzIGEgc3BlY2lmaWMgd2luZG93XHJcbiAgICovXHJcbiAgZm9jdXNXaW5kb3cod2luZG93SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgd2luZG93ID0gdGhpcy53aW5kb3dzLmdldCh3aW5kb3dJZCk7XHJcbiAgICBpZiAoIXdpbmRvdyB8fCB3aW5kb3cuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy5pc01pbmltaXplZCgpKSB7XHJcbiAgICAgIHdpbmRvdy5yZXN0b3JlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93LmZvY3VzKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgbWVzc2FnZSB0byBhIHNwZWNpZmljIHdpbmRvd1xyXG4gICAqL1xyXG4gIHNlbmRUb1dpbmRvdyh3aW5kb3dJZDogc3RyaW5nLCBjaGFubmVsOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB3aW5kb3cgPSB0aGlzLndpbmRvd3MuZ2V0KHdpbmRvd0lkKTtcclxuICAgIGlmICghd2luZG93IHx8IHdpbmRvdy5pc0Rlc3Ryb3llZCgpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3cud2ViQ29udGVudHMuc2VuZChjaGFubmVsLCAuLi5hcmdzKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZCBtZXNzYWdlIHRvIGFsbCB3aW5kb3dzXHJcbiAgICovXHJcbiAgc2VuZFRvQWxsV2luZG93cyhjaGFubmVsOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcbiAgICB0aGlzLmdldEFsbFdpbmRvd3MoKS5mb3JFYWNoKHdpbmRvdyA9PiB7XHJcbiAgICAgIHdpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIC4uLmFyZ3MpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGZvY3VzZWQgd2luZG93XHJcbiAgICovXHJcbiAgZ2V0Rm9jdXNlZFdpbmRvdygpOiBCcm93c2VyV2luZG93IHwgbnVsbCB7XHJcbiAgICByZXR1cm4gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIG1haW4gd2luZG93IChmaXJzdCBjcmVhdGVkIHdpbmRvdylcclxuICAgKi9cclxuICBnZXRNYWluV2luZG93KCk6IEJyb3dzZXJXaW5kb3cgfCBudWxsIHtcclxuICAgIGNvbnN0IG1haW5XaW5kb3dJZCA9IEFycmF5LmZyb20odGhpcy53aW5kb3dzLmtleXMoKSlbMF07XHJcbiAgICByZXR1cm4gbWFpbldpbmRvd0lkID8gdGhpcy5nZXRXaW5kb3cobWFpbldpbmRvd0lkKSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIG1lc3NhZ2UgYmV0d2VlbiBzcGVjaWZpYyB3aW5kb3dzXHJcbiAgICovXHJcbiAgc2VuZFdpbmRvd1RvV2luZG93KFxyXG4gICAgZnJvbVdpbmRvd0lkOiBzdHJpbmcsXHJcbiAgICB0b1dpbmRvd0lkOiBzdHJpbmcsXHJcbiAgICBjaGFubmVsOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBhbnksXHJcbiAgKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBmcm9tV2luZG93ID0gdGhpcy5nZXRXaW5kb3coZnJvbVdpbmRvd0lkKTtcclxuICAgIGNvbnN0IHRvV2luZG93ID0gdGhpcy5nZXRXaW5kb3codG9XaW5kb3dJZCk7XHJcblxyXG4gICAgaWYgKCFmcm9tV2luZG93IHx8ICF0b1dpbmRvdykge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIGJldHdlZW4gd2luZG93czogJHtmcm9tV2luZG93SWR9IC0+ICR7dG9XaW5kb3dJZH1gLFxyXG4gICAgICAgICdXaW5kb3dNYW5hZ2VyJyxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbmQgbWVzc2FnZSB0byB0YXJnZXQgd2luZG93XHJcbiAgICB0b1dpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIHtcclxuICAgICAgZnJvbVdpbmRvd0lkLFxyXG4gICAgICB0b1dpbmRvd0lkLFxyXG4gICAgICBtZXNzYWdlLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBFbWl0IGNvbW11bmljYXRpb24gZXZlbnRcclxuICAgIHRoaXMuZW1pdCgnd2luZG93LWNvbW11bmljYXRpb24nLCB7IGZyb21XaW5kb3dJZCwgdG9XaW5kb3dJZCwgbWVzc2FnZSB9KTtcclxuXHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgYE1lc3NhZ2Ugc2VudCBiZXR3ZWVuIHdpbmRvd3M6ICR7ZnJvbVdpbmRvd0lkfSAtPiAke3RvV2luZG93SWR9YCxcclxuICAgICAgJ1dpbmRvd01hbmFnZXInLFxyXG4gICAgKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnJvYWRjYXN0IG1lc3NhZ2UgZnJvbSBvbmUgd2luZG93IHRvIGFsbCBvdGhlcnNcclxuICAgKi9cclxuICBicm9hZGNhc3RGcm9tV2luZG93KFxyXG4gICAgZnJvbVdpbmRvd0lkOiBzdHJpbmcsXHJcbiAgICBjaGFubmVsOiBzdHJpbmcsXHJcbiAgICBtZXNzYWdlOiBhbnksXHJcbiAgKTogdm9pZCB7XHJcbiAgICBjb25zdCBmcm9tV2luZG93ID0gdGhpcy5nZXRXaW5kb3coZnJvbVdpbmRvd0lkKTtcclxuICAgIGlmICghZnJvbVdpbmRvdykge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gYnJvYWRjYXN0IGZyb20gd2luZG93OiAke2Zyb21XaW5kb3dJZH1gLFxyXG4gICAgICAgICdXaW5kb3dNYW5hZ2VyJyxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG90aGVyV2luZG93cyA9IHRoaXMuZ2V0QWxsV2luZG93cygpLmZpbHRlcih3aW5kb3cgPT4ge1xyXG4gICAgICBjb25zdCB3aW5kb3dJZCA9IHRoaXMuZ2V0V2luZG93SWRCeVdpbmRvdyh3aW5kb3cpO1xyXG4gICAgICByZXR1cm4gd2luZG93SWQgIT09IGZyb21XaW5kb3dJZDtcclxuICAgIH0pO1xyXG5cclxuICAgIG90aGVyV2luZG93cy5mb3JFYWNoKHdpbmRvdyA9PiB7XHJcbiAgICAgIHdpbmRvdy53ZWJDb250ZW50cy5zZW5kKGNoYW5uZWwsIHtcclxuICAgICAgICBmcm9tV2luZG93SWQsXHJcbiAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRW1pdCBicm9hZGNhc3QgZXZlbnRcclxuICAgIHRoaXMuZW1pdCgnYnJvYWRjYXN0LW1lc3NhZ2UnLCB7IGZyb21XaW5kb3dJZCwgbWVzc2FnZSB9KTtcclxuXHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgYE1lc3NhZ2UgYnJvYWRjYXN0IGZyb20gd2luZG93OiAke2Zyb21XaW5kb3dJZH0gdG8gJHtvdGhlcldpbmRvd3MubGVuZ3RofSB3aW5kb3dzYCxcclxuICAgICAgJ1dpbmRvd01hbmFnZXInLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB3aW5kb3cgSUQgYnkgQnJvd3NlcldpbmRvdyBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGdldFdpbmRvd0lkQnlXaW5kb3cod2luZG93OiBCcm93c2VyV2luZG93KTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgd2luXSBvZiB0aGlzLndpbmRvd3MuZW50cmllcygpKSB7XHJcbiAgICAgIGlmICh3aW4gPT09IHdpbmRvdyAmJiAhd2luLmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCB3aW5kb3cgSURzXHJcbiAgICovXHJcbiAgZ2V0QWxsV2luZG93SWRzKCk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMud2luZG93cy5rZXlzKCkpLmZpbHRlcihpZCA9PiB7XHJcbiAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMud2luZG93cy5nZXQoaWQpO1xyXG4gICAgICByZXR1cm4gd2luZG93ICYmICF3aW5kb3cuaXNEZXN0cm95ZWQoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHdpbmRvdyBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgZ2V0V2luZG93U3RhdHMoKToge1xyXG4gICAgdG90YWxXaW5kb3dzOiBudW1iZXI7XHJcbiAgICBhY3RpdmVXaW5kb3dzOiBudW1iZXI7XHJcbiAgICBmb2N1c2VkV2luZG93OiBzdHJpbmcgfCBudWxsO1xyXG4gICAgbWFpbldpbmRvdzogc3RyaW5nIHwgbnVsbDtcclxuICAgIHdpbmRvd1N0YXRlczogUmVjb3JkPHN0cmluZywgUGFydGlhbDxXaW5kb3dTdGF0ZT4+O1xyXG4gIH0ge1xyXG4gICAgY29uc3QgYWN0aXZlV2luZG93cyA9IHRoaXMuZ2V0QWxsV2luZG93cygpO1xyXG4gICAgY29uc3QgZm9jdXNlZFdpbmRvdyA9IHRoaXMuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgY29uc3QgZm9jdXNlZFdpbmRvd0lkID0gZm9jdXNlZFdpbmRvd1xyXG4gICAgICA/IHRoaXMuZ2V0V2luZG93SWRCeVdpbmRvdyhmb2N1c2VkV2luZG93KVxyXG4gICAgICA6IG51bGw7XHJcbiAgICBjb25zdCBtYWluV2luZG93SWQgPSBBcnJheS5mcm9tKHRoaXMud2luZG93cy5rZXlzKCkpWzBdIHx8IG51bGw7XHJcblxyXG4gICAgY29uc3Qgd2luZG93U3RhdGVzOiBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsPFdpbmRvd1N0YXRlPj4gPSB7fTtcclxuICAgIGZvciAoY29uc3QgW2lkLCBzdGF0ZV0gb2YgdGhpcy53aW5kb3dTdGF0ZXMuZW50cmllcygpKSB7XHJcbiAgICAgIHdpbmRvd1N0YXRlc1tpZF0gPSB7XHJcbiAgICAgICAgaXNNYXhpbWl6ZWQ6IHN0YXRlLmlzTWF4aW1pemVkLFxyXG4gICAgICAgIGlzTWluaW1pemVkOiBzdGF0ZS5pc01pbmltaXplZCxcclxuICAgICAgICBpc1Zpc2libGU6IHN0YXRlLmlzVmlzaWJsZSxcclxuICAgICAgICBpc0ZvY3VzZWQ6IHN0YXRlLmlzRm9jdXNlZCxcclxuICAgICAgICBsYXN0Rm9jdXNlZDogc3RhdGUubGFzdEZvY3VzZWQsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxXaW5kb3dzOiB0aGlzLndpbmRvd3Muc2l6ZSxcclxuICAgICAgYWN0aXZlV2luZG93czogYWN0aXZlV2luZG93cy5sZW5ndGgsXHJcbiAgICAgIGZvY3VzZWRXaW5kb3c6IGZvY3VzZWRXaW5kb3dJZCxcclxuICAgICAgbWFpbldpbmRvdzogbWFpbldpbmRvd0lkLFxyXG4gICAgICB3aW5kb3dTdGF0ZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHdpbmRvdyBib3VuZHMgY29uc2lkZXJpbmcgc2NyZWVuIGNvbnN0cmFpbnRzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVXaW5kb3dCb3VuZHMoXHJcbiAgICBjb25maWc6IFdpbmRvd0NvbmZpZyxcclxuICAgIHNhdmVkU3RhdGU/OiBXaW5kb3dTdGF0ZSxcclxuICApOiBFbGVjdHJvbi5SZWN0YW5nbGUge1xyXG4gICAgY29uc3QgcHJpbWFyeURpc3BsYXkgPSBzY3JlZW4uZ2V0UHJpbWFyeURpc3BsYXkoKTtcclxuICAgIGNvbnN0IHsgd2lkdGg6IHNjcmVlbldpZHRoLCBoZWlnaHQ6IHNjcmVlbkhlaWdodCB9ID1cclxuICAgICAgcHJpbWFyeURpc3BsYXkud29ya0FyZWFTaXplO1xyXG5cclxuICAgIGxldCBib3VuZHM6IEVsZWN0cm9uLlJlY3RhbmdsZSA9IHtcclxuICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcclxuICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0LFxyXG4gICAgICB4OiBjb25maWcueCA/PyAwLFxyXG4gICAgICB5OiBjb25maWcueSA/PyAwLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBVc2Ugc2F2ZWQgc3RhdGUgaWYgYXZhaWxhYmxlIGFuZCB2YWxpZFxyXG4gICAgaWYgKFxyXG4gICAgICBzYXZlZFN0YXRlICYmXHJcbiAgICAgIHRoaXMuaXNWYWxpZEJvdW5kcyhzYXZlZFN0YXRlLmJvdW5kcywgc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodClcclxuICAgICkge1xyXG4gICAgICBib3VuZHMgPSB7IC4uLnNhdmVkU3RhdGUuYm91bmRzIH07XHJcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5jZW50ZXIgfHwgKCFjb25maWcueCAmJiAhY29uZmlnLnkpKSB7XHJcbiAgICAgIC8vIENlbnRlciB0aGUgd2luZG93XHJcbiAgICAgIGJvdW5kcy54ID0gTWF0aC5mbG9vcigoc2NyZWVuV2lkdGggLSBib3VuZHMud2lkdGgpIC8gMik7XHJcbiAgICAgIGJvdW5kcy55ID0gTWF0aC5mbG9vcigoc2NyZWVuSGVpZ2h0IC0gYm91bmRzLmhlaWdodCkgLyAyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgd2luZG93IGZpdHMgb24gc2NyZWVuXHJcbiAgICBib3VuZHMud2lkdGggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIHNjcmVlbldpZHRoKTtcclxuICAgIGJvdW5kcy5oZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzY3JlZW5IZWlnaHQpO1xyXG4gICAgYm91bmRzLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihib3VuZHMueCwgc2NyZWVuV2lkdGggLSBib3VuZHMud2lkdGgpKTtcclxuICAgIGJvdW5kcy55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYm91bmRzLnksIHNjcmVlbkhlaWdodCAtIGJvdW5kcy5oZWlnaHQpKTtcclxuXHJcbiAgICByZXR1cm4gYm91bmRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYm91bmRzIGFyZSB2YWxpZCBmb3IgdGhlIGN1cnJlbnQgc2NyZWVuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc1ZhbGlkQm91bmRzKFxyXG4gICAgYm91bmRzOiBFbGVjdHJvbi5SZWN0YW5nbGUsXHJcbiAgICBzY3JlZW5XaWR0aDogbnVtYmVyLFxyXG4gICAgc2NyZWVuSGVpZ2h0OiBudW1iZXIsXHJcbiAgKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBib3VuZHMueCA+PSAwICYmXHJcbiAgICAgIGJvdW5kcy55ID49IDAgJiZcclxuICAgICAgYm91bmRzLnggKyBib3VuZHMud2lkdGggPD0gc2NyZWVuV2lkdGggJiZcclxuICAgICAgYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IDw9IHNjcmVlbkhlaWdodCAmJlxyXG4gICAgICBib3VuZHMud2lkdGggPiAwICYmXHJcbiAgICAgIGJvdW5kcy5oZWlnaHQgPiAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGZvciBhIHNwZWNpZmljIHdpbmRvd1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc2V0dXBXaW5kb3dFdmVudEhhbmRsZXJzKFxyXG4gICAgd2luZG93OiBCcm93c2VyV2luZG93LFxyXG4gICAgd2luZG93SWQ6IHN0cmluZyxcclxuICApOiB2b2lkIHtcclxuICAgIC8vIFdpbmRvdyBjbG9zZWRcclxuICAgIHdpbmRvdy5vbignY2xvc2VkJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLmhhbmRsZVdpbmRvd0Nsb3NlZCh3aW5kb3dJZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBXaW5kb3cgZm9jdXMvYmx1clxyXG4gICAgd2luZG93Lm9uKCdmb2N1cycsICgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwge1xyXG4gICAgICAgIGlzRm9jdXNlZDogdHJ1ZSxcclxuICAgICAgICBsYXN0Rm9jdXNlZDogRGF0ZS5ub3coKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuZW1pdCgnd2luZG93LWZvY3VzZWQnLCB7IHdpbmRvd0lkIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd2luZG93Lm9uKCdibHVyJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLnVwZGF0ZVdpbmRvd1N0YXRlKHdpbmRvd0lkLCB7IGlzRm9jdXNlZDogZmFsc2UgfSk7XHJcbiAgICAgIHRoaXMuZW1pdCgnd2luZG93LWJsdXJyZWQnLCB7IHdpbmRvd0lkIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2luZG93IG1pbmltaXplL21heGltaXplXHJcbiAgICB3aW5kb3cub24oJ21pbmltaXplJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLnVwZGF0ZVdpbmRvd1N0YXRlKHdpbmRvd0lkLCB7IGlzTWluaW1pemVkOiB0cnVlIH0pO1xyXG4gICAgICB0aGlzLmVtaXQoJ3dpbmRvdy1taW5pbWl6ZWQnLCB7IHdpbmRvd0lkIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd2luZG93Lm9uKCdtYXhpbWl6ZScsICgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwgeyBpc01heGltaXplZDogdHJ1ZSB9KTtcclxuICAgICAgdGhpcy5lbWl0KCd3aW5kb3ctbWF4aW1pemVkJywgeyB3aW5kb3dJZCB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHdpbmRvdy5vbigndW5tYXhpbWl6ZScsICgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwgeyBpc01heGltaXplZDogZmFsc2UgfSk7XHJcbiAgICAgIHRoaXMuZW1pdCgnd2luZG93LXVubWF4aW1pemVkJywgeyB3aW5kb3dJZCB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdpbmRvdyBtb3ZlL3Jlc2l6ZSB3aXRoIGRlYm91bmNpbmdcclxuICAgIGNvbnN0IGRlYm91bmNlZFN0YXRlVXBkYXRlID0gdGhpcy5kZWJvdW5jZSgoKSA9PiB7XHJcbiAgICAgIGlmICghd2luZG93LmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB3aW5kb3cuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwgeyBib3VuZHMgfSk7XHJcbiAgICAgICAgdGhpcy5zYXZlV2luZG93U3RhdGVEZWJvdW5jZWQod2luZG93SWQpO1xyXG4gICAgICB9XHJcbiAgICB9LCA1MDApO1xyXG5cclxuICAgIHdpbmRvdy5vbignbW92ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHdpbmRvdy5nZXRCb3VuZHMoKTtcclxuICAgICAgdGhpcy5lbWl0KCd3aW5kb3ctbW92ZWQnLCB7IHdpbmRvd0lkLCBib3VuZHMgfSk7XHJcbiAgICAgIGRlYm91bmNlZFN0YXRlVXBkYXRlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB3aW5kb3cub24oJ3Jlc2l6ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHdpbmRvdy5nZXRCb3VuZHMoKTtcclxuICAgICAgdGhpcy5lbWl0KCd3aW5kb3ctcmVzaXplZCcsIHsgd2luZG93SWQsIGJvdW5kcyB9KTtcclxuICAgICAgZGVib3VuY2VkU3RhdGVVcGRhdGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdpbmRvdyBzaG93L2hpZGVcclxuICAgIHdpbmRvdy5vbignc2hvdycsICgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwgeyBpc1Zpc2libGU6IHRydWUgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB3aW5kb3cub24oJ2hpZGUnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlV2luZG93U3RhdGUod2luZG93SWQsIHsgaXNWaXNpYmxlOiBmYWxzZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzdG9yZVxyXG4gICAgd2luZG93Lm9uKCdyZXN0b3JlJywgKCkgPT4ge1xyXG4gICAgICB0aGlzLnVwZGF0ZVdpbmRvd1N0YXRlKHdpbmRvd0lkLCB7IGlzTWluaW1pemVkOiBmYWxzZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEhhbmRsZSBmdWxsc2NyZWVuIGNoYW5nZXNcclxuICAgIHdpbmRvdy5vbignZW50ZXItZnVsbC1zY3JlZW4nLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlV2luZG93U3RhdGUod2luZG93SWQsIHsgaXNGdWxsU2NyZWVuOiB0cnVlIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgd2luZG93Lm9uKCdsZWF2ZS1mdWxsLXNjcmVlbicsICgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVXaW5kb3dTdGF0ZSh3aW5kb3dJZCwgeyBpc0Z1bGxTY3JlZW46IGZhbHNlIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgd2luZG93IGNsb3NlZCBldmVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgaGFuZGxlV2luZG93Q2xvc2VkKHdpbmRvd0lkOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBXaW5kb3cgY2xvc2VkOiAke3dpbmRvd0lkfWAsICdXaW5kb3dNYW5hZ2VyJyk7XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlc1xyXG4gICAgdGhpcy53aW5kb3dzLmRlbGV0ZSh3aW5kb3dJZCk7XHJcbiAgICB0aGlzLndpbmRvd0NvbmZpZ3MuZGVsZXRlKHdpbmRvd0lkKTtcclxuICAgIHRoaXMud2luZG93U3RhdGVzLmRlbGV0ZSh3aW5kb3dJZCk7XHJcblxyXG4gICAgdGhpcy5lbWl0KCd3aW5kb3ctY2xvc2VkJywgeyB3aW5kb3dJZCB9KTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBhbGwgd2luZG93cyBhcmUgY2xvc2VkXHJcbiAgICBpZiAodGhpcy53aW5kb3dzLnNpemUgPT09IDApIHtcclxuICAgICAgdGhpcy5lbWl0KCdhbGwtd2luZG93cy1jbG9zZWQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB3aW5kb3cgc3RhdGVcclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZVdpbmRvd1N0YXRlKFxyXG4gICAgd2luZG93SWQ6IHN0cmluZyxcclxuICAgIHVwZGF0ZXM6IFBhcnRpYWw8V2luZG93U3RhdGU+LFxyXG4gICk6IHZvaWQge1xyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy53aW5kb3dTdGF0ZXMuZ2V0KHdpbmRvd0lkKTtcclxuICAgIGlmIChjdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy53aW5kb3dTdGF0ZXMuc2V0KHdpbmRvd0lkLCB7IC4uLmN1cnJlbnRTdGF0ZSwgLi4udXBkYXRlcyB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgd2luZG93IHN0YXRlIGZyb20gc2V0dGluZ3NcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGxvYWRXaW5kb3dTdGF0ZSh3aW5kb3dJZDogc3RyaW5nKTogUHJvbWlzZTxXaW5kb3dTdGF0ZSB8IG51bGw+IHtcclxuICAgIGlmICghdGhpcy5zZXR0aW5ncykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZUtleSA9IGB3aW5kb3dTdGF0ZS4ke3dpbmRvd0lkfWA7XHJcbiAgICAgIGNvbnN0IHNhdmVkU3RhdGUgPSBhd2FpdCB0aGlzLnNldHRpbmdzLmdldDxXaW5kb3dTdGF0ZT4oc3RhdGVLZXkpO1xyXG4gICAgICByZXR1cm4gc2F2ZWRTdGF0ZSB8fCBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5sb2dnZXIud2FybihcclxuICAgICAgICBgRmFpbGVkIHRvIGxvYWQgd2luZG93IHN0YXRlOiAke3dpbmRvd0lkfWAsXHJcbiAgICAgICAgJ1dpbmRvd01hbmFnZXInLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSB3aW5kb3cgc3RhdGUgdG8gc2V0dGluZ3NcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHNhdmVXaW5kb3dTdGF0ZSh3aW5kb3dJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy53aW5kb3dTdGF0ZXMuZ2V0KHdpbmRvd0lkKTtcclxuICAgICAgaWYgKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVLZXkgPSBgd2luZG93U3RhdGUuJHt3aW5kb3dJZH1gO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3Muc2V0KHN0YXRlS2V5LCBzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFdpbmRvdyBzdGF0ZSBzYXZlZDogJHt3aW5kb3dJZH1gLCAnV2luZG93TWFuYWdlcicpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gc2F2ZSB3aW5kb3cgc3RhdGU6ICR7d2luZG93SWR9YCxcclxuICAgICAgICAnV2luZG93TWFuYWdlcicsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IsXHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlYm91bmNlZCB3aW5kb3cgc3RhdGUgc2F2aW5nXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzYXZlV2luZG93U3RhdGVEZWJvdW5jZWQod2luZG93SWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc3RhdGVVcGRhdGVUaW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YXRlVXBkYXRlVGltZW91dCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGF0ZVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5zYXZlV2luZG93U3RhdGUod2luZG93SWQpO1xyXG4gICAgfSwgMTAwMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdXAgYXBwbGljYXRpb24tbGV2ZWwgZXZlbnQgaGFuZGxlcnNcclxuICAgKi9cclxuICBwcml2YXRlIHNldHVwQXBwRXZlbnRIYW5kbGVycygpOiB2b2lkIHtcclxuICAgIC8vIEhhbmRsZSBhcHAgYWN0aXZhdGlvbiAobWFjT1MpXHJcbiAgICBhcHAub24oJ2FjdGl2YXRlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy53aW5kb3dzLnNpemUgPT09IDAgJiYgIXRoaXMuaXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcclxuICAgICAgICAgICdBcHAgYWN0aXZhdGVkIHdpdGggbm8gd2luZG93cywgcmVxdWVzdGluZyBtYWluIHdpbmRvdyBjcmVhdGlvbicsXHJcbiAgICAgICAgICAnV2luZG93TWFuYWdlcicsXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QtbWFpbi13aW5kb3cnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSGFuZGxlIGFsbCB3aW5kb3dzIGNsb3NlZFxyXG4gICAgYXBwLm9uKCd3aW5kb3ctYWxsLWNsb3NlZCcsICgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KCdhbGwtd2luZG93cy1jbG9zZWQnKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBkZWJvdW5jZSBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHByaXZhdGUgZGVib3VuY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcclxuICAgIGZ1bmM6IFQsXHJcbiAgICB3YWl0OiBudW1iZXIsXHJcbiAgKTogVCB7XHJcbiAgICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XHJcbiAgICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGZ1bmMuYXBwbHkodGhpcywgYXJncyksIHdhaXQpO1xyXG4gICAgfSkgYXMgVDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFudXAgYW5kIHNodXRkb3duXHJcbiAgICovXHJcbiAgYXN5bmMgc2h1dGRvd24oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdXaW5kb3cgbWFuYWdlciBzaHV0dGluZyBkb3duJywgJ1dpbmRvd01hbmFnZXInKTtcclxuICAgIHRoaXMuaXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG5cclxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIHRpbWVvdXRzXHJcbiAgICBpZiAodGhpcy5zdGF0ZVVwZGF0ZVRpbWVvdXQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc3RhdGVVcGRhdGVUaW1lb3V0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTYXZlIGFsbCB3aW5kb3cgc3RhdGVzXHJcbiAgICBjb25zdCBzYXZlUHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMud2luZG93cy5rZXlzKCkpLm1hcChpZCA9PlxyXG4gICAgICB0aGlzLnNhdmVXaW5kb3dTdGF0ZShpZCksXHJcbiAgICApO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHNhdmVQcm9taXNlcyk7XHJcblxyXG4gICAgLy8gQ2xvc2UgYWxsIHdpbmRvd3NcclxuICAgIGF3YWl0IHRoaXMuY2xvc2VBbGxXaW5kb3dzKCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnNcclxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcblxyXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnV2luZG93IG1hbmFnZXIgc2h1dGRvd24gY29tcGxldGUnLCAnV2luZG93TWFuYWdlcicpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/backend/services/window-manager-service.ts\n\n}");

/***/ }),

/***/ "./src/backend/utils/dependency-utils.ts":
/*!***********************************************!*\
  !*** ./src/backend/utils/dependency-utils.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Utility functions for dependency management\n * Provides helper functions for downloading, extracting, and validating dependencies\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.downloadFile = downloadFile;\nexports.extractZip = extractZip;\nexports.extractTar = extractTar;\nexports.makeExecutable = makeExecutable;\nexports.validateBinary = validateBinary;\nexports.getBinaryVersion = getBinaryVersion;\nexports.cleanupTempFiles = cleanupTempFiles;\nexports.formatBytes = formatBytes;\nexports.retryWithBackoff = retryWithBackoff;\nexports.checkUrlAccessibility = checkUrlAccessibility;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst fs = tslib_1.__importStar(__webpack_require__(/*! fs-extra */ \"fs-extra\"));\nconst path = tslib_1.__importStar(__webpack_require__(/*! path */ \"path\"));\nconst https = tslib_1.__importStar(__webpack_require__(/*! https */ \"https\"));\nconst http = tslib_1.__importStar(__webpack_require__(/*! http */ \"http\"));\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = tslib_1.__importStar(__webpack_require__(/*! zlib */ \"zlib\"));\nconst tar = tslib_1.__importStar(__webpack_require__(/*! tar */ \"./node_modules/tar/dist/commonjs/index.js\"));\nconst errors_1 = __webpack_require__(/*! @/shared/errors */ \"./src/shared/errors.ts\");\nconst streamPipeline = (0, util_1.promisify)(stream_1.pipeline);\n/**\n * Download a file from a URL with progress tracking\n */\nasync function downloadFile(url, destinationPath, onProgress) {\n    try {\n        await fs.ensureDir(path.dirname(destinationPath));\n        return new Promise((resolve, reject) => {\n            const protocol = url.startsWith('https:') ? https : http;\n            const request = protocol.get(url, (response) => {\n                if (response.statusCode === 302 || response.statusCode === 301) {\n                    // Handle redirects\n                    if (response.headers.location) {\n                        downloadFile(response.headers.location, destinationPath, onProgress)\n                            .then(resolve)\n                            .catch(reject);\n                        return;\n                    }\n                }\n                if (response.statusCode !== 200) {\n                    reject(new errors_1.DependencyDownloadError(`HTTP ${response.statusCode}: ${response.statusMessage}`));\n                    return;\n                }\n                const totalSize = parseInt(response.headers['content-length'] || '0', 10);\n                let downloadedSize = 0;\n                const fileStream = fs.createWriteStream(destinationPath);\n                response.on('data', (chunk) => {\n                    downloadedSize += chunk.length;\n                    if (onProgress && totalSize > 0) {\n                        const progress = Math.round((downloadedSize / totalSize) * 100);\n                        onProgress({\n                            dependency: 'ytdlp', // Will be set by caller\n                            progress,\n                            status: 'downloading',\n                            message: `Downloaded ${formatBytes(downloadedSize)} of ${formatBytes(totalSize)}`,\n                        });\n                    }\n                });\n                response.pipe(fileStream);\n                fileStream.on('finish', () => {\n                    fileStream.close();\n                    resolve();\n                });\n                fileStream.on('error', (error) => {\n                    fs.unlink(destinationPath).catch(() => { }); // Clean up on error\n                    reject(new errors_1.DependencyDownloadError(`File write error: ${error.message}`));\n                });\n            });\n            request.on('error', (error) => {\n                reject(new errors_1.DependencyDownloadError(`Download error: ${error.message}`));\n            });\n            request.setTimeout(30000, () => {\n                request.destroy();\n                reject(new errors_1.DependencyDownloadError('Download timeout'));\n            });\n        });\n    }\n    catch (error) {\n        throw new errors_1.DependencyDownloadError(`Failed to download file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Extract a ZIP file\n */\nasync function extractZip(zipPath, extractPath) {\n    try {\n        const AdmZip = __webpack_require__(/*! adm-zip */ \"./node_modules/adm-zip/adm-zip.js\");\n        const zip = new AdmZip(zipPath);\n        await fs.ensureDir(extractPath);\n        zip.extractAllTo(extractPath, true);\n    }\n    catch (error) {\n        throw new errors_1.DependencyInstallationError(`Failed to extract ZIP: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Extract a TAR file (with optional compression)\n */\nasync function extractTar(tarPath, extractPath) {\n    try {\n        await fs.ensureDir(extractPath);\n        const readStream = fs.createReadStream(tarPath);\n        let extractStream;\n        if (tarPath.endsWith('.gz') || tarPath.endsWith('.tgz')) {\n            extractStream = readStream.pipe(zlib.createGunzip());\n        }\n        else if (tarPath.endsWith('.xz')) {\n            // For .xz files, we need to use a different approach\n            const { spawn } = __webpack_require__(/*! child_process */ \"child_process\");\n            return new Promise((resolve, reject) => {\n                const xz = spawn('tar', ['-xJf', tarPath, '-C', extractPath]);\n                xz.on('close', (code) => {\n                    if (code === 0) {\n                        resolve();\n                    }\n                    else {\n                        reject(new errors_1.DependencyInstallationError(`tar extraction failed with code ${code}`));\n                    }\n                });\n                xz.on('error', (error) => {\n                    reject(new errors_1.DependencyInstallationError(`tar extraction error: ${error.message}`));\n                });\n            });\n        }\n        else {\n            extractStream = readStream;\n        }\n        await streamPipeline(extractStream, tar.extract({ cwd: extractPath, strip: 1 }));\n    }\n    catch (error) {\n        throw new errors_1.DependencyInstallationError(`Failed to extract TAR: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Make a file executable (Unix-like systems)\n */\nasync function makeExecutable(filePath) {\n    try {\n        if (process.platform !== 'win32') {\n            await fs.chmod(filePath, 0o755);\n        }\n    }\n    catch (error) {\n        throw new errors_1.DependencyInstallationError(`Failed to make file executable: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Validate that a binary exists and is executable\n */\nasync function validateBinary(binaryPath) {\n    try {\n        // Check if file exists\n        const exists = await fs.pathExists(binaryPath);\n        if (!exists) {\n            return false;\n        }\n        // Check if file is executable\n        try {\n            await fs.access(binaryPath, fs.constants.F_OK | fs.constants.X_OK);\n        }\n        catch {\n            return false;\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Get version information from a binary\n */\nasync function getBinaryVersion(binaryPath, versionArgs = ['--version']) {\n    try {\n        return new Promise((resolve) => {\n            const process = (0, child_process_1.spawn)(binaryPath, versionArgs, {\n                stdio: ['ignore', 'pipe', 'pipe'],\n                timeout: 10000,\n            });\n            let output = '';\n            let errorOutput = '';\n            process.stdout?.on('data', (data) => {\n                output += data.toString();\n            });\n            process.stderr?.on('data', (data) => {\n                errorOutput += data.toString();\n            });\n            process.on('close', (code) => {\n                if (code === 0 && output.trim()) {\n                    // Extract version from output (first line usually contains version)\n                    const firstLine = output.split('\\n')[0];\n                    const versionMatch = firstLine.match(/(\\d+\\.[\\d.]+)/);\n                    resolve(versionMatch ? versionMatch[1] : firstLine.trim());\n                }\n                else if (errorOutput.trim()) {\n                    // Some tools output version to stderr\n                    const firstLine = errorOutput.split('\\n')[0];\n                    const versionMatch = firstLine.match(/(\\d+\\.[\\d.]+)/);\n                    resolve(versionMatch ? versionMatch[1] : firstLine.trim());\n                }\n                else {\n                    resolve(null);\n                }\n            });\n            process.on('error', () => {\n                resolve(null);\n            });\n            // Timeout fallback\n            setTimeout(() => {\n                process.kill();\n                resolve(null);\n            }, 10000);\n        });\n    }\n    catch {\n        return null;\n    }\n}\n/**\n * Clean up temporary files and directories\n */\nasync function cleanupTempFiles(tempDir) {\n    try {\n        if (await fs.pathExists(tempDir)) {\n            await fs.remove(tempDir);\n        }\n    }\n    catch (error) {\n        // Log but don't throw - cleanup failures shouldn't break the main process\n        console.warn(`Failed to cleanup temp files: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Format bytes to human-readable string\n */\nfunction formatBytes(bytes) {\n    if (bytes === 0)\n        return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n/**\n * Retry a function with exponential backoff\n */\nasync function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {\n    let lastError;\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n            return await fn();\n        }\n        catch (error) {\n            lastError = error instanceof Error ? error : new Error('Unknown error');\n            if (attempt === maxRetries) {\n                break;\n            }\n            // Exponential backoff with jitter\n            const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n    }\n    throw lastError;\n}\n/**\n * Check if a URL is accessible\n */\nasync function checkUrlAccessibility(url) {\n    return new Promise((resolve) => {\n        const protocol = url.startsWith('https:') ? https : http;\n        const request = protocol.request(url, { method: 'HEAD', timeout: 5000 }, (response) => {\n            resolve(response.statusCode === 200 || response.statusCode === 302 || response.statusCode === 301);\n        });\n        request.on('error', () => {\n            resolve(false);\n        });\n        request.on('timeout', () => {\n            request.destroy();\n            resolve(false);\n        });\n        request.end();\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFja2VuZC91dGlscy9kZXBlbmRlbmN5LXV0aWxzLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBdUJILG9DQXVFQztBQUtELGdDQVVDO0FBS0QsZ0NBb0NDO0FBS0Qsd0NBUUM7QUFLRCx3Q0FtQkM7QUFLRCw0Q0FnREM7QUFLRCw0Q0FTQztBQUtELGtDQVFDO0FBS0QsNENBd0JDO0FBS0Qsc0RBbUJDOztBQTlURCxpRkFBK0I7QUFDL0IsMkVBQTZCO0FBQzdCLDhFQUErQjtBQUMvQiwyRUFBNkI7QUFDN0Isa0ZBQXNDO0FBQ3RDLHVEQUFpQztBQUNqQyw2REFBa0M7QUFDbEMsMkVBQTZCO0FBQzdCLDhHQUEyQjtBQUMzQixzRkFJeUI7QUFHekIsTUFBTSxjQUFjLEdBQUcsb0JBQVMsRUFBQyxpQkFBUSxDQUFDLENBQUM7QUFFM0M7O0dBRUc7QUFDSSxLQUFLLFVBQVUsWUFBWSxDQUNoQyxHQUFXLEVBQ1gsZUFBdUIsRUFDdkIsVUFBMkQ7SUFFM0QsSUFBSSxDQUFDO1FBQ0gsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUVsRCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3JDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBRXpELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxFQUFFLEVBQUU7Z0JBQzdDLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxHQUFHLEVBQUUsQ0FBQztvQkFDL0QsbUJBQW1CO29CQUNuQixJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7d0JBQzlCLFlBQVksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsVUFBVSxDQUFDOzZCQUNqRSxJQUFJLENBQUMsT0FBTyxDQUFDOzZCQUNiLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDakIsT0FBTztvQkFDVCxDQUFDO2dCQUNILENBQUM7Z0JBRUQsSUFBSSxRQUFRLENBQUMsVUFBVSxLQUFLLEdBQUcsRUFBRSxDQUFDO29CQUNoQyxNQUFNLENBQUMsSUFBSSxnQ0FBdUIsQ0FBQyxRQUFRLFFBQVEsQ0FBQyxVQUFVLEtBQUssUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDOUYsT0FBTztnQkFDVCxDQUFDO2dCQUVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLElBQUksR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUM7Z0JBRXZCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFFekQsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDNUIsY0FBYyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUM7b0JBRS9CLElBQUksVUFBVSxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQzt3QkFDaEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQzt3QkFDaEUsVUFBVSxDQUFDOzRCQUNULFVBQVUsRUFBRSxPQUFPLEVBQUUsd0JBQXdCOzRCQUM3QyxRQUFROzRCQUNSLE1BQU0sRUFBRSxhQUFhOzRCQUNyQixPQUFPLEVBQUUsY0FBYyxXQUFXLENBQUMsY0FBYyxDQUFDLE9BQU8sV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO3lCQUNsRixDQUFDLENBQUM7b0JBQ0wsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFFSCxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUUxQixVQUFVLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUU7b0JBQzNCLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDbkIsT0FBTyxFQUFFLENBQUM7Z0JBQ1osQ0FBQyxDQUFDLENBQUM7Z0JBRUgsVUFBVSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDL0IsRUFBRSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0I7b0JBQ2hFLE1BQU0sQ0FBQyxJQUFJLGdDQUF1QixDQUFDLHFCQUFxQixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUM1RSxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDNUIsTUFBTSxDQUFDLElBQUksZ0NBQXVCLENBQUMsbUJBQW1CLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUUsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUU7Z0JBQzdCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDbEIsTUFBTSxDQUFDLElBQUksZ0NBQXVCLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO1lBQzFELENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLE1BQU0sSUFBSSxnQ0FBdUIsQ0FBQyw0QkFBNEIsS0FBSyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUM1SCxDQUFDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLFVBQVUsQ0FBQyxPQUFlLEVBQUUsV0FBbUI7SUFDbkUsSUFBSSxDQUFDO1FBQ0gsTUFBTSxNQUFNLEdBQUcsbUJBQU8sQ0FBQyxrREFBUyxDQUFDLENBQUM7UUFDbEMsTUFBTSxHQUFHLEdBQUcsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFaEMsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2hDLEdBQUcsQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsTUFBTSxJQUFJLG9DQUEyQixDQUFDLDBCQUEwQixLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBQzlILENBQUM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSSxLQUFLLFVBQVUsVUFBVSxDQUFDLE9BQWUsRUFBRSxXQUFtQjtJQUNuRSxJQUFJLENBQUM7UUFDSCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFaEMsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hELElBQUksYUFBYSxDQUFDO1FBRWxCLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDeEQsYUFBYSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7UUFDdkQsQ0FBQzthQUFNLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ25DLHFEQUFxRDtZQUNyRCxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsbUJBQU8sQ0FBQyxvQ0FBZSxDQUFDLENBQUM7WUFDM0MsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDckMsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQzlELEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBWSxFQUFFLEVBQUU7b0JBQzlCLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUNmLE9BQU8sRUFBRSxDQUFDO29CQUNaLENBQUM7eUJBQU0sQ0FBQzt3QkFDTixNQUFNLENBQUMsSUFBSSxvQ0FBMkIsQ0FBQyxtQ0FBbUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNyRixDQUFDO2dCQUNILENBQUMsQ0FBQyxDQUFDO2dCQUNILEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBWSxFQUFFLEVBQUU7b0JBQzlCLE1BQU0sQ0FBQyxJQUFJLG9DQUEyQixDQUFDLHlCQUF5QixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNwRixDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQzthQUFNLENBQUM7WUFDTixhQUFhLEdBQUcsVUFBVSxDQUFDO1FBQzdCLENBQUM7UUFFRCxNQUFNLGNBQWMsQ0FDbEIsYUFBYSxFQUNiLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUM1QyxDQUFDO0lBQ0osQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixNQUFNLElBQUksb0NBQTJCLENBQUMsMEJBQTBCLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7SUFDOUgsQ0FBQztBQUNILENBQUM7QUFFRDs7R0FFRztBQUNJLEtBQUssVUFBVSxjQUFjLENBQUMsUUFBZ0I7SUFDbkQsSUFBSSxDQUFDO1FBQ0gsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRSxDQUFDO1lBQ2pDLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEMsQ0FBQztJQUNILENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsTUFBTSxJQUFJLG9DQUEyQixDQUFDLG1DQUFtQyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZJLENBQUM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUFDLFVBQWtCO0lBQ3JELElBQUksQ0FBQztRQUNILHVCQUF1QjtRQUN2QixNQUFNLE1BQU0sR0FBRyxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ1osT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsOEJBQThCO1FBQzlCLElBQUksQ0FBQztZQUNILE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBQUMsTUFBTSxDQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGdCQUFnQixDQUFDLFVBQWtCLEVBQUUsY0FBd0IsQ0FBQyxXQUFXLENBQUM7SUFDOUYsSUFBSSxDQUFDO1FBQ0gsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQzdCLE1BQU0sT0FBTyxHQUFHLHlCQUFLLEVBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRTtnQkFDN0MsS0FBSyxFQUFFLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUM7Z0JBQ2pDLE9BQU8sRUFBRSxLQUFLO2FBQ2YsQ0FBQyxDQUFDO1lBRUgsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztZQUVyQixPQUFPLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDbEMsTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUM1QixDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNsQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pDLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDM0IsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO29CQUNoQyxvRUFBb0U7b0JBQ3BFLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3hDLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBQ3RELE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7Z0JBQzdELENBQUM7cUJBQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztvQkFDOUIsc0NBQXNDO29CQUN0QyxNQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM3QyxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUN0RCxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUM3RCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNoQixDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7Z0JBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQixDQUFDLENBQUMsQ0FBQztZQUVILG1CQUFtQjtZQUNuQixVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUNkLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDZixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDaEIsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ1osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGdCQUFnQixDQUFDLE9BQWU7SUFDcEQsSUFBSSxDQUFDO1FBQ0gsSUFBSSxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNqQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0IsQ0FBQztJQUNILENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsMEVBQTBFO1FBQzFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsaUNBQWlDLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7SUFDNUcsQ0FBQztBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxLQUFhO0lBQ3ZDLElBQUksS0FBSyxLQUFLLENBQUM7UUFBRSxPQUFPLFNBQVMsQ0FBQztJQUVsQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDZixNQUFNLEtBQUssR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFcEQsT0FBTyxVQUFVLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFFLENBQUM7QUFFRDs7R0FFRztBQUNJLEtBQUssVUFBVSxnQkFBZ0IsQ0FDcEMsRUFBb0IsRUFDcEIsYUFBcUIsQ0FBQyxFQUN0QixZQUFvQixJQUFJO0lBRXhCLElBQUksU0FBZ0IsQ0FBQztJQUVyQixLQUFLLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxPQUFPLElBQUksVUFBVSxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUM7UUFDdkQsSUFBSSxDQUFDO1lBQ0gsT0FBTyxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsU0FBUyxHQUFHLEtBQUssWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7WUFFeEUsSUFBSSxPQUFPLEtBQUssVUFBVSxFQUFFLENBQUM7Z0JBQzNCLE1BQU07WUFDUixDQUFDO1lBRUQsa0NBQWtDO1lBQ2xDLE1BQU0sS0FBSyxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDO1lBQ3RFLE1BQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDM0QsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNLFNBQVUsQ0FBQztBQUNuQixDQUFDO0FBRUQ7O0dBRUc7QUFDSSxLQUFLLFVBQVUscUJBQXFCLENBQUMsR0FBVztJQUNyRCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDN0IsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFekQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3BGLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxLQUFLLEdBQUcsSUFBSSxRQUFRLENBQUMsVUFBVSxLQUFLLEdBQUcsSUFBSSxRQUFRLENBQUMsVUFBVSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ3JHLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRTtZQUN6QixPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BsYXlsaXN0aWZ5Ly4vc3JjL2JhY2tlbmQvdXRpbHMvZGVwZW5kZW5jeS11dGlscy50cz9lOWZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVwZW5kZW5jeSBtYW5hZ2VtZW50XHJcbiAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGRvd25sb2FkaW5nLCBleHRyYWN0aW5nLCBhbmQgdmFsaWRhdGluZyBkZXBlbmRlbmNpZXNcclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGh0dHBzIGZyb20gJ2h0dHBzJztcclxuaW1wb3J0ICogYXMgaHR0cCBmcm9tICdodHRwJztcclxuaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcclxuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XHJcbmltcG9ydCB7IHBpcGVsaW5lIH0gZnJvbSAnc3RyZWFtJztcclxuaW1wb3J0ICogYXMgemxpYiBmcm9tICd6bGliJztcclxuaW1wb3J0ICogYXMgdGFyIGZyb20gJ3Rhcic7XHJcbmltcG9ydCB7IFxyXG4gIERlcGVuZGVuY3lEb3dubG9hZEVycm9yLCBcclxuICBEZXBlbmRlbmN5SW5zdGFsbGF0aW9uRXJyb3IsIFxyXG4gIERlcGVuZGVuY3lWYWxpZGF0aW9uRXJyb3IgXHJcbn0gZnJvbSAnQC9zaGFyZWQvZXJyb3JzJztcclxuaW1wb3J0IHR5cGUgeyBEZXBlbmRlbmN5RG93bmxvYWRQcm9ncmVzcyB9IGZyb20gJ0Avc2hhcmVkL2ludGVyZmFjZXMvZGVwZW5kZW5jeS1tYW5hZ2VyJztcclxuXHJcbmNvbnN0IHN0cmVhbVBpcGVsaW5lID0gcHJvbWlzaWZ5KHBpcGVsaW5lKTtcclxuXHJcbi8qKlxyXG4gKiBEb3dubG9hZCBhIGZpbGUgZnJvbSBhIFVSTCB3aXRoIHByb2dyZXNzIHRyYWNraW5nXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKFxyXG4gIHVybDogc3RyaW5nLCBcclxuICBkZXN0aW5hdGlvblBhdGg6IHN0cmluZyxcclxuICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBEZXBlbmRlbmN5RG93bmxvYWRQcm9ncmVzcykgPT4gdm9pZFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgZnMuZW5zdXJlRGlyKHBhdGguZGlybmFtZShkZXN0aW5hdGlvblBhdGgpKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgcHJvdG9jb2wgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyBodHRwcyA6IGh0dHA7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gcHJvdG9jb2wuZ2V0KHVybCwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEpIHtcclxuICAgICAgICAgIC8vIEhhbmRsZSByZWRpcmVjdHNcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGRvd25sb2FkRmlsZShyZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uLCBkZXN0aW5hdGlvblBhdGgsIG9uUHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcclxuICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XHJcbiAgICAgICAgICByZWplY3QobmV3IERlcGVuZGVuY3lEb3dubG9hZEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gKSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgJzAnLCAxMCk7XHJcbiAgICAgICAgbGV0IGRvd25sb2FkZWRTaXplID0gMDtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBmaWxlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdGluYXRpb25QYXRoKTtcclxuICAgICAgICBcclxuICAgICAgICByZXNwb25zZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgZG93bmxvYWRlZFNpemUgKz0gY2h1bmsubGVuZ3RoO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiB0b3RhbFNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5yb3VuZCgoZG93bmxvYWRlZFNpemUgLyB0b3RhbFNpemUpICogMTAwKTtcclxuICAgICAgICAgICAgb25Qcm9ncmVzcyh7XHJcbiAgICAgICAgICAgICAgZGVwZW5kZW5jeTogJ3l0ZGxwJywgLy8gV2lsbCBiZSBzZXQgYnkgY2FsbGVyXHJcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZG93bmxvYWRpbmcnLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBEb3dubG9hZGVkICR7Zm9ybWF0Qnl0ZXMoZG93bmxvYWRlZFNpemUpfSBvZiAke2Zvcm1hdEJ5dGVzKHRvdGFsU2l6ZSl9YCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVzcG9uc2UucGlwZShmaWxlU3RyZWFtKTtcclxuICAgICAgICBcclxuICAgICAgICBmaWxlU3RyZWFtLm9uKCdmaW5pc2gnLCAoKSA9PiB7XHJcbiAgICAgICAgICBmaWxlU3RyZWFtLmNsb3NlKCk7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZmlsZVN0cmVhbS5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgIGZzLnVubGluayhkZXN0aW5hdGlvblBhdGgpLmNhdGNoKCgpID0+IHt9KTsgLy8gQ2xlYW4gdXAgb24gZXJyb3JcclxuICAgICAgICAgIHJlamVjdChuZXcgRGVwZW5kZW5jeURvd25sb2FkRXJyb3IoYEZpbGUgd3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICByZWplY3QobmV3IERlcGVuZGVuY3lEb3dubG9hZEVycm9yKGBEb3dubG9hZCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApKTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXF1ZXN0LnNldFRpbWVvdXQoMzAwMDAsICgpID0+IHtcclxuICAgICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgICByZWplY3QobmV3IERlcGVuZGVuY3lEb3dubG9hZEVycm9yKCdEb3dubG9hZCB0aW1lb3V0JykpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0aHJvdyBuZXcgRGVwZW5kZW5jeURvd25sb2FkRXJyb3IoYEZhaWxlZCB0byBkb3dubG9hZCBmaWxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgYSBaSVAgZmlsZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RaaXAoemlwUGF0aDogc3RyaW5nLCBleHRyYWN0UGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IEFkbVppcCA9IHJlcXVpcmUoJ2FkbS16aXAnKTtcclxuICAgIGNvbnN0IHppcCA9IG5ldyBBZG1aaXAoemlwUGF0aCk7XHJcbiAgICBcclxuICAgIGF3YWl0IGZzLmVuc3VyZURpcihleHRyYWN0UGF0aCk7XHJcbiAgICB6aXAuZXh0cmFjdEFsbFRvKGV4dHJhY3RQYXRoLCB0cnVlKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgWklQOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgYSBUQVIgZmlsZSAod2l0aCBvcHRpb25hbCBjb21wcmVzc2lvbilcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHRyYWN0VGFyKHRhclBhdGg6IHN0cmluZywgZXh0cmFjdFBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBmcy5lbnN1cmVEaXIoZXh0cmFjdFBhdGgpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZWFkU3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbSh0YXJQYXRoKTtcclxuICAgIGxldCBleHRyYWN0U3RyZWFtO1xyXG4gICAgXHJcbiAgICBpZiAodGFyUGF0aC5lbmRzV2l0aCgnLmd6JykgfHwgdGFyUGF0aC5lbmRzV2l0aCgnLnRneicpKSB7XHJcbiAgICAgIGV4dHJhY3RTdHJlYW0gPSByZWFkU3RyZWFtLnBpcGUoemxpYi5jcmVhdGVHdW56aXAoKSk7XHJcbiAgICB9IGVsc2UgaWYgKHRhclBhdGguZW5kc1dpdGgoJy54eicpKSB7XHJcbiAgICAgIC8vIEZvciAueHogZmlsZXMsIHdlIG5lZWQgdG8gdXNlIGEgZGlmZmVyZW50IGFwcHJvYWNoXHJcbiAgICAgIGNvbnN0IHsgc3Bhd24gfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCB4eiA9IHNwYXduKCd0YXInLCBbJy14SmYnLCB0YXJQYXRoLCAnLUMnLCBleHRyYWN0UGF0aF0pO1xyXG4gICAgICAgIHh6Lm9uKCdjbG9zZScsIChjb2RlOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgRGVwZW5kZW5jeUluc3RhbGxhdGlvbkVycm9yKGB0YXIgZXh0cmFjdGlvbiBmYWlsZWQgd2l0aCBjb2RlICR7Y29kZX1gKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgeHoub24oJ2Vycm9yJywgKGVycm9yOiBFcnJvcikgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBEZXBlbmRlbmN5SW5zdGFsbGF0aW9uRXJyb3IoYHRhciBleHRyYWN0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGV4dHJhY3RTdHJlYW0gPSByZWFkU3RyZWFtO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBhd2FpdCBzdHJlYW1QaXBlbGluZShcclxuICAgICAgZXh0cmFjdFN0cmVhbSxcclxuICAgICAgdGFyLmV4dHJhY3QoeyBjd2Q6IGV4dHJhY3RQYXRoLCBzdHJpcDogMSB9KVxyXG4gICAgKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgVEFSOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBmaWxlIGV4ZWN1dGFibGUgKFVuaXgtbGlrZSBzeXN0ZW1zKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1ha2VFeGVjdXRhYmxlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcclxuICAgICAgYXdhaXQgZnMuY2htb2QoZmlsZVBhdGgsIDBvNzU1KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvcihgRmFpbGVkIHRvIG1ha2UgZmlsZSBleGVjdXRhYmxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoYXQgYSBiaW5hcnkgZXhpc3RzIGFuZCBpcyBleGVjdXRhYmxlXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnkoYmluYXJ5UGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIENoZWNrIGlmIGZpbGUgZXhpc3RzXHJcbiAgICBjb25zdCBleGlzdHMgPSBhd2FpdCBmcy5wYXRoRXhpc3RzKGJpbmFyeVBhdGgpO1xyXG4gICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBmaWxlIGlzIGV4ZWN1dGFibGVcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGZzLmFjY2VzcyhiaW5hcnlQYXRoLCBmcy5jb25zdGFudHMuRl9PSyB8IGZzLmNvbnN0YW50cy5YX09LKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB2ZXJzaW9uIGluZm9ybWF0aW9uIGZyb20gYSBiaW5hcnlcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCaW5hcnlWZXJzaW9uKGJpbmFyeVBhdGg6IHN0cmluZywgdmVyc2lvbkFyZ3M6IHN0cmluZ1tdID0gWyctLXZlcnNpb24nXSk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgY29uc3QgcHJvY2VzcyA9IHNwYXduKGJpbmFyeVBhdGgsIHZlcnNpb25BcmdzLCB7XHJcbiAgICAgICAgc3RkaW86IFsnaWdub3JlJywgJ3BpcGUnLCAncGlwZSddLFxyXG4gICAgICAgIHRpbWVvdXQ6IDEwMDAwLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGxldCBvdXRwdXQgPSAnJztcclxuICAgICAgbGV0IGVycm9yT3V0cHV0ID0gJyc7XHJcbiAgICAgIFxyXG4gICAgICBwcm9jZXNzLnN0ZG91dD8ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgIG91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcHJvY2Vzcy5zdGRlcnI/Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICAgICBlcnJvck91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xyXG4gICAgICAgIGlmIChjb2RlID09PSAwICYmIG91dHB1dC50cmltKCkpIHtcclxuICAgICAgICAgIC8vIEV4dHJhY3QgdmVyc2lvbiBmcm9tIG91dHB1dCAoZmlyc3QgbGluZSB1c3VhbGx5IGNvbnRhaW5zIHZlcnNpb24pXHJcbiAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBvdXRwdXQuc3BsaXQoJ1xcbicpWzBdO1xyXG4gICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID0gZmlyc3RMaW5lLm1hdGNoKC8oXFxkK1xcLltcXGQuXSspLyk7XHJcbiAgICAgICAgICByZXNvbHZlKHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXSA6IGZpcnN0TGluZS50cmltKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JPdXRwdXQudHJpbSgpKSB7XHJcbiAgICAgICAgICAvLyBTb21lIHRvb2xzIG91dHB1dCB2ZXJzaW9uIHRvIHN0ZGVyclxyXG4gICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gZXJyb3JPdXRwdXQuc3BsaXQoJ1xcbicpWzBdO1xyXG4gICAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID0gZmlyc3RMaW5lLm1hdGNoKC8oXFxkK1xcLltcXGQuXSspLyk7XHJcbiAgICAgICAgICByZXNvbHZlKHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXSA6IGZpcnN0TGluZS50cmltKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBwcm9jZXNzLm9uKCdlcnJvcicsICgpID0+IHtcclxuICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRpbWVvdXQgZmFsbGJhY2tcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzcy5raWxsKCk7XHJcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgfSwgMTAwMDApO1xyXG4gICAgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhbiB1cCB0ZW1wb3JhcnkgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cFRlbXBGaWxlcyh0ZW1wRGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHModGVtcERpcikpIHtcclxuICAgICAgYXdhaXQgZnMucmVtb3ZlKHRlbXBEaXIpO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBMb2cgYnV0IGRvbid0IHRocm93IC0gY2xlYW51cCBmYWlsdXJlcyBzaG91bGRuJ3QgYnJlYWsgdGhlIG1haW4gcHJvY2Vzc1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gY2xlYW51cCB0ZW1wIGZpbGVzOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBieXRlcyB0byBodW1hbi1yZWFkYWJsZSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlczogbnVtYmVyKTogc3RyaW5nIHtcclxuICBpZiAoYnl0ZXMgPT09IDApIHJldHVybiAnMCBCeXRlcyc7XHJcbiAgXHJcbiAgY29uc3QgayA9IDEwMjQ7XHJcbiAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJ107XHJcbiAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZXMpIC8gTWF0aC5sb2coaykpO1xyXG4gIFxyXG4gIHJldHVybiBwYXJzZUZsb2F0KChieXRlcyAvIE1hdGgucG93KGssIGkpKS50b0ZpeGVkKDIpKSArICcgJyArIHNpemVzW2ldO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0cnkgYSBmdW5jdGlvbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeVdpdGhCYWNrb2ZmPFQ+KFxyXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxyXG4gIG1heFJldHJpZXM6IG51bWJlciA9IDMsXHJcbiAgYmFzZURlbGF5OiBudW1iZXIgPSAxMDAwXHJcbik6IFByb21pc2U8VD4ge1xyXG4gIGxldCBsYXN0RXJyb3I6IEVycm9yO1xyXG4gIFxyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsYXN0RXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChhdHRlbXB0ID09PSBtYXhSZXRyaWVzKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aCBqaXR0ZXJcclxuICAgICAgY29uc3QgZGVsYXkgPSBiYXNlRGVsYXkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSArIE1hdGgucmFuZG9tKCkgKiAxMDAwO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgdGhyb3cgbGFzdEVycm9yITtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgVVJMIGlzIGFjY2Vzc2libGVcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1VybEFjY2Vzc2liaWxpdHkodXJsOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIGNvbnN0IHByb3RvY29sID0gdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gaHR0cHMgOiBodHRwO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXF1ZXN0ID0gcHJvdG9jb2wucmVxdWVzdCh1cmwsIHsgbWV0aG9kOiAnSEVBRCcsIHRpbWVvdXQ6IDUwMDAgfSwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgIHJlc29sdmUocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgKCkgPT4ge1xyXG4gICAgICByZXNvbHZlKGZhbHNlKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXF1ZXN0Lm9uKCd0aW1lb3V0JywgKCkgPT4ge1xyXG4gICAgICByZXF1ZXN0LmRlc3Ryb3koKTtcclxuICAgICAgcmVzb2x2ZShmYWxzZSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmVxdWVzdC5lbmQoKTtcclxuICB9KTtcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/backend/utils/dependency-utils.ts\n\n}");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * Main process entry point for Playlistify Electron application\n * Handles application lifecycle, window management, and IPC communication\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst error_handlers_1 = __webpack_require__(/*! ./backend/handlers/error-handlers */ \"./src/backend/handlers/error-handlers.ts\");\nconst application_lifecycle_service_1 = __webpack_require__(/*! ./backend/services/application-lifecycle-service */ \"./src/backend/services/application-lifecycle-service.ts\");\nconst index_1 = __webpack_require__(/*! ./backend/handlers/index */ \"./src/backend/handlers/index.ts\");\nconst development_service_1 = __webpack_require__(/*! ./backend/services/development-service */ \"./src/backend/services/development-service.ts\");\nconst window_manager_service_1 = __webpack_require__(/*! ./backend/services/window-manager-service */ \"./src/backend/services/window-manager-service.ts\");\nconst error_handler_service_1 = __webpack_require__(/*! ./backend/services/error-handler-service */ \"./src/backend/services/error-handler-service.ts\");\nconst logger_service_1 = __webpack_require__(/*! ./backend/services/logger-service */ \"./src/backend/services/logger-service.ts\");\nconst electron_1 = __webpack_require__(/*! electron */ \"electron\");\n// Handle creating/removing shortcuts on Windows when installing/uninstalling\nif (__webpack_require__(/*! electron-squirrel-startup */ \"./node_modules/electron-squirrel-startup/index.js\")) {\n    electron_1.app.quit();\n}\n// Initialize logger service\nconst logger = (0, logger_service_1.createLogger)({\n    level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',\n    development: {\n        enhanced: process.env.NODE_ENV === 'development',\n        stackTrace: process.env.NODE_ENV === 'development',\n    },\n});\n// Initialize development service\nconst developmentService = (0, development_service_1.createDevelopmentService)({\n    enabled: process.env.NODE_ENV === 'development',\n    performanceMonitoring: true,\n    memoryTracking: true,\n});\n// Initialize core services\nconst errorHandler = new error_handler_service_1.ErrorHandlerService(logger);\nconst windowManager = new window_manager_service_1.WindowManagerService(logger);\nconst applicationLifecycle = new application_lifecycle_service_1.ApplicationLifecycleService(logger, windowManager, errorHandler);\n// Application configuration following the design specification\nconst APP_CONFIG = {\n    window: {\n        width: 800,\n        height: 600,\n        minWidth: 600,\n        minHeight: 400,\n        center: true,\n    },\n    security: {\n        nodeIntegration: false,\n        contextIsolation: true,\n        webSecurity: true,\n        allowRunningInsecureContent: false,\n        experimentalFeatures: false,\n    },\n    development: {\n        devTools: process.env.NODE_ENV === 'development',\n        hotReload: process.env.NODE_ENV === 'development',\n        debugLogging: process.env.NODE_ENV === 'development',\n    },\n};\n// Application initialization with secure IPC communication\nconst initializeApp = async () => {\n    try {\n        logger.info('App initialization started', 'MainProcess');\n        // Initialize application lifecycle service\n        await applicationLifecycle.initialize();\n        // Register core shutdown procedures\n        errorHandler.registerShutdownProcedure({\n            name: 'logger',\n            priority: 1,\n            timeout: 5000,\n            procedure: async () => {\n                await logger.shutdown();\n            },\n        });\n        errorHandler.registerShutdownProcedure({\n            name: 'development-service',\n            priority: 2,\n            timeout: 3000,\n            procedure: async () => {\n                if (process.env.NODE_ENV === 'development') {\n                    developmentService.shutdown();\n                }\n            },\n        });\n        errorHandler.registerShutdownProcedure({\n            name: 'ipc-handlers',\n            priority: 3,\n            timeout: 5000,\n            procedure: async () => {\n                if (process.env.NODE_ENV !== 'test') {\n                    (0, index_1.cleanupIPCHandlers)();\n                    (0, error_handlers_1.cleanupErrorHandlers)();\n                }\n            },\n        });\n        // Initialize secure IPC communication architecture\n        if (process.env.NODE_ENV !== 'test') {\n            (0, index_1.initializeIPCHandlers)();\n            (0, error_handlers_1.initializeErrorHandlers)(errorHandler);\n            logger.info('Secure IPC communication system initialized', 'MainProcess');\n        }\n        logger.info('App services initialized successfully', 'MainProcess');\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('Failed to initialize app services', 'MainProcess', {\n            error: errorMessage,\n        });\n        // Use error handler for initialization errors\n        await errorHandler.handleError(error instanceof Error ? error : new Error(errorMessage), {\n            operation: 'initialization',\n            component: 'MainProcess',\n        });\n        throw error;\n    }\n};\n// Initialize the application\nconst initializeApplication = async () => {\n    try {\n        // Initialize app services first\n        await initializeApp();\n        // Log system information in development mode\n        if (process.env.NODE_ENV === 'development') {\n            developmentService.logSystemInfo();\n        }\n        logger.info('Application initialization completed', 'MainProcess');\n    }\n    catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('Failed to initialize application', 'MainProcess', {\n            error: errorMessage,\n        });\n        throw error;\n    }\n};\n// Application lifecycle is now managed by ApplicationLifecycleService\n// The service handles all app events and window management automatically\n// Initialize the application when ready\nelectron_1.app.whenReady().then(() => {\n    initializeApplication().catch(error => {\n        logger.error('Failed to initialize application on ready', 'MainProcess', {\n            error: error instanceof Error ? error.message : error,\n        });\n        electron_1.app.quit();\n    });\n});\nlogger.debug('Main process initialized with configuration', 'MainProcess', {\n    config: APP_CONFIG,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTtRQUNwQyxNQUFNLENBQUMsS0FBSyxDQUFDLDJDQUEyQyxFQUFFLGFBQWEsRUFBRTtZQUN2RSxLQUFLLEVBQUUsS0FBSyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSztTQUN0RCxDQUFDLENBQUM7UUFDSCxjQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDYixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsTUFBTSxDQUFDLEtBQUssQ0FBQyw2Q0FBNkMsRUFBRSxhQUFhLEVBQUU7SUFDekUsTUFBTSxFQUFFLFVBQVU7Q0FDbkIsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGxheWxpc3RpZnkvLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBNYWluIHByb2Nlc3MgZW50cnkgcG9pbnQgZm9yIFBsYXlsaXN0aWZ5IEVsZWN0cm9uIGFwcGxpY2F0aW9uXHJcbiAqIEhhbmRsZXMgYXBwbGljYXRpb24gbGlmZWN5Y2xlLCB3aW5kb3cgbWFuYWdlbWVudCwgYW5kIElQQyBjb21tdW5pY2F0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICBjbGVhbnVwRXJyb3JIYW5kbGVycyxcclxuICBpbml0aWFsaXplRXJyb3JIYW5kbGVycyxcclxufSBmcm9tICcuL2JhY2tlbmQvaGFuZGxlcnMvZXJyb3ItaGFuZGxlcnMnO1xyXG5pbXBvcnQgeyBBcHBsaWNhdGlvbkxpZmVjeWNsZVNlcnZpY2UgfSBmcm9tICcuL2JhY2tlbmQvc2VydmljZXMvYXBwbGljYXRpb24tbGlmZWN5Y2xlLXNlcnZpY2UnO1xyXG5pbXBvcnQge1xyXG4gIGNsZWFudXBJUENIYW5kbGVycyxcclxuICBpbml0aWFsaXplSVBDSGFuZGxlcnMsXHJcbn0gZnJvbSAnLi9iYWNrZW5kL2hhbmRsZXJzL2luZGV4JztcclxuaW1wb3J0IHsgY3JlYXRlRGV2ZWxvcG1lbnRTZXJ2aWNlIH0gZnJvbSAnLi9iYWNrZW5kL3NlcnZpY2VzL2RldmVsb3BtZW50LXNlcnZpY2UnO1xyXG5pbXBvcnQgeyBXaW5kb3dNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vYmFja2VuZC9zZXJ2aWNlcy93aW5kb3ctbWFuYWdlci1zZXJ2aWNlJztcclxuaW1wb3J0IHsgRXJyb3JIYW5kbGVyU2VydmljZSB9IGZyb20gJy4vYmFja2VuZC9zZXJ2aWNlcy9lcnJvci1oYW5kbGVyLXNlcnZpY2UnO1xyXG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuL2JhY2tlbmQvc2VydmljZXMvbG9nZ2VyLXNlcnZpY2UnO1xyXG5pbXBvcnQgdHlwZSB7IEFwcENvbmZpZyB9IGZyb20gJ0Avc2hhcmVkL3R5cGVzJztcclxuaW1wb3J0IHsgYXBwIH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5cclxuLy8gSGFuZGxlIGNyZWF0aW5nL3JlbW92aW5nIHNob3J0Y3V0cyBvbiBXaW5kb3dzIHdoZW4gaW5zdGFsbGluZy91bmluc3RhbGxpbmdcclxuaWYgKHJlcXVpcmUoJ2VsZWN0cm9uLXNxdWlycmVsLXN0YXJ0dXAnKSkge1xyXG4gIGFwcC5xdWl0KCk7XHJcbn1cclxuXHJcbi8vIEluaXRpYWxpemUgbG9nZ2VyIHNlcnZpY2VcclxuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcclxuICBsZXZlbDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyAnZGVidWcnIDogJ2luZm8nLFxyXG4gIGRldmVsb3BtZW50OiB7XHJcbiAgICBlbmhhbmNlZDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXHJcbiAgICBzdGFja1RyYWNlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIEluaXRpYWxpemUgZGV2ZWxvcG1lbnQgc2VydmljZVxyXG5jb25zdCBkZXZlbG9wbWVudFNlcnZpY2UgPSBjcmVhdGVEZXZlbG9wbWVudFNlcnZpY2Uoe1xyXG4gIGVuYWJsZWQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxyXG4gIHBlcmZvcm1hbmNlTW9uaXRvcmluZzogdHJ1ZSxcclxuICBtZW1vcnlUcmFja2luZzogdHJ1ZSxcclxufSk7XHJcblxyXG4vLyBJbml0aWFsaXplIGNvcmUgc2VydmljZXNcclxuY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UobG9nZ2VyKTtcclxuY29uc3Qgd2luZG93TWFuYWdlciA9IG5ldyBXaW5kb3dNYW5hZ2VyU2VydmljZShsb2dnZXIpO1xyXG5jb25zdCBhcHBsaWNhdGlvbkxpZmVjeWNsZSA9IG5ldyBBcHBsaWNhdGlvbkxpZmVjeWNsZVNlcnZpY2UoXHJcbiAgbG9nZ2VyLFxyXG4gIHdpbmRvd01hbmFnZXIsXHJcbiAgZXJyb3JIYW5kbGVyLFxyXG4pO1xyXG5cclxuLy8gQXBwbGljYXRpb24gY29uZmlndXJhdGlvbiBmb2xsb3dpbmcgdGhlIGRlc2lnbiBzcGVjaWZpY2F0aW9uXHJcbmNvbnN0IEFQUF9DT05GSUc6IEFwcENvbmZpZyA9IHtcclxuICB3aW5kb3c6IHtcclxuICAgIHdpZHRoOiA4MDAsXHJcbiAgICBoZWlnaHQ6IDYwMCxcclxuICAgIG1pbldpZHRoOiA2MDAsXHJcbiAgICBtaW5IZWlnaHQ6IDQwMCxcclxuICAgIGNlbnRlcjogdHJ1ZSxcclxuICB9LFxyXG4gIHNlY3VyaXR5OiB7XHJcbiAgICBub2RlSW50ZWdyYXRpb246IGZhbHNlLFxyXG4gICAgY29udGV4dElzb2xhdGlvbjogdHJ1ZSxcclxuICAgIHdlYlNlY3VyaXR5OiB0cnVlLFxyXG4gICAgYWxsb3dSdW5uaW5nSW5zZWN1cmVDb250ZW50OiBmYWxzZSxcclxuICAgIGV4cGVyaW1lbnRhbEZlYXR1cmVzOiBmYWxzZSxcclxuICB9LFxyXG4gIGRldmVsb3BtZW50OiB7XHJcbiAgICBkZXZUb29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXHJcbiAgICBob3RSZWxvYWQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxyXG4gICAgZGVidWdMb2dnaW5nOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyxcclxuICB9LFxyXG59O1xyXG5cclxuLy8gQXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24gd2l0aCBzZWN1cmUgSVBDIGNvbW11bmljYXRpb25cclxuY29uc3QgaW5pdGlhbGl6ZUFwcCA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICB0cnkge1xyXG4gICAgbG9nZ2VyLmluZm8oJ0FwcCBpbml0aWFsaXphdGlvbiBzdGFydGVkJywgJ01haW5Qcm9jZXNzJyk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhcHBsaWNhdGlvbiBsaWZlY3ljbGUgc2VydmljZVxyXG4gICAgYXdhaXQgYXBwbGljYXRpb25MaWZlY3ljbGUuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIGNvcmUgc2h1dGRvd24gcHJvY2VkdXJlc1xyXG4gICAgZXJyb3JIYW5kbGVyLnJlZ2lzdGVyU2h1dGRvd25Qcm9jZWR1cmUoe1xyXG4gICAgICBuYW1lOiAnbG9nZ2VyJyxcclxuICAgICAgcHJpb3JpdHk6IDEsXHJcbiAgICAgIHRpbWVvdXQ6IDUwMDAsXHJcbiAgICAgIHByb2NlZHVyZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGxvZ2dlci5zaHV0ZG93bigpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgZXJyb3JIYW5kbGVyLnJlZ2lzdGVyU2h1dGRvd25Qcm9jZWR1cmUoe1xyXG4gICAgICBuYW1lOiAnZGV2ZWxvcG1lbnQtc2VydmljZScsXHJcbiAgICAgIHByaW9yaXR5OiAyLFxyXG4gICAgICB0aW1lb3V0OiAzMDAwLFxyXG4gICAgICBwcm9jZWR1cmU6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcclxuICAgICAgICAgIGRldmVsb3BtZW50U2VydmljZS5zaHV0ZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGVycm9ySGFuZGxlci5yZWdpc3RlclNodXRkb3duUHJvY2VkdXJlKHtcclxuICAgICAgbmFtZTogJ2lwYy1oYW5kbGVycycsXHJcbiAgICAgIHByaW9yaXR5OiAzLFxyXG4gICAgICB0aW1lb3V0OiA1MDAwLFxyXG4gICAgICBwcm9jZWR1cmU6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xyXG4gICAgICAgICAgY2xlYW51cElQQ0hhbmRsZXJzKCk7XHJcbiAgICAgICAgICBjbGVhbnVwRXJyb3JIYW5kbGVycygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgc2VjdXJlIElQQyBjb21tdW5pY2F0aW9uIGFyY2hpdGVjdHVyZVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcpIHtcclxuICAgICAgaW5pdGlhbGl6ZUlQQ0hhbmRsZXJzKCk7XHJcbiAgICAgIGluaXRpYWxpemVFcnJvckhhbmRsZXJzKGVycm9ySGFuZGxlcik7XHJcbiAgICAgIGxvZ2dlci5pbmZvKCdTZWN1cmUgSVBDIGNvbW11bmljYXRpb24gc3lzdGVtIGluaXRpYWxpemVkJywgJ01haW5Qcm9jZXNzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9nZ2VyLmluZm8oJ0FwcCBzZXJ2aWNlcyBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknLCAnTWFpblByb2Nlc3MnKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG4gICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHAgc2VydmljZXMnLCAnTWFpblByb2Nlc3MnLCB7XHJcbiAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBVc2UgZXJyb3IgaGFuZGxlciBmb3IgaW5pdGlhbGl6YXRpb24gZXJyb3JzXHJcbiAgICBhd2FpdCBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoXHJcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLFxyXG4gICAgICB7XHJcbiAgICAgICAgb3BlcmF0aW9uOiAnaW5pdGlhbGl6YXRpb24nLFxyXG4gICAgICAgIGNvbXBvbmVudDogJ01haW5Qcm9jZXNzJyxcclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gSW5pdGlhbGl6ZSB0aGUgYXBwbGljYXRpb25cclxuY29uc3QgaW5pdGlhbGl6ZUFwcGxpY2F0aW9uID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJbml0aWFsaXplIGFwcCBzZXJ2aWNlcyBmaXJzdFxyXG4gICAgYXdhaXQgaW5pdGlhbGl6ZUFwcCgpO1xyXG5cclxuICAgIC8vIExvZyBzeXN0ZW0gaW5mb3JtYXRpb24gaW4gZGV2ZWxvcG1lbnQgbW9kZVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XHJcbiAgICAgIGRldmVsb3BtZW50U2VydmljZS5sb2dTeXN0ZW1JbmZvKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9nZ2VyLmluZm8oJ0FwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlZCcsICdNYWluUHJvY2VzcycpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcbiAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIGFwcGxpY2F0aW9uJywgJ01haW5Qcm9jZXNzJywge1xyXG4gICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxyXG4gICAgfSk7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn07XHJcblxyXG4vLyBBcHBsaWNhdGlvbiBsaWZlY3ljbGUgaXMgbm93IG1hbmFnZWQgYnkgQXBwbGljYXRpb25MaWZlY3ljbGVTZXJ2aWNlXHJcbi8vIFRoZSBzZXJ2aWNlIGhhbmRsZXMgYWxsIGFwcCBldmVudHMgYW5kIHdpbmRvdyBtYW5hZ2VtZW50IGF1dG9tYXRpY2FsbHlcclxuXHJcbi8vIEluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uIHdoZW4gcmVhZHlcclxuYXBwLndoZW5SZWFkeSgpLnRoZW4oKCkgPT4ge1xyXG4gIGluaXRpYWxpemVBcHBsaWNhdGlvbigpLmNhdGNoKGVycm9yID0+IHtcclxuICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgYXBwbGljYXRpb24gb24gcmVhZHknLCAnTWFpblByb2Nlc3MnLCB7XHJcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLFxyXG4gICAgfSk7XHJcbiAgICBhcHAucXVpdCgpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbmxvZ2dlci5kZWJ1ZygnTWFpbiBwcm9jZXNzIGluaXRpYWxpemVkIHdpdGggY29uZmlndXJhdGlvbicsICdNYWluUHJvY2VzcycsIHtcclxuICBjb25maWc6IEFQUF9DT05GSUcsXHJcbn0pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.ts\n\n}");

/***/ }),

/***/ "./src/shared/errors.ts":
/*!******************************!*\
  !*** ./src/shared/errors.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n// src/shared/errors.ts\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PermissionError = exports.SecurityError = exports.ValidationError = exports.TimeoutError = exports.NetworkError = exports.DependencyDownloadError = exports.DependencyValidationError = exports.DependencyInstallationError = exports.DependencyError = exports.DiskFullError = exports.FileSystemReadOnlyError = exports.SchemaExecutionError = exports.DatabaseConnectionError = exports.DatabaseError = exports.CircularDependencyError = exports.TaskNotFoundError = exports.InvalidStateTransitionError = exports.ParentTaskNotFoundError = exports.InvalidInputError = exports.ApplicationError = exports.IPCError = exports.ConfigurationError = exports.SystemError = exports.BaseError = void 0;\n/**\n * Base error class with enhanced error information\n */\nclass BaseError extends Error {\n    constructor(message, code, options = {}) {\n        super(message);\n        this.name = this.constructor.name;\n        this.code = code;\n        this.context = options.context;\n        this.details = options.details;\n        this.timestamp = new Date();\n        this.recoverable = options.recoverable ?? false;\n        this.userMessage = options.userMessage;\n        this.suggestions = options.suggestions;\n        this.cause = options.cause;\n        // Maintain proper stack trace\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    /**\n     * Convert error to JSON for logging and reporting\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            code: this.code,\n            context: this.context,\n            details: this.details,\n            timestamp: this.timestamp.toISOString(),\n            recoverable: this.recoverable,\n            userMessage: this.userMessage,\n            suggestions: this.suggestions,\n            stack: this.stack,\n        };\n    }\n}\nexports.BaseError = BaseError;\n/**\n * System-level errors (OS, hardware, permissions)\n */\nclass SystemError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'System',\n            recoverable: options.recoverable ?? true,\n        });\n    }\n}\nexports.SystemError = SystemError;\n/**\n * Configuration and settings errors\n */\nclass ConfigurationError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'Configuration',\n            recoverable: options.recoverable ?? true,\n        });\n    }\n}\nexports.ConfigurationError = ConfigurationError;\n/**\n * IPC communication errors\n */\nclass IPCError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'IPC',\n            recoverable: options.recoverable ?? true,\n        });\n    }\n}\nexports.IPCError = IPCError;\n/**\n * Application lifecycle errors\n */\nclass ApplicationError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'Application',\n            recoverable: options.recoverable ?? false,\n        });\n    }\n}\nexports.ApplicationError = ApplicationError;\n// Task Management Errors\nclass InvalidInputError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'INVALID_INPUT', {\n            ...options,\n            context: options.context || 'TaskManagement',\n            recoverable: true,\n            userMessage: 'Invalid input provided. Please check your data and try again.',\n            suggestions: ['Verify input format', 'Check required fields', 'Consult documentation'],\n        });\n    }\n}\nexports.InvalidInputError = InvalidInputError;\nclass ParentTaskNotFoundError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'PARENT_TASK_NOT_FOUND', {\n            ...options,\n            context: options.context || 'TaskManagement',\n            recoverable: true,\n            userMessage: 'Parent task not found. The task may have been deleted or moved.',\n            suggestions: ['Refresh the task list', 'Check if the parent task exists', 'Create the parent task first'],\n        });\n    }\n}\nexports.ParentTaskNotFoundError = ParentTaskNotFoundError;\nclass InvalidStateTransitionError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'INVALID_STATE_TRANSITION', {\n            ...options,\n            context: options.context || 'TaskManagement',\n            recoverable: true,\n            userMessage: 'Invalid task state transition. The requested operation is not allowed.',\n            suggestions: ['Check current task state', 'Review allowed transitions', 'Try a different operation'],\n        });\n    }\n}\nexports.InvalidStateTransitionError = InvalidStateTransitionError;\nclass TaskNotFoundError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'TASK_NOT_FOUND', {\n            ...options,\n            context: options.context || 'TaskManagement',\n            recoverable: true,\n            userMessage: 'Task not found. The task may have been deleted or moved.',\n            suggestions: ['Refresh the task list', 'Check if the task ID is correct', 'Search for the task by name'],\n        });\n    }\n}\nexports.TaskNotFoundError = TaskNotFoundError;\nclass CircularDependencyError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'CIRCULAR_DEPENDENCY', {\n            ...options,\n            context: options.context || 'TaskManagement',\n            recoverable: true,\n            userMessage: 'Circular dependency detected. Tasks cannot depend on themselves.',\n            suggestions: ['Review task dependencies', 'Remove circular references', 'Restructure task hierarchy'],\n        });\n    }\n}\nexports.CircularDependencyError = CircularDependencyError;\n// Database Errors\nclass DatabaseError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DATABASE_ERROR', {\n            ...options,\n            context: options.context || 'Database',\n            recoverable: true,\n            userMessage: 'Database operation failed. Please try again.',\n            suggestions: ['Retry the operation', 'Check database connection', 'Restart the application'],\n        });\n    }\n}\nexports.DatabaseError = DatabaseError;\nclass DatabaseConnectionError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DATABASE_CONNECTION_ERROR', {\n            ...options,\n            context: options.context || 'Database',\n            recoverable: true,\n            userMessage: 'Cannot connect to database. Please check your setup.',\n            suggestions: ['Check database file permissions', 'Verify database path', 'Restart the application'],\n        });\n    }\n}\nexports.DatabaseConnectionError = DatabaseConnectionError;\nclass SchemaExecutionError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'SCHEMA_EXECUTION_ERROR', {\n            ...options,\n            context: options.context || 'Database',\n            recoverable: false,\n            userMessage: 'Database schema error. The application may need to be reinstalled.',\n            suggestions: ['Restart the application', 'Clear application data', 'Reinstall the application'],\n        });\n    }\n}\nexports.SchemaExecutionError = SchemaExecutionError;\n// File System Errors\nclass FileSystemReadOnlyError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'FILESYSTEM_READONLY', {\n            ...options,\n            context: options.context || 'FileSystem',\n            recoverable: true,\n            userMessage: 'Cannot write to file system. Check permissions or disk space.',\n            suggestions: ['Check file permissions', 'Verify disk space', 'Run as administrator', 'Choose different location'],\n        });\n    }\n}\nexports.FileSystemReadOnlyError = FileSystemReadOnlyError;\nclass DiskFullError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DISK_FULL', {\n            ...options,\n            context: options.context || 'FileSystem',\n            recoverable: true,\n            userMessage: 'Not enough disk space. Please free up space and try again.',\n            suggestions: ['Free up disk space', 'Choose different download location', 'Delete unnecessary files'],\n        });\n    }\n}\nexports.DiskFullError = DiskFullError;\n// Dependency Management Errors\nclass DependencyError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DEPENDENCY_ERROR', {\n            ...options,\n            context: options.context || 'Dependencies',\n            recoverable: true,\n            userMessage: 'Dependency management error. Some features may not work properly.',\n            suggestions: ['Restart the application', 'Check internet connection', 'Try manual installation'],\n        });\n    }\n}\nexports.DependencyError = DependencyError;\nclass DependencyInstallationError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DEPENDENCY_INSTALLATION_ERROR', {\n            ...options,\n            context: options.context || 'Dependencies',\n            recoverable: true,\n            userMessage: 'Failed to install required dependencies. Some features may not work.',\n            suggestions: ['Check internet connection', 'Retry installation', 'Check firewall settings', 'Try manual installation'],\n        });\n    }\n}\nexports.DependencyInstallationError = DependencyInstallationError;\nclass DependencyValidationError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DEPENDENCY_VALIDATION_ERROR', {\n            ...options,\n            context: options.context || 'Dependencies',\n            recoverable: true,\n            userMessage: 'Dependency validation failed. The installed version may be corrupted.',\n            suggestions: ['Reinstall dependencies', 'Check file integrity', 'Clear dependency cache'],\n        });\n    }\n}\nexports.DependencyValidationError = DependencyValidationError;\nclass DependencyDownloadError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'DEPENDENCY_DOWNLOAD_ERROR', {\n            ...options,\n            context: options.context || 'Dependencies',\n            recoverable: true,\n            userMessage: 'Failed to download required dependencies. Check your internet connection.',\n            suggestions: ['Check internet connection', 'Retry download', 'Check firewall settings', 'Use different network'],\n        });\n    }\n}\nexports.DependencyDownloadError = DependencyDownloadError;\n// Network and Connectivity Errors\nclass NetworkError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'Network',\n            recoverable: true,\n            userMessage: 'Network connection error. Please check your internet connection.',\n            suggestions: ['Check internet connection', 'Try again later', 'Check firewall settings'],\n        });\n    }\n}\nexports.NetworkError = NetworkError;\nclass TimeoutError extends BaseError {\n    constructor(message, options = {}) {\n        super(message, 'TIMEOUT_ERROR', {\n            ...options,\n            context: options.context || 'Network',\n            recoverable: true,\n            userMessage: 'Operation timed out. Please try again.',\n            suggestions: ['Try again', 'Check internet connection', 'Increase timeout settings'],\n        });\n    }\n}\nexports.TimeoutError = TimeoutError;\n// Validation Errors\nclass ValidationError extends BaseError {\n    constructor(message, field, options = {}) {\n        super(message, 'VALIDATION_ERROR', {\n            ...options,\n            context: options.context || 'Validation',\n            recoverable: true,\n            details: { ...options.details, field },\n            userMessage: `Validation failed${field ? ` for ${field}` : ''}. Please check your input.`,\n            suggestions: ['Check input format', 'Verify required fields', 'Review validation rules'],\n        });\n    }\n}\nexports.ValidationError = ValidationError;\n// Security Errors\nclass SecurityError extends BaseError {\n    constructor(message, code, options = {}) {\n        super(message, code, {\n            ...options,\n            context: options.context || 'Security',\n            recoverable: false,\n            userMessage: 'Security violation detected. Operation blocked for safety.',\n            suggestions: ['Contact support', 'Check application integrity', 'Restart application'],\n        });\n    }\n}\nexports.SecurityError = SecurityError;\n// Permission Errors\nclass PermissionError extends BaseError {\n    constructor(message, resource, options = {}) {\n        super(message, 'PERMISSION_ERROR', {\n            ...options,\n            context: options.context || 'Permissions',\n            recoverable: true,\n            details: { ...options.details, resource },\n            userMessage: `Permission denied${resource ? ` for ${resource}` : ''}. Check file permissions.`,\n            suggestions: ['Run as administrator', 'Check file permissions', 'Change file location'],\n        });\n    }\n}\nexports.PermissionError = PermissionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcmVkL2Vycm9ycy50cyIsIm1hcHBpbmdzIjoiO0FBQUEsdUJBQXVCOzs7QUFjdkI7O0dBRUc7QUFDSCxNQUFzQixTQUFVLFNBQVEsS0FBSztJQVUzQyxZQUNFLE9BQWUsRUFDZixJQUFZLEVBQ1osVUFBNEIsRUFBRTtRQUU5QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDL0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUM7UUFDaEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUN2QyxJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFFM0IsOEJBQThCO1FBQzlCLElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDNUIsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbEQsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU07UUFDSixPQUFPO1lBQ0wsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87WUFDckIsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFO1lBQ3ZDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztZQUM3QixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO1lBQzdCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztTQUNsQixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBakRELDhCQWlEQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsU0FBUztJQUN4QyxZQUFZLE9BQWUsRUFBRSxJQUFZLEVBQUUsVUFBNEIsRUFBRTtRQUN2RSxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtZQUNuQixHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxRQUFRO1lBQ3BDLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVyxJQUFJLElBQUk7U0FDekMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBUkQsa0NBUUM7QUFFRDs7R0FFRztBQUNILE1BQWEsa0JBQW1CLFNBQVEsU0FBUztJQUMvQyxZQUFZLE9BQWUsRUFBRSxJQUFZLEVBQUUsVUFBNEIsRUFBRTtRQUN2RSxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtZQUNuQixHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxlQUFlO1lBQzNDLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVyxJQUFJLElBQUk7U0FDekMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBUkQsZ0RBUUM7QUFFRDs7R0FFRztBQUNILE1BQWEsUUFBUyxTQUFRLFNBQVM7SUFDckMsWUFBWSxPQUFlLEVBQUUsSUFBWSxFQUFFLFVBQTRCLEVBQUU7UUFDdkUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7WUFDbkIsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksS0FBSztZQUNqQyxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSxJQUFJO1NBQ3pDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVJELDRCQVFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGdCQUFpQixTQUFRLFNBQVM7SUFDN0MsWUFBWSxPQUFlLEVBQUUsSUFBWSxFQUFFLFVBQTRCLEVBQUU7UUFDdkUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7WUFDbkIsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksYUFBYTtZQUN6QyxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSxLQUFLO1NBQzFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVJELDRDQVFDO0FBRUQseUJBQXlCO0FBQ3pCLE1BQWEsaUJBQWtCLFNBQVEsU0FBUztJQUM5QyxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsZUFBZSxFQUFFO1lBQzlCLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLGdCQUFnQjtZQUM1QyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsK0RBQStEO1lBQzVFLFdBQVcsRUFBRSxDQUFDLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFLHVCQUF1QixDQUFDO1NBQ3ZGLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELDhDQVVDO0FBRUQsTUFBYSx1QkFBd0IsU0FBUSxTQUFTO0lBQ3BELFlBQVksT0FBZSxFQUFFLFVBQTRCLEVBQUU7UUFDekQsS0FBSyxDQUFDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRTtZQUN0QyxHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxnQkFBZ0I7WUFDNUMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLGlFQUFpRTtZQUM5RSxXQUFXLEVBQUUsQ0FBQyx1QkFBdUIsRUFBRSxpQ0FBaUMsRUFBRSw4QkFBOEIsQ0FBQztTQUMxRyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFWRCwwREFVQztBQUVELE1BQWEsMkJBQTRCLFNBQVEsU0FBUztJQUN4RCxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsMEJBQTBCLEVBQUU7WUFDekMsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksZ0JBQWdCO1lBQzVDLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLFdBQVcsRUFBRSx3RUFBd0U7WUFDckYsV0FBVyxFQUFFLENBQUMsMEJBQTBCLEVBQUUsNEJBQTRCLEVBQUUsMkJBQTJCLENBQUM7U0FDckcsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBVkQsa0VBVUM7QUFFRCxNQUFhLGlCQUFrQixTQUFRLFNBQVM7SUFDOUMsWUFBWSxPQUFlLEVBQUUsVUFBNEIsRUFBRTtRQUN6RCxLQUFLLENBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFO1lBQy9CLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLGdCQUFnQjtZQUM1QyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsMERBQTBEO1lBQ3ZFLFdBQVcsRUFBRSxDQUFDLHVCQUF1QixFQUFFLGlDQUFpQyxFQUFFLDZCQUE2QixDQUFDO1NBQ3pHLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELDhDQVVDO0FBRUQsTUFBYSx1QkFBd0IsU0FBUSxTQUFTO0lBQ3BELFlBQVksT0FBZSxFQUFFLFVBQTRCLEVBQUU7UUFDekQsS0FBSyxDQUFDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRTtZQUNwQyxHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxnQkFBZ0I7WUFDNUMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLGtFQUFrRTtZQUMvRSxXQUFXLEVBQUUsQ0FBQywwQkFBMEIsRUFBRSw0QkFBNEIsRUFBRSw0QkFBNEIsQ0FBQztTQUN0RyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFWRCwwREFVQztBQUVELGtCQUFrQjtBQUNsQixNQUFhLGFBQWMsU0FBUSxTQUFTO0lBQzFDLFlBQVksT0FBZSxFQUFFLFVBQTRCLEVBQUU7UUFDekQsS0FBSyxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRTtZQUMvQixHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxVQUFVO1lBQ3RDLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLFdBQVcsRUFBRSw4Q0FBOEM7WUFDM0QsV0FBVyxFQUFFLENBQUMscUJBQXFCLEVBQUUsMkJBQTJCLEVBQUUseUJBQXlCLENBQUM7U0FDN0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBVkQsc0NBVUM7QUFFRCxNQUFhLHVCQUF3QixTQUFRLFNBQVM7SUFDcEQsWUFBWSxPQUFlLEVBQUUsVUFBNEIsRUFBRTtRQUN6RCxLQUFLLENBQUMsT0FBTyxFQUFFLDJCQUEyQixFQUFFO1lBQzFDLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLFVBQVU7WUFDdEMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLHNEQUFzRDtZQUNuRSxXQUFXLEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRSxzQkFBc0IsRUFBRSx5QkFBeUIsQ0FBQztTQUNwRyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFWRCwwREFVQztBQUVELE1BQWEsb0JBQXFCLFNBQVEsU0FBUztJQUNqRCxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsd0JBQXdCLEVBQUU7WUFDdkMsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksVUFBVTtZQUN0QyxXQUFXLEVBQUUsS0FBSztZQUNsQixXQUFXLEVBQUUsb0VBQW9FO1lBQ2pGLFdBQVcsRUFBRSxDQUFDLHlCQUF5QixFQUFFLHdCQUF3QixFQUFFLDJCQUEyQixDQUFDO1NBQ2hHLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELG9EQVVDO0FBRUQscUJBQXFCO0FBQ3JCLE1BQWEsdUJBQXdCLFNBQVEsU0FBUztJQUNwRCxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUU7WUFDcEMsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksWUFBWTtZQUN4QyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsK0RBQStEO1lBQzVFLFdBQVcsRUFBRSxDQUFDLHdCQUF3QixFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLDJCQUEyQixDQUFDO1NBQ2xILENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELDBEQVVDO0FBRUQsTUFBYSxhQUFjLFNBQVEsU0FBUztJQUMxQyxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFO1lBQzFCLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLFlBQVk7WUFDeEMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLDREQUE0RDtZQUN6RSxXQUFXLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSxvQ0FBb0MsRUFBRSwwQkFBMEIsQ0FBQztTQUN0RyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFWRCxzQ0FVQztBQUVELCtCQUErQjtBQUMvQixNQUFhLGVBQWdCLFNBQVEsU0FBUztJQUM1QyxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUU7WUFDakMsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksY0FBYztZQUMxQyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsbUVBQW1FO1lBQ2hGLFdBQVcsRUFBRSxDQUFDLHlCQUF5QixFQUFFLDJCQUEyQixFQUFFLHlCQUF5QixDQUFDO1NBQ2pHLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELDBDQVVDO0FBRUQsTUFBYSwyQkFBNEIsU0FBUSxTQUFTO0lBQ3hELFlBQVksT0FBZSxFQUFFLFVBQTRCLEVBQUU7UUFDekQsS0FBSyxDQUFDLE9BQU8sRUFBRSwrQkFBK0IsRUFBRTtZQUM5QyxHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxjQUFjO1lBQzFDLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLFdBQVcsRUFBRSxzRUFBc0U7WUFDbkYsV0FBVyxFQUFFLENBQUMsMkJBQTJCLEVBQUUsb0JBQW9CLEVBQUUseUJBQXlCLEVBQUUseUJBQXlCLENBQUM7U0FDdkgsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBVkQsa0VBVUM7QUFFRCxNQUFhLHlCQUEwQixTQUFRLFNBQVM7SUFDdEQsWUFBWSxPQUFlLEVBQUUsVUFBNEIsRUFBRTtRQUN6RCxLQUFLLENBQUMsT0FBTyxFQUFFLDZCQUE2QixFQUFFO1lBQzVDLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLGNBQWM7WUFDMUMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLHVFQUF1RTtZQUNwRixXQUFXLEVBQUUsQ0FBQyx3QkFBd0IsRUFBRSxzQkFBc0IsRUFBRSx3QkFBd0IsQ0FBQztTQUMxRixDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFWRCw4REFVQztBQUVELE1BQWEsdUJBQXdCLFNBQVEsU0FBUztJQUNwRCxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsMkJBQTJCLEVBQUU7WUFDMUMsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksY0FBYztZQUMxQyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsMkVBQTJFO1lBQ3hGLFdBQVcsRUFBRSxDQUFDLDJCQUEyQixFQUFFLGdCQUFnQixFQUFFLHlCQUF5QixFQUFFLHVCQUF1QixDQUFDO1NBQ2pILENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELDBEQVVDO0FBRUQsa0NBQWtDO0FBQ2xDLE1BQWEsWUFBYSxTQUFRLFNBQVM7SUFDekMsWUFBWSxPQUFlLEVBQUUsSUFBWSxFQUFFLFVBQTRCLEVBQUU7UUFDdkUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7WUFDbkIsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksU0FBUztZQUNyQyxXQUFXLEVBQUUsSUFBSTtZQUNqQixXQUFXLEVBQUUsa0VBQWtFO1lBQy9FLFdBQVcsRUFBRSxDQUFDLDJCQUEyQixFQUFFLGlCQUFpQixFQUFFLHlCQUF5QixDQUFDO1NBQ3pGLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELG9DQVVDO0FBRUQsTUFBYSxZQUFhLFNBQVEsU0FBUztJQUN6QyxZQUFZLE9BQWUsRUFBRSxVQUE0QixFQUFFO1FBQ3pELEtBQUssQ0FBQyxPQUFPLEVBQUUsZUFBZSxFQUFFO1lBQzlCLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLFNBQVM7WUFDckMsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLHdDQUF3QztZQUNyRCxXQUFXLEVBQUUsQ0FBQyxXQUFXLEVBQUUsMkJBQTJCLEVBQUUsMkJBQTJCLENBQUM7U0FDckYsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBVkQsb0NBVUM7QUFFRCxvQkFBb0I7QUFDcEIsTUFBYSxlQUFnQixTQUFRLFNBQVM7SUFDNUMsWUFBWSxPQUFlLEVBQUUsS0FBYyxFQUFFLFVBQTRCLEVBQUU7UUFDekUsS0FBSyxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRTtZQUNqQyxHQUFHLE9BQU87WUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxZQUFZO1lBQ3hDLFdBQVcsRUFBRSxJQUFJO1lBQ2pCLE9BQU8sRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUU7WUFDdEMsV0FBVyxFQUFFLG9CQUFvQixLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsNEJBQTRCO1lBQ3pGLFdBQVcsRUFBRSxDQUFDLG9CQUFvQixFQUFFLHdCQUF3QixFQUFFLHlCQUF5QixDQUFDO1NBQ3pGLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVhELDBDQVdDO0FBRUQsa0JBQWtCO0FBQ2xCLE1BQWEsYUFBYyxTQUFRLFNBQVM7SUFDMUMsWUFBWSxPQUFlLEVBQUUsSUFBWSxFQUFFLFVBQTRCLEVBQUU7UUFDdkUsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7WUFDbkIsR0FBRyxPQUFPO1lBQ1YsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLElBQUksVUFBVTtZQUN0QyxXQUFXLEVBQUUsS0FBSztZQUNsQixXQUFXLEVBQUUsNERBQTREO1lBQ3pFLFdBQVcsRUFBRSxDQUFDLGlCQUFpQixFQUFFLDZCQUE2QixFQUFFLHFCQUFxQixDQUFDO1NBQ3ZGLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQVZELHNDQVVDO0FBRUQsb0JBQW9CO0FBQ3BCLE1BQWEsZUFBZ0IsU0FBUSxTQUFTO0lBQzVDLFlBQVksT0FBZSxFQUFFLFFBQWlCLEVBQUUsVUFBNEIsRUFBRTtRQUM1RSxLQUFLLENBQUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFO1lBQ2pDLEdBQUcsT0FBTztZQUNWLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxJQUFJLGFBQWE7WUFDekMsV0FBVyxFQUFFLElBQUk7WUFDakIsT0FBTyxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRTtZQUN6QyxXQUFXLEVBQUUsb0JBQW9CLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSwyQkFBMkI7WUFDOUYsV0FBVyxFQUFFLENBQUMsc0JBQXNCLEVBQUUsd0JBQXdCLEVBQUUsc0JBQXNCLENBQUM7U0FDeEYsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBWEQsMENBV0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9zaGFyZWQvZXJyb3JzLnRzP2E5MzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3NoYXJlZC9lcnJvcnMudHNcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGVycm9yIG9wdGlvbnMgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VFcnJvck9wdGlvbnMge1xyXG4gIGNvbnRleHQ/OiBzdHJpbmc7XHJcbiAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgcmVjb3ZlcmFibGU/OiBib29sZWFuO1xyXG4gIHVzZXJNZXNzYWdlPzogc3RyaW5nO1xyXG4gIHN1Z2dlc3Rpb25zPzogc3RyaW5nW107XHJcbiAgY2F1c2U/OiBFcnJvcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgZXJyb3IgY2xhc3Mgd2l0aCBlbmhhbmNlZCBlcnJvciBpbmZvcm1hdGlvblxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBwdWJsaWMgcmVhZG9ubHkgY29kZTogc3RyaW5nO1xyXG4gIHB1YmxpYyByZWFkb25seSBjb250ZXh0Pzogc3RyaW5nO1xyXG4gIHB1YmxpYyByZWFkb25seSBkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICBwdWJsaWMgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xyXG4gIHB1YmxpYyByZWFkb25seSByZWNvdmVyYWJsZTogYm9vbGVhbjtcclxuICBwdWJsaWMgcmVhZG9ubHkgdXNlck1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgcHVibGljIHJlYWRvbmx5IHN1Z2dlc3Rpb25zPzogc3RyaW5nW107XHJcbiAgcHVibGljIHJlYWRvbmx5IGNhdXNlPzogRXJyb3I7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgbWVzc2FnZTogc3RyaW5nLFxyXG4gICAgY29kZTogc3RyaW5nLFxyXG4gICAgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9XHJcbiAgKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XHJcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRpb25zLmRldGFpbHM7XHJcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICB0aGlzLnJlY292ZXJhYmxlID0gb3B0aW9ucy5yZWNvdmVyYWJsZSA/PyBmYWxzZTtcclxuICAgIHRoaXMudXNlck1lc3NhZ2UgPSBvcHRpb25zLnVzZXJNZXNzYWdlO1xyXG4gICAgdGhpcy5zdWdnZXN0aW9ucyA9IG9wdGlvbnMuc3VnZ2VzdGlvbnM7XHJcbiAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcclxuICAgIFxyXG4gICAgLy8gTWFpbnRhaW4gcHJvcGVyIHN0YWNrIHRyYWNlXHJcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IGVycm9yIHRvIEpTT04gZm9yIGxvZ2dpbmcgYW5kIHJlcG9ydGluZ1xyXG4gICAqL1xyXG4gIHRvSlNPTigpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxyXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXHJcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcclxuICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxyXG4gICAgICB0aW1lc3RhbXA6IHRoaXMudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHJlY292ZXJhYmxlOiB0aGlzLnJlY292ZXJhYmxlLFxyXG4gICAgICB1c2VyTWVzc2FnZTogdGhpcy51c2VyTWVzc2FnZSxcclxuICAgICAgc3VnZ2VzdGlvbnM6IHRoaXMuc3VnZ2VzdGlvbnMsXHJcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTeXN0ZW0tbGV2ZWwgZXJyb3JzIChPUywgaGFyZHdhcmUsIHBlcm1pc3Npb25zKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGNvZGU6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCBjb2RlLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB8fCAnU3lzdGVtJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IG9wdGlvbnMucmVjb3ZlcmFibGUgPz8gdHJ1ZSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbmZpZ3VyYXRpb24gYW5kIHNldHRpbmdzIGVycm9yc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgY29kZSwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ0NvbmZpZ3VyYXRpb24nLFxyXG4gICAgICByZWNvdmVyYWJsZTogb3B0aW9ucy5yZWNvdmVyYWJsZSA/PyB0cnVlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSVBDIGNvbW11bmljYXRpb24gZXJyb3JzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSVBDRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29kZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsIGNvZGUsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdJUEMnLFxyXG4gICAgICByZWNvdmVyYWJsZTogb3B0aW9ucy5yZWNvdmVyYWJsZSA/PyB0cnVlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQXBwbGljYXRpb24gbGlmZWN5Y2xlIGVycm9yc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFwcGxpY2F0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgY29kZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsIGNvZGUsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdBcHBsaWNhdGlvbicsXHJcbiAgICAgIHJlY292ZXJhYmxlOiBvcHRpb25zLnJlY292ZXJhYmxlID8/IGZhbHNlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUYXNrIE1hbmFnZW1lbnQgRXJyb3JzXHJcbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW5wdXRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsICdJTlZBTElEX0lOUFVUJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ1Rhc2tNYW5hZ2VtZW50JyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnSW52YWxpZCBpbnB1dCBwcm92aWRlZC4gUGxlYXNlIGNoZWNrIHlvdXIgZGF0YSBhbmQgdHJ5IGFnYWluLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ1ZlcmlmeSBpbnB1dCBmb3JtYXQnLCAnQ2hlY2sgcmVxdWlyZWQgZmllbGRzJywgJ0NvbnN1bHQgZG9jdW1lbnRhdGlvbiddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGFyZW50VGFza05vdEZvdW5kRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnUEFSRU5UX1RBU0tfTk9UX0ZPVU5EJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ1Rhc2tNYW5hZ2VtZW50JyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnUGFyZW50IHRhc2sgbm90IGZvdW5kLiBUaGUgdGFzayBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgb3IgbW92ZWQuJyxcclxuICAgICAgc3VnZ2VzdGlvbnM6IFsnUmVmcmVzaCB0aGUgdGFzayBsaXN0JywgJ0NoZWNrIGlmIHRoZSBwYXJlbnQgdGFzayBleGlzdHMnLCAnQ3JlYXRlIHRoZSBwYXJlbnQgdGFzayBmaXJzdCddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0YXRlVHJhbnNpdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0lOVkFMSURfU1RBVEVfVFJBTlNJVElPTicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdUYXNrTWFuYWdlbWVudCcsXHJcbiAgICAgIHJlY292ZXJhYmxlOiB0cnVlLFxyXG4gICAgICB1c2VyTWVzc2FnZTogJ0ludmFsaWQgdGFzayBzdGF0ZSB0cmFuc2l0aW9uLiBUaGUgcmVxdWVzdGVkIG9wZXJhdGlvbiBpcyBub3QgYWxsb3dlZC4nLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydDaGVjayBjdXJyZW50IHRhc2sgc3RhdGUnLCAnUmV2aWV3IGFsbG93ZWQgdHJhbnNpdGlvbnMnLCAnVHJ5IGEgZGlmZmVyZW50IG9wZXJhdGlvbiddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVGFza05vdEZvdW5kRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnVEFTS19OT1RfRk9VTkQnLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB8fCAnVGFza01hbmFnZW1lbnQnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdUYXNrIG5vdCBmb3VuZC4gVGhlIHRhc2sgbWF5IGhhdmUgYmVlbiBkZWxldGVkIG9yIG1vdmVkLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ1JlZnJlc2ggdGhlIHRhc2sgbGlzdCcsICdDaGVjayBpZiB0aGUgdGFzayBJRCBpcyBjb3JyZWN0JywgJ1NlYXJjaCBmb3IgdGhlIHRhc2sgYnkgbmFtZSddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQ2lyY3VsYXJEZXBlbmRlbmN5RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnQ0lSQ1VMQVJfREVQRU5ERU5DWScsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdUYXNrTWFuYWdlbWVudCcsXHJcbiAgICAgIHJlY292ZXJhYmxlOiB0cnVlLFxyXG4gICAgICB1c2VyTWVzc2FnZTogJ0NpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIFRhc2tzIGNhbm5vdCBkZXBlbmQgb24gdGhlbXNlbHZlcy4nLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydSZXZpZXcgdGFzayBkZXBlbmRlbmNpZXMnLCAnUmVtb3ZlIGNpcmN1bGFyIHJlZmVyZW5jZXMnLCAnUmVzdHJ1Y3R1cmUgdGFzayBoaWVyYXJjaHknXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRGF0YWJhc2UgRXJyb3JzXHJcbmV4cG9ydCBjbGFzcyBEYXRhYmFzZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0RBVEFCQVNFX0VSUk9SJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ0RhdGFiYXNlJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydSZXRyeSB0aGUgb3BlcmF0aW9uJywgJ0NoZWNrIGRhdGFiYXNlIGNvbm5lY3Rpb24nLCAnUmVzdGFydCB0aGUgYXBwbGljYXRpb24nXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIERhdGFiYXNlQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0RBVEFCQVNFX0NPTk5FQ1RJT05fRVJST1InLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB8fCAnRGF0YWJhc2UnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdDYW5ub3QgY29ubmVjdCB0byBkYXRhYmFzZS4gUGxlYXNlIGNoZWNrIHlvdXIgc2V0dXAuJyxcclxuICAgICAgc3VnZ2VzdGlvbnM6IFsnQ2hlY2sgZGF0YWJhc2UgZmlsZSBwZXJtaXNzaW9ucycsICdWZXJpZnkgZGF0YWJhc2UgcGF0aCcsICdSZXN0YXJ0IHRoZSBhcHBsaWNhdGlvbiddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2NoZW1hRXhlY3V0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnU0NIRU1BX0VYRUNVVElPTl9FUlJPUicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdEYXRhYmFzZScsXHJcbiAgICAgIHJlY292ZXJhYmxlOiBmYWxzZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdEYXRhYmFzZSBzY2hlbWEgZXJyb3IuIFRoZSBhcHBsaWNhdGlvbiBtYXkgbmVlZCB0byBiZSByZWluc3RhbGxlZC4nLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydSZXN0YXJ0IHRoZSBhcHBsaWNhdGlvbicsICdDbGVhciBhcHBsaWNhdGlvbiBkYXRhJywgJ1JlaW5zdGFsbCB0aGUgYXBwbGljYXRpb24nXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRmlsZSBTeXN0ZW0gRXJyb3JzXHJcbmV4cG9ydCBjbGFzcyBGaWxlU3lzdGVtUmVhZE9ubHlFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsICdGSUxFU1lTVEVNX1JFQURPTkxZJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ0ZpbGVTeXN0ZW0nLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdDYW5ub3Qgd3JpdGUgdG8gZmlsZSBzeXN0ZW0uIENoZWNrIHBlcm1pc3Npb25zIG9yIGRpc2sgc3BhY2UuJyxcclxuICAgICAgc3VnZ2VzdGlvbnM6IFsnQ2hlY2sgZmlsZSBwZXJtaXNzaW9ucycsICdWZXJpZnkgZGlzayBzcGFjZScsICdSdW4gYXMgYWRtaW5pc3RyYXRvcicsICdDaG9vc2UgZGlmZmVyZW50IGxvY2F0aW9uJ10sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEaXNrRnVsbEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0RJU0tfRlVMTCcsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdGaWxlU3lzdGVtJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnTm90IGVub3VnaCBkaXNrIHNwYWNlLiBQbGVhc2UgZnJlZSB1cCBzcGFjZSBhbmQgdHJ5IGFnYWluLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ0ZyZWUgdXAgZGlzayBzcGFjZScsICdDaG9vc2UgZGlmZmVyZW50IGRvd25sb2FkIGxvY2F0aW9uJywgJ0RlbGV0ZSB1bm5lY2Vzc2FyeSBmaWxlcyddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBEZXBlbmRlbmN5IE1hbmFnZW1lbnQgRXJyb3JzXHJcbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnREVQRU5ERU5DWV9FUlJPUicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdEZXBlbmRlbmNpZXMnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdEZXBlbmRlbmN5IG1hbmFnZW1lbnQgZXJyb3IuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCB3b3JrIHByb3Blcmx5LicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ1Jlc3RhcnQgdGhlIGFwcGxpY2F0aW9uJywgJ0NoZWNrIGludGVybmV0IGNvbm5lY3Rpb24nLCAnVHJ5IG1hbnVhbCBpbnN0YWxsYXRpb24nXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lJbnN0YWxsYXRpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsICdERVBFTkRFTkNZX0lOU1RBTExBVElPTl9FUlJPUicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdEZXBlbmRlbmNpZXMnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdGYWlsZWQgdG8gaW5zdGFsbCByZXF1aXJlZCBkZXBlbmRlbmNpZXMuIFNvbWUgZmVhdHVyZXMgbWF5IG5vdCB3b3JrLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ0NoZWNrIGludGVybmV0IGNvbm5lY3Rpb24nLCAnUmV0cnkgaW5zdGFsbGF0aW9uJywgJ0NoZWNrIGZpcmV3YWxsIHNldHRpbmdzJywgJ1RyeSBtYW51YWwgaW5zdGFsbGF0aW9uJ10sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0RFUEVOREVOQ1lfVkFMSURBVElPTl9FUlJPUicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdEZXBlbmRlbmNpZXMnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdEZXBlbmRlbmN5IHZhbGlkYXRpb24gZmFpbGVkLiBUaGUgaW5zdGFsbGVkIHZlcnNpb24gbWF5IGJlIGNvcnJ1cHRlZC4nLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydSZWluc3RhbGwgZGVwZW5kZW5jaWVzJywgJ0NoZWNrIGZpbGUgaW50ZWdyaXR5JywgJ0NsZWFyIGRlcGVuZGVuY3kgY2FjaGUnXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lEb3dubG9hZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgJ0RFUEVOREVOQ1lfRE9XTkxPQURfRVJST1InLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB8fCAnRGVwZW5kZW5jaWVzJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnRmFpbGVkIHRvIGRvd25sb2FkIHJlcXVpcmVkIGRlcGVuZGVuY2llcy4gQ2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ0NoZWNrIGludGVybmV0IGNvbm5lY3Rpb24nLCAnUmV0cnkgZG93bmxvYWQnLCAnQ2hlY2sgZmlyZXdhbGwgc2V0dGluZ3MnLCAnVXNlIGRpZmZlcmVudCBuZXR3b3JrJ10sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIE5ldHdvcmsgYW5kIENvbm5lY3Rpdml0eSBFcnJvcnNcclxuZXhwb3J0IGNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb2RlOiBzdHJpbmcsIG9wdGlvbnM6IEJhc2VFcnJvck9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSwgY29kZSwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ05ldHdvcmsnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdOZXR3b3JrIGNvbm5lY3Rpb24gZXJyb3IuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJyxcclxuICAgICAgc3VnZ2VzdGlvbnM6IFsnQ2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbicsICdUcnkgYWdhaW4gbGF0ZXInLCAnQ2hlY2sgZmlyZXdhbGwgc2V0dGluZ3MnXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsICdUSU1FT1VUX0VSUk9SJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ05ldHdvcmsnLFxyXG4gICAgICByZWNvdmVyYWJsZTogdHJ1ZSxcclxuICAgICAgdXNlck1lc3NhZ2U6ICdPcGVyYXRpb24gdGltZWQgb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ1RyeSBhZ2FpbicsICdDaGVjayBpbnRlcm5ldCBjb25uZWN0aW9uJywgJ0luY3JlYXNlIHRpbWVvdXQgc2V0dGluZ3MnXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVmFsaWRhdGlvbiBFcnJvcnNcclxuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBmaWVsZD86IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCAnVkFMSURBVElPTl9FUlJPUicsIHtcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0IHx8ICdWYWxpZGF0aW9uJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIGRldGFpbHM6IHsgLi4ub3B0aW9ucy5kZXRhaWxzLCBmaWVsZCB9LFxyXG4gICAgICB1c2VyTWVzc2FnZTogYFZhbGlkYXRpb24gZmFpbGVkJHtmaWVsZCA/IGAgZm9yICR7ZmllbGR9YCA6ICcnfS4gUGxlYXNlIGNoZWNrIHlvdXIgaW5wdXQuYCxcclxuICAgICAgc3VnZ2VzdGlvbnM6IFsnQ2hlY2sgaW5wdXQgZm9ybWF0JywgJ1ZlcmlmeSByZXF1aXJlZCBmaWVsZHMnLCAnUmV2aWV3IHZhbGlkYXRpb24gcnVsZXMnXSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gU2VjdXJpdHkgRXJyb3JzXHJcbmV4cG9ydCBjbGFzcyBTZWN1cml0eUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGNvZGU6IHN0cmluZywgb3B0aW9uczogQmFzZUVycm9yT3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlLCBjb2RlLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB8fCAnU2VjdXJpdHknLFxyXG4gICAgICByZWNvdmVyYWJsZTogZmFsc2UsXHJcbiAgICAgIHVzZXJNZXNzYWdlOiAnU2VjdXJpdHkgdmlvbGF0aW9uIGRldGVjdGVkLiBPcGVyYXRpb24gYmxvY2tlZCBmb3Igc2FmZXR5LicsXHJcbiAgICAgIHN1Z2dlc3Rpb25zOiBbJ0NvbnRhY3Qgc3VwcG9ydCcsICdDaGVjayBhcHBsaWNhdGlvbiBpbnRlZ3JpdHknLCAnUmVzdGFydCBhcHBsaWNhdGlvbiddLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQZXJtaXNzaW9uIEVycm9yc1xyXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHJlc291cmNlPzogc3RyaW5nLCBvcHRpb25zOiBCYXNlRXJyb3JPcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UsICdQRVJNSVNTSU9OX0VSUk9SJywge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwgJ1Blcm1pc3Npb25zJyxcclxuICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXHJcbiAgICAgIGRldGFpbHM6IHsgLi4ub3B0aW9ucy5kZXRhaWxzLCByZXNvdXJjZSB9LFxyXG4gICAgICB1c2VyTWVzc2FnZTogYFBlcm1pc3Npb24gZGVuaWVkJHtyZXNvdXJjZSA/IGAgZm9yICR7cmVzb3VyY2V9YCA6ICcnfS4gQ2hlY2sgZmlsZSBwZXJtaXNzaW9ucy5gLFxyXG4gICAgICBzdWdnZXN0aW9uczogWydSdW4gYXMgYWRtaW5pc3RyYXRvcicsICdDaGVjayBmaWxlIHBlcm1pc3Npb25zJywgJ0NoYW5nZSBmaWxlIGxvY2F0aW9uJ10sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/errors.ts\n\n}");

/***/ }),

/***/ "./src/shared/types/settings-types.ts":
/*!********************************************!*\
  !*** ./src/shared/types/settings-types.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n/**\n * TypeScript interfaces for Settings and File System Services\n *\n * This file defines all the types used for persistent storage,\n * settings management, and file system operations.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SETTINGS_SCHEMA = exports.DEFAULT_USER_SETTINGS = exports.FileSystemError = exports.SettingsError = void 0;\n// Error types\nclass SettingsError extends Error {\n    constructor(message, code, details) {\n        super(message);\n        this.code = code;\n        this.details = details;\n        this.name = 'SettingsError';\n    }\n}\nexports.SettingsError = SettingsError;\nclass FileSystemError extends Error {\n    constructor(message, code, path, details) {\n        super(message);\n        this.code = code;\n        this.path = path;\n        this.details = details;\n        this.name = 'FileSystemError';\n    }\n}\nexports.FileSystemError = FileSystemError;\n// Constants\nexports.DEFAULT_USER_SETTINGS = {\n    theme: 'light',\n    language: 'en',\n    downloadLocation: '',\n    tempDirectory: '',\n    startMinimized: false,\n    closeToTray: false,\n    autoUpdate: true,\n    videoQuality: 'best',\n    maxConcurrentDownloads: 3,\n    windowSize: {\n        width: 1200,\n        height: 800,\n    },\n    windowPosition: {\n        x: 100,\n        y: 100,\n    },\n    notificationsEnabled: true,\n};\nexports.SETTINGS_SCHEMA = {\n    theme: {\n        type: 'string',\n        enum: ['light', 'dark', 'system'],\n        default: 'light',\n    },\n    language: {\n        type: 'string',\n        default: 'en',\n    },\n    downloadLocation: {\n        type: 'string',\n        default: '',\n    },\n    tempDirectory: {\n        type: 'string',\n        default: '',\n    },\n    startMinimized: {\n        type: 'boolean',\n        default: false,\n    },\n    closeToTray: {\n        type: 'boolean',\n        default: false,\n    },\n    autoUpdate: {\n        type: 'boolean',\n        default: true,\n    },\n    videoQuality: {\n        type: 'string',\n        enum: ['best', 'worst', '720p', '1080p'],\n        default: 'best',\n    },\n    maxConcurrentDownloads: {\n        type: 'number',\n        minimum: 1,\n        maximum: 10,\n        default: 3,\n    },\n    windowSize: {\n        type: 'object',\n        properties: {\n            width: { type: 'number', minimum: 800, default: 1200 },\n            height: { type: 'number', minimum: 600, default: 800 },\n        },\n        default: { width: 1200, height: 800 },\n    },\n    windowPosition: {\n        type: 'object',\n        properties: {\n            x: { type: 'number', default: 100 },\n            y: { type: 'number', default: 100 },\n        },\n        default: { x: 100, y: 100 },\n    },\n    notificationsEnabled: {\n        type: 'boolean',\n        default: true,\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUSxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTtTQUN2RDtRQUNELE9BQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtLQUN0QztJQUNELGNBQWMsRUFBRTtRQUNkLElBQUksRUFBRSxRQUFRO1FBQ2QsVUFBVSxFQUFFO1lBQ1YsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQ25DLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRTtTQUNwQztRQUNELE9BQU8sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRTtLQUM1QjtJQUNELG9CQUFvQixFQUFFO1FBQ3BCLElBQUksRUFBRSxTQUFTO1FBQ2YsT0FBTyxFQUFFLElBQUk7S0FDZDtDQUNPLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5bGlzdGlmeS8uL3NyYy9zaGFyZWQvdHlwZXMvc2V0dGluZ3MtdHlwZXMudHM/MGYxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVHlwZVNjcmlwdCBpbnRlcmZhY2VzIGZvciBTZXR0aW5ncyBhbmQgRmlsZSBTeXN0ZW0gU2VydmljZXNcclxuICogXHJcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIGFsbCB0aGUgdHlwZXMgdXNlZCBmb3IgcGVyc2lzdGVudCBzdG9yYWdlLFxyXG4gKiBzZXR0aW5ncyBtYW5hZ2VtZW50LCBhbmQgZmlsZSBzeXN0ZW0gb3BlcmF0aW9ucy5cclxuICovXHJcblxyXG4vLyBTZXR0aW5ncyBzY2hlbWEgdHlwZXNcclxuZXhwb3J0IGludGVyZmFjZSBVc2VyU2V0dGluZ3Mge1xyXG4gIC8vIEdlbmVyYWwgc2V0dGluZ3NcclxuICB0aGVtZTogJ2xpZ2h0JyB8ICdkYXJrJyB8ICdzeXN0ZW0nO1xyXG4gIGxhbmd1YWdlOiBzdHJpbmc7XHJcbiAgXHJcbiAgLy8gRGlyZWN0b3J5IHNldHRpbmdzXHJcbiAgZG93bmxvYWRMb2NhdGlvbjogc3RyaW5nO1xyXG4gIHRlbXBEaXJlY3Rvcnk6IHN0cmluZztcclxuICBcclxuICAvLyBBcHBsaWNhdGlvbiBiZWhhdmlvclxyXG4gIHN0YXJ0TWluaW1pemVkOiBib29sZWFuO1xyXG4gIGNsb3NlVG9UcmF5OiBib29sZWFuO1xyXG4gIGF1dG9VcGRhdGU6IGJvb2xlYW47XHJcbiAgXHJcbiAgLy8gVmlkZW8gc2V0dGluZ3NcclxuICB2aWRlb1F1YWxpdHk6ICdiZXN0JyB8ICd3b3JzdCcgfCAnNzIwcCcgfCAnMTA4MHAnO1xyXG4gIG1heENvbmN1cnJlbnREb3dubG9hZHM6IG51bWJlcjtcclxuICBcclxuICAvLyBVSSBzZXR0aW5nc1xyXG4gIHdpbmRvd1NpemU6IHtcclxuICAgIHdpZHRoOiBudW1iZXI7XHJcbiAgICBoZWlnaHQ6IG51bWJlcjtcclxuICB9O1xyXG4gIHdpbmRvd1Bvc2l0aW9uOiB7XHJcbiAgICB4OiBudW1iZXI7XHJcbiAgICB5OiBudW1iZXI7XHJcbiAgfTtcclxuICBcclxuICAvLyBOb3RpZmljYXRpb25zXHJcbiAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IGJvb2xlYW47XHJcbiAgXHJcbiAgLy8gQWR2YW5jZWQgc2V0dGluZ3NcclxuICBkZWJ1Z01vZGU/OiBib29sZWFuO1xyXG4gIGxvZ0xldmVsPzogJ2Vycm9yJyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1Zyc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3NWYWxpZGF0aW9uUmVzdWx0IHtcclxuICBpc1ZhbGlkOiBib29sZWFuO1xyXG4gIGVycm9yczogc3RyaW5nW107XHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzRXhwb3J0RGF0YSB7XHJcbiAgdmVyc2lvbjogc3RyaW5nO1xyXG4gIGV4cG9ydERhdGU6IERhdGU7XHJcbiAgc2V0dGluZ3M6IFBhcnRpYWw8VXNlclNldHRpbmdzPjtcclxufVxyXG5cclxuLy8gRmlsZSBzeXN0ZW0gdHlwZXNcclxuZXhwb3J0IGludGVyZmFjZSBGaWxlU3lzdGVtU3RhdHMge1xyXG4gIHNpemU6IG51bWJlcjtcclxuICBpc0ZpbGU6IGJvb2xlYW47XHJcbiAgaXNEaXJlY3Rvcnk6IGJvb2xlYW47XHJcbiAgY3JlYXRlZEF0OiBEYXRlO1xyXG4gIG1vZGlmaWVkQXQ6IERhdGU7XHJcbiAgYWNjZXNzZWRBdDogRGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEaXJlY3RvcnlTdHJ1Y3R1cmUge1xyXG4gIHBhdGg6IHN0cmluZztcclxuICBleGlzdHM6IGJvb2xlYW47XHJcbiAgZmlsZXM6IHN0cmluZ1tdO1xyXG4gIGRpcmVjdG9yaWVzOiBzdHJpbmdbXTtcclxuICB0b3RhbEl0ZW1zOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlsZU9wZXJhdGlvblJlc3VsdCB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBwYXRoOiBzdHJpbmc7XHJcbiAgZXJyb3I/OiBzdHJpbmc7XHJcbiAgc2l6ZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYXRoVmFsaWRhdGlvblJlc3VsdCB7XHJcbiAgaXNWYWxpZDogYm9vbGVhbjtcclxuICBpc1NlY3VyZTogYm9vbGVhbjtcclxuICBzYW5pdGl6ZWRQYXRoOiBzdHJpbmc7XHJcbiAgZXJyb3JzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLy8gQXBwbGljYXRpb24gZGlyZWN0b3J5IHN0cnVjdHVyZVxyXG5leHBvcnQgaW50ZXJmYWNlIEFwcERpcmVjdG9yaWVzIHtcclxuICB1c2VyRGF0YTogc3RyaW5nO1xyXG4gIGRvd25sb2Fkczogc3RyaW5nO1xyXG4gIHRlbXA6IHN0cmluZztcclxuICBsb2dzOiBzdHJpbmc7XHJcbiAgY2FjaGU6IHN0cmluZztcclxuICBkZXBlbmRlbmNpZXM6IHN0cmluZztcclxuICBjb25maWc6IHN0cmluZztcclxufVxyXG5cclxuLy8gU2VydmljZSBpbnRlcmZhY2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNldHRpbmdzU2VydmljZSB7XHJcbiAgLy8gQmFzaWMgb3BlcmF0aW9uc1xyXG4gIGdldDxLIGV4dGVuZHMga2V5b2YgVXNlclNldHRpbmdzPihrZXk6IEspOiBVc2VyU2V0dGluZ3NbS107XHJcbiAgc2V0PEsgZXh0ZW5kcyBrZXlvZiBVc2VyU2V0dGluZ3M+KGtleTogSywgdmFsdWU6IFVzZXJTZXR0aW5nc1tLXSk6IHZvaWQ7XHJcbiAgZ2V0QWxsKCk6IFVzZXJTZXR0aW5ncztcclxuICByZXNldCgpOiB2b2lkO1xyXG4gIFxyXG4gIC8vIEFkdmFuY2VkIG9wZXJhdGlvbnNcclxuICBoYXMoa2V5OiBrZXlvZiBVc2VyU2V0dGluZ3MpOiBib29sZWFuO1xyXG4gIGRlbGV0ZShrZXk6IGtleW9mIFVzZXJTZXR0aW5ncyk6IHZvaWQ7XHJcbiAgXHJcbiAgLy8gVmFsaWRhdGlvbiBhbmQgc2FuaXRpemF0aW9uXHJcbiAgdmFsaWRhdGUoKTogU2V0dGluZ3NWYWxpZGF0aW9uUmVzdWx0O1xyXG4gIHNhbml0aXplKCk6IHZvaWQ7XHJcbiAgXHJcbiAgLy8gSW1wb3J0L0V4cG9ydFxyXG4gIGV4cG9ydCgpOiBTZXR0aW5nc0V4cG9ydERhdGE7XHJcbiAgaW1wb3J0KGRhdGE6IFNldHRpbmdzRXhwb3J0RGF0YSk6IGJvb2xlYW47XHJcbiAgXHJcbiAgLy8gVXRpbGl0aWVzXHJcbiAgZ2V0U3RvcmVQYXRoKCk6IHN0cmluZztcclxuICBpbml0aWFsaXplRGVmYXVsdHMoKTogUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJRmlsZVN5c3RlbVNlcnZpY2Uge1xyXG4gIC8vIEZpbGUgb3BlcmF0aW9uc1xyXG4gIGV4aXN0cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gIHJlYWRGaWxlKHBhdGg6IHN0cmluZywgZW5jb2Rpbmc/OiBCdWZmZXJFbmNvZGluZyk6IFByb21pc2U8c3RyaW5nIHwgQnVmZmVyPjtcclxuICB3cml0ZUZpbGUocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgfCBCdWZmZXIsIGVuY29kaW5nPzogQnVmZmVyRW5jb2RpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG4gIGRlbGV0ZUZpbGUocGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcclxuICBjb3B5RmlsZShzb3VyY2U6IHN0cmluZywgZGVzdGluYXRpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD47XHJcbiAgbW92ZUZpbGUoc291cmNlOiBzdHJpbmcsIGRlc3RpbmF0aW9uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG4gIFxyXG4gIC8vIERpcmVjdG9yeSBvcGVyYXRpb25zXHJcbiAgZW5zdXJlRGlyZWN0b3J5KHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XHJcbiAgbGlzdERpcmVjdG9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPERpcmVjdG9yeVN0cnVjdHVyZT47XHJcbiAgZGVsZXRlRGlyZWN0b3J5KHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XHJcbiAgXHJcbiAgLy8gSlNPTiBvcGVyYXRpb25zXHJcbiAgcmVhZEpzb248VCA9IGFueT4ocGF0aDogc3RyaW5nKTogUHJvbWlzZTxUPjtcclxuICB3cml0ZUpzb24ocGF0aDogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+O1xyXG4gIFxyXG4gIC8vIFBhdGggb3BlcmF0aW9uc1xyXG4gIHZhbGlkYXRlUGF0aChwYXRoOiBzdHJpbmcsIGJhc2VQYXRoPzogc3RyaW5nKTogUGF0aFZhbGlkYXRpb25SZXN1bHQ7XHJcbiAgc2FuaXRpemVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZztcclxuICByZXNvbHZlUGF0aCguLi5wYXRoczogc3RyaW5nW10pOiBzdHJpbmc7XHJcbiAgXHJcbiAgLy8gU3RhdHMgYW5kIGluZm9cclxuICBnZXRTdGF0cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPEZpbGVTeXN0ZW1TdGF0cz47XHJcbiAgZ2V0U2l6ZShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj47XHJcbiAgXHJcbiAgLy8gQXBwbGljYXRpb24gZGlyZWN0b3JpZXNcclxuICBnZXRBcHBEaXJlY3RvcmllcygpOiBBcHBEaXJlY3RvcmllcztcclxuICBpbml0aWFsaXplQXBwRGlyZWN0b3JpZXMoKTogUHJvbWlzZTx2b2lkPjtcclxuICBcclxuICAvLyBDbGVhbnVwIG9wZXJhdGlvbnNcclxuICBjbGVhbnVwVGVtcEZpbGVzKCk6IFByb21pc2U8dm9pZD47XHJcbiAgY2xlYW51cE9sZExvZ3MobWF4QWdlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xyXG59XHJcblxyXG4vLyBFcnJvciB0eXBlc1xyXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyBjb2RlOiBzdHJpbmcsIHB1YmxpYyBkZXRhaWxzPzogYW55KSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9ICdTZXR0aW5nc0Vycm9yJztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlU3lzdGVtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgY29kZTogc3RyaW5nLCBwdWJsaWMgcGF0aD86IHN0cmluZywgcHVibGljIGRldGFpbHM/OiBhbnkpIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgdGhpcy5uYW1lID0gJ0ZpbGVTeXN0ZW1FcnJvcic7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVVNFUl9TRVRUSU5HUzogVXNlclNldHRpbmdzID0ge1xyXG4gIHRoZW1lOiAnbGlnaHQnLFxyXG4gIGxhbmd1YWdlOiAnZW4nLFxyXG4gIGRvd25sb2FkTG9jYXRpb246ICcnLFxyXG4gIHRlbXBEaXJlY3Rvcnk6ICcnLFxyXG4gIHN0YXJ0TWluaW1pemVkOiBmYWxzZSxcclxuICBjbG9zZVRvVHJheTogZmFsc2UsXHJcbiAgYXV0b1VwZGF0ZTogdHJ1ZSxcclxuICB2aWRlb1F1YWxpdHk6ICdiZXN0JyxcclxuICBtYXhDb25jdXJyZW50RG93bmxvYWRzOiAzLFxyXG4gIHdpbmRvd1NpemU6IHtcclxuICAgIHdpZHRoOiAxMjAwLFxyXG4gICAgaGVpZ2h0OiA4MDAsXHJcbiAgfSxcclxuICB3aW5kb3dQb3NpdGlvbjoge1xyXG4gICAgeDogMTAwLFxyXG4gICAgeTogMTAwLFxyXG4gIH0sXHJcbiAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgU0VUVElOR1NfU0NIRU1BID0ge1xyXG4gIHRoZW1lOiB7XHJcbiAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgIGVudW06IFsnbGlnaHQnLCAnZGFyaycsICdzeXN0ZW0nXSxcclxuICAgIGRlZmF1bHQ6ICdsaWdodCcsXHJcbiAgfSxcclxuICBsYW5ndWFnZToge1xyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICBkZWZhdWx0OiAnZW4nLFxyXG4gIH0sXHJcbiAgZG93bmxvYWRMb2NhdGlvbjoge1xyXG4gICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICBkZWZhdWx0OiAnJyxcclxuICB9LFxyXG4gIHRlbXBEaXJlY3Rvcnk6IHtcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgZGVmYXVsdDogJycsXHJcbiAgfSxcclxuICBzdGFydE1pbmltaXplZDoge1xyXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxyXG4gICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgfSxcclxuICBjbG9zZVRvVHJheToge1xyXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxyXG4gICAgZGVmYXVsdDogZmFsc2UsXHJcbiAgfSxcclxuICBhdXRvVXBkYXRlOiB7XHJcbiAgICB0eXBlOiAnYm9vbGVhbicsXHJcbiAgICBkZWZhdWx0OiB0cnVlLFxyXG4gIH0sXHJcbiAgdmlkZW9RdWFsaXR5OiB7XHJcbiAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgIGVudW06IFsnYmVzdCcsICd3b3JzdCcsICc3MjBwJywgJzEwODBwJ10sXHJcbiAgICBkZWZhdWx0OiAnYmVzdCcsXHJcbiAgfSxcclxuICBtYXhDb25jdXJyZW50RG93bmxvYWRzOiB7XHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgIG1pbmltdW06IDEsXHJcbiAgICBtYXhpbXVtOiAxMCxcclxuICAgIGRlZmF1bHQ6IDMsXHJcbiAgfSxcclxuICB3aW5kb3dTaXplOiB7XHJcbiAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgd2lkdGg6IHsgdHlwZTogJ251bWJlcicsIG1pbmltdW06IDgwMCwgZGVmYXVsdDogMTIwMCB9LFxyXG4gICAgICBoZWlnaHQ6IHsgdHlwZTogJ251bWJlcicsIG1pbmltdW06IDYwMCwgZGVmYXVsdDogODAwIH0sXHJcbiAgICB9LFxyXG4gICAgZGVmYXVsdDogeyB3aWR0aDogMTIwMCwgaGVpZ2h0OiA4MDAgfSxcclxuICB9LFxyXG4gIHdpbmRvd1Bvc2l0aW9uOiB7XHJcbiAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgeDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMTAwIH0sXHJcbiAgICAgIHk6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEwMCB9LFxyXG4gICAgfSxcclxuICAgIGRlZmF1bHQ6IHsgeDogMTAwLCB5OiAxMDAgfSxcclxuICB9LFxyXG4gIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB7XHJcbiAgICB0eXBlOiAnYm9vbGVhbicsXHJcbiAgICBkZWZhdWx0OiB0cnVlLFxyXG4gIH0sXHJcbn0gYXMgY29uc3Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shared/types/settings-types.ts\n\n}");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs-extra":
/*!***************************!*\
  !*** external "fs-extra" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs-extra");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "node:assert":
/*!******************************!*\
  !*** external "node:assert" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:assert");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:os":
/*!**************************!*\
  !*** external "node:os" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:string_decoder":
/*!**************************************!*\
  !*** external "node:string_decoder" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:string_decoder");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;